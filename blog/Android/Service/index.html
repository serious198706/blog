<!DOCTYPE html><html class="appearance-user-can-set" lang="zh"><head><meta charset="UTF-8"><title>Notex</title><meta name="description" content="Keep low profile, he said."><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="在 Android 系统中，四大组件中，Service 的重要性也是不言而喻的，它可以长时间在后台生存，执行一些复杂的或者耗时的工作。即便用户切换到了其他应用，Service 仍将在后台继续运行。此外，组件可通过绑定到 Service 与之进行交互，甚至是执行进程间通信 (IPC)。


Service 的分类我们一般将 Service 分为三大类：后台 Service 、绑定 Service 和前台 Service 。其中，后台 Service 和绑定 Service 是『不可见 Service』，前台 Service 是『可见 Service』。
后台 Service后台 Service （Background Service）一般是用来执行一些用户不会直接注意到的操作，比如解压数据包，比如进行网络请求.."><script src="//unpkg.com/valine/dist/Valine.min.js"></script><meta name="generator" content="Hexo 5.4.2"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><!-- a(href= url_for("/"))= (theme.user && theme.user.name || config.author) + "'s blog"--><a href="/">Notex</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">关于 Service</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">主页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">主页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Service-%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">Service 的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E5%8F%B0-Service"><span class="toc-text">后台 Service</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A-Service"><span class="toc-text">绑定 Service</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E5%8F%B0-Service"><span class="toc-text">前台 Service</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8-Service"><span class="toc-text">为什么要使用 Service</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Service-%E7%9A%84%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8D%97"><span class="toc-text">Service 的食用指南</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E5%86%99%E6%96%B9%E6%B3%95"><span class="toc-text">覆写方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E-Service"><span class="toc-text">声明 Service</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8-Service"><span class="toc-text">启动 Service</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87startService-%E5%90%AF%E5%8A%A8%E7%9A%84-Service"><span class="toc-text">通过startService()启动的 Service</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87bindService-%E5%90%AF%E5%8A%A8%E7%9A%84-Service"><span class="toc-text">通过bindService()启动的 Service</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E5%89%8D%E5%8F%B0-Service"><span class="toc-text">启动前台 Service</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IntentService"><span class="toc-text">IntentService</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Service-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">Service 的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Service%E8%AF%A6%E8%A7%A3"><span class="toc-text">Service详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A-Service-%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="toc-text">普通 Service 的启动过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A-Service-%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="toc-text">绑定 Service 的启动过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IntentService-%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90"><span class="toc-text">IntentService 原理解析</span></a></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/Android"><i class="tag post-item-tag">Android</i></a><a href="/tags/Android%20Framework"><i class="tag post-item-tag">Android Framework</i></a><a href="/tags/Service"><i class="tag post-item-tag">Service</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">关于 Service</h1><time class="has-text-grey" datetime="2020-05-09T16:00:00.000Z">2020-05-10</time><article class="mt-2 post-content"><p>在 Android 系统中，四大组件中，Service 的重要性也是不言而喻的，它可以长时间在后台生存，执行一些复杂的或者耗时的工作。即便用户切换到了其他应用，Service 仍将在后台继续运行。此外，组件可通过绑定到 Service 与之进行交互，甚至是执行进程间通信 (IPC)。</p>
<span id="more"></span>

<h2 id="Service-的分类"><a href="#Service-的分类" class="headerlink" title="Service 的分类"></a>Service 的分类</h2><p>我们一般将 Service 分为三大类：后台 Service 、绑定 Service 和前台 Service 。其中，后台 Service 和绑定 Service 是『不可见 Service』，前台 Service 是『可见 Service』。</p>
<h3 id="后台-Service"><a href="#后台-Service" class="headerlink" title="后台 Service"></a>后台 Service</h3><p>后台 Service （Background Service）一般是用来执行一些用户不会直接注意到的操作，比如解压数据包，比如进行网络请求。</p>
<p>需要注意的是，API 26（Android 8.0）之后，如果应用本身没有在前台运行，系统会对后台<strong>可执行的操作增加一些限制</strong>。这些限制有两个方面：</p>
<ol>
<li><p><strong>后台 Service 限制</strong>。这些限制不适用于前台 Service，因为前台 Service 更容易引起用户注意。</p>
<p>在后台运行的 Service 会消耗资源，这有可能会造成不良的用户体验，所以 Android 对应用状态进行了区分：<strong>前台应用</strong>和<strong>后台应用</strong>。满足下面任意条件，即可视为前台应用：</p>
<ul>
<li>具有可见的 Activity</li>
<li>具有前台 Service</li>
<li>另一个前台应用已关联到该应用，比如说输入法在应用中弹出，应用正在与屏幕识别和读取功能交互等等。</li>
</ul>
<p>如果上面的条件<strong>都不满足</strong>，应用就会被视为<strong>后台应用</strong>。</p>
<p>当应用处于前台时，可以随意创建和运行前台、后台 Service。当进入后台时，会有几分钟的时间，应用仍然可以创建和使用 Service，这个时间一过，应用就会被视为处于<strong>空闲</strong>状态，这时，系统将<strong>停止应用的后台 Service</strong>。</p>
<p>但是，大多数情况下，可以使用 JobScheduler 来完成 Service 能完成的操作。对于 JobScheduler 的解析，在<br><a href="/jobscheduler-and-workmanager/" target="_blank">这篇文章里</a>。</p>
</li>
<li><p><strong>广播限制</strong>。除了一些特殊的例外情况，应用<strong>无法使用 AndroidManifest 注册隐式广播</strong>。但是仍然可以在运行时注册广播，并且可以使用 AndroidManifest 注册<strong>专门针对它们的显式广播</strong>。具体的限制如下：</p>
<ul>
<li>应用<strong>不能在 AndroidManifest 中为隐式广播注册广播接收器</strong>。例如<code>ACTION_PACKAGE_REPLACED</code>广播。显式广播不受影响。</li>
<li>应用可以使用<code>Context.registerReceiver()</code>为任意广播（不管是显式还是隐式）注册接收器。</li>
<li>需要<strong>签名权限的广播不受此限制所限</strong>，因为这些广播只会发送到使用相同证书签名的应用，而不是发送到设备上的所有应用。</li>
</ul>
<p>同样地，之前使用隐式广播的应用也可以使用 <strong>JobScheduler + 动态注册广播接收器</strong>来实现类似的功能。</p>
</li>
</ol>
<h3 id="绑定-Service"><a href="#绑定-Service" class="headerlink" title="绑定 Service"></a>绑定 Service</h3><p>当系统组件与 Service 进行绑定时， Service 就处于『<strong>绑定状态</strong>』。绑定 Service 会以 C/S 模式提供接口，以便组件与 Service 进行交互、发送请求、接收结果，甚至是跨进程通信（IPC）来执行这些操作。绑定 Service 只会<strong>在与某个系统组件绑定时才会运行</strong>。多个组件可同时绑定到该 Service ，全部取消绑定后，该 Service 才会被销毁。</p>
<p>但是，绑定 Service 并不是说不能以正常的方式来运行，一个 Service ，它既可以是启动 Service （以无限期运行），也同时支持绑定，看你要覆写哪种方法了：<code>onStartCommand()</code>是让组件来启动 Service 后会回调的方法，而<code>onBind()</code>是以绑定方式启动 Service 后回调的方法。但无论是哪种 Service ，都可以使用 Intent 来启动它。</p>
<h3 id="前台-Service"><a href="#前台-Service" class="headerlink" title="前台 Service"></a>前台 Service</h3><p>前台 Service （Foreground Service）可以被用户看到。通常前台 Service <strong>必须在通知栏显示一个通知</strong>，比如各种音乐 APP：</p>
<p><img src="/img/service-1588775376.jpeg"></p>
<p>即使用户停止与 App 的交互， Service 也依然会继续运行。</p>
<h2 id="为什么要使用-Service"><a href="#为什么要使用-Service" class="headerlink" title="为什么要使用 Service"></a>为什么要使用 Service</h2><p>如上所述，使用 Service 有诸多限制，而且还分什么前台后台绑定，<strong>用子线程它不香吗？</strong></p>
<p>这里要看使用场景。</p>
<p>Service 是一种即便用户不与它交互，也能一直运行在后台的组件，它默认是运行在主线程上的。因此，Service 适合<strong>执行短期的、不阻塞的、不与用户交互的任务</strong>。如果你必须要在主线程之外执行一些操作，比如密集性的网络通信、比如进行大量数据的初始化和解析，那你最好还是选择在 Service 中新建一个线程来做这件事。</p>
<h2 id="Service-的食用指南"><a href="#Service-的食用指南" class="headerlink" title="Service 的食用指南"></a>Service 的食用指南</h2><h3 id="覆写方法"><a href="#覆写方法" class="headerlink" title="覆写方法"></a>覆写方法</h3><p>使用 Service 的时候，我们必须要自定义一个继承 Service 的类，并覆写下面几种重要的方法：</p>
<ul>
<li><p><code>onStartCommand(Intent intent, int flags, int startId)</code>：</p>
<p>当另一个组件（如 Activity）请求启动 Service 时，一般会通过调用<code>startService()</code>来启动，此时，系统会执行<code>onStartCommand()</code>方法（具体如何调用的，查看<a href="#%E6%99%AE%E9%80%9A%20-Service-%20%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B">这一章节</a>），如果此时有 Intent 传入，则可以进行一些初始化的工作。通常情况下，这个方法被调用的时候， Service 已经启动了。如果是要覆写该方法的话，那你得使用<code>stopSelf()</code>或 <code>stopService()</code>来停止 Service 。如果只想提供一个绑定 Service ，则无需覆写此方法。</p>
<blockquote>
<p>你可能会注意到，在覆写时，还有个<code>onStart()</code>方法，如果查看源码的话，在<code>onStartCommand()</code>中直接调用了<code>onStart()</code>。该方法在 Android 4.0.3之后就被废弃了，现在都采用直接覆写<code>onStartCommand()</code>方法了。</p>
</blockquote>
</li>
</ul>
<p>  它的第一个参数是一个 Intent，是启动 Service 时组件传递过来的 Intent，可以用于初始化。<strong>这个 Intent 有可能为 null</strong>，哪怕你明明传递了非 null 的 Intent。具体原因在下面会讲到。</p>
<p>  它的第二个参数是一个 int 值，是启动 Service 时系统给的额外参数，一般情况下是0，也有可能是<code>START_FLAT_REDELIVERY</code>（Intent 之前传递过）和<code>START_FLAG_RETRY</code>（之前的 Intent 没有正确传递过来，重试传递）的<strong>或值</strong>。</p>
<p>  它的第三个参数也是一个 int 值，叫<code>startId</code>，它用来唯一标识一次启动请求，会在<code>stopSelfResult(int)</code>这个方法中用到这个值，用以终止当前 Service。它和<code>stopService()</code>是有区别的，<code>stopService()</code>方法一旦被调用，就直接一刀砍死 Service，毫不留情；但<code>stopSelfResult()</code>会检查<code>startId</code>，如果在调用<code>stopSelfResult()</code>的时候又来了个启动的请求，此时<code>startId</code>发生了变化，它就会大喊一声『刀下留人~~~~』，Service 就不会死掉了。</p>
<p>  它的返回值也是一个 int 值，有下面几种选择：</p>
<ul>
<li><code>START_STICKY</code>：被系统清理后，会保留 Service 的启动状态，但不保留 Intent，系统重启 Service 后会重新调用<code>onStartCommand()</code>方法，但如果这期间没有收到任何 Intent，那传入的 Intent 就是 null，需要小心处理。</li>
<li><code>START_STICKY_COMPATIBILITY</code>：<code>START_STICKY</code> 的兼容版本，但是不能保证<code>onStartCommand()</code>会被调用。</li>
<li><code>START_NOT_STICKY</code>：被系统清理后，不保留 Service 状态。</li>
<li><code>START_REDELIVER_INTENT</code>：被系统清理后，会保留 Service 状态，同时会保留 Intent，系统重启 Service 后会重新调用<code>onStartCommand()</code>方法，此时会传入之前保留的 Intent。</li>
</ul>
<p>  默认情况下，<code>onStartCommand()</code>会返回<code>START_STICKY_COMPATIBILITY</code>或者<code>START_STICKY</code>。</p>
<ul>
<li><p><code>onBind(Intent intent)</code>：</p>
<p>当以绑定方式启动 Service 时，系统会调用这个方法（具体如何调用的，查看<a href="##service-%E7%9A%84%E5%88%86%E7%B1%BB">这一章节</a>），如果此时有 Intent 传入，则可以进行一些初始化的工作。如果要实现与 Client 端通信，那么这个方法必须要返回一个 IBinder 的接口；如果该 Service 不希望与 Client 端通信，可以直接返回 null。</p>
</li>
<li><p><code>onCreate()</code>：</p>
<p>这一看就是生命周期回调方法。这个方法会在<code>onStartCommand()</code>和<code>onBind()</code>之前被调用。如果 Service 已经在运行了，而再次尝试启动 Service 的话，这个方法<strong>不会再被调用</strong>。</p>
</li>
<li><p><code>onDestroy()</code>：</p>
<p>生命周期回调方法，在 Service 被销毁之前调用。可以在这里面做一些回收线程、注销 BroadcastReceiver 之类的工作。</p>
<p>值得注意的是，Service 在<strong>一般情况下不会被销毁</strong>，如果这个 Service 是前台 Service ，那它<strong>几乎永远不会终止</strong>（运行在某些国产OS上除外，说砍就砍没得商量🔪）；如果 Service 被绑定到前台 Activity 上，它也<strong>不太可能会终止</strong>；如果系统在<strong>低内存且必须回收资源以保证前台 Activity 与用户的交互</strong>的情况下终止了 Service ，那么在这种情况缓解时会<strong>立即重启 Service</strong> ——当然，要看<code>onStartCommand()</code>中你返回了个啥。</p>
</li>
</ul>
<h3 id="声明-Service"><a href="#声明-Service" class="headerlink" title="声明 Service"></a>声明 Service</h3><p>如果想要该 Service 可用，必须在 AndroidManifest 中注册这个 Service ，如下：</p>
<pre><code class="xml">&lt;manifest ...&gt;
  &lt;application ...&gt;
    &lt;service android:name=&quot;.CustomService&quot; /&gt;
  &lt;/application&gt;
&lt;/manifest&gt;
</code></pre>
<p>在<code>&lt;service&gt;</code>标签中，还有很多其他的属性可以设置，我们来介绍几个比较重要的。</p>
<ul>
<li><code>android:name</code>：这是唯一必需的属性，用于<strong>指定 Service 的类名</strong>。在维护代码的过程中，尽量保持这个类名不变，以避免一些用<strong>显式 Intent 启动 Service</strong> 的代码碰钉子。</li>
</ul>
<blockquote>
<p><strong>显式 Intent</strong></p>
<p>隐式 Intent 指的是<strong>不指定特定处理者</strong>的 Intent，谁都可以接收和处理；而<strong>显式 Intent 指定了接收者</strong>，除了指定的接收者外，任何应用都无法接收和使用这个 Intent，使得应用更加安全。<br>从 Android 5.0 开始，如果使用隐式 Intent 调用<code>bindService()</code>，就会抛出异常：<br>java.lang.IllegalArgumentException: Service Intent must be explicit</p>
</blockquote>
<ul>
<li><p><code>android:enabled</code>：表示系统是否可以实例化该 Service 。默认为<code>true</code>，表示可以。如果设置了<code>false</code>，可以通过调用<code>PackageManager.setComponentEnabledSetting()</code>方法动态开启。</p>
</li>
<li><p><code>android:exported</code>：表示<strong>其他的应用能否调用该 Service 或者与之交互</strong>。该属性的默认值取决于该 Service 是否包含 Intent Filter。如果没有任何 Filter 则表示 Service 只能通过指定确切的类名来调用，也意味着该 Service 是『应用内部专享』，因为其他的应用不知道它的类名（正常情况下）。在这种情况下，默认值是<code>false</code>；反之如果有任意一个 Filter 则表明 Service 可以供外部使用，这时默认值是<code>true</code>。</p>
<p>另外，要限制这个 Service 的暴露，将该字段设置为 false 并不是唯一的方式。还可以使用权限控制<code>android:permission</code>来限制哪些外部应用可以与 Service 交互。下面会讲到。</p>
</li>
<li><p><code>android:permission</code>：组件启动 Service 或绑定到 Service 所必需的权限的名称。如果<code>startService()</code>、<code>bindService()</code>或<code>stopService()</code>的调用者<strong>尚未获得此权限</strong>，那该方法将<strong>不起作用</strong>，且系统不会将 Intent 对象传送给 Service ，也即无法完成交互。<strong>如果未设置该属性，则系统将会将其设置为<code>&lt;application&gt;</code>标签中<code>permission</code>属性所设置的权限</strong>（注意：不是<code>&lt;uses-permisson&gt;</code>标签）。如果两个属性都没设置，则 Service 不受权限保护。</p>
</li>
<li><p><code>android:process</code>：将运行 Service 的进程名称。正常情况下，应用的所有组件都会在为<strong>应用创建的默认进程</strong>中运行。该名称与<strong>应用包名相同</strong>。<code>&lt;application&gt;</code> 元素的<code>process</code>属性可为所有组件设置默认进程名称。不过，组件可以使用自己的<code>process</code>属性替换默认值，从而将应用散布到多个进程中。</p>
<p>如果为此属性分配的名称<strong>以冒号<code>:</code>开头</strong>，则系统会<strong>在需要时创建应用专用的新进程</strong>，并且 Service 会<strong>在该进程中运行</strong>。如果进程名称<strong>以小写字符开头</strong>，则 Service 将在<strong>使用该名称的全局进程中运行，前提是它拥有相应的权限</strong>。如此一来，不同应用中的组件便可共享进程，从而减少资源使用。</p>
</li>
</ul>
<h3 id="启动-Service"><a href="#启动-Service" class="headerlink" title="启动 Service"></a>启动 Service</h3><p>启动 Service 有两种方法，上面讲过了，<code>startService()</code>和<code>bindService()</code>方法。我们还是分开来讲。</p>
<h4 id="通过startService-启动的-Service"><a href="#通过startService-启动的-Service" class="headerlink" title="通过startService()启动的 Service"></a>通过<code>startService()</code>启动的 Service</h4><pre><code class="java">Intent intent = new Intent(this, CustomService.class);
startService(intent);
</code></pre>
<p>这种方式启动 Service ，系统将会调用<code>onStartCommand()</code>方法。这种 Service 在启动之后，<strong>其生命周期将独立于它的启动者</strong>。例如一个 Activity 通过这种方式启动了 Service ，哪怕 Activity 不可见了、甚至被销毁了， Service 也会继续运行。因此，我们应该在 Service 完成工作后，调用它的<code>stopSelf()</code>来停止运行，或者由其他的组件调用<code>stopService()</code>来停止该 Service 。</p>
<p>在调用该方法时，可以传递一个 Intent 对象给 Service ， Service 会在<code>onStartCommand()</code>中接收到这个 Intent。多次通过这种方式启动，会多次调用到<code>onStartCommand()</code>方法。<strong>这通常被用来向 Service 传递数据</strong>。</p>
<p>此处必须再强调一次， Service 启动后，<strong>是工作在主线程上的</strong>。如果交给 Service 去做一些密集性的、耗时的、阻塞的任务，可能会影响 Activity 的性能。如果要使用 Service 做这些事，你可以在 Service 中新建线程来做这些事。</p>
<h4 id="通过bindService-启动的-Service"><a href="#通过bindService-启动的-Service" class="headerlink" title="通过bindService()启动的 Service"></a>通过<code>bindService()</code>启动的 Service</h4><pre><code class="java">ServiceConnection conn = new ServiceConnection() &#123;
    @Override
    public void onServiceConnected(ComponentName className,
                  IBinder service) &#123;
        LocalBinder binder = (LocalBinder) service;
        mService = binder.getService();
        mBound = true;
    &#125;

    @Override
    public void onServiceDisconnected(ComponentName arg0) &#123;
        mBound = false;
    &#125;
&#125;
Intent intent = new Intent(this, CustomService.class);
bindService(intent, conn, Context.BIND_AUTO_CREATE);
</code></pre>
<p>组件可以通过上述方式与 Service 进行长期绑定。这种 Service 在一般情况下，不允许组件通过调用<code>startService()</code>方法来启动它。它通常只在<strong>为其他应用组件提供服务时</strong>处于活动状态，并不会无限期地在后台运行。</p>
<p>这种启动方式多用在与 Activity 或者其他组件的交互，以及通过进程间通信（IPC）与其他应用产生交互。</p>
<p>一旦绑定，Service 就会启动，如果当前没有任何组件与 Service 是绑定状态，那 Service <strong>就会被系统销毁</strong>，所以，对于这种 Service ，我们**不必调用<code>stopSelf()</code>或者<code>stopService()</code>**。</p>
<p>上面我们也说过，同一个 Service 可以<strong>同时被多个组件绑定</strong>。</p>
<p>在以这种方式绑定 Service 时，系统会调用<code>onBind()</code>方法，我们需要<strong>自己实现<code>onBind()</code>回调方法，返回一个 IBinder 对象，供 Client 来与 Service 进行交互</strong>。多次绑定同一个 Service ，并不会重复调用<code>onBind()</code>方法，系统会在第一次绑定时生成 IBinder 对象，并对其进行缓存，在之后的绑定中，直接返回这个对象给 Client。</p>
<p>ServiceConnection 会监控与 Service 的连接状态，如上面代码所示，它有两个需要覆写的方法：<code>onServiceConnected()</code>和<code>onServiceDisconnected()</code>。前者会传递一个 IBinder 对象进来，Client 这时需要<strong>强转成自己需要的 Binder 对象</strong>，并可以调用该对象的方法，完成与 Service 的通信。后者则是<strong>与 Service 主动解绑或丢失链接</strong>时的回调。</p>
<h4 id="启动前台-Service"><a href="#启动前台-Service" class="headerlink" title="启动前台 Service"></a>启动前台 Service</h4><p>上面的两种 Service 都是『后台 Service 』，换言之，它们不会被用户可见。如果要启动用户可见的『前台 Service 』，需要调用<code>startForegroundService()</code>方法。</p>
<pre><code class="java">Intent intent = new Intent(this, CustomService.class);
startForegroundService(intent);
</code></pre>
<p>使用这种方法启动 Service ，就意味着 Service 在启动之后，就会<strong>立刻调用它的<code>startForeground(int, Notification)</code>方法</strong>，用于在通知栏中创建通知。</p>
<pre><code class="java">final int ONGOING_NOTIFICATION_ID = 1;  // 该值不可为0

Intent notificationIntent = new Intent(this, MainActivity.class);
PendingIntent pendingIntent =
        PendingIntent.getActivity(this, 0, notificationIntent, 0);

Notification notification =
          new Notification.Builder(this, CHANNEL_DEFAULT_IMPORTANCE)
    .setContentTitle(getText(R.string.notification_title))
    .setContentText(getText(R.string.notification_message))
    .setSmallIcon(R.drawable.icon)
    .setContentIntent(pendingIntent)
    .setTicker(getText(R.string.ticker_text))
    .build();

startForeground(ONGOING_NOTIFICATION_ID, notification);
</code></pre>
<p>使用前台 Service 可以变相实现『保活』，因为系统几乎不会考虑将它停止，哪怕内存空间不足。但是这并不代表我们可以滥用前台 Service ，因为每一个 Service 都会消耗系统资源。</p>
<p>如果要移除前台 Service，需要手动调用<code>stopForeground(bool)</code>，参数表示是否要同时移除通知栏的通知。<strong>这个方法不会终止 Service</strong>。如果使用了<code>stopServie()</code>来终止 Service，那么通知栏中的通知也会随之被移除。</p>
<h3 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h3><p>IntentService 是 Service 的子类，它包含一个 HandlerThread，这意味着它<strong>并不是在主线程上工作</strong>的，可以将一些具有顺序性的、不需要同时处理的任务交给 IntentService 来处理。</p>
<p>要使用这个类，我们只需要实现它的<code>onHandleIntent()</code>方法，该方法会接收每个启动请求中的 Intent，并交给 HandlerThread 去处理。</p>
<p>值得注意的是，使用 IntentService 时，如果你需要重写<code>onStartCommand()</code>方法，在处理完自己的工作后，<strong>必须要调用<code>return super.onStartCommand()</code>方法来返回</strong>，以保证在<code>onHandleIntent()</code>中能正确接收到 Intent。</p>
<p>IntentService 在处理完所有请求后会停止 Service ，所以，<strong>不必调用<code>stopSelf()</code>方法</strong>。</p>
<blockquote>
<p>IntentService 在 API 30 中被废弃了。</p>
</blockquote>
<h2 id="Service-的生命周期"><a href="#Service-的生命周期" class="headerlink" title="Service 的生命周期"></a>Service 的生命周期</h2><p>盗个官网的图，美滋儿滋儿：</p>
<div class="center-img">

<p><img src="/img/service-1588840496.png"></p>
<p><em>左边是使用startService()调用的生命周期，右边是bindService()</em></p>
</div>

<p>可见，Service 的生命周期很简单，与 Activity 相比简直是小巫见格格巫。下面的代码，就可以监控 Service 的所有生命周期：</p>
<pre><code class="java">public class CustomService extends Service &#123;
    int startMode;       // indicates how to behave if the service is killed
    IBinder binder;      // interface for clients that bind
    boolean allowRebind; // indicates whether onRebind should be used

    @Override
    public void onCreate() &#123;
        // Service 创建时回调
    &#125;

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) &#123;
        // 服务已启动，每一次使用 startService() 启动服务时回调
        return mStartMode;
    &#125;
    @Override
    public IBinder onBind(Intent intent) &#123;
        // 一个 Client 正在尝试调用 bindService() 绑定该服务
        return mBinder;
    &#125;
    @Override
    public boolean onUnbind(Intent intent) &#123;
        // 一个 Client 正在尝试调用 unbindService() 与该服务解绑
        return mAllowRebind;
    &#125;
    @Override
    public void onRebind(Intent intent) &#123;
        // 一个 Client 在解绑后又尝试重新绑定
    &#125;
    @Override
    public void onDestroy() &#123;
        // Service 销毁之前回调
    &#125;
&#125;
</code></pre>
<p>看出来了吗？与 Activity 不一样的地方是，每一个生命周期方法，<strong>都不需要调用超类的生命周期方法</strong>。</p>
<h2 id="Service详解"><a href="#Service详解" class="headerlink" title="Service详解"></a>Service详解</h2><p>好，来到这篇文章最核心最复杂的部分了。我们先提出几个问题，然后带着问题去理解这部分。</p>
<blockquote>
<p>Service 是如何启动的？</p>
<p>传递给 Service 的 Intent 是如何交到 Service 手中的？</p>
<p>IntentService 是如何实现的？</p>
</blockquote>
<p>我们来逐个解释。</p>
<h3 id="普通-Service-的启动过程"><a href="#普通-Service-的启动过程" class="headerlink" title="普通 Service 的启动过程"></a>普通 Service 的启动过程</h3><p>我们都知道，启动 Service 最常用的方法是<code>Context.startService()</code>，我们就从这儿入手，看看 Service 的启动过程是怎样的：</p>
<pre><code class="java">// android.content.Context.java

public abstract ComponentName startService(Intent service);
</code></pre>
<p>Service 继承自 ContextWrapper，所以</p>
<p>Context 是一个抽象类，它的主要实现在 ContextImpl 类里：</p>
<pre><code class="java">// android.app.ContextImpl.java

@Override
public ComponentName startService(Intent service) &#123;
    warnIfCallingFromSystemProcess(); // 检查当前进程的 uid 是否与 Process.SYSTEM_UID 相等
    return startServiceCommon(service, false, mUser);
&#125;

private ComponentName startServiceCommon(Intent service, boolean requireForeground,
            UserHandle user) &#123;
        try &#123;
            validateServiceIntent(service);
            service.prepareToLeaveProcess(this);
            ComponentName cn = ActivityManager.getService().startService(
                mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(
                            getContentResolver()), requireForeground,
                            getOpPackageName(), user.getIdentifier());
            ...
            return cn;
        &#125; catch (RemoteException e) &#123;
            throw e.rethrowFromSystemServer();
        &#125;
    &#125;
</code></pre>
<p>由上面的代码可以看出，Context 将启动 Service 的任务转交给了 ActivityManager。同时交给 ActivityManager 的，还有当前 App 的主线程。这里可以解释为什么 Service 启动时会默认在主线程执行任务。</p>
<p>有人要杠了：这不明明是 Service 嘛，为啥交给 ActivityManager 来启动？先别杠，我们继续往下深入：</p>
<pre><code class="java">// android.app.ActivityManager.java

public static IActivityManager getService() &#123;
    return IActivityManagerSingleton.get();
&#125;
</code></pre>
<p>这里使用单例模式返回了 IActivityManager 的 Binder 对象，也即真正的<code>startService()</code>工作是在 ActivityManagerService 中完成的。</p>
<pre><code class="java">// com.android.server.ActivityManagerService

public class ActivityManagerService extends IActivityManager.Stub
        implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback &#123;
    ...
    ActiveServices mServices;
    ...
    @Override
    public ComponentName startService(IApplicationThread caller, Intent service,
            String resolvedType, boolean requireForeground, String callingPackage, int userId)
            throws TransactionTooLargeException &#123;
        ...
        // 使用 synchronized 来保证创建 Service 时的线程安全
        synchronized(this) &#123;
            final int callingPid = Binder.getCallingPid();
            final int callingUid = Binder.getCallingUid();
            final long origId = Binder.clearCallingIdentity();
            ComponentName res;
            try &#123;
                res = mServices.startServiceLocked(caller, service,
                        resolvedType, callingPid, callingUid,
                        requireForeground, callingPackage, userId);
            &#125; finally &#123;
                Binder.restoreCallingIdentity(origId);
            &#125;
            return res;
        &#125;
    &#125;
    ...
&#125;
</code></pre>
<p>继续看<code>ActiveServices.startServiceLocked()</code>方法：</p>
<pre><code class="java">// com.android.server.am.ActiveServices.java

ComponentName startServiceLocked(IApplicationThread caller, Intent service, String resolvedType,
        int callingPid, int callingUid, boolean fgRequired, String callingPackage, final int userId)
        throws TransactionTooLargeException &#123;
    return startServiceLocked(caller, service, resolvedType, callingPid, callingUid, fgRequired,
            callingPackage, userId, false);
&#125;

ComponentName startServiceLocked(IApplicationThread caller, Intent service, String resolvedType,
        int callingPid, int callingUid, boolean fgRequired, String callingPackage,
        final int userId, boolean allowBackgroundActivityStarts)
        throws TransactionTooLargeException &#123;
    ...
    // 各种启动前的检查、如 App 是否存在、AndroidManifest 中是否注册、权限是否合理
    ...
    // 将 Intent 包装进了 ServiceRecord 的新实例中
    r.pendingStarts.add(new ServiceRecord.StartItem(r, false, r.makeNextStartId(),
              service, neededGrants, callingUid));
    if (fgRequired) &#123;
        // 前台服务启动成功
        ServiceState stracker = r.getTracker();
        if (stracker != null) &#123;
            stracker.setForeground(true, mAm.mProcessStats.getMemFactorLocked(),
                    r.lastActivity);
        &#125;
        mAm.mAppOpsService.startOperation(AppOpsManager.getToken(mAm.mAppOpsService),
                AppOpsManager.OP_START_FOREGROUND, r.appInfo.uid, r.packageName, true);
    &#125;
    ...
    ComponentName cmp = startServiceInnerLocked(smap, service, r, callerFg, addToStarting);
    return cmp;
&#125;

ComponentName startServiceInnerLocked(ServiceMap smap, Intent service, ServiceRecord r,
        boolean callerFg, boolean addToStarting) throws TransactionTooLargeException &#123;
    ...
    // 记录一次运行，方便系统计算电量与运行时间的关系
    synchronized (r.stats.getBatteryStats()) &#123;
        r.stats.startRunningLocked();
    &#125;
    String error = bringUpServiceLocked(r, service.getFlags(), callerFg, false, false);
    ...
    return r.name;
&#125;

private String bringUpServiceLocked(ServiceRecord r, int intentFlags, boolean execInFg,
        boolean whileRestarting, boolean permissionsReviewRequired)
        throws TransactionTooLargeException &#123;
    ...
    // 还是各种检查

    // Service 正在被启动，此时它不能被 force stop
    try &#123;
        AppGlobals.getPackageManager().setPackageStoppedState(
                r.packageName, false, r.userId);
    &#125; catch (RemoteException e) &#123;
    &#125; catch (IllegalArgumentException e) &#123;
        Slog.w(TAG, &quot;Failed trying to unstop package &quot;
                + r.packageName + &quot;: &quot; + e);
    &#125;

    ...
    ProcessRecord app;

    if (!isolated) &#123;
        app = mAm.getProcessRecordLocked(procName, r.appInfo.uid, false);

        if (app != null &amp;&amp; app.thread != null) &#123;
            try &#123;
                app.addPackage(r.appInfo.packageName, r.appInfo.longVersionCode, mAm.mProcessStats);
                // 这里开始启动服务
                realStartServiceLocked(r, app, execInFg);
                return null;
            &#125; catch (TransactionTooLargeException e) &#123;
                throw e;
            &#125; catch (RemoteException e) &#123;
                Slog.w(TAG, &quot;Exception when starting service &quot; + r.shortInstanceName, e);
            &#125;

            // If a dead object exception was thrown -- fall through to
            // restart the application.
        &#125;
    &#125; else &#123;
        ...
    &#125;

    ...
    return null;
&#125;

private final void realStartServiceLocked(ServiceRecord r,
            ProcessRecord app, boolean execInFg) throws RemoteException &#123;
    ...
    // 好熟悉的一句话，在 AMS 中，也是使用了 ActivityThread 中的 scheduleXXX 来实现的创建 Activity 的功能
    app.thread.scheduleCreateService(r, r.serviceInfo,
            mAm.compatibilityInfoForPackage(r.serviceInfo.applicationInfo),
            app.getReportedProcState());
    ...
    // 这里开始向 Service 发送 Intent，也即调用 onStartCommand() 方法
    sendServiceArgsLocked(r, execInFg, true);
    ...
&#125;

private final void sendServiceArgsLocked(ServiceRecord r, boolean execInFg,
            boolean oomAdjusted) throws TransactionTooLargeException &#123;
    ...
    r.app.thread.scheduleServiceArgs(r, slice);
    ...
&#125;
</code></pre>
<p>可以看到，与 AMS 创建 Activity 的过程很相似，都是通过 ActivityThread 来完成最后的创建工作，之前所有的检查工作，都是为了保证安全性，同时记录一些 Service 的启动信息，以便进行后期管理。</p>
<p><code>scheduleCreateService()</code>和<code>scheduleCreateArgs()</code>分别向 ActivityThread 中的 Handler 发送了<code>CREATE_SERVICE</code>和<code>SERVICE_ARGS</code>事件，并分别调用到<code>handleCreateService()</code>和<code>handleServiceArgs((ServiceArgsData)msg.obj)</code>方法：</p>
<pre><code class="java">// android.app.ActivityThread.java

private void handleCreateService(CreateServiceData data) &#123;
    ...
    LoadedApk packageInfo = getPackageInfoNoCheck(
            data.info.applicationInfo, data.compatInfo);
    Service service = null;
    try &#123;
        // 利用反射创建 Service 的实例
        java.lang.ClassLoader cl = packageInfo.getClassLoader();
        service = packageInfo.getAppFactory()
                .instantiateService(cl, data.info.name, data.intent);
    &#125; catch (Exception e) &#123;
        if (!mInstrumentation.onException(service, e)) &#123;
            throw new RuntimeException(
                &quot;Unable to instantiate service &quot; + data.info.name
                + &quot;: &quot; + e.toString(), e);
        &#125;
    &#125;

    try &#123;
        if (localLOGV) Slog.v(TAG, &quot;Creating service &quot; + data.info.name);

        ContextImpl context = ContextImpl.createAppContext(this, packageInfo);
        context.setOuterContext(service);

        Application app = packageInfo.makeApplication(false, mInstrumentation);
        service.attach(context, this, data.info.name, data.token, app,
                ActivityManager.getService());

        // 调用了 Service 的 onCreate 生命周期方法
        service.onCreate();
        mServices.put(data.token, service);
        try &#123;
            ActivityManager.getService().serviceDoneExecuting(
                    data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0);
        &#125; catch (RemoteException e) &#123;
            throw e.rethrowFromSystemServer();
        &#125;
    &#125; catch (Exception e) &#123;
        if (!mInstrumentation.onException(service, e)) &#123;
            throw new RuntimeException(
                &quot;Unable to create service &quot; + data.info.name
                + &quot;: &quot; + e.toString(), e);
        &#125;
    &#125;
&#125;

private void handleServiceArgs(ServiceArgsData data) &#123;
    Service s = mServices.get(data.token);
    if (s != null) &#123;
        try &#123;
            if (data.args != null) &#123;
                data.args.setExtrasClassLoader(s.getClassLoader());
                data.args.prepareToEnterProcess();
            &#125;
            int res;
            if (!data.taskRemoved) &#123;
                // 调用了 onStartCommand 生命周期方法
                res = s.onStartCommand(data.args, data.flags, data.startId);
            &#125; else &#123;
                s.onTaskRemoved(data.args);
                res = Service.START_TASK_REMOVED_COMPLETE;
            &#125;

            QueuedWork.waitToFinish();

            try &#123;
                ActivityManager.getService().serviceDoneExecuting(
                        data.token, SERVICE_DONE_EXECUTING_START, data.startId, res);
            &#125; catch (RemoteException e) &#123;
                throw e.rethrowFromSystemServer();
            &#125;
        &#125; catch (Exception e) &#123;
            if (!mInstrumentation.onException(s, e)) &#123;
                throw new RuntimeException(
                        &quot;Unable to start service &quot; + s
                        + &quot; with &quot; + data.args + &quot;: &quot; + e.toString(), e);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>至此，Service 完成了创建和 Intent 的传递。我们用一张时序图，来展示整个过程：</p>
<p><img src="/img/service-1588840496.png"></p>
<h3 id="绑定-Service-的启动过程"><a href="#绑定-Service-的启动过程" class="headerlink" title="绑定 Service 的启动过程"></a>绑定 Service 的启动过程</h3><p>还是从入口方法<code>Context.bindService()</code>开始看：</p>
<pre><code class="java">// android.app.ContextImpl.java

@Override
public boolean bindService(Intent service, ServiceConnection conn, int flags) &#123;
    warnIfCallingFromSystemProcess(); // 检查当前进程的 uid 是不是 Process.SYSTEM_UID
    return bindServiceCommon(service, conn, flags, null, mMainThread.getHandler(), null, getUser());
&#125;

private boolean bindServiceCommon(Intent service, ServiceConnection conn, int flags,
        String instanceName, Handler handler, Executor executor, UserHandle user) &#123;
    ...
    int res = ActivityManager.getService().bindIsolatedService(
        mMainThread.getApplicationThread(), getActivityToken(), service,
        service.resolveTypeIfNeeded(getContentResolver()),
        sd, flags, instanceName, getOpPackageName(), user.getIdentifier());
    ...
&#125;
</code></pre>
<p>与上面相同，还是来到了 ActivityManagerService 中，省略部分代码：</p>
<pre><code class="java">// com.android.server.ActivityManagerService

public class ActivityManagerService extends IActivityManager.Stub
        implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback &#123;
    ...
    ActiveServices mServices;
    ...
    public int bindIsolatedService(IApplicationThread caller, IBinder token, Intent service,
        String resolvedType, IServiceConnection connection, int flags, String instanceName,
        String callingPackage, int userId) throws TransactionTooLargeException &#123;
        ...
        synchronized(this) &#123;
            return mServices.bindServiceLocked(caller, token, service,
                resolvedType, connection, flags, instanceName, callingPackage, userId);
        &#125;
    &#125;
    ...
&#125;
</code></pre>
<p>这里与普通 Service 不同的是，它没有返回 ComponentName，而是返回了一个 int 值。</p>
<pre><code class="java">// com.android.server.am.ActiveServices.java

int bindServiceLocked(IApplicationThread caller, IBinder token, Intent service,
        String resolvedType, final IServiceConnection connection, int flags,
        String instanceName, String callingPackage, final int userId)
        throws TransactionTooLargeException &#123;
    ...
    // 各种检查
    ...

    // 这里有个很重要的操作。
    // 如果在应用的任何组件运行之前，需要让用户检查是否可以给予权限，这时会先计划一个绑定服务，但是并不启用它，
    // 然后启动 review Activity，并给它一个 callback，用户交互完成后，再完成服务的绑定工作
    if (mAm.getPackageManagerInternalLocked().isPermissionsReviewRequired(
            s.packageName, s.userId)) &#123;

        permissionsReviewRequired = true;

        final ServiceRecord serviceRecord = s;
        final Intent serviceIntent = service;

        RemoteCallback callback = new RemoteCallback(
                new RemoteCallback.OnResultListener() &#123;
            @Override
            public void onResult(Bundle result) &#123;
                synchronized(mAm) &#123;
                    final long identity = Binder.clearCallingIdentity();
                    try &#123;
                        if (!mPendingServices.contains(serviceRecord)) &#123;
                            return;
                        &#125;
                        // If there is still a pending record, then the service
                        // binding request is still valid, so hook them up. We
                        // proceed only if the caller cleared the review requirement
                        // otherwise we unbind because the user didn&#39;t approve.
                        if (!mAm.getPackageManagerInternalLocked()
                                .isPermissionsReviewRequired(
                                        serviceRecord.packageName,
                                        serviceRecord.userId)) &#123;
                            try &#123;
                                // 用户通过了权限验证，则创建 Service 实例
                                bringUpServiceLocked(serviceRecord,
                                        serviceIntent.getFlags(),
                                        callerFg, false, false);
                            &#125; catch (RemoteException e) &#123;
                                /* ignore - local call */
                            &#125;
                        &#125; else &#123;
                            unbindServiceLocked(connection);
                        &#125;
                    &#125; finally &#123;
                        Binder.restoreCallingIdentity(identity);
                    &#125;
                &#125;
            &#125;
        &#125;);

        final Intent intent = new Intent(Intent.ACTION_REVIEW_PERMISSIONS);
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK
                | Intent.FLAG_ACTIVITY_MULTIPLE_TASK
                | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
        intent.putExtra(Intent.EXTRA_PACKAGE_NAME, s.packageName);
        intent.putExtra(Intent.EXTRA_REMOTE_CALLBACK, callback);

        mAm.mHandler.post(new Runnable() &#123;
            @Override
            public void run() &#123;
                mAm.mContext.startActivityAsUser(intent, new UserHandle(userId));
            &#125;
        &#125;);
    &#125;

    final long origId = Binder.clearCallingIdentity();

    try &#123;
        ...
        // 如果这时 Service 还没有被创建，则创建 Service 实例
        if ((flags&amp;Context.BIND_AUTO_CREATE) != 0) &#123;
            s.lastActivity = SystemClock.uptimeMillis();
            if (bringUpServiceLocked(s, service.getFlags(), callerFg, false,
                    permissionsReviewRequired) != null) &#123;
                return 0;
            &#125;
        &#125;
        ...
        if (s.app != null &amp;&amp; b.intent.received) &#123;
            // Service 已经在运行了，就可以直接进行 connect
            // 此处的 connected 是 IServiceConnection.aidl 中定义的，这个方法由 LoadedApk 来实现，具体查看『关于 Context』一文，此处略过
            // 最后会调用到 ServiceConnection.onServiceConnected() 方法，完成了绑定工作
            try &#123;
                c.conn.connected(s.name, b.intent.binder, false);
            &#125; catch (Exception e) &#123;
                Slog.w(TAG, &quot;Failure sending service &quot; + s.shortInstanceName
                        + &quot; to connection &quot; + c.conn.asBinder()
                        + &quot; (in &quot; + c.binding.client.processName + &quot;)&quot;, e);
            &#125;

            // 如果是重新绑定
            if (b.intent.apps.size() == 1 &amp;&amp; b.intent.doRebind) &#123;
                requestServiceBindingLocked(s, b.intent, callerFg, true);
            &#125;
        // 如果是第一次绑定
        &#125; else if (!b.intent.requested) &#123;
            requestServiceBindingLocked(s, b.intent, callerFg, false);
        &#125;

        getServiceMapLocked(s.userId).ensureNotStartingBackgroundLocked(s);

    &#125; finally &#123;
        Binder.restoreCallingIdentity(origId);
    &#125;

    return 1;
&#125;

private final boolean requestServiceBindingLocked(ServiceRecord r, IntentBindRecord i,
        boolean execInFg, boolean rebind) throws TransactionTooLargeException &#123;
    ...
    r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind,
            r.app.getReportedProcState());
    ...
&#125;
</code></pre>
<p>继续交给 ActivityThread 去做这件事，经过发送<code>BIND_SERVICE</code>的消息后，来到了<code>ActivityThread.handleBindService()</code>方法：</p>
<pre><code class="java">// android.app.ActivityThread

private void handleBindService(BindServiceData data) &#123;
    Service s = mServices.get(data.token);

    if (s != null) &#123;
        try &#123;
            data.intent.setExtrasClassLoader(s.getClassLoader());
            data.intent.prepareToEnterProcess();
            try &#123;
                if (!data.rebind) &#123;
                    // 调用 Servcie 对象的 onBind 生命周期方法
                    IBinder binder = s.onBind(data.intent);
                    ActivityManager.getService().publishService(
                            data.token, data.intent, binder);
                &#125; else &#123;
                    // 调用 Servcie 对象的 onRebind 生命周期方法
                    s.onRebind(data.intent);
                    ActivityManager.getService().serviceDoneExecuting(
                            data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0);
                &#125;
            &#125; catch (RemoteException ex) &#123;
                throw ex.rethrowFromSystemServer();
            &#125;
        &#125; catch (Exception e) &#123;
            if (!mInstrumentation.onException(s, e)) &#123;
                throw new RuntimeException(
                        &quot;Unable to bind to service &quot; + s
                        + &quot; with &quot; + data.intent + &quot;: &quot; + e.toString(), e);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>又回到了 ActivityManagerService 中。这里我们看到了两个方法<code>publishService()</code>和<code>serviceDoneExecuting()</code>。追踪下去，发现<code>publishService()</code>方法最终还是调用了 LoadedApk.connected() 方法；而<code>serviceDoneExecuting()</code>方法并没有，因为这个方法是在 rebind 的情况下才会调用，刚才在 ActiveServices.bindServiceLocked 已经针对 rebind 情况调用过一次 LoadedApk.connected() 了。</p>
<p>至此，绑定 Service 的启动完成。</p>
<p>同样地，我们使用一张时序图来展示一下这个过程：</p>
<p><img src="/img/service-1588840496.png"></p>
<h3 id="IntentService-原理解析"><a href="#IntentService-原理解析" class="headerlink" title="IntentService 原理解析"></a>IntentService 原理解析</h3><p>IntentService 的特点就不再赘述了，我们直接看它关键的代码，然后再解释它的原理：</p>
<pre><code class="java">public abstract class IntentService extends Service &#123;
    // 有自己的 Looper
    private volatile Looper mServiceLooper;
    // 有自定义的 Handler
    private volatile ServiceHandler mServiceHandler;
    private String mName;
    private boolean mRedelivery;

    // 将 Handler 绑定到初始化的线程中
    private final class ServiceHandler extends Handler &#123;
        public ServiceHandler(Looper looper) &#123;
            super(looper);
        &#125;

        @Override
        public void handleMessage(Message msg) &#123;
            onHandleIntent((Intent)msg.obj);
            stopSelf(msg.arg1);
        &#125;
    &#125;

    // 传入 name 以供内部的 HandlerThread 使用，方便进行调试
    public IntentService(String name) &#123;
        super();
        mName = name;
    &#125;

    // 设置 intent 是否会被重新传递
    //
    // 如果设置为 true，onStartCommand() 会返回 Serivce.START_REDELIVER_INTENT，这种情况下，
    // 如果 onHandleIntent() 还没有执行完返回，进程就死掉了，这时进程会被重启然后重新传递刚才的 intent。
    // 如果之前发送了多个 intent （其他的在等待），只有最近发送的一个能保证被送达（其他的不一定了）。
    // 
    // 如果设置为 false onStartCommand() 会返回 Serivce.START_NOT_STICKY，如果进行死掉，intent 也就随风消散了
    //
    public void setIntentRedelivery(boolean enabled) &#123;
        mRedelivery = enabled;
    &#125;

    @Override
    public void onCreate() &#123;
        super.onCreate();
        // 新建了一个局部的 HandlerThread，也即不允许外部直接管理这个线程的状态。
        HandlerThread thread = new HandlerThread(&quot;IntentService[&quot; + mName + &quot;]&quot;);
        thread.start();

        mServiceLooper = thread.getLooper();
        mServiceHandler = new ServiceHandler(mServiceLooper);
    &#125;

    @Override
    public void onStart(@Nullable Intent intent, int startId) &#123;
        Message msg = mServiceHandler.obtainMessage();
        msg.arg1 = startId;
        msg.obj = intent;
        mServiceHandler.sendMessage(msg);
    &#125;

    // 不要重写这个方法
    @Override
    public int onStartCommand(@Nullable Intent intent, int flags, int startId) &#123;
        onStart(intent, startId);
        return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;
    &#125;

    @Override
    public void onDestroy() &#123;
        mServiceLooper.quit();
    &#125;

    // 除非你需要绑定这个服务，否则不用重写这个方法
    @Override
    @Nullable
    public IBinder onBind(Intent intent) &#123;
        return null;
    &#125;

    // 唯一需要重写的的方法，在这里可以处理调用者发送来的数据
    @WorkerThread
    protected abstract void onHandleIntent(@Nullable Intent intent);
&#125;
</code></pre>
<p>可见这个类并不是很神秘：</p>
<ol>
<li>继承了 Service 类；</li>
<li>重写了<code>onCreate()</code>方法，并在其中定义了一个局部的 HandlerThread，并不允许外部直接访问；</li>
<li>定义了一个 ServiceHandler 并与新建的 HandlerThread 绑定；</li>
<li>重写了<code>onStart()</code>方法，在每次启动服务调用到<code>onStartCommand()</code>的时候，调用<code>onStart()</code>，并将消息传递给 ServiceHandler；</li>
<li>定义了一个抽象方法<code>onHandleIntent(Intent)</code>供子类使用，用于真正处理请求。</li>
</ol>
<p>这个类虽然很常用，但是 Google 决定在 Android R（Android 11）中，将会<strong>废弃这个类</strong>，原因与最开始提到的『后台操作限制』相同，一个总是在后台运行的服务，必然会造成资源的消耗与浪费。Android 现在大力推宠的是 androidx 中的 <a target="_blank" rel="noopener" href="https://developer.android.com/reference/androidx/work/WorkManager.html">WorkManager</a> 和 <a target="_blank" rel="noopener" href="https://developer.android.com/reference/androidx/core/app/JobIntentService.html">JobIntentService</a>，我将会在其他的文章里讲解。</p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/Kotlin/2020-05-13-kotlin-coroutine/" title="Kotlin 协程"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">Previous: Kotlin 协程</span></a><a class="button is-default" href="/Android/JobScheduler/" title="JobScheduler 和 WorkManager"><span class="has-text-weight-semibold">Next: JobScheduler 和 WorkManager</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container" id="vcomments" data-comment_valine_id="b7rbKQnQFa9DYl1anYfacJRz-gzGzoHsz" data-comment_valine_key="nUuKvGHOJBRylruJLW2Fmekg"></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com//"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/serious198706"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com//"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com//"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> cy198706 2023</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="京ICP备2022033375号" target="_blank" rel="noopener" href="https://beian.miit.gov.cn/">京ICP备2022033375号 </a></p></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>