<!DOCTYPE html><html class="appearance-user-can-set" lang="zh"><head><meta charset="UTF-8"><title>Notex</title><meta name="description" content="Keep low profile, he said."><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="View的绘制流程View树的绘制流程当 Activity 接收到焦点的时候，它会被请求绘制布局。该请求由 Android Framework 处理。绘制是从根节点开始，对布局树进行 measure 和 draw。整个 View 树的绘图流程在 ViewRoot 类的performTraversals()函数展开，该函数所做的工作可简单概况为是否需要重新计算视图大小（measure）、是否需要重新安置视图的位置（layout）、以及是否需要重绘（draw），流程图如下：



View 绘制流程函数调用链
值得注意的是，用户主动调用invalidate()请求重绘 View 树，即 draw 过程，假如视图发生大小没有变化就不会调用layout()，并且只绘制那些调用了invalidate()方法的 Vie.."><script src="//unpkg.com/valine/dist/Valine.min.js"></script><meta name="generator" content="Hexo 5.4.2"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><!-- a(href= url_for("/"))= (theme.user && theme.user.name || config.author) + "'s blog"--><a href="/">Notex</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">View 的绘制流程</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">主页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">主页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#View%E7%9A%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B"><span class="toc-text">View的绘制流程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#View%E6%A0%91%E7%9A%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B"><span class="toc-text">View树的绘制流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#View-%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E9%93%BE"><span class="toc-text">View 绘制流程函数调用链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Measure%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-text">Measure过程分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Layout%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-text">Layout过程分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Draw%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-text">Draw过程分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%9A%84%E9%87%8D%E8%A6%81%E6%96%B9%E6%B3%95"><span class="toc-text">其他的重要方法</span></a></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/Android"><i class="tag post-item-tag">Android</i></a><a href="/tags/Android%20Framework"><i class="tag post-item-tag">Android Framework</i></a><a href="/tags/View"><i class="tag post-item-tag">View</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">View 的绘制流程</h1><time class="has-text-grey" datetime="2023-01-31T06:58:14.691Z">2023-01-31</time><article class="mt-2 post-content"><h1 id="View的绘制流程"><a href="#View的绘制流程" class="headerlink" title="View的绘制流程"></a>View的绘制流程</h1><h2 id="View树的绘制流程"><a href="#View树的绘制流程" class="headerlink" title="View树的绘制流程"></a>View树的绘制流程</h2><p>当 Activity 接收到焦点的时候，它会被请求绘制布局。该请求由 Android Framework 处理。绘制是从根节点开始，对布局树进行 measure 和 draw。整个 View 树的绘图流程在 ViewRoot 类的<code>performTraversals()</code>函数展开，该函数所做的工作可简单概况为<strong>是否需要重新计算视图大小</strong>（measure）、<strong>是否需要重新安置视图的位置</strong>（layout）、以及<strong>是否需要重绘</strong>（draw），流程图如下：</p>
<p><img src="/img/1.png" alt="View的绘制流程图"></p>
<span id="more"></span>

<h2 id="View-绘制流程函数调用链"><a href="#View-绘制流程函数调用链" class="headerlink" title="View 绘制流程函数调用链"></a>View 绘制流程函数调用链</h2><p><img style="width: 50%; text-align: center" src="/img/2.png"></img></p>
<p>值得注意的是，用户主动调用<code>invalidate()</code>请求重绘 View 树，即 draw 过程，假如视图发生大小没有变化就不会调用<code>layout()</code>，并且只绘制那些调用了<code>invalidate()</code>方法的 View。</p>
<p>但是当布局变化的时候，比如方向变化，尺寸的变化，会调用<code>requestLayout()</code>方法。在自定义的视图中，如果某些情况下希望重新测量尺寸大小，应该手动去调用该方法，它会触发<code>measure()</code>和<code>layout()</code>，但不会进行<code>draw</code>。</p>
<p>从整体上来看<code>Measure</code>和<code>Layout</code>两个步骤的执行：</p>
<p><img src="/img/3.png" alt="View的绘制流程图"></p>
<p>树的遍历是有序的，由父视图到子视图，每一个<code>ViewGroup</code>负责测绘它所有的子视图，而最底层的<code>View</code>会负责测绘自身。</p>
<p><code>Draw</code>的执行流程：</p>
<p><img src="/img/4.png" alt="Draw流程"></p>
<h2 id="Measure过程分析"><a href="#Measure过程分析" class="headerlink" title="Measure过程分析"></a><code>Measure</code>过程分析</h2><p><code>measure</code>过程是在调用<code>measure(int, int)</code>方法，从上到下有序的测量<code>View</code>，在<code>measure</code>过程的最后，每个视图存储了自己的尺寸大小和测量规格。</p>
<p><code>layout</code>过程是在调用<code>layout(int, int, int, int)</code>方法，也是自上而下进行遍历。在该过程中，每个父视图会根据<code>measure</code>过程得到的尺寸来摆放自己的子视图。</p>
<p><code>measure</code>过程会为一个<code>View</code>及所有子节点的<code>mMeasuredWidth</code>和<code>mMeasuredHeight</code>变量赋值，该值可以通过 <code>getMeasuredWidth()</code>和<code>getMeasuredHeight()</code>方法获得。而且这两个值必须在父<code>View</code>约束范围之内，这样才可以保证所有的父<code>View</code>都接收所有子<code>View</code>的测量。如果子<code>View</code>对于<code>measure</code>得到的大小不满意的时候，父<code>View</code>会介入并设置测量规则进行第二次<code>measure</code>。</p>
<p>比如，父<code>View</code>可以先根据未给定的<code>dimension</code>去测量每一个子<code>View</code>，如果最终子<code>View</code>的未约束尺寸太大或者太小的时候，父<code>View</code>就会使用一个确切的大小再次对子<code>View</code>进行<code>measure</code>。</p>
<p>根据上面的流程，我们来看看源码：</p>
<p><a href="../../source/android/ViewGroup.java"><code>ViewGroup.java</code></a>:</p>
<pre><code class="java">    /**
     * 告诉所有子 view：给你们个 MeasureSpec，去自个儿测量自个儿的大小切！
     * PS: 如果谁的状态是 GONE，那你们就别搞了！
     *
     * @param widthMeasureSpec 
     * @param heightMeasureSpec
     */
    protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) &#123;
        final int size = mChildrenCount;
        final View[] children = mChildren;
        for (int i = 0; i &lt; size; ++i) &#123;
            final View child = children[i];
            if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123;
                measureChild(child, widthMeasureSpec, heightMeasureSpec);
            &#125;
        &#125;
    &#125;
</code></pre>
<p>看看<code>measureChild</code>是如何做的：</p>
<pre><code class="java">    /**
     * 调用子 view 的 measure 方法来测量，根据父类的给的 MeasureSpec 和自己的 padding 值，
     * 让 getChildMeasureSpec() 去获取具体的 MeasureSpec。
     * 
     * @param child 
     * @param parentWidthMeasureSpec
     * @param parentHeightMeasureSpec
     */
    protected void measureChild(View child, int parentWidthMeasureSpec,
            int parentHeightMeasureSpec) &#123;
        final LayoutParams lp = child.getLayoutParams();

        final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,
                mPaddingLeft + mPaddingRight, lp.width);
        final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,
                mPaddingTop + mPaddingBottom, lp.height);

        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
    &#125;
</code></pre>
<p>最复杂的工作：<code>getChildMeasureSpec()</code>:</p>
<pre><code class="java">    /**
     * 简单来说，就是根据某个方向的 父view 的 MeasureSpec 的值和 padding 和 childDimension，
     * 来决定这个 view 的 MeasureSpec: 一个int值
     *
     * @param spec The requirements for this view
     * @param padding The padding of this view for the current dimension and
     *        margins, if applicable
     * @param childDimension How big the child wants to be in the current
     *        dimension
     * @return a MeasureSpec integer for the child
     */
    public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123;
        int specMode = MeasureSpec.getMode(spec);
        int specSize = MeasureSpec.getSize(spec);

        int size = Math.max(0, specSize - padding);

        int resultSize = 0;
        int resultMode = 0;

        switch (specMode) &#123;
        // Parent has imposed an exact size on us
        case MeasureSpec.EXACTLY:
            if (childDimension &gt;= 0) &#123;
                resultSize = childDimension;
                resultMode = MeasureSpec.EXACTLY;
            &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123;
                // Child wants to be our size. So be it.
                resultSize = size;
                resultMode = MeasureSpec.EXACTLY;
            &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123;
                // Child wants to determine its own size. It can&#39;t be
                // bigger than us.
                resultSize = size;
                resultMode = MeasureSpec.AT_MOST;
            &#125;
            break;

        // Parent has imposed a maximum size on us
        case MeasureSpec.AT_MOST:
            if (childDimension &gt;= 0) &#123;
                // Child wants a specific size... so be it
                resultSize = childDimension;
                resultMode = MeasureSpec.EXACTLY;
            &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123;
                // Child wants to be our size, but our size is not fixed.
                // Constrain child to not be bigger than us.
                resultSize = size;
                resultMode = MeasureSpec.AT_MOST;
            &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123;
                // Child wants to determine its own size. It can&#39;t be
                // bigger than us.
                resultSize = size;
                resultMode = MeasureSpec.AT_MOST;
            &#125;
            break;

        // Parent asked to see how big we want to be
        case MeasureSpec.UNSPECIFIED:
            if (childDimension &gt;= 0) &#123;
                // Child wants a specific size... let him have it
                resultSize = childDimension;
                resultMode = MeasureSpec.EXACTLY;
            &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123;
                // Child wants to be our size... find out how big it should
                // be
                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;
                resultMode = MeasureSpec.UNSPECIFIED;
            &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123;
                // Child wants to determine its own size.... find out how
                // big it should be
                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;
                resultMode = MeasureSpec.UNSPECIFIED;
            &#125;
            break;
        &#125;
        //noinspection ResourceType
        return MeasureSpec.makeMeasureSpec(resultSize, resultMode);
    &#125;
</code></pre>
<p>获取到了子<code>view</code>的<code>MeasureSpec</code>，然后就会进入 <code>View.java</code>:</p>
<pre><code class="java">    /**
     * 调用该方法来获取一个view到底该有多大。父视图提供width与height约束信息
     *
     * 测量过程中，实际的测量结果会由 onMeasure(int, int) 这个方法返回。
     * 也就是说，只有 onMeasure(int, int) 这个方法能被子类覆写。
     *
     * @param widthMeasureSpec 水平方向父类强加的Measure需求
     * @param heightMeasureSpec 垂直方向父类强加的Measure需求
     *
     */
    public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123;
        boolean optical = isLayoutModeOptical(this);
        if (optical != isLayoutModeOptical(mParent)) &#123;
            Insets insets = getOpticalInsets();
            int oWidth  = insets.left + insets.right;
            int oHeight = insets.top  + insets.bottom;
            widthMeasureSpec  = MeasureSpec.adjust(widthMeasureSpec,  optical ? -oWidth  : oWidth);
            heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight);
        &#125;

        // Suppress sign extension for the low bytes
        long key = (long) widthMeasureSpec &lt;&lt; 32 | (long) heightMeasureSpec &amp; 0xffffffffL;
        if (mMeasureCache == null) mMeasureCache = new LongSparseLongArray(2);

        final boolean forceLayout = (mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT;

        // Optimize layout by avoiding an extra EXACTLY pass when the view is
        // already measured as the correct size. In API 23 and below, this
        // extra pass is required to make LinearLayout re-distribute weight.
        final boolean specChanged = widthMeasureSpec != mOldWidthMeasureSpec
                || heightMeasureSpec != mOldHeightMeasureSpec;
        final boolean isSpecExactly = MeasureSpec.getMode(widthMeasureSpec) == MeasureSpec.EXACTLY
                &amp;&amp; MeasureSpec.getMode(heightMeasureSpec) == MeasureSpec.EXACTLY;
        final boolean matchesSpecSize = getMeasuredWidth() == MeasureSpec.getSize(widthMeasureSpec)
                &amp;&amp; getMeasuredHeight() == MeasureSpec.getSize(heightMeasureSpec);
        final boolean needsLayout = specChanged
                &amp;&amp; (sAlwaysRemeasureExactly || !isSpecExactly || !matchesSpecSize);

        if (forceLayout || needsLayout) &#123;
            // first clears the measured dimension flag
            mPrivateFlags &amp;= ~PFLAG_MEASURED_DIMENSION_SET;

            resolveRtlPropertiesIfNeeded();

            int cacheIndex = forceLayout ? -1 : mMeasureCache.indexOfKey(key);
            if (cacheIndex &lt; 0 || sIgnoreMeasureCache) &#123;
                // measure ourselves, this should set the measured dimension flag back
                // 这里返回了测量结果
                onMeasure(widthMeasureSpec, heightMeasureSpec);
                mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;
            &#125; else &#123;
                long value = mMeasureCache.valueAt(cacheIndex);
                // Casting a long to int drops the high 32 bits, no mask needed
                setMeasuredDimensionRaw((int) (value &gt;&gt; 32), (int) value);
                mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;
            &#125;

            // flag not set, setMeasuredDimension() was not invoked, we raise
            // an exception to warn the developer
            if ((mPrivateFlags &amp; PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) &#123;
                throw new IllegalStateException(&quot;View with id &quot; + getId() + &quot;: &quot;
                        + getClass().getName() + &quot;#onMeasure() did not set the&quot;
                        + &quot; measured dimension by calling&quot;
                        + &quot; setMeasuredDimension()&quot;);
            &#125;

            mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;
        &#125;

        mOldWidthMeasureSpec = widthMeasureSpec;
        mOldHeightMeasureSpec = heightMeasureSpec;

        mMeasureCache.put(key, ((long) mMeasuredWidth) &lt;&lt; 32 |
                (long) mMeasuredHeight &amp; 0xffffffffL); // suppress sign extension
    &#125;
</code></pre>
<p>我们再来看看<code>onMeasure(int, int)</code>:</p>
<pre><code class="java">    /**
     * 测量view自身和它的内容来确定view的width和height。该方法由 measure(int, int) 调用
     * 并且应该被子类覆写，来获取准确且高效的测量结果。
     *
     * 注意：在覆写该方法的时候，你必须调用 setMeasuredDimension(int, int) 方法来存储该 view 的 width 和 height。
     * 如果不这么干的话，将会触发 IllegalStateException 异常。直接调用父类的 onMeasure(int, int) 无效。
     *
     * 基类实现测量时，默认使用的是背景的 size，除非 MeasureSpec 提供了一个更大的 size。
     * 子类应该在覆写 onMeasure(int, int) 时提供它的内容的精确测量方法
     *
     * 如果该方法被覆写，子类应确保测量的 width 和 height 要大于 view 的最小 width 和最小 height，
     * 可以分别通过 getSuggestedMinimumWidth() 和 getSuggestedMinimumHeight() 来获取
     *
     * @param widthMeasureSpec 水平方向父类强加的Measure需求
     * @param heightMeasureSpec 垂直方向父类强加的Measure需求
     * 
     */
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;
        setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),
                getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));
    &#125;
</code></pre>
<p>至此，<code>measure</code>过程结束。</p>
<h2 id="Layout过程分析"><a href="#Layout过程分析" class="headerlink" title="Layout过程分析"></a><code>Layout</code>过程分析</h2><p>首先要明确的是，子<code>View</code>的具体位置都是相对于父<code>View</code>而言的。</p>
<p>在<code>layout</code>过程中，子<code>View</code>会调用<code>getMeasuredWidth()</code>和<code>getMeasuredHeight()</code>方法获取到<code>measure</code>过程得到的<code>mMeasuredWidth</code>和<code>mMeasuredHeight</code>，做为自己的<code>width</code>和<code>height</code>。然后调用每一个子<code>View</code>的<code>layout(l, t, r, b)</code>函数，来确定每个子<code>View</code>在父<code>View</code>中的位置。</p>
<p><strong>注意，<code>View</code>的<code>onLayout</code>方法为空实现，而<code>ViewGroup</code>的<code>onLayout</code>为<code>abstract</code>，因此，如果自定义的 View 要继承 ViewGroup 时，必须实现<code>onLayout</code>函数。</strong></p>
<p><a href="../../source/android/View.java"><code>View.java</code></a></p>
<p>首先看看<code>View</code>类的<code>layout()</code>方法：</p>
<pre><code class="java">    /**
     * 将 size 和 position 应用到该 view 和它所有的子孙 view 中
     * 
     * 这是 layout 机制的第二阶段（第一阶段当然是 measure啦）。
     * 在这个阶段里，每个父 view 会调用所有子 view 的 layout() 方法来给它们指定 position。
     * 一般情况下会使用存储在子 view 里的 measure 值来定位。
     *
     * 派生类不要覆写这个方法。
     * 有子 view 的派生类应该覆写 onLayout 方法，并且在这个方法里，调用它所有子 view 的 layout 方法。
     *
     * @param l Left position, relative to parent
     * @param t Top position, relative to parent
     * @param r Right position, relative to parent
     * @param b Bottom position, relative to parent
     */
    @SuppressWarnings(&#123;&quot;unchecked&quot;&#125;)
    public void layout(int l, int t, int r, int b) &#123;
        if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) &#123;
            onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);
            mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;
        &#125;

        int oldL = mLeft;
        int oldT = mTop;
        int oldB = mBottom;
        int oldR = mRight;

        boolean changed = isLayoutModeOptical(mParent) ?
                setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);

        if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;
            onLayout(changed, l, t, r, b);

            if (shouldDrawRoundScrollbar()) &#123;
                if(mRoundScrollbarRenderer == null) &#123;
                    mRoundScrollbarRenderer = new RoundScrollbarRenderer(this);
                &#125;
            &#125; else &#123;
                mRoundScrollbarRenderer = null;
            &#125;

            mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;

            ListenerInfo li = mListenerInfo;
            if (li != null &amp;&amp; li.mOnLayoutChangeListeners != null) &#123;
                ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =
                        (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();
                int numListeners = listenersCopy.size();
                for (int i = 0; i &lt; numListeners; ++i) &#123;
                    listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB);
                &#125;
            &#125;
        &#125;

        final boolean wasLayoutValid = isLayoutValid();

        mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;
        mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;

        if (!wasLayoutValid &amp;&amp; isFocused()) &#123;
            mPrivateFlags &amp;= ~PFLAG_WANTS_FOCUS;
            if (canTakeFocus()) &#123;
                // We have a robust focus, so parents should no longer be wanting focus.
                clearParentsWantFocus();
            &#125; else if (getViewRootImpl() == null || !getViewRootImpl().isInLayout()) &#123;
                // This is a weird case. Most-likely the user, rather than ViewRootImpl, called
                // layout. In this case, there&#39;s no guarantee that parent layouts will be evaluated
                // and thus the safest action is to clear focus here.
                clearFocusInternal(null, /* propagate */ true, /* refocus */ false);
                clearParentsWantFocus();
            &#125; else if (!hasParentWantsFocus()) &#123;
                // original requestFocus was likely on this view directly, so just clear focus
                clearFocusInternal(null, /* propagate */ true, /* refocus */ false);
            &#125;
            // otherwise, we let parents handle re-assigning focus during their layout passes.
        &#125; else if ((mPrivateFlags &amp; PFLAG_WANTS_FOCUS) != 0) &#123;
            mPrivateFlags &amp;= ~PFLAG_WANTS_FOCUS;
            View focused = findFocus();
            if (focused != null) &#123;
                // Try to restore focus as close as possible to our starting focus.
                if (!restoreDefaultFocus() &amp;&amp; !hasParentWantsFocus()) &#123;
                    // Give up and clear focus once we&#39;ve reached the top-most parent which wants
                    // focus.
                    focused.clearFocusInternal(null, /* propagate */ true, /* refocus */ false);
                &#125;
            &#125;
        &#125;

        if ((mPrivateFlags3 &amp; PFLAG3_NOTIFY_AUTOFILL_ENTER_ON_LAYOUT) != 0) &#123;
            mPrivateFlags3 &amp;= ~PFLAG3_NOTIFY_AUTOFILL_ENTER_ON_LAYOUT;
            notifyEnterOrExitForAutoFillIfNeeded(true);
        &#125;
    &#125;
</code></pre>
<p>可以看到在<code>layout</code>过程中调用了<code>onLayout()</code> 方法，派生类此时可以覆写<code>onLayout()</code>方法，来获取<code>view</code>的位置。</p>
<pre><code class="java">    /**
     * Called from layout when this view should
     * assign a size and position to each of its children.
     *
     * Derived classes with children should override
     * this method and call layout on each of
     * their children.
     * @param changed This is a new size or position for this view
     * @param left Left position, relative to parent
     * @param top Top position, relative to parent
     * @param right Right position, relative to parent
     * @param bottom Bottom position, relative to parent
     */
    protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123;
    &#125;
</code></pre>
<p>让我们举个栗子来看看<code>LinearLayout</code>的<code>onLayout()</code>：</p>
<pre><code class="java">    @Override
    protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;
        if (mOrientation == VERTICAL) &#123;
            layoutVertical(l, t, r, b);
        &#125; else &#123;
            layoutHorizontal(l, t, r, b);
        &#125;
    &#125;

    /**
     * 如果该 LinearLayout 的 orientation 被设置成 VERTICAL 的话，调用该方法来确定它的 position
     *
     * @param left
     * @param top
     * @param right
     * @param bottom
     */
    void layoutVertical(int left, int top, int right, int bottom) &#123;
        final int paddingLeft = mPaddingLeft;

        int childTop;
        int childLeft;

        // Where right end of child should go
        final int width = right - left;
        int childRight = width - mPaddingRight;

        // Space available for child
        int childSpace = width - paddingLeft - mPaddingRight;

        final int count = getVirtualChildCount();

        final int majorGravity = mGravity &amp; Gravity.VERTICAL_GRAVITY_MASK;
        final int minorGravity = mGravity &amp; Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK;

        switch (majorGravity) &#123;
           case Gravity.BOTTOM:
               // mTotalLength contains the padding already
               childTop = mPaddingTop + bottom - top - mTotalLength;
               break;

               // mTotalLength contains the padding already
           case Gravity.CENTER_VERTICAL:
               childTop = mPaddingTop + (bottom - top - mTotalLength) / 2;
               break;

           case Gravity.TOP:
           default:
               childTop = mPaddingTop;
               break;
        &#125;

        for (int i = 0; i &lt; count; i++) &#123;
            final View child = getVirtualChildAt(i);
            if (child == null) &#123;
                childTop += measureNullChild(i);
            &#125; else if (child.getVisibility() != GONE) &#123;
                final int childWidth = child.getMeasuredWidth();
                final int childHeight = child.getMeasuredHeight();

                final LinearLayout.LayoutParams lp =
                        (LinearLayout.LayoutParams) child.getLayoutParams();

                int gravity = lp.gravity;
                if (gravity &lt; 0) &#123;
                    gravity = minorGravity;
                &#125;
                final int layoutDirection = getLayoutDirection();
                final int absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection);
                switch (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123;
                    case Gravity.CENTER_HORIZONTAL:
                        childLeft = paddingLeft + ((childSpace - childWidth) / 2)
                                + lp.leftMargin - lp.rightMargin;
                        break;

                    case Gravity.RIGHT:
                        childLeft = childRight - childWidth - lp.rightMargin;
                        break;

                    case Gravity.LEFT:
                    default:
                        childLeft = paddingLeft + lp.leftMargin;
                        break;
                &#125;

                if (hasDividerBeforeChildAt(i)) &#123;
                    childTop += mDividerHeight;
                &#125;

                childTop += lp.topMargin;
                setChildFrame(child, childLeft, childTop + getLocationOffset(child),
                        childWidth, childHeight);
                childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child);

                i += getChildrenSkipCount(child, i);
            &#125;
        &#125;
    &#125;

    /**
     * 如果该 LinearLayout 的 orientation 被设置成 HORIZONTAL 的话，调用该方法来确定它的 position
     *
     * @param left
     * @param top
     * @param right
     * @param bottom
     */
    void layoutHorizontal(int left, int top, int right, int bottom) &#123;
        final boolean isLayoutRtl = isLayoutRtl();
        final int paddingTop = mPaddingTop;

        int childTop;
        int childLeft;

        // Where bottom of child should go
        final int height = bottom - top;
        int childBottom = height - mPaddingBottom;

        // Space available for child
        int childSpace = height - paddingTop - mPaddingBottom;

        final int count = getVirtualChildCount();

        final int majorGravity = mGravity &amp; Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK;
        final int minorGravity = mGravity &amp; Gravity.VERTICAL_GRAVITY_MASK;

        final boolean baselineAligned = mBaselineAligned;

        final int[] maxAscent = mMaxAscent;
        final int[] maxDescent = mMaxDescent;

        final int layoutDirection = getLayoutDirection();
        switch (Gravity.getAbsoluteGravity(majorGravity, layoutDirection)) &#123;
            case Gravity.RIGHT:
                // mTotalLength contains the padding already
                childLeft = mPaddingLeft + right - left - mTotalLength;
                break;

            case Gravity.CENTER_HORIZONTAL:
                // mTotalLength contains the padding already
                childLeft = mPaddingLeft + (right - left - mTotalLength) / 2;
                break;

            case Gravity.LEFT:
            default:
                childLeft = mPaddingLeft;
                break;
        &#125;

        int start = 0;
        int dir = 1;
        //In case of RTL, start drawing from the last child.
        if (isLayoutRtl) &#123;
            start = count - 1;
            dir = -1;
        &#125;

        for (int i = 0; i &lt; count; i++) &#123;
            final int childIndex = start + dir * i;
            final View child = getVirtualChildAt(childIndex);
            if (child == null) &#123;
                childLeft += measureNullChild(childIndex);
            &#125; else if (child.getVisibility() != GONE) &#123;
                final int childWidth = child.getMeasuredWidth();
                final int childHeight = child.getMeasuredHeight();
                int childBaseline = -1;

                final LinearLayout.LayoutParams lp =
                        (LinearLayout.LayoutParams) child.getLayoutParams();

                if (baselineAligned &amp;&amp; lp.height != LayoutParams.MATCH_PARENT) &#123;
                    childBaseline = child.getBaseline();
                &#125;

                int gravity = lp.gravity;
                if (gravity &lt; 0) &#123;
                    gravity = minorGravity;
                &#125;

                switch (gravity &amp; Gravity.VERTICAL_GRAVITY_MASK) &#123;
                    case Gravity.TOP:
                        childTop = paddingTop + lp.topMargin;
                        if (childBaseline != -1) &#123;
                            childTop += maxAscent[INDEX_TOP] - childBaseline;
                        &#125;
                        break;

                    case Gravity.CENTER_VERTICAL:
                        // Removed support for baseline alignment when layout_gravity or
                        // gravity == center_vertical. See bug #1038483.
                        // Keep the code around if we need to re-enable this feature
                        // if (childBaseline != -1) &#123;
                        //     // Align baselines vertically only if the child is smaller than us
                        //     if (childSpace - childHeight &gt; 0) &#123;
                        //         childTop = paddingTop + (childSpace / 2) - childBaseline;
                        //     &#125; else &#123;
                        //         childTop = paddingTop + (childSpace - childHeight) / 2;
                        //     &#125;
                        // &#125; else &#123;
                        childTop = paddingTop + ((childSpace - childHeight) / 2)
                                + lp.topMargin - lp.bottomMargin;
                        break;

                    case Gravity.BOTTOM:
                        childTop = childBottom - childHeight - lp.bottomMargin;
                        if (childBaseline != -1) &#123;
                            int descent = child.getMeasuredHeight() - childBaseline;
                            childTop -= (maxDescent[INDEX_BOTTOM] - descent);
                        &#125;
                        break;
                    default:
                        childTop = paddingTop;
                        break;
                &#125;

                if (hasDividerBeforeChildAt(childIndex)) &#123;
                    childLeft += mDividerWidth;
                &#125;

                childLeft += lp.leftMargin;
                setChildFrame(child, childLeft + getLocationOffset(child), childTop,
                        childWidth, childHeight);
                childLeft += childWidth + lp.rightMargin +
                        getNextLocationOffset(child);

                i += getChildrenSkipCount(child, childIndex);
            &#125;
        &#125;
    &#125;
</code></pre>
<p>可以看出，<code>VERTICAL</code>方向的<code>LinearLayout</code>和<code>HORIZONTAL</code>方向的<code>LinearLayout</code>，在定位过程中，区别并不大。唯一不太相同的地方，就是<code>HORIZONTAL</code>的<code>LinearLayout</code>需要判断是否为<code>RTL(Right-to-Left)</code>布局。</p>
<h2 id="Draw过程分析"><a href="#Draw过程分析" class="headerlink" title="Draw过程分析"></a><code>Draw</code>过程分析</h2><p><code>Draw</code>过程最重要的三个方法：</p>
<ul>
<li><code>View.dispatchDraw(Canvas)</code>:<br>该方法发起对子视图的绘制。<code>View</code>中默认是空实现，<code>ViewGroup</code>覆写了<code>dispatchDraw()</code>来对其子视图进行绘制。该方法我们不用去管，自定义的<code>ViewGroup</code>不应该对<code>dispatchDraw()</code>进行复写。</li>
<li><code>View.draw(Canvas)</code>:<br>由于<code>ViewGroup</code>并没有覆写此方法，因此，所有的视图最终都是调用<code>View</code>的<code>draw</code>方法进行绘制的。在自定义的视图中，也不应该覆写该方法，而是覆写<code>onDraw(Canvas)</code>方法进行绘制，如果自定义的视图确实要覆写该方法，那么请先调用<code>super.draw(canvas)</code>完成系统的绘制，然后再进行自定义的绘制。</li>
<li><code>View.onDraw(Canvas)</code>:<br><code>View.onDraw(Canvas)</code>默认是空实现，自定义绘制过程需要覆写的方法，用来绘制自身的内容。</li>
</ul>
<p>来看看源码吧：</p>
<p>先来看<code>ViewGroup.dispatchDraw(Canvas)</code>方法。该方法由系统调用，我们不需要主动调用：</p>
<pre><code class="java">    @Override
    protected void dispatchDraw(Canvas canvas) &#123;
        boolean usingRenderNodeProperties = canvas.isRecordingFor(mRenderNode);
        final int childrenCount = mChildrenCount;
        final View[] children = mChildren;
        int flags = mGroupFlags;

        if ((flags &amp; FLAG_RUN_ANIMATION) != 0 &amp;&amp; canAnimate()) &#123;
            final boolean buildCache = !isHardwareAccelerated();
            for (int i = 0; i &lt; childrenCount; i++) &#123;
                final View child = children[i];
                if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE) &#123;
                    final LayoutParams params = child.getLayoutParams();
                    attachLayoutAnimationParameters(child, params, i, childrenCount);
                    bindLayoutAnimation(child);
                &#125;
            &#125;

            final LayoutAnimationController controller = mLayoutAnimationController;
            if (controller.willOverlap()) &#123;
                mGroupFlags |= FLAG_OPTIMIZE_INVALIDATE;
            &#125;

            controller.start();

            mGroupFlags &amp;= ~FLAG_RUN_ANIMATION;
            mGroupFlags &amp;= ~FLAG_ANIMATION_DONE;

            if (mAnimationListener != null) &#123;
                mAnimationListener.onAnimationStart(controller.getAnimation());
            &#125;
        &#125;

        int clipSaveCount = 0;
        final boolean clipToPadding = (flags &amp; CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK;
        if (clipToPadding) &#123;
            clipSaveCount = canvas.save(Canvas.CLIP_SAVE_FLAG);
            canvas.clipRect(mScrollX + mPaddingLeft, mScrollY + mPaddingTop,
                    mScrollX + mRight - mLeft - mPaddingRight,
                    mScrollY + mBottom - mTop - mPaddingBottom);
        &#125;

        // We will draw our child&#39;s animation, let&#39;s reset the flag
        mPrivateFlags &amp;= ~PFLAG_DRAW_ANIMATION;
        mGroupFlags &amp;= ~FLAG_INVALIDATE_REQUIRED;

        boolean more = false;
        final long drawingTime = getDrawingTime();

        if (usingRenderNodeProperties) canvas.insertReorderBarrier();
        final int transientCount = mTransientIndices == null ? 0 : mTransientIndices.size();
        int transientIndex = transientCount != 0 ? 0 : -1;
        // Only use the preordered list if not HW accelerated, since the HW pipeline will do the
        // draw reordering internally
        final ArrayList&lt;View&gt; preorderedList = usingRenderNodeProperties
                ? null : buildOrderedChildList();
        final boolean customOrder = preorderedList == null
                &amp;&amp; isChildrenDrawingOrderEnabled();

        // 开始绘制 child
        for (int i = 0; i &lt; childrenCount; i++) &#123;
            while (transientIndex &gt;= 0 &amp;&amp; mTransientIndices.get(transientIndex) == i) &#123;
                final View transientChild = mTransientViews.get(transientIndex);
                if ((transientChild.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE ||
                        transientChild.getAnimation() != null) &#123;
                    more |= drawChild(canvas, transientChild, drawingTime);
                &#125;
                transientIndex++;
                if (transientIndex &gt;= transientCount) &#123;
                    transientIndex = -1;
                &#125;
            &#125;

            final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);
            final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);
            if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) &#123;
                more |= drawChild(canvas, child, drawingTime);
            &#125;
        &#125;
        while (transientIndex &gt;= 0) &#123;
            // there may be additional transient views after the normal views
            final View transientChild = mTransientViews.get(transientIndex);
            if ((transientChild.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE ||
                    transientChild.getAnimation() != null) &#123;
                more |= drawChild(canvas, transientChild, drawingTime);
            &#125;
            transientIndex++;
            if (transientIndex &gt;= transientCount) &#123;
                break;
            &#125;
        &#125;
        if (preorderedList != null) preorderedList.clear();

        // Draw any disappearing views that have animations
        if (mDisappearingChildren != null) &#123;
            final ArrayList&lt;View&gt; disappearingChildren = mDisappearingChildren;
            final int disappearingCount = disappearingChildren.size() - 1;
            // Go backwards -- we may delete as animations finish
            for (int i = disappearingCount; i &gt;= 0; i--) &#123;
                final View child = disappearingChildren.get(i);
                more |= drawChild(canvas, child, drawingTime);
            &#125;
        &#125;
        if (usingRenderNodeProperties) canvas.insertInorderBarrier();

        if (debugDraw()) &#123;
            onDebugDraw(canvas);
        &#125;

        if (clipToPadding) &#123;
            canvas.restoreToCount(clipSaveCount);
        &#125;

        // mGroupFlags might have been updated by drawChild()
        flags = mGroupFlags;

        if ((flags &amp; FLAG_INVALIDATE_REQUIRED) == FLAG_INVALIDATE_REQUIRED) &#123;
            invalidate(true);
        &#125;

        if ((flags &amp; FLAG_ANIMATION_DONE) == 0 &amp;&amp; (flags &amp; FLAG_NOTIFY_ANIMATION_LISTENER) == 0 &amp;&amp;
                mLayoutAnimationController.isDone() &amp;&amp; !more) &#123;
            // We want to erase the drawing cache and notify the listener after the
            // next frame is drawn because one extra invalidate() is caused by
            // drawChild() after the animation is over
            mGroupFlags |= FLAG_NOTIFY_ANIMATION_LISTENER;
            final Runnable end = new Runnable() &#123;
               @Override
               public void run() &#123;
                   notifyAnimationListener();
               &#125;
            &#125;;
            post(end);
        &#125;
    &#125;
</code></pre>
<p>可以看到，<code>dispatchDraw(Canvas)</code>方法主要有处理动画相关的事务、绘制child、绘制消失的child。</p>
<p>在绘制child时，调用的<code>drawChild()</code>如下：</p>
<pre><code class="java">    /**
     * 绘制该 ViewGroup 其中一个 child。该方法的主要职责是将 canvas 置为合适的状态（包括 clipping、translating等），
     * 让 child 的初始滚动位置置为 0,0，并应用动画效果。
     *
     * @param canvas The canvas on which to draw the child
     * @param child Who to draw
     * @param drawingTime The time at which draw is occurring
     * @return True if an invalidate() was issued
     */
    protected boolean drawChild(Canvas canvas, View child, long drawingTime) &#123;
        return child.draw(canvas, this, drawingTime);
    &#125;
</code></pre>
<p>接着就是<code>View.draw(Canvas)</code>部分：</p>
<pre><code class="java">    /**
     * 使用给定的 canvas 手动渲染这个 view（和它的子 view 们）。
     * 该 view 必须已经完成了 layout 过程，才能调用该方法。
     * 当实现自定义 view 时，覆写onDraw(Canvas)方法，而不是覆写draw(Canvas)方法。如果真的要覆写，那先调用一个super.draw(canvas)
     *
     * @param canvas The Canvas to which the View is rendered.
     */
    @CallSuper
    public void draw(Canvas canvas) &#123;
        final int privateFlags = mPrivateFlags;
        mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;

        /*
         * 遍历绘制需要按照下面的步骤来：
         *
         *      1. 绘制背景
         *      2. 如果需要绘制边缘渐隐，则需要保存 canvas 的图层
         *      3. 绘制 view 的内容
         *      4. 绘制 child
         *      5. 如果需要，绘制边缘渐隐并恢复图层
         *      6. 绘制其他装饰（比如 scrollbar）
         */

        // 第1步，绘制背景
        int saveCount;

        drawBackground(canvas);

        // 如果可能的话，跳过第2步和第5步。
        final int viewFlags = mViewFlags;
        boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0;
        boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0;
        if (!verticalEdges &amp;&amp; !horizontalEdges) &#123;
            // 第3步，绘制内容
            onDraw(canvas);

            // 第4步，绘制子child
            dispatchDraw(canvas);

            drawAutofilledHighlight(canvas);

            // Overlay 也是内容的一部分，绘制在前景的下层
            if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) &#123;
                mOverlay.getOverlayView().dispatchDraw(canvas);
            &#125;

            // 第6步，绘制其他装饰（前景色啊 scrollbar 啊）
            onDrawForeground(canvas);

            // 第7步，绘制默认的焦点高亮
            drawDefaultFocusHighlight(canvas);

            if (debugDraw()) &#123;
                debugDrawFocus(canvas);
            &#125;

            // 完事儿走人
            return;
        &#125;

        /*
         * 这儿实现了一个完整的流程，这个流程并不常见，因为它会对速度有一定的影响。
         */

        boolean drawTop = false;
        boolean drawBottom = false;
        boolean drawLeft = false;
        boolean drawRight = false;

        float topFadeStrength = 0.0f;
        float bottomFadeStrength = 0.0f;
        float leftFadeStrength = 0.0f;
        float rightFadeStrength = 0.0f;

        // 第2步，保存 canvas 的图层
        int paddingLeft = mPaddingLeft;

        final boolean offsetRequired = isPaddingOffsetRequired();
        if (offsetRequired) &#123;
            paddingLeft += getLeftPaddingOffset();
        &#125;

        int left = mScrollX + paddingLeft;
        int right = left + mRight - mLeft - mPaddingRight - paddingLeft;
        int top = mScrollY + getFadeTop(offsetRequired);
        int bottom = top + getFadeHeight(offsetRequired);

        if (offsetRequired) &#123;
            right += getRightPaddingOffset();
            bottom += getBottomPaddingOffset();
        &#125;

        final ScrollabilityCache scrollabilityCache = mScrollCache;
        final float fadeHeight = scrollabilityCache.fadingEdgeLength;
        int length = (int) fadeHeight;

        // clip the fade length if top and bottom fades overlap
        // overlapping fades produce odd-looking artifacts
        if (verticalEdges &amp;&amp; (top + length &gt; bottom - length)) &#123;
            length = (bottom - top) / 2;
        &#125;

        // also clip horizontal fades if necessary
        if (horizontalEdges &amp;&amp; (left + length &gt; right - length)) &#123;
            length = (right - left) / 2;
        &#125;

        if (verticalEdges) &#123;
            topFadeStrength = Math.max(0.0f, Math.min(1.0f, getTopFadingEdgeStrength()));
            drawTop = topFadeStrength * fadeHeight &gt; 1.0f;
            bottomFadeStrength = Math.max(0.0f, Math.min(1.0f, getBottomFadingEdgeStrength()));
            drawBottom = bottomFadeStrength * fadeHeight &gt; 1.0f;
        &#125;

        if (horizontalEdges) &#123;
            leftFadeStrength = Math.max(0.0f, Math.min(1.0f, getLeftFadingEdgeStrength()));
            drawLeft = leftFadeStrength * fadeHeight &gt; 1.0f;
            rightFadeStrength = Math.max(0.0f, Math.min(1.0f, getRightFadingEdgeStrength()));
            drawRight = rightFadeStrength * fadeHeight &gt; 1.0f;
        &#125;

        saveCount = canvas.getSaveCount();
        int topSaveCount = -1;
        int bottomSaveCount = -1;
        int leftSaveCount = -1;
        int rightSaveCount = -1;

        int solidColor = getSolidColor();
        if (solidColor == 0) &#123;
            if (drawTop) &#123;
                topSaveCount = canvas.saveUnclippedLayer(left, top, right, top + length);
            &#125;

            if (drawBottom) &#123;
                bottomSaveCount = canvas.saveUnclippedLayer(left, bottom - length, right, bottom);
            &#125;

            if (drawLeft) &#123;
                leftSaveCount = canvas.saveUnclippedLayer(left, top, left + length, bottom);
            &#125;

            if (drawRight) &#123;
                rightSaveCount = canvas.saveUnclippedLayer(right - length, top, right, bottom);
            &#125;
        &#125; else &#123;
            scrollabilityCache.setFadeColor(solidColor);
        &#125;

        // 第3步，绘制内容 
        onDraw(canvas);

        // 第4步，绘制child
        dispatchDraw(canvas);

        // 第5步，绘制渐隐边缘并恢复图层
        final Paint p = scrollabilityCache.paint;
        final Matrix matrix = scrollabilityCache.matrix;
        final Shader fade = scrollabilityCache.shader;

        // 还得按照保存的顺序反向恢复
        if (drawRight) &#123;
            matrix.setScale(1, fadeHeight * rightFadeStrength);
            matrix.postRotate(90);
            matrix.postTranslate(right, top);
            fade.setLocalMatrix(matrix);
            p.setShader(fade);
            if (solidColor == 0) &#123;
                canvas.restoreUnclippedLayer(rightSaveCount, p);

            &#125; else &#123;
                canvas.drawRect(right - length, top, right, bottom, p);
            &#125;
        &#125;

        if (drawLeft) &#123;
            matrix.setScale(1, fadeHeight * leftFadeStrength);
            matrix.postRotate(-90);
            matrix.postTranslate(left, top);
            fade.setLocalMatrix(matrix);
            p.setShader(fade);
            if (solidColor == 0) &#123;
                canvas.restoreUnclippedLayer(leftSaveCount, p);
            &#125; else &#123;
                canvas.drawRect(left, top, left + length, bottom, p);
            &#125;
        &#125;

        if (drawBottom) &#123;
            matrix.setScale(1, fadeHeight * bottomFadeStrength);
            matrix.postRotate(180);
            matrix.postTranslate(left, bottom);
            fade.setLocalMatrix(matrix);
            p.setShader(fade);
            if (solidColor == 0) &#123;
                canvas.restoreUnclippedLayer(bottomSaveCount, p);
            &#125; else &#123;
                canvas.drawRect(left, bottom - length, right, bottom, p);
            &#125;
        &#125;

        if (drawTop) &#123;
            matrix.setScale(1, fadeHeight * topFadeStrength);
            matrix.postTranslate(left, top);
            fade.setLocalMatrix(matrix);
            p.setShader(fade);
            if (solidColor == 0) &#123;
                canvas.restoreUnclippedLayer(topSaveCount, p);
            &#125; else &#123;
                canvas.drawRect(left, top, right, top + length, p);
            &#125;
        &#125;

        canvas.restoreToCount(saveCount);

        drawAutofilledHighlight(canvas);

        // Overlay 也是内容的一部分，绘制在前景的下层
        if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) &#123;
            mOverlay.getOverlayView().dispatchDraw(canvas);
        &#125;

        // 第6步，绘制其他装饰（前景色啊 scrollbar 啊）
        onDrawForeground(canvas);

        if (debugDraw()) &#123;
            debugDrawFocus(canvas);
        &#125;
    &#125;
</code></pre>
<p>由代码可以看出，第2步和第5步是可以省略不做的，并且可以极大地提高性能。所以通常情况下，不要设置FadingEdge。</p>
<p>::: tip</p>
<p>FadingEdge是个啥？</p>
<p>就是<strong>边缘渐隐</strong>，通常长这个样子：</p>
<p><img width="20%" src="/img/5.png"></img></p>
<p>根据<a target="_blank" rel="noopener" href="https://developer.android.com/reference/android/R.attr.html#fadingEdge">官方文档</a>来看，android:fadingEdge已经被弃用了。如果想实现这种效果，要这样设置：</p>
<pre><code class="xml">android:requiresFadingEdge=&quot;horizontal&quot;
android:fadingEdgeLength=&quot;40dp&quot;
android:ellipsize=&quot;none&quot;
</code></pre>
<p>同时，尽量将<code>layout_width</code>设置为<code>match_parent</code>或者<code>100dp</code>之类的。<br>:::</p>
<p>同样地，我们还是拿<code>LinearLayout</code>来举例，看看它的<code>onDraw(Canvas)</code>是如何实现的：</p>
<pre><code class="java">    @Override
    protected void onDraw(Canvas canvas) &#123;
        if (mDivider == null) &#123;
            return;
        &#125;

        if (mOrientation == VERTICAL) &#123;
            drawDividersVertical(canvas);
        &#125; else &#123;
            drawDividersHorizontal(canvas);
        &#125;
    &#125;

    void drawDividersVertical(Canvas canvas) &#123;
        final int count = getVirtualChildCount();
        for (int i = 0; i &lt; count; i++) &#123;
            final View child = getVirtualChildAt(i);
            if (child != null &amp;&amp; child.getVisibility() != GONE) &#123;
                if (hasDividerBeforeChildAt(i)) &#123;
                    final LayoutParams lp = (LayoutParams) child.getLayoutParams();
                    final int top = child.getTop() - lp.topMargin - mDividerHeight;
                    drawHorizontalDivider(canvas, top);
                &#125;
            &#125;
        &#125;

        if (hasDividerBeforeChildAt(count)) &#123;
            final View child = getLastNonGoneChild();
            int bottom = 0;
            if (child == null) &#123;
                bottom = getHeight() - getPaddingBottom() - mDividerHeight;
            &#125; else &#123;
                final LayoutParams lp = (LayoutParams) child.getLayoutParams();
                bottom = child.getBottom() + lp.bottomMargin;
            &#125;
            drawHorizontalDivider(canvas, bottom);
        &#125;
    &#125;

    void drawDividersHorizontal(Canvas canvas) &#123;
        final int count = getVirtualChildCount();
        final boolean isLayoutRtl = isLayoutRtl();
        for (int i = 0; i &lt; count; i++) &#123;
            final View child = getVirtualChildAt(i);
            if (child != null &amp;&amp; child.getVisibility() != GONE) &#123;
                if (hasDividerBeforeChildAt(i)) &#123;
                    final LayoutParams lp = (LayoutParams) child.getLayoutParams();
                    final int position;
                    if (isLayoutRtl) &#123;
                        position = child.getRight() + lp.rightMargin;
                    &#125; else &#123;
                        position = child.getLeft() - lp.leftMargin - mDividerWidth;
                    &#125;
                    drawVerticalDivider(canvas, position);
                &#125;
            &#125;
        &#125;

        if (hasDividerBeforeChildAt(count)) &#123;
            final View child = getLastNonGoneChild();
            int position;
            if (child == null) &#123;
                if (isLayoutRtl) &#123;
                    position = getPaddingLeft();
                &#125; else &#123;
                    position = getWidth() - getPaddingRight() - mDividerWidth;
                &#125;
            &#125; else &#123;
                final LayoutParams lp = (LayoutParams) child.getLayoutParams();
                if (isLayoutRtl) &#123;
                    position = child.getLeft() - lp.leftMargin - mDividerWidth;
                &#125; else &#123;
                    position = child.getRight() + lp.rightMargin;
                &#125;
            &#125;
            drawVerticalDivider(canvas, position);
        &#125;
    &#125;
</code></pre>
<p>可以看到，在<code>LinearLayout</code>的<code>onDraw(Canvas)</code>方法中，只是多绘制了一个<code>divider</code>，如果没有<code>divider</code>的话，那就不再处理。</p>
<h2 id="其他的重要方法"><a href="#其他的重要方法" class="headerlink" title="其他的重要方法"></a>其他的重要方法</h2><ul>
<li><code>invalidate()</code>方法：</li>
</ul>
<p>该方法请求重绘<code>View</code>树，即<code>draw</code>过程，假如视图发生大小没有变化就不会调用<code>layout</code>过程，并且只绘制那些『需要重绘的』<br>视图，即谁请求<code>invalidate()</code>方法，就绘制谁(<code>View</code>的话，只绘制该<code>View</code>；<code>ViewGroup</code>，则绘制整个<code>ViewGroup</code>)。</p>
<p>一般引起<code>invalidate()</code>操作的函数如下：</p>
<ol>
<li><p>直接调用<code>invalidate()</code>方法，请求重新<code>draw()</code>，但只会绘制调用者本身。</p>
</li>
<li><p><code>setSelection()</code>方法 ：请求重新<code>draw()</code>，但只会绘制调用者本身。</p>
</li>
<li><p><code>setVisibility()</code>方法 ： 当<code>View</code>可视状态在<code>INVISIBLE</code>转换<code>VISIBLE</code>时，会间接调用<code>invalidate()</code>方法，<br>继而绘制该View。</p>
</li>
<li><p><code>setEnabled()</code>方法 ： 请求重新<code>draw()</code>，但不会重新绘制任何视图包括该调用者本身。</p>
</li>
</ol>
<ul>
<li><code>requestLayout()</code>方法：</li>
</ul>
<p>看字面意思『请求布局』。调用该方法会导致调用<code>measure</code>过程和<code>layout</code>过程，但只是对<code>View</code>树重新布局，不会调用<code>draw</code>过程，也就是不会重新绘制。</p>
<p>看一眼它的源码吧：</p>
<pre><code class="java">    /**
     * 当某些东西发生了改变并刷新了 View 布局时，调用该方法。
     * 该方法会对 View 树进行一次 layout 流程。
     * 该方法不应该在 view 树正在进行 layout 流程（可由 isInLayout()方法判断）时被调用。
     * 如果调用该方法时正在进行 layout 流程，这次的请求会被放在当前 layout 流程结束之后（也就是再跑一次），或者是
     * 绘制完当前帧之后。
     *
     * 子类覆写该方法时，要调用 super.requestLayout() 以保证能正确处理一些 request-during-layout 的错误。
     */
    @CallSuper
    public void requestLayout() &#123;
        if (mMeasureCache != null) mMeasureCache.clear();

        if (mAttachInfo != null &amp;&amp; mAttachInfo.mViewRequestingLayout == null) &#123;
            // Only trigger request-during-layout logic if this is the view requesting it,
            // not the views in its parent hierarchy
            ViewRootImpl viewRoot = getViewRootImpl();
            if (viewRoot != null &amp;&amp; viewRoot.isInLayout()) &#123;
                if (!viewRoot.requestLayoutDuringLayout(this)) &#123;
                    return;
                &#125;
            &#125;
            mAttachInfo.mViewRequestingLayout = this;
        &#125;

        mPrivateFlags |= PFLAG_FORCE_LAYOUT;
        mPrivateFlags |= PFLAG_INVALIDATED;

        if (mParent != null &amp;&amp; !mParent.isLayoutRequested()) &#123;
            mParent.requestLayout();
        &#125;
        if (mAttachInfo != null &amp;&amp; mAttachInfo.mViewRequestingLayout == this) &#123;
            mAttachInfo.mViewRequestingLayout = null;
        &#125;
    &#125;
</code></pre>
<p>可以看到，<code>requestLayout()</code>方法会不断向上传，向父<code>view</code>请求布局，最后会交给<code>DecorView</code>，也即根<code>view</code>，最终会被<code>ViewRootImpl</code>接收并得到处理。关于<code>ViewRootImpl</code>，会单开一篇文章再来讲，里面会涉及到<code>Activity</code>、<code>Window</code>、<code>WindowManager</code>等内容。</p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/Android/Retrofit/" title="Retrofit 实现原理解析"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">Previous: Retrofit 实现原理解析</span></a><a class="button is-default" href="/Android/ViewRootImpl%20%E8%A7%A3%E6%9E%90/" title="ViewRootImpl 解析"><span class="has-text-weight-semibold">Next: ViewRootImpl 解析</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container" id="vcomments" data-comment_valine_id="b7rbKQnQFa9DYl1anYfacJRz-gzGzoHsz" data-comment_valine_key="nUuKvGHOJBRylruJLW2Fmekg"></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com//"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/serious198706"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com//"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com//"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> cy198706 2023</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="京ICP备2022033375号" target="_blank" rel="noopener" href="https://beian.miit.gov.cn/">京ICP备2022033375号 </a></p></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>