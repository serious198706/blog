<!DOCTYPE html><html class="appearance-user-can-set" lang="zh"><head><meta charset="UTF-8"><title>Notex</title><meta name="description" content="Keep low profile, he said."><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="40. 最小的 K 个数NowCoder
解题思路快速选择
复杂度：O(N) + O(1)
只有当允许修改数组元素时才可以使用

快速排序的 partition() 方法，会返回一个整数 j 使得 a[l..j-1] 小于等于 a[j]，且 a[j+1..h] 大于等于 a[j]，此时 a[j] 就是数组的第 j 大元素。可以利用这个特性找出数组的第 K 个元素，这种找第 K 个元素的算法称为快速选择算法。
public ArrayList&amp;lt;Integer&amp;gt; GetLeastNumbers_Solution(int[] nums, int k) &amp;#123;
    ArrayList&amp;lt;Integer&amp;gt; ret = new ArrayList&amp;lt;&amp;gt;();
    if (k.."><script src="//unpkg.com/valine/dist/Valine.min.js"></script><meta name="generator" content="Hexo 5.4.2"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><!-- a(href= url_for("/"))= (theme.user && theme.user.name || config.author) + "'s blog"--><a href="/">Notex</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center"></p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">主页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">主页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#40-%E6%9C%80%E5%B0%8F%E7%9A%84-K-%E4%B8%AA%E6%95%B0"><span class="toc-text">40. 最小的 K 个数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-text">解题思路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9"><span class="toc-text">快速选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E5%B0%8F%E4%B8%BA-K-%E7%9A%84%E6%9C%80%E5%B0%8F%E5%A0%86"><span class="toc-text">大小为 K 的最小堆</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#41-1-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="toc-text">41.1 数据流中的中位数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-1"><span class="toc-text">解题思路</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#41-2-%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6"><span class="toc-text">41.2 字符流中第一个不重复的字符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-2"><span class="toc-text">解题思路</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#42-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C"><span class="toc-text">42. 连续子数组的最大和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-2"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-3"><span class="toc-text">解题思路</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#43-%E4%BB%8E-1-%E5%88%B0-n-%E6%95%B4%E6%95%B0%E4%B8%AD-1-%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0"><span class="toc-text">43. 从 1 到 n 整数中 1 出现的次数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-4"><span class="toc-text">解题思路</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#44-%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E7%9A%84%E6%9F%90%E4%B8%80%E4%BD%8D%E6%95%B0%E5%AD%97"><span class="toc-text">44. 数字序列中的某一位数字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-3"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-5"><span class="toc-text">解题思路</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#45-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0"><span class="toc-text">45. 把数组排成最小的数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-4"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-6"><span class="toc-text">解题思路</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#46-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">46. 把数字翻译成字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-5"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-7"><span class="toc-text">解题思路</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#47-%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC"><span class="toc-text">47. 礼物的最大价值</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-6"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-8"><span class="toc-text">解题思路</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#48-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">48. 最长不含重复字符的子字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-7"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-9"><span class="toc-text">解题思路</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#49-%E4%B8%91%E6%95%B0"><span class="toc-text">49. 丑数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-8"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-10"><span class="toc-text">解题思路</span></a></li></ol></li></ol></div><div class="column is-9"><header class="my-4"></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle"></h1><time class="has-text-grey" datetime="2023-01-31T06:58:14.698Z">2023-01-31</time><article class="mt-2 post-content"><h1 id="40-最小的-K-个数"><a href="#40-最小的-K-个数" class="headerlink" title="40. 最小的 K 个数"></a>40. 最小的 K 个数</h1><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=13&tqId=11182&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">NowCoder</a></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="快速选择"><a href="#快速选择" class="headerlink" title="快速选择"></a>快速选择</h3><ul>
<li>复杂度：O(N) + O(1)</li>
<li>只有当允许修改数组元素时才可以使用</li>
</ul>
<p>快速排序的 partition() 方法，会返回一个整数 j 使得 a[l..j-1] 小于等于 a[j]，且 a[j+1..h] 大于等于 a[j]，此时 a[j] 就是数组的第 j 大元素。可以利用这个特性找出数组的第 K 个元素，这种找第 K 个元素的算法称为快速选择算法。</p>
<pre><code class="java">public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int[] nums, int k) &#123;
    ArrayList&lt;Integer&gt; ret = new ArrayList&lt;&gt;();
    if (k &gt; nums.length || k &lt;= 0)
        return ret;
    findKthSmallest(nums, k - 1);
    /* findKthSmallest 会改变数组，使得前 k 个数都是最小的 k 个数 */
    for (int i = 0; i &lt; k; i++)
        ret.add(nums[i]);
    return ret;
&#125;

public void findKthSmallest(int[] nums, int k) &#123;
    int l = 0, h = nums.length - 1;
    while (l &lt; h) &#123;
        int j = partition(nums, l, h);
        if (j == k)
            break;
        if (j &gt; k)
            h = j - 1;
        else
            l = j + 1;
    &#125;
&#125;

private int partition(int[] nums, int l, int h) &#123;
    int p = nums[l];     /* 切分元素 */
    int i = l, j = h + 1;
    while (true) &#123;
        while (i != h &amp;&amp; nums[++i] &lt; p) ;
        while (j != l &amp;&amp; nums[--j] &gt; p) ;
        if (i &gt;= j)
            break;
        swap(nums, i, j);
    &#125;
    swap(nums, l, j);
    return j;
&#125;

private void swap(int[] nums, int i, int j) &#123;
    int t = nums[i];
    nums[i] = nums[j];
    nums[j] = t;
&#125;
</code></pre>
<h3 id="大小为-K-的最小堆"><a href="#大小为-K-的最小堆" class="headerlink" title="大小为 K 的最小堆"></a>大小为 K 的最小堆</h3><ul>
<li>复杂度：O(NlogK) + O(K)</li>
<li>特别适合处理海量数据</li>
</ul>
<p>应该使用大顶堆来维护最小堆，而不能直接创建一个小顶堆并设置一个大小，企图让小顶堆中的元素都是最小元素。</p>
<p>维护一个大小为 K 的最小堆过程如下：在添加一个元素之后，如果大顶堆的大小大于 K，那么需要将大顶堆的堆顶元素去除。</p>
<pre><code class="java">public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int[] nums, int k) &#123;
    if (k &gt; nums.length || k &lt;= 0)
        return new ArrayList&lt;&gt;();
    PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);
    for (int num : nums) &#123;
        maxHeap.add(num);
        if (maxHeap.size() &gt; k)
            maxHeap.poll();
    &#125;
    return new ArrayList&lt;&gt;(maxHeap);
&#125;
</code></pre>
<h1 id="41-1-数据流中的中位数"><a href="#41-1-数据流中的中位数" class="headerlink" title="41.1 数据流中的中位数"></a>41.1 数据流中的中位数</h1><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/9be0172896bd43948f8a32fb954e1be1?tpId=13&tqId=11216&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">NowCoder</a></p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p>
<h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><pre><code class="java">/* 大顶堆，存储左半边元素 */
private PriorityQueue&lt;Integer&gt; left = new PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);
/* 小顶堆，存储右半边元素，并且右半边元素都大于左半边 */
private PriorityQueue&lt;Integer&gt; right = new PriorityQueue&lt;&gt;();
/* 当前数据流读入的元素个数 */
private int N = 0;

public void Insert(Integer val) &#123;
    /* 插入要保证两个堆存于平衡状态 */
    if (N % 2 == 0) &#123;
        /* N 为偶数的情况下插入到右半边。
         * 因为右半边元素都要大于左半边，但是新插入的元素不一定比左半边元素来的大，
         * 因此需要先将元素插入左半边，然后利用左半边为大顶堆的特点，取出堆顶元素即为最大元素，此时插入右半边 */
        left.add(val);
        right.add(left.poll());
    &#125; else &#123;
        right.add(val);
        left.add(right.poll());
    &#125;
    N++;
&#125;

public Double GetMedian() &#123;
    if (N % 2 == 0)
        return (left.peek() + right.peek()) / 2.0;
    else
        return (double) right.peek();
&#125;
</code></pre>
<h1 id="41-2-字符流中第一个不重复的字符"><a href="#41-2-字符流中第一个不重复的字符" class="headerlink" title="41.2 字符流中第一个不重复的字符"></a>41.2 字符流中第一个不重复的字符</h1><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/00de97733b8e4f97a3fb5c680ee10720?tpId=13&tqId=11207&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">NowCoder</a></p>
<h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符 “go” 时，第一个只出现一次的字符是 “g”。当从该字符流中读出前六个字符“google” 时，第一个只出现一次的字符是 “l”。</p>
<h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><pre><code class="java">private int[] cnts = new int[256];
private Queue&lt;Character&gt; queue = new LinkedList&lt;&gt;();

public void Insert(char ch) &#123;
    cnts[ch]++;
    queue.add(ch);
    while (!queue.isEmpty() &amp;&amp; cnts[queue.peek()] &gt; 1)
        queue.poll();
&#125;

public char FirstAppearingOnce() &#123;
    return queue.isEmpty() ? &#39;#&#39; : queue.peek();
&#125;
</code></pre>
<h1 id="42-连续子数组的最大和"><a href="#42-连续子数组的最大和" class="headerlink" title="42. 连续子数组的最大和"></a>42. 连续子数组的最大和</h1><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/459bd355da1549fa8a49e350bf3df484?tpId=13&tqId=11183&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">NowCoder</a></p>
<h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>{6, -3, -2, 7, -15, 1, 2, 2}，连续子数组的最大和为 8（从第 0 个开始，到第 3 个为止）。</p>
<h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><pre><code class="java">public int FindGreatestSumOfSubArray(int[] nums) &#123;
    if (nums == null || nums.length == 0)
        return 0;
    int greatestSum = Integer.MIN_VALUE;
    int sum = 0;
    for (int val : nums) &#123;
        sum = sum &lt;= 0 ? val : sum + val;
        greatestSum = Math.max(greatestSum, sum);
    &#125;
    return greatestSum;
&#125;
</code></pre>
<h1 id="43-从-1-到-n-整数中-1-出现的次数"><a href="#43-从-1-到-n-整数中-1-出现的次数" class="headerlink" title="43. 从 1 到 n 整数中 1 出现的次数"></a>43. 从 1 到 n 整数中 1 出现的次数</h1><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/bd7f978302044eee894445e244c7eee6?tpId=13&tqId=11184&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">NowCoder</a></p>
<h2 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h2><pre><code class="java">public int NumberOf1Between1AndN_Solution(int n) &#123;
    int cnt = 0;
    for (int m = 1; m &lt;= n; m *= 10) &#123;
        int a = n / m, b = n % m;
        cnt += (a + 8) / 10 * m + (a % 10 == 1 ? b + 1 : 0);
    &#125;
    return cnt;
&#125;
</code></pre>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/number-of-digit-one/discuss/64381/4+-lines-O(log-n)-C++JavaPython">Leetcode : 233. Number of Digit One</a></p>
</blockquote>
<h1 id="44-数字序列中的某一位数字"><a href="#44-数字序列中的某一位数字" class="headerlink" title="44. 数字序列中的某一位数字"></a>44. 数字序列中的某一位数字</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>数字以 0123456789101112131415… 的格式序列化到一个字符串中，求这个字符串的第 index 位。</p>
<h2 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h2><pre><code class="java">public int getDigitAtIndex(int index) &#123;
    if (index &lt; 0)
        return -1;
    int place = 1;  // 1 表示个位，2 表示 十位...
    while (true) &#123;
        int amount = getAmountOfPlace(place);
        int totalAmount = amount * place;
        if (index &lt; totalAmount)
            return getDigitAtIndex(index, place);
        index -= totalAmount;
        place++;
    &#125;
&#125;

/**
 * place 位数的数字组成的字符串长度
 * 10, 90, 900, ...
 */
private int getAmountOfPlace(int place) &#123;
    if (place == 1)
        return 10;
    return (int) Math.pow(10, place - 1) * 9;
&#125;

/**
 * place 位数的起始数字
 * 0, 10, 100, ...
 */
private int getBeginNumberOfPlace(int place) &#123;
    if (place == 1)
        return 0;
    return (int) Math.pow(10, place - 1);
&#125;

/**
 * 在 place 位数组成的字符串中，第 index 个数
 */
private int getDigitAtIndex(int index, int place) &#123;
    int beginNumber = getBeginNumberOfPlace(place);
    int shiftNumber = index / place;
    String number = (beginNumber + shiftNumber) + &quot;&quot;;
    int count = index % place;
    return number.charAt(count) - &#39;0&#39;;
&#125;
</code></pre>
<h1 id="45-把数组排成最小的数"><a href="#45-把数组排成最小的数" class="headerlink" title="45. 把数组排成最小的数"></a>45. 把数组排成最小的数</h1><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/8fecd3f8ba334add803bf2a06af1b993?tpId=13&tqId=11185&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">NowCoder</a></p>
<h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组 {3，32，321}，则打印出这三个数字能排成的最小数字为 321323。</p>
<h2 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h2><p>可以看成是一个排序问题，在比较两个字符串 S1 和 S2 的大小时，应该比较的是 S1+S2 和 S2+S1 的大小，如果 S1+S2 &lt; S2+S1，那么应该把 S1 排在前面，否则应该把 S2 排在前面。</p>
<pre><code class="java">public String PrintMinNumber(int[] numbers) &#123;
    if (numbers == null || numbers.length == 0)
        return &quot;&quot;;
    int n = numbers.length;
    String[] nums = new String[n];
    for (int i = 0; i &lt; n; i++)
        nums[i] = numbers[i] + &quot;&quot;;
    Arrays.sort(nums, (s1, s2) -&gt; (s1 + s2).compareTo(s2 + s1));
    String ret = &quot;&quot;;
    for (String str : nums)
        ret += str;
    return ret;
&#125;
</code></pre>
<h1 id="46-把数字翻译成字符串"><a href="#46-把数字翻译成字符串" class="headerlink" title="46. 把数字翻译成字符串"></a>46. 把数字翻译成字符串</h1><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/decode-ways/description/">Leetcode</a></p>
<h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数字，按照如下规则翻译成字符串：1 翻译成“a”，2 翻译成“b”… 26 翻译成“z”。一个数字有多种翻译可能，例如 12258 一共有 5 种，分别是 abbeh，lbeh，aveh，abyh，lyh。实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p>
<h2 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h2><pre><code class="java">public int numDecodings(String s) &#123;
    if (s == null || s.length() == 0)
        return 0;
    int n = s.length();
    int[] dp = new int[n + 1];
    dp[0] = 1;
    dp[1] = s.charAt(0) == &#39;0&#39; ? 0 : 1;
    for (int i = 2; i &lt;= n; i++) &#123;
        int one = Integer.valueOf(s.substring(i - 1, i));
        if (one != 0)
            dp[i] += dp[i - 1];
        if (s.charAt(i - 2) == &#39;0&#39;)
            continue;
        int two = Integer.valueOf(s.substring(i - 2, i));
        if (two &lt;= 26)
            dp[i] += dp[i - 2];
    &#125;
    return dp[n];
&#125;
</code></pre>
<h1 id="47-礼物的最大价值"><a href="#47-礼物的最大价值" class="headerlink" title="47. 礼物的最大价值"></a>47. 礼物的最大价值</h1><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/questionTerminal/72a99e28381a407991f2c96d8cb238ab">NowCoder</a></p>
<h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个 m*n 的棋盘的每一个格都放有一个礼物，每个礼物都有一定价值（大于 0）。从左上角开始拿礼物，每次向右或向下移动一格，直到右下角结束。给定一个棋盘，求拿到礼物的最大价值。例如，对于如下棋盘</p>
<pre><code>1    10   3    8
12   2    9    6
5    7    4    11
3    7    16   5
</code></pre>
<p>礼物的最大价值为 1+12+5+7+7+16+5=53。</p>
<h2 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h2><p>应该用动态规划求解，而不是深度优先搜索，深度优先搜索过于复杂，不是最优解。</p>
<pre><code class="java">public int getMost(int[][] values) &#123;
    if (values == null || values.length == 0 || values[0].length == 0)
        return 0;
    int n = values[0].length;
    int[] dp = new int[n];
    for (int[] value : values) &#123;
        dp[0] += value[0];
        for (int i = 1; i &lt; n; i++)
            dp[i] = Math.max(dp[i], dp[i - 1]) + value[i];
    &#125;
    return dp[n - 1];
&#125;
</code></pre>
<h1 id="48-最长不含重复字符的子字符串"><a href="#48-最长不含重复字符的子字符串" class="headerlink" title="48. 最长不含重复字符的子字符串"></a>48. 最长不含重复字符的子字符串</h1><h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个字符串（只包含 a~z 的字符），求其最长不含重复字符的子字符串的长度。例如对于 arabcacfr，最长不含重复字符的子字符串为 acfr，长度为 4。</p>
<h2 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h2><pre><code class="java">public int longestSubStringWithoutDuplication(String str) &#123;
    int curLen = 0;
    int maxLen = 0;
    int[] preIndexs = new int[26];
    Arrays.fill(preIndexs, -1);
    for (int curI = 0; curI &lt; str.length(); curI++) &#123;
        int c = str.charAt(curI) - &#39;a&#39;;
        int preI = preIndexs[c];
        if (preI == -1 || curI - preI &gt; curLen) &#123;
            curLen++;
        &#125; else &#123;
            maxLen = Math.max(maxLen, curLen);
            curLen = curI - preI;
        &#125;
        preIndexs[c] = curI;
    &#125;
    maxLen = Math.max(maxLen, curLen);
    return maxLen;
&#125;
</code></pre>
<h1 id="49-丑数"><a href="#49-丑数" class="headerlink" title="49. 丑数"></a>49. 丑数</h1><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/6aa9e04fc3794f68acf8778237ba065b?tpId=13&tqId=11186&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">NowCoder</a></p>
<h2 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h2><p>把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。例如 6、8 都是丑数，但 14 不是，因为它包含因子 7。习惯上我们把 1 当做是第一个丑数。求按从小到大的顺序的第 N 个丑数。</p>
<h2 id="解题思路-10"><a href="#解题思路-10" class="headerlink" title="解题思路"></a>解题思路</h2><pre><code class="java">public int GetUglyNumber_Solution(int N) &#123;
    if (N &lt;= 6)
        return N;
    int i2 = 0, i3 = 0, i5 = 0;
    int[] dp = new int[N];
    dp[0] = 1;
    for (int i = 1; i &lt; N; i++) &#123;
        int next2 = dp[i2] * 2, next3 = dp[i3] * 3, next5 = dp[i5] * 5;
        dp[i] = Math.min(next2, Math.min(next3, next5));
        if (dp[i] == next2)
            i2++;
        if (dp[i] == next3)
            i3++;
        if (dp[i] == next5)
            i5++;
    &#125;
    return dp[N - 1];
&#125;
</code></pre>
<div align="center"><img width="320px" src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/githubio/公众号二维码-2.png"></img></div>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><em></em></section><article class="mt-6 comment-container" id="vcomments" data-comment_valine_id="b7rbKQnQFa9DYl1anYfacJRz-gzGzoHsz" data-comment_valine_key="nUuKvGHOJBRylruJLW2Fmekg"></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com//"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/serious198706"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com//"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com//"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> cy198706 2023</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="京ICP备2022033375号" target="_blank" rel="noopener" href="https://beian.miit.gov.cn/">京ICP备2022033375号 </a></p></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>