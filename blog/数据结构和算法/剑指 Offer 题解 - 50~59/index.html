<!DOCTYPE html><html class="appearance-user-can-set" lang="zh"><head><meta charset="UTF-8"><title>Notex</title><meta name="description" content="Keep low profile, he said."><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="
50. 第一个只出现一次的字符位置
51. 数组中的逆序对
52. 两个链表的第一个公共结点
53. 数字在排序数组中出现的次数
54. 二叉查找树的第 K 个结点
55.1 二叉树的深度
55.2 平衡二叉树
56. 数组中只出现一次的数字
57.1 和为 S 的两个数字
57.2 和为 S 的连续正数序列
58.1 翻转单词顺序列
58.2 左旋转字符串
59. 滑动窗口的最大值

50. 第一个只出现一次的字符位置NowCoder
题目描述在一个字符串中找到第一个只出现一次的字符，并返回它的位置。
Input: abacc
Output: b

解题思路最直观的解法是使用 HashMap 对出现次数进行统计，但是考虑到要统计的字符范围有限，因此可以使用整型数组代替 HashMap，从而将空间复杂度由.."><script src="//unpkg.com/valine/dist/Valine.min.js"></script><meta name="generator" content="Hexo 5.4.2"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><!-- a(href= url_for("/"))= (theme.user && theme.user.name || config.author) + "'s blog"--><a href="/">Notex</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center"></p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">主页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">主页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#50-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6%E4%BD%8D%E7%BD%AE"><span class="toc-text">50. 第一个只出现一次的字符位置</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-text">解题思路</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#51-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9"><span class="toc-text">51. 数组中的逆序对</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-1"><span class="toc-text">解题思路</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#52-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9"><span class="toc-text">52. 两个链表的第一个公共结点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-2"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-2"><span class="toc-text">解题思路</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#53-%E6%95%B0%E5%AD%97%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0"><span class="toc-text">53. 数字在排序数组中出现的次数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-3"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-3"><span class="toc-text">解题思路</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#54-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E7%9A%84%E7%AC%AC-K-%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="toc-text">54. 二叉查找树的第 K 个结点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-4"><span class="toc-text">解题思路</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#55-1-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6"><span class="toc-text">55.1 二叉树的深度</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-4"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-5"><span class="toc-text">解题思路</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#55-2-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">55.2 平衡二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-5"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-6"><span class="toc-text">解题思路</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#56-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-text">56. 数组中只出现一次的数字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-6"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-7"><span class="toc-text">解题思路</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#57-1-%E5%92%8C%E4%B8%BA-S-%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97"><span class="toc-text">57.1 和为 S 的两个数字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-7"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-8"><span class="toc-text">解题思路</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#57-2-%E5%92%8C%E4%B8%BA-S-%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97"><span class="toc-text">57.2 和为 S 的连续正数序列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-8"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-9"><span class="toc-text">解题思路</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#58-1-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F%E5%88%97"><span class="toc-text">58.1 翻转单词顺序列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-9"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-10"><span class="toc-text">解题思路</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#58-2-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">58.2 左旋转字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-10"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-11"><span class="toc-text">解题思路</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#59-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-text">59. 滑动窗口的最大值</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-11"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-12"><span class="toc-text">解题思路</span></a></li></ol></li></ol></div><div class="column is-9"><header class="my-4"></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle"></h1><time class="has-text-grey" datetime="2023-01-31T06:58:14.700Z">2023-01-31</time><article class="mt-2 post-content"><ul>
<li><a href="#50-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6%E4%BD%8D%E7%BD%AE">50. 第一个只出现一次的字符位置</a></li>
<li><a href="#51-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9">51. 数组中的逆序对</a></li>
<li><a href="#52-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9">52. 两个链表的第一个公共结点</a></li>
<li><a href="#53-%E6%95%B0%E5%AD%97%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0">53. 数字在排序数组中出现的次数</a></li>
<li><a href="#54-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E7%9A%84%E7%AC%AC-k-%E4%B8%AA%E7%BB%93%E7%82%B9">54. 二叉查找树的第 K 个结点</a></li>
<li><a href="#551-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6">55.1 二叉树的深度</a></li>
<li><a href="#552-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91">55.2 平衡二叉树</a></li>
<li><a href="#56-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97">56. 数组中只出现一次的数字</a></li>
<li><a href="#571-%E5%92%8C%E4%B8%BA-s-%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97">57.1 和为 S 的两个数字</a></li>
<li><a href="#572-%E5%92%8C%E4%B8%BA-s-%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97">57.2 和为 S 的连续正数序列</a></li>
<li><a href="#581-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F%E5%88%97">58.1 翻转单词顺序列</a></li>
<li><a href="#582-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2">58.2 左旋转字符串</a></li>
<li><a href="#59-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC">59. 滑动窗口的最大值</a></li>
</ul>
<h1 id="50-第一个只出现一次的字符位置"><a href="#50-第一个只出现一次的字符位置" class="headerlink" title="50. 第一个只出现一次的字符位置"></a>50. 第一个只出现一次的字符位置</h1><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/1c82e8cf713b4bbeb2a5b31cf5b0417c?tpId=13&tqId=11187&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">NowCoder</a></p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个字符串中找到第一个只出现一次的字符，并返回它的位置。</p>
<pre><code>Input: abacc
Output: b
</code></pre>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>最直观的解法是使用 HashMap 对出现次数进行统计，但是考虑到要统计的字符范围有限，因此可以使用整型数组代替 HashMap，从而将空间复杂度由 O(N) 降低为 O(1)。</p>
<pre><code class="java">public int FirstNotRepeatingChar(String str) &#123;
    int[] cnts = new int[256];
    for (int i = 0; i &lt; str.length(); i++)
        cnts[str.charAt(i)]++;
    for (int i = 0; i &lt; str.length(); i++)
        if (cnts[str.charAt(i)] == 1)
            return i;
    return -1;
&#125;
</code></pre>
<p>以上实现的空间复杂度还不是最优的。考虑到只需要找到只出现一次的字符，那么需要统计的次数信息只有 0,1,更大，使用两个比特位就能存储这些信息。</p>
<pre><code class="java">public int FirstNotRepeatingChar2(String str) &#123;
    BitSet bs1 = new BitSet(256);
    BitSet bs2 = new BitSet(256);
    for (char c : str.toCharArray()) &#123;
        if (!bs1.get(c) &amp;&amp; !bs2.get(c))
            bs1.set(c);     // 0 0 -&gt; 0 1
        else if (bs1.get(c) &amp;&amp; !bs2.get(c))
            bs2.set(c);     // 0 1 -&gt; 1 1
    &#125;
    for (int i = 0; i &lt; str.length(); i++) &#123;
        char c = str.charAt(i);
        if (bs1.get(c) &amp;&amp; !bs2.get(c))  // 0 1
            return i;
    &#125;
    return -1;
&#125;
</code></pre>
<h1 id="51-数组中的逆序对"><a href="#51-数组中的逆序对" class="headerlink" title="51. 数组中的逆序对"></a>51. 数组中的逆序对</h1><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5?tpId=13&tqId=11188&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">NowCoder</a></p>
<h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p>
<h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><pre><code class="java">private long cnt = 0;
private int[] tmp;  // 在这里声明辅助数组，而不是在 merge() 递归函数中声明

public int InversePairs(int[] nums) &#123;
    tmp = new int[nums.length];
    mergeSort(nums, 0, nums.length - 1);
    return (int) (cnt % 1000000007);
&#125;

private void mergeSort(int[] nums, int l, int h) &#123;
    if (h - l &lt; 1)
        return;
    int m = l + (h - l) / 2;
    mergeSort(nums, l, m);
    mergeSort(nums, m + 1, h);
    merge(nums, l, m, h);
&#125;

private void merge(int[] nums, int l, int m, int h) &#123;
    int i = l, j = m + 1, k = l;
    while (i &lt;= m || j &lt;= h) &#123;
        if (i &gt; m)
            tmp[k] = nums[j++];
        else if (j &gt; h)
            tmp[k] = nums[i++];
        else if (nums[i] &lt;= nums[j])
            tmp[k] = nums[i++];
        else &#123;
            tmp[k] = nums[j++];
            this.cnt += m - i + 1;  // nums[i] &gt; nums[j]，说明 nums[i...mid] 都大于 nums[j]
        &#125;
        k++;
    &#125;
    for (k = l; k &lt;= h; k++)
        nums[k] = tmp[k];
&#125;
</code></pre>
<h1 id="52-两个链表的第一个公共结点"><a href="#52-两个链表的第一个公共结点" class="headerlink" title="52. 两个链表的第一个公共结点"></a>52. 两个链表的第一个公共结点</h1><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=13&tqId=11189&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">NowCoder</a></p>
<h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5f1cb999-cb9a-4f6c-a0af-d90377295ab8.png" width="500"/> </div><br>

<h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b = b + c + a。</p>
<p>当访问链表 A 的指针访问到链表尾部时，令它从链表 B 的头部重新开始访问链表 B；同样地，当访问链表 B 的指针访问到链表尾部时，令它从链表 A 的头部重新开始访问链表 A。这样就能控制访问 A 和 B 两个链表的指针能同时访问到交点。</p>
<pre><code class="java">public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) &#123;
    ListNode l1 = pHead1, l2 = pHead2;
    while (l1 != l2) &#123;
        l1 = (l1 == null) ? pHead2 : l1.next;
        l2 = (l2 == null) ? pHead1 : l2.next;
    &#125;
    return l1;
&#125;
</code></pre>
<h1 id="53-数字在排序数组中出现的次数"><a href="#53-数字在排序数组中出现的次数" class="headerlink" title="53. 数字在排序数组中出现的次数"></a>53. 数字在排序数组中出现的次数</h1><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/70610bf967994b22bb1c26f9ae901fa2?tpId=13&tqId=11190&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">NowCoder</a></p>
<h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code class="html">Input:
nums = 1, 2, 3, 3, 3, 3, 4, 6
K = 3

Output:
4
</code></pre>
<h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><pre><code class="java">public int GetNumberOfK(int[] nums, int K) &#123;
    int first = binarySearch(nums, K);
    int last = binarySearch(nums, K + 1);
    return (first == nums.length || nums[first] != K) ? 0 : last - first;
&#125;

private int binarySearch(int[] nums, int K) &#123;
    int l = 0, h = nums.length;
    while (l &lt; h) &#123;
        int m = l + (h - l) / 2;
        if (nums[m] &gt;= K)
            h = m;
        else
            l = m + 1;
    &#125;
    return l;
&#125;
</code></pre>
<h1 id="54-二叉查找树的第-K-个结点"><a href="#54-二叉查找树的第-K-个结点" class="headerlink" title="54. 二叉查找树的第 K 个结点"></a>54. 二叉查找树的第 K 个结点</h1><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/ef068f602dde4d28aab2b210e859150a?tpId=13&tqId=11215&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">NowCoder</a></p>
<h2 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h2><p>利用二叉查找树中序遍历有序的特点。</p>
<pre><code class="java">private TreeNode ret;
private int cnt = 0;

public TreeNode KthNode(TreeNode pRoot, int k) &#123;
    inOrder(pRoot, k);
    return ret;
&#125;

private void inOrder(TreeNode root, int k) &#123;
    if (root == null || cnt &gt;= k)
        return;
    inOrder(root.left, k);
    cnt++;
    if (cnt == k)
        ret = root;
    inOrder(root.right, k);
&#125;
</code></pre>
<h1 id="55-1-二叉树的深度"><a href="#55-1-二叉树的深度" class="headerlink" title="55.1 二叉树的深度"></a>55.1 二叉树的深度</h1><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/435fb86331474282a3499955f0a41e8b?tpId=13&tqId=11191&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">NowCoder</a></p>
<h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ba355101-4a93-4c71-94fb-1da83639727b.jpg" width="350px"/> </div><br>

<h2 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h2><pre><code class="java">public int TreeDepth(TreeNode root) &#123;
    return root == null ? 0 : 1 + Math.max(TreeDepth(root.left), TreeDepth(root.right));
&#125;
</code></pre>
<h1 id="55-2-平衡二叉树"><a href="#55-2-平衡二叉树" class="headerlink" title="55.2 平衡二叉树"></a>55.2 平衡二叉树</h1><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/8b3b95850edb4115918ecebdf1b4d222?tpId=13&tqId=11192&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">NowCoder</a></p>
<h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>平衡二叉树左右子树高度差不超过 1。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/af1d1166-63af-47b6-9aa3-2bf2bd37bd03.jpg" width="250px"/> </div><br>

<h2 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h2><pre><code class="java">private boolean isBalanced = true;

public boolean IsBalanced_Solution(TreeNode root) &#123;
    height(root);
    return isBalanced;
&#125;

private int height(TreeNode root) &#123;
    if (root == null || !isBalanced)
        return 0;
    int left = height(root.left);
    int right = height(root.right);
    if (Math.abs(left - right) &gt; 1)
        isBalanced = false;
    return 1 + Math.max(left, right);
&#125;
</code></pre>
<h1 id="56-数组中只出现一次的数字"><a href="#56-数组中只出现一次的数字" class="headerlink" title="56. 数组中只出现一次的数字"></a>56. 数组中只出现一次的数字</h1><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/e02fdb54d7524710a7d664d082bb7811?tpId=13&tqId=11193&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">NowCoder</a></p>
<h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次，找出这两个数。</p>
<h2 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h2><p>两个不相等的元素在位级表示上必定会有一位存在不同，将数组的所有元素异或得到的结果为不存在重复的两个元素异或的结果。</p>
<p>diff &amp;= -diff 得到出 diff 最右侧不为 0 的位，也就是不存在重复的两个元素在位级表示上最右侧不同的那一位，利用这一位就可以将两个元素区分开来。</p>
<pre><code class="java">public void FindNumsAppearOnce(int[] nums, int num1[], int num2[]) &#123;
    int diff = 0;
    for (int num : nums)
        diff ^= num;
    diff &amp;= -diff;
    for (int num : nums) &#123;
        if ((num &amp; diff) == 0)
            num1[0] ^= num;
        else
            num2[0] ^= num;
    &#125;
&#125;
</code></pre>
<h1 id="57-1-和为-S-的两个数字"><a href="#57-1-和为-S-的两个数字" class="headerlink" title="57.1 和为 S 的两个数字"></a>57.1 和为 S 的两个数字</h1><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/390da4f7a00f44bea7c2f3d19491311b?tpId=13&tqId=11195&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">NowCoder</a></p>
<h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个递增排序的数组和一个数字 S，在数组中查找两个数，使得他们的和正好是 S。如果有多对数字的和等于 S，输出两个数的乘积最小的。</p>
<h2 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用双指针，一个指针指向元素较小的值，一个指针指向元素较大的值。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。</p>
<ul>
<li>如果两个指针指向元素的和 sum == target，那么得到要求的结果；</li>
<li>如果 sum &gt; target，移动较大的元素，使 sum 变小一些；</li>
<li>如果 sum &lt; target，移动较小的元素，使 sum 变大一些。</li>
</ul>
<pre><code class="java">public ArrayList&lt;Integer&gt; FindNumbersWithSum(int[] array, int sum) &#123;
    int i = 0, j = array.length - 1;
    while (i &lt; j) &#123;
        int cur = array[i] + array[j];
        if (cur == sum)
            return new ArrayList&lt;&gt;(Arrays.asList(array[i], array[j]));
        if (cur &lt; sum)
            i++;
        else
            j--;
    &#125;
    return new ArrayList&lt;&gt;();
&#125;
</code></pre>
<h1 id="57-2-和为-S-的连续正数序列"><a href="#57-2-和为-S-的连续正数序列" class="headerlink" title="57.2 和为 S 的连续正数序列"></a>57.2 和为 S 的连续正数序列</h1><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/c451a3fd84b64cb19485dad758a55ebe?tpId=13&tqId=11194&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">NowCoder</a></p>
<h2 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h2><p>输出所有和为 S 的连续正数序列。</p>
<p>例如和为 100 的连续序列有：</p>
<pre><code>[9, 10, 11, 12, 13, 14, 15, 16]
[18, 19, 20, 21, 22]。
</code></pre>
<h2 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h2><pre><code class="java">public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindContinuousSequence(int sum) &#123;
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;();
    int start = 1, end = 2;
    int curSum = 3;
    while (end &lt; sum) &#123;
        if (curSum &gt; sum) &#123;
            curSum -= start;
            start++;
        &#125; else if (curSum &lt; sum) &#123;
            end++;
            curSum += end;
        &#125; else &#123;
            ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();
            for (int i = start; i &lt;= end; i++)
                list.add(i);
            ret.add(list);
            curSum -= start;
            start++;
            end++;
            curSum += end;
        &#125;
    &#125;
    return ret;
&#125;
</code></pre>
<h1 id="58-1-翻转单词顺序列"><a href="#58-1-翻转单词顺序列" class="headerlink" title="58.1 翻转单词顺序列"></a>58.1 翻转单词顺序列</h1><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/3194a4f4cf814f63919d0790578d51f3?tpId=13&tqId=11197&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">NowCoder</a></p>
<h2 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code class="html">Input:
&quot;I am a student.&quot;

Output:
&quot;student. a am I&quot;
</code></pre>
<h2 id="解题思路-10"><a href="#解题思路-10" class="headerlink" title="解题思路"></a>解题思路</h2><p>题目应该有一个隐含条件，就是不能用额外的空间。虽然 Java 的题目输入参数为 String 类型，需要先创建一个字符数组使得空间复杂度为 O(N)，但是正确的参数类型应该和原书一样，为字符数组，并且只能使用该字符数组的空间。任何使用了额外空间的解法在面试时都会大打折扣，包括递归解法。</p>
<p>正确的解法应该是和书上一样，先旋转每个单词，再旋转整个字符串。</p>
<pre><code class="java">public String ReverseSentence(String str) &#123;
    int n = str.length();
    char[] chars = str.toCharArray();
    int i = 0, j = 0;
    while (j &lt;= n) &#123;
        if (j == n || chars[j] == &#39; &#39;) &#123;
            reverse(chars, i, j - 1);
            i = j + 1;
        &#125;
        j++;
    &#125;
    reverse(chars, 0, n - 1);
    return new String(chars);
&#125;

private void reverse(char[] c, int i, int j) &#123;
    while (i &lt; j)
        swap(c, i++, j--);
&#125;

private void swap(char[] c, int i, int j) &#123;
    char t = c[i];
    c[i] = c[j];
    c[j] = t;
&#125;
</code></pre>
<h1 id="58-2-左旋转字符串"><a href="#58-2-左旋转字符串" class="headerlink" title="58.2 左旋转字符串"></a>58.2 左旋转字符串</h1><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/12d959b108cb42b1ab72cef4d36af5ec?tpId=13&tqId=11196&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">NowCoder</a></p>
<h2 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code class="html">Input:
S=&quot;abcXYZdef&quot;
K=3

Output:
&quot;XYZdefabc&quot;
</code></pre>
<h2 id="解题思路-11"><a href="#解题思路-11" class="headerlink" title="解题思路"></a>解题思路</h2><p>先将 “abc” 和 “XYZdef” 分别翻转，得到 “cbafedZYX”，然后再把整个字符串翻转得到 “XYZdefabc”。</p>
<pre><code class="java">public String LeftRotateString(String str, int n) &#123;
    if (n &gt;= str.length())
        return str;
    char[] chars = str.toCharArray();
    reverse(chars, 0, n - 1);
    reverse(chars, n, chars.length - 1);
    reverse(chars, 0, chars.length - 1);
    return new String(chars);
&#125;

private void reverse(char[] chars, int i, int j) &#123;
    while (i &lt; j)
        swap(chars, i++, j--);
&#125;

private void swap(char[] chars, int i, int j) &#123;
    char t = chars[i];
    chars[i] = chars[j];
    chars[j] = t;
&#125;
</code></pre>
<h1 id="59-滑动窗口的最大值"><a href="#59-滑动窗口的最大值" class="headerlink" title="59. 滑动窗口的最大值"></a>59. 滑动窗口的最大值</h1><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/1624bc35a45c42c0bc17d17fa0cba788?tpId=13&tqId=11217&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">NowCoder</a></p>
<h2 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。</p>
<p>例如，如果输入数组 {2, 3, 4, 2, 6, 2, 5, 1} 及滑动窗口的大小 3，那么一共存在 6 个滑动窗口，他们的最大值分别为 {4, 4, 6, 6, 6, 5}。</p>
<h2 id="解题思路-12"><a href="#解题思路-12" class="headerlink" title="解题思路"></a>解题思路</h2><pre><code class="java">public ArrayList&lt;Integer&gt; maxInWindows(int[] num, int size) &#123;
    ArrayList&lt;Integer&gt; ret = new ArrayList&lt;&gt;();
    if (size &gt; num.length || size &lt; 1)
        return ret;
    PriorityQueue&lt;Integer&gt; heap = new PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);  /* 大顶堆 */
    for (int i = 0; i &lt; size; i++)
        heap.add(num[i]);
    ret.add(heap.peek());
    for (int i = 0, j = i + size; j &lt; num.length; i++, j++) &#123;            /* 维护一个大小为 size 的大顶堆 */
        heap.remove(num[i]);
        heap.add(num[j]);
        ret.add(heap.peek());
    &#125;
    return ret;
&#125;
</code></pre>
<div align="center"><img width="320px" src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/githubio/公众号二维码-2.png"></img></div>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><em></em></section><article class="mt-6 comment-container" id="vcomments" data-comment_valine_id="b7rbKQnQFa9DYl1anYfacJRz-gzGzoHsz" data-comment_valine_key="nUuKvGHOJBRylruJLW2Fmekg"></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com//"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/serious198706"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com//"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com//"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> cy198706 2023</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="京ICP备2022033375号" target="_blank" rel="noopener" href="https://beian.miit.gov.cn/">京ICP备2022033375号 </a></p></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>