<!DOCTYPE html><html class="appearance-user-can-set" lang="zh"><head><meta charset="UTF-8"><title>Notex</title><meta name="description" content="Keep low profile, he said."><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="
一、构建工具的作用
二、Java 主流构建工具
三、Maven
参考资料

一、构建工具的作用构建一个项目通常包含了依赖管理、测试、编译、打包、发布等流程，构建工具可以自动化进行这些操作，从而为我们减少这些繁琐的工作。
其中构建工具提供的依赖管理能够可以自动处理依赖关系。例如一个项目需要用到依赖 A，A 又依赖于 B，那么构建工具就能帮我们导入 B，而不需要我们手动去寻找并导入。
在 Java 项目中，打包流程通常是将项目打包成 Jar 包。在没有构建工具的情况下，我们需要使用命令行工具或者 IDE 手动打包。而发布流程通常是将 Jar 包上传到服务器上。
二、Java 主流构建工具Ant 具有编译、测试和打包功能，其后出现的 Maven 在 Ant 的功能基础上又新增了依赖管理功能，而最新的 Gradl.."><script src="//unpkg.com/valine/dist/Valine.min.js"></script><meta name="generator" content="Hexo 5.4.2"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><!-- a(href= url_for("/"))= (theme.user && theme.user.name || config.author) + "'s blog"--><a href="/">Notex</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center"></p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">主页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">主页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">一、构建工具的作用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Java-%E4%B8%BB%E6%B5%81%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7"><span class="toc-text">二、Java 主流构建工具</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81Maven"><span class="toc-text">三、Maven</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%93%E5%BA%93"><span class="toc-text">仓库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#POM"><span class="toc-text">POM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%8E%9F%E5%88%99"><span class="toc-text">依赖原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BE%9D%E8%B5%96%E8%B7%AF%E5%BE%84%E6%9C%80%E7%9F%AD%E4%BC%98%E5%85%88%E5%8E%9F%E5%88%99"><span class="toc-text">1. 依赖路径最短优先原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A3%B0%E6%98%8E%E9%A1%BA%E5%BA%8F%E4%BC%98%E5%85%88%E5%8E%9F%E5%88%99"><span class="toc-text">2. 声明顺序优先原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%A6%86%E5%86%99%E4%BC%98%E5%85%88%E5%8E%9F%E5%88%99"><span class="toc-text">3. 覆写优先原则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E4%BE%9D%E8%B5%96%E5%86%B2%E7%AA%81"><span class="toc-text">解决依赖冲突</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-text">参考资料</span></a></li></ol></div><div class="column is-9"><header class="my-4"></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle"></h1><time class="has-text-grey" datetime="2023-01-31T06:58:14.701Z">2023-01-31</time><article class="mt-2 post-content"><ul>
<li><a href="#%E4%B8%80%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%9C%E7%94%A8">一、构建工具的作用</a></li>
<li><a href="#%E4%BA%8Cjava-%E4%B8%BB%E6%B5%81%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7">二、Java 主流构建工具</a></li>
<li><a href="#%E4%B8%89maven">三、Maven</a></li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<h1 id="一、构建工具的作用"><a href="#一、构建工具的作用" class="headerlink" title="一、构建工具的作用"></a>一、构建工具的作用</h1><p>构建一个项目通常包含了依赖管理、测试、编译、打包、发布等流程，构建工具可以自动化进行这些操作，从而为我们减少这些繁琐的工作。</p>
<p>其中构建工具提供的依赖管理能够可以自动处理依赖关系。例如一个项目需要用到依赖 A，A 又依赖于 B，那么构建工具就能帮我们导入 B，而不需要我们手动去寻找并导入。</p>
<p>在 Java 项目中，打包流程通常是将项目打包成 Jar 包。在没有构建工具的情况下，我们需要使用命令行工具或者 IDE 手动打包。而发布流程通常是将 Jar 包上传到服务器上。</p>
<h1 id="二、Java-主流构建工具"><a href="#二、Java-主流构建工具" class="headerlink" title="二、Java 主流构建工具"></a>二、Java 主流构建工具</h1><p>Ant 具有编译、测试和打包功能，其后出现的 Maven 在 Ant 的功能基础上又新增了依赖管理功能，而最新的 Gradle 又在 Maven 的功能基础上新增了对 Groovy 语言的支持。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208204118932.png"/> </div><br>

<p>Gradle 和 Maven 的区别是，它使用 Groovy 这种特定领域语言（DSL）来管理构建脚本，而不再使用 XML 这种标记性语言。因为项目如果庞大的话，XML 很容易就变得臃肿。</p>
<p>例如要在项目中引入 Junit，Maven 的代码如下：</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
   &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
 
   &lt;groupId&gt;jizg.study.maven.hello&lt;/groupId&gt;
   &lt;artifactId&gt;hello-first&lt;/artifactId&gt;
   &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;

   &lt;dependencies&gt;
          &lt;dependency&gt;
               &lt;groupId&gt;junit&lt;/groupId&gt;
               &lt;artifactId&gt;junit&lt;/artifactId&gt;
               &lt;version&gt;4.10&lt;/version&gt;
               &lt;scope&gt;test&lt;/scope&gt;
          &lt;/dependency&gt;
   &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<p>而 Gradle 只需要几行代码：</p>
<pre><code class="java">dependencies &#123;
    testCompile &quot;junit:junit:4.10&quot;
&#125;
</code></pre>
<h1 id="三、Maven"><a href="#三、Maven" class="headerlink" title="三、Maven"></a>三、Maven</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>提供了项目对象模型（POM）文件来管理项目的构建。</p>
<h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><p>仓库的搜索顺序为：本地仓库、中央仓库、远程仓库。</p>
<ul>
<li>本地仓库用来存储项目的依赖库；</li>
<li>中央仓库是下载依赖库的默认位置；</li>
<li>远程仓库，因为并非所有的依赖库都在中央仓库，或者中央仓库访问速度很慢，远程仓库是中央仓库的补充。</li>
</ul>
<h2 id="POM"><a href="#POM" class="headerlink" title="POM"></a>POM</h2><p>POM 代表项目对象模型，它是一个 XML 文件，保存在项目根目录的 pom.xml 文件中。</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;junit&lt;/groupId&gt;
    &lt;artifactId&gt;junit&lt;/artifactId&gt;
    &lt;version&gt;4.12&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<p>[groupId, artifactId, version, packaging, classifier] 称为一个项目的坐标，其中 groupId、artifactId、version 必须定义，packaging 可选（默认为 Jar），classifier 不能直接定义的，需要结合插件使用。</p>
<ul>
<li>groupId：项目组 Id，必须全球唯一；</li>
<li>artifactId：项目 Id，即项目名；</li>
<li>version：项目版本；</li>
<li>packaging：项目打包方式。</li>
</ul>
<h2 id="依赖原则"><a href="#依赖原则" class="headerlink" title="依赖原则"></a>依赖原则</h2><h3 id="1-依赖路径最短优先原则"><a href="#1-依赖路径最短优先原则" class="headerlink" title="1. 依赖路径最短优先原则"></a>1. 依赖路径最短优先原则</h3><pre><code class="html">A -&gt; B -&gt; C -&gt; X(1.0)
A -&gt; D -&gt; X(2.0)
</code></pre>
<p>由于 X(2.0) 路径最短，所以使用 X(2.0)。</p>
<h3 id="2-声明顺序优先原则"><a href="#2-声明顺序优先原则" class="headerlink" title="2. 声明顺序优先原则"></a>2. 声明顺序优先原则</h3><pre><code class="html">A -&gt; B -&gt; X(1.0)
A -&gt; C -&gt; X(2.0)
</code></pre>
<p>在 POM 中最先声明的优先，上面的两个依赖如果先声明 B，那么最后使用 X(1.0)。</p>
<h3 id="3-覆写优先原则"><a href="#3-覆写优先原则" class="headerlink" title="3. 覆写优先原则"></a>3. 覆写优先原则</h3><p>子 POM 内声明的依赖优先于父 POM 中声明的依赖。</p>
<h2 id="解决依赖冲突"><a href="#解决依赖冲突" class="headerlink" title="解决依赖冲突"></a>解决依赖冲突</h2><p>找到 Maven 加载的 Jar 包版本，使用 <code>mvn dependency:tree</code> 查看依赖树，根据依赖原则来调整依赖在 POM 文件的声明顺序。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a target="_blank" rel="noopener" href="http://maven.apache.org/pom.html#Dependency_Version_Requirement_Specification">POM Reference</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/7249871/what-is-a-build-tool">What is a build tool?</a></li>
<li><a target="_blank" rel="noopener" href="https://programmingmitra.blogspot.com/2016/05/java-build-tools-comparisons-ant-vs.html">Java Build Tools Comparisons: Ant vs Maven vs Gradle</a></li>
<li><a target="_blank" rel="noopener" href="http://sagioto.github.io/maven2gradle/">maven 2 gradle</a></li>
<li><a target="_blank" rel="noopener" href="https://www.imooc.com/learn/833">新一代构建工具 gradle</a></li>
</ul>
<div align="center"><img width="320px" src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/githubio/公众号二维码-2.png"></img></div>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><em></em></section><article class="mt-6 comment-container" id="vcomments" data-comment_valine_id="b7rbKQnQFa9DYl1anYfacJRz-gzGzoHsz" data-comment_valine_key="nUuKvGHOJBRylruJLW2Fmekg"></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com//"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/serious198706"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com//"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com//"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> cy198706 2023</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="京ICP备2022033375号" target="_blank" rel="noopener" href="https://beian.miit.gov.cn/">京ICP备2022033375号 </a></p></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>