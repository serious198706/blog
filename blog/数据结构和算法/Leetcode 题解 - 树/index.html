<!DOCTYPE html><html class="appearance-user-can-set" lang="zh"><head><meta charset="UTF-8"><title>Notex</title><meta name="description" content="Keep low profile, he said."><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="
递归
1. 树的高度
2. 平衡树
3. 两节点的最长路径
4. 翻转树
5. 归并两棵树
6. 判断路径和是否等于一个数
7. 统计路径和等于一个数的路径数量
8. 子树
9. 树的对称
10. 最小路径
11. 统计左叶子节点的和
12. 相同节点值的最大路径长度
13. 间隔遍历
14. 找出二叉树中第二小的节点


层次遍历
1. 一棵树每层节点的平均数
2. 得到左下角的节点


前中后序遍历
1. 非递归实现二叉树的前序遍历
2. 非递归实现二叉树的后序遍历
3. 非递归实现二叉树的中序遍历


BST
1. 修剪二叉查找树
2. 寻找二叉查找树的第 k 个元素
3. 把二叉查找树每个节点的值都加上比它大的节点的值
4. 二叉查找树的最近公共祖先
5. 二叉树的最近公共祖先
6. 从有序数组中.."><script src="//unpkg.com/valine/dist/Valine.min.js"></script><meta name="generator" content="Hexo 5.4.2"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><!-- a(href= url_for("/"))= (theme.user && theme.user.name || config.author) + "'s blog"--><a href="/">Notex</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center"></p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">主页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">主页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-text">递归</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6"><span class="toc-text">1. 树的高度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%B9%B3%E8%A1%A1%E6%A0%91"><span class="toc-text">2. 平衡树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%B8%A4%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E9%95%BF%E8%B7%AF%E5%BE%84"><span class="toc-text">3. 两节点的最长路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%BF%BB%E8%BD%AC%E6%A0%91"><span class="toc-text">4. 翻转树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%BD%92%E5%B9%B6%E4%B8%A4%E6%A3%B5%E6%A0%91"><span class="toc-text">5. 归并两棵树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%88%A4%E6%96%AD%E8%B7%AF%E5%BE%84%E5%92%8C%E6%98%AF%E5%90%A6%E7%AD%89%E4%BA%8E%E4%B8%80%E4%B8%AA%E6%95%B0"><span class="toc-text">6. 判断路径和是否等于一个数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E7%BB%9F%E8%AE%A1%E8%B7%AF%E5%BE%84%E5%92%8C%E7%AD%89%E4%BA%8E%E4%B8%80%E4%B8%AA%E6%95%B0%E7%9A%84%E8%B7%AF%E5%BE%84%E6%95%B0%E9%87%8F"><span class="toc-text">7. 统计路径和等于一个数的路径数量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%AD%90%E6%A0%91"><span class="toc-text">8. 子树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E6%A0%91%E7%9A%84%E5%AF%B9%E7%A7%B0"><span class="toc-text">9. 树的对称</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84"><span class="toc-text">10. 最小路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E7%BB%9F%E8%AE%A1%E5%B7%A6%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E7%9A%84%E5%92%8C"><span class="toc-text">11. 统计左叶子节点的和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E7%9B%B8%E5%90%8C%E8%8A%82%E7%82%B9%E5%80%BC%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6"><span class="toc-text">12. 相同节点值的最大路径长度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E9%97%B4%E9%9A%94%E9%81%8D%E5%8E%86"><span class="toc-text">13. 间隔遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E6%89%BE%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%AC%AC%E4%BA%8C%E5%B0%8F%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-text">14. 找出二叉树中第二小的节点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="toc-text">层次遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%B8%80%E6%A3%B5%E6%A0%91%E6%AF%8F%E5%B1%82%E8%8A%82%E7%82%B9%E7%9A%84%E5%B9%B3%E5%9D%87%E6%95%B0"><span class="toc-text">1. 一棵树每层节点的平均数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%BE%97%E5%88%B0%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-text">2. 得到左下角的节点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">前中后序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">1. 非递归实现二叉树的前序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">2. 非递归实现二叉树的后序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">3. 非递归实现二叉树的中序遍历</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#BST"><span class="toc-text">BST</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="toc-text">1. 修剪二叉查找树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%AF%BB%E6%89%BE%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E7%9A%84%E7%AC%AC-k-%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-text">2. 寻找二叉查找树的第 k 个元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E5%80%BC%E9%83%BD%E5%8A%A0%E4%B8%8A%E6%AF%94%E5%AE%83%E5%A4%A7%E7%9A%84%E8%8A%82%E7%82%B9%E7%9A%84%E5%80%BC"><span class="toc-text">3. 把二叉查找树每个节点的值都加上比它大的节点的值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-text">4. 二叉查找树的最近公共祖先</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-text">5. 二叉树的最近公共祖先</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E4%BB%8E%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="toc-text">6. 从有序数组中构造二叉查找树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%A0%B9%E6%8D%AE%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E6%9E%84%E9%80%A0%E5%B9%B3%E8%A1%A1%E7%9A%84%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="toc-text">7. 根据有序链表构造平衡的二叉查找树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E4%B8%AD%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%EF%BC%8C%E4%BD%BF%E5%AE%83%E4%BB%AC%E7%9A%84%E5%92%8C%E4%B8%BA%E4%B8%80%E4%B8%AA%E7%BB%99%E5%AE%9A%E5%80%BC"><span class="toc-text">8. 在二叉查找树中寻找两个节点，使它们的和为一个给定值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E4%B8%AD%E6%9F%A5%E6%89%BE%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E4%B9%8B%E5%B7%AE%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%80%BC"><span class="toc-text">9. 在二叉查找树中查找两个节点之差的最小绝对值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E5%AF%BB%E6%89%BE%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E5%80%BC"><span class="toc-text">10. 寻找二叉查找树中出现次数最多的值</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Trie"><span class="toc-text">Trie</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-Trie"><span class="toc-text">1. 实现一个 Trie</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-Trie%EF%BC%8C%E7%94%A8%E6%9D%A5%E6%B1%82%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-text">2. 实现一个 Trie，用来求前缀和</span></a></li></ol></li></ol></div><div class="column is-9"><header class="my-4"></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle"></h1><time class="has-text-grey" datetime="2023-01-31T06:58:14.701Z">2023-01-31</time><article class="mt-2 post-content"><ul>
<li><a href="#%E9%80%92%E5%BD%92">递归</a><ul>
<li><a href="#1-%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6">1. 树的高度</a></li>
<li><a href="#2-%E5%B9%B3%E8%A1%A1%E6%A0%91">2. 平衡树</a></li>
<li><a href="#3-%E4%B8%A4%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E9%95%BF%E8%B7%AF%E5%BE%84">3. 两节点的最长路径</a></li>
<li><a href="#4-%E7%BF%BB%E8%BD%AC%E6%A0%91">4. 翻转树</a></li>
<li><a href="#5-%E5%BD%92%E5%B9%B6%E4%B8%A4%E6%A3%B5%E6%A0%91">5. 归并两棵树</a></li>
<li><a href="#6-%E5%88%A4%E6%96%AD%E8%B7%AF%E5%BE%84%E5%92%8C%E6%98%AF%E5%90%A6%E7%AD%89%E4%BA%8E%E4%B8%80%E4%B8%AA%E6%95%B0">6. 判断路径和是否等于一个数</a></li>
<li><a href="#7-%E7%BB%9F%E8%AE%A1%E8%B7%AF%E5%BE%84%E5%92%8C%E7%AD%89%E4%BA%8E%E4%B8%80%E4%B8%AA%E6%95%B0%E7%9A%84%E8%B7%AF%E5%BE%84%E6%95%B0%E9%87%8F">7. 统计路径和等于一个数的路径数量</a></li>
<li><a href="#8-%E5%AD%90%E6%A0%91">8. 子树</a></li>
<li><a href="#9-%E6%A0%91%E7%9A%84%E5%AF%B9%E7%A7%B0">9. 树的对称</a></li>
<li><a href="#10-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84">10. 最小路径</a></li>
<li><a href="#11-%E7%BB%9F%E8%AE%A1%E5%B7%A6%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E7%9A%84%E5%92%8C">11. 统计左叶子节点的和</a></li>
<li><a href="#12-%E7%9B%B8%E5%90%8C%E8%8A%82%E7%82%B9%E5%80%BC%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6">12. 相同节点值的最大路径长度</a></li>
<li><a href="#13-%E9%97%B4%E9%9A%94%E9%81%8D%E5%8E%86">13. 间隔遍历</a></li>
<li><a href="#14-%E6%89%BE%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%AC%AC%E4%BA%8C%E5%B0%8F%E7%9A%84%E8%8A%82%E7%82%B9">14. 找出二叉树中第二小的节点</a></li>
</ul>
</li>
<li><a href="#%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86">层次遍历</a><ul>
<li><a href="#1-%E4%B8%80%E6%A3%B5%E6%A0%91%E6%AF%8F%E5%B1%82%E8%8A%82%E7%82%B9%E7%9A%84%E5%B9%B3%E5%9D%87%E6%95%B0">1. 一棵树每层节点的平均数</a></li>
<li><a href="#2-%E5%BE%97%E5%88%B0%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E8%8A%82%E7%82%B9">2. 得到左下角的节点</a></li>
</ul>
</li>
<li><a href="#%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86">前中后序遍历</a><ul>
<li><a href="#1-%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86">1. 非递归实现二叉树的前序遍历</a></li>
<li><a href="#2-%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86">2. 非递归实现二叉树的后序遍历</a></li>
<li><a href="#3-%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86">3. 非递归实现二叉树的中序遍历</a></li>
</ul>
</li>
<li><a href="#bst">BST</a><ul>
<li><a href="#1-%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91">1. 修剪二叉查找树</a></li>
<li><a href="#2-%E5%AF%BB%E6%89%BE%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E7%9A%84%E7%AC%AC-k-%E4%B8%AA%E5%85%83%E7%B4%A0">2. 寻找二叉查找树的第 k 个元素</a></li>
<li><a href="#3-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E5%80%BC%E9%83%BD%E5%8A%A0%E4%B8%8A%E6%AF%94%E5%AE%83%E5%A4%A7%E7%9A%84%E8%8A%82%E7%82%B9%E7%9A%84%E5%80%BC">3. 把二叉查找树每个节点的值都加上比它大的节点的值</a></li>
<li><a href="#4-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88">4. 二叉查找树的最近公共祖先</a></li>
<li><a href="#5-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88">5. 二叉树的最近公共祖先</a></li>
<li><a href="#6-%E4%BB%8E%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91">6. 从有序数组中构造二叉查找树</a></li>
<li><a href="#7-%E6%A0%B9%E6%8D%AE%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E6%9E%84%E9%80%A0%E5%B9%B3%E8%A1%A1%E7%9A%84%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91">7. 根据有序链表构造平衡的二叉查找树</a></li>
<li><a href="#8-%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E4%B8%AD%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%EF%BC%8C%E4%BD%BF%E5%AE%83%E4%BB%AC%E7%9A%84%E5%92%8C%E4%B8%BA%E4%B8%80%E4%B8%AA%E7%BB%99%E5%AE%9A%E5%80%BC">8. 在二叉查找树中寻找两个节点，使它们的和为一个给定值</a></li>
<li><a href="#9-%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E4%B8%AD%E6%9F%A5%E6%89%BE%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E4%B9%8B%E5%B7%AE%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%80%BC">9. 在二叉查找树中查找两个节点之差的最小绝对值</a></li>
<li><a href="#10-%E5%AF%BB%E6%89%BE%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E5%80%BC">10. 寻找二叉查找树中出现次数最多的值</a></li>
</ul>
</li>
<li><a href="#trie">Trie</a><ul>
<li><a href="#1-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-trie">1. 实现一个 Trie</a></li>
<li><a href="#2-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-trie%EF%BC%8C%E7%94%A8%E6%9D%A5%E6%B1%82%E5%89%8D%E7%BC%80%E5%92%8C">2. 实现一个 Trie，用来求前缀和</a></li>
</ul>
</li>
</ul>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>一棵树要么是空树，要么有两个指针，每个指针指向一棵树。树是一种递归结构，很多树的问题可以使用递归来处理。</p>
<h2 id="1-树的高度"><a href="#1-树的高度" class="headerlink" title="1. 树的高度"></a>1. 树的高度</h2><p>104. Maximum Depth of Binary Tree (Easy)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-depth-of-binary-tree/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/description/">力扣</a></p>
<pre><code class="java">public int maxDepth(TreeNode root) &#123;
    if (root == null) return 0;
    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
&#125;
</code></pre>
<h2 id="2-平衡树"><a href="#2-平衡树" class="headerlink" title="2. 平衡树"></a>2. 平衡树</h2><p>110. Balanced Binary Tree (Easy)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/balanced-binary-tree/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/balanced-binary-tree/description/">力扣</a></p>
<pre><code class="html">    3
   / \
  9  20
    /  \
   15   7
</code></pre>
<p>平衡树左右子树高度差都小于等于 1</p>
<pre><code class="java">private boolean result = true;

public boolean isBalanced(TreeNode root) &#123;
    maxDepth(root);
    return result;
&#125;

public int maxDepth(TreeNode root) &#123;
    if (root == null) return 0;
    int l = maxDepth(root.left);
    int r = maxDepth(root.right);
    if (Math.abs(l - r) &gt; 1) result = false;
    return 1 + Math.max(l, r);
&#125;
</code></pre>
<h2 id="3-两节点的最长路径"><a href="#3-两节点的最长路径" class="headerlink" title="3. 两节点的最长路径"></a>3. 两节点的最长路径</h2><p>543. Diameter of Binary Tree (Easy)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/diameter-of-binary-tree/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/diameter-of-binary-tree/description/">力扣</a></p>
<pre><code class="html">Input:

         1
        / \
       2  3
      / \
     4   5

Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].
</code></pre>
<pre><code class="java">private int max = 0;

public int diameterOfBinaryTree(TreeNode root) &#123;
    depth(root);
    return max;
&#125;

private int depth(TreeNode root) &#123;
    if (root == null) return 0;
    int leftDepth = depth(root.left);
    int rightDepth = depth(root.right);
    max = Math.max(max, leftDepth + rightDepth);
    return Math.max(leftDepth, rightDepth) + 1;
&#125;
</code></pre>
<h2 id="4-翻转树"><a href="#4-翻转树" class="headerlink" title="4. 翻转树"></a>4. 翻转树</h2><p>226. Invert Binary Tree (Easy)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/invert-binary-tree/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/invert-binary-tree/description/">力扣</a></p>
<pre><code class="java">public TreeNode invertTree(TreeNode root) &#123;
    if (root == null) return null;
    TreeNode left = root.left;  // 后面的操作会改变 left 指针，因此先保存下来
    root.left = invertTree(root.right);
    root.right = invertTree(left);
    return root;
&#125;
</code></pre>
<h2 id="5-归并两棵树"><a href="#5-归并两棵树" class="headerlink" title="5. 归并两棵树"></a>5. 归并两棵树</h2><p>617. Merge Two Binary Trees (Easy)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/merge-two-binary-trees/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-two-binary-trees/description/">力扣</a></p>
<pre><code class="html">Input:
       Tree 1                     Tree 2
          1                         2
         / \                       / \
        3   2                     1   3
       /                           \   \
      5                             4   7

Output:
         3
        / \
       4   5
      / \   \
     5   4   7
</code></pre>
<pre><code class="java">public TreeNode mergeTrees(TreeNode t1, TreeNode t2) &#123;
    if (t1 == null &amp;&amp; t2 == null) return null;
    if (t1 == null) return t2;
    if (t2 == null) return t1;
    TreeNode root = new TreeNode(t1.val + t2.val);
    root.left = mergeTrees(t1.left, t2.left);
    root.right = mergeTrees(t1.right, t2.right);
    return root;
&#125;
</code></pre>
<h2 id="6-判断路径和是否等于一个数"><a href="#6-判断路径和是否等于一个数" class="headerlink" title="6. 判断路径和是否等于一个数"></a>6. 判断路径和是否等于一个数</h2><p>Leetcdoe : 112. Path Sum (Easy)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/path-sum/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum/description/">力扣</a></p>
<pre><code class="html">Given the below binary tree and sum = 22,

              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1

return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22.
</code></pre>
<p>路径和定义为从 root 到 leaf 的所有节点的和。</p>
<pre><code class="java">public boolean hasPathSum(TreeNode root, int sum) &#123;
    if (root == null) return false;
    if (root.left == null &amp;&amp; root.right == null &amp;&amp; root.val == sum) return true;
    return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);
&#125;
</code></pre>
<h2 id="7-统计路径和等于一个数的路径数量"><a href="#7-统计路径和等于一个数的路径数量" class="headerlink" title="7. 统计路径和等于一个数的路径数量"></a>7. 统计路径和等于一个数的路径数量</h2><p>437. Path Sum III (Easy)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/path-sum-iii/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum-iii/description/">力扣</a></p>
<pre><code class="html">root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8

      10
     /  \
    5   -3
   / \    \
  3   2   11
 / \   \
3  -2   1

Return 3. The paths that sum to 8 are:

1.  5 -&gt; 3
2.  5 -&gt; 2 -&gt; 1
3. -3 -&gt; 11
</code></pre>
<p>路径不一定以 root 开头，也不一定以 leaf 结尾，但是必须连续。</p>
<pre><code class="java">public int pathSum(TreeNode root, int sum) &#123;
    if (root == null) return 0;
    int ret = pathSumStartWithRoot(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum);
    return ret;
&#125;

private int pathSumStartWithRoot(TreeNode root, int sum) &#123;
    if (root == null) return 0;
    int ret = 0;
    if (root.val == sum) ret++;
    ret += pathSumStartWithRoot(root.left, sum - root.val) + pathSumStartWithRoot(root.right, sum - root.val);
    return ret;
&#125;
</code></pre>
<h2 id="8-子树"><a href="#8-子树" class="headerlink" title="8. 子树"></a>8. 子树</h2><p>572. Subtree of Another Tree (Easy)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/subtree-of-another-tree/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subtree-of-another-tree/description/">力扣</a></p>
<pre><code class="html">Given tree s:
     3
    / \
   4   5
  / \
 1   2

Given tree t:
   4
  / \
 1   2

Return true, because t has the same structure and node values with a subtree of s.

Given tree s:

     3
    / \
   4   5
  / \
 1   2
    /
   0

Given tree t:
   4
  / \
 1   2

Return false.
</code></pre>
<pre><code class="java">public boolean isSubtree(TreeNode s, TreeNode t) &#123;
    if (s == null) return false;
    return isSubtreeWithRoot(s, t) || isSubtree(s.left, t) || isSubtree(s.right, t);
&#125;

private boolean isSubtreeWithRoot(TreeNode s, TreeNode t) &#123;
    if (t == null &amp;&amp; s == null) return true;
    if (t == null || s == null) return false;
    if (t.val != s.val) return false;
    return isSubtreeWithRoot(s.left, t.left) &amp;&amp; isSubtreeWithRoot(s.right, t.right);
&#125;
</code></pre>
<h2 id="9-树的对称"><a href="#9-树的对称" class="headerlink" title="9. 树的对称"></a>9. 树的对称</h2><p>101. Symmetric Tree (Easy)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/symmetric-tree/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/symmetric-tree/description/">力扣</a></p>
<pre><code class="html">    1
   / \
  2   2
 / \ / \
3  4 4  3
</code></pre>
<pre><code class="java">public boolean isSymmetric(TreeNode root) &#123;
    if (root == null) return true;
    return isSymmetric(root.left, root.right);
&#125;

private boolean isSymmetric(TreeNode t1, TreeNode t2) &#123;
    if (t1 == null &amp;&amp; t2 == null) return true;
    if (t1 == null || t2 == null) return false;
    if (t1.val != t2.val) return false;
    return isSymmetric(t1.left, t2.right) &amp;&amp; isSymmetric(t1.right, t2.left);
&#125;
</code></pre>
<h2 id="10-最小路径"><a href="#10-最小路径" class="headerlink" title="10. 最小路径"></a>10. 最小路径</h2><p>111. Minimum Depth of Binary Tree (Easy)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-depth-of-binary-tree/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/description/">力扣</a></p>
<p>树的根节点到叶子节点的最小路径长度</p>
<pre><code class="java">public int minDepth(TreeNode root) &#123;
    if (root == null) return 0;
    int left = minDepth(root.left);
    int right = minDepth(root.right);
    if (left == 0 || right == 0) return left + right + 1;
    return Math.min(left, right) + 1;
&#125;
</code></pre>
<h2 id="11-统计左叶子节点的和"><a href="#11-统计左叶子节点的和" class="headerlink" title="11. 统计左叶子节点的和"></a>11. 统计左叶子节点的和</h2><p>404. Sum of Left Leaves (Easy)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/sum-of-left-leaves/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sum-of-left-leaves/description/">力扣</a></p>
<pre><code class="html">    3
   / \
  9  20
    /  \
   15   7

There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24.
</code></pre>
<pre><code class="java">public int sumOfLeftLeaves(TreeNode root) &#123;
    if (root == null) return 0;
    if (isLeaf(root.left)) return root.left.val + sumOfLeftLeaves(root.right);
    return sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right);
&#125;

private boolean isLeaf(TreeNode node)&#123;
    if (node == null) return false;
    return node.left == null &amp;&amp; node.right == null;
&#125;
</code></pre>
<h2 id="12-相同节点值的最大路径长度"><a href="#12-相同节点值的最大路径长度" class="headerlink" title="12. 相同节点值的最大路径长度"></a>12. 相同节点值的最大路径长度</h2><p>687. Longest Univalue Path (Easy)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-univalue-path/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-univalue-path/">力扣</a></p>
<pre><code class="html">             1
            / \
           4   5
          / \   \
         4   4   5

Output : 2
</code></pre>
<pre><code class="java">private int path = 0;

public int longestUnivaluePath(TreeNode root) &#123;
    dfs(root);
    return path;
&#125;

private int dfs(TreeNode root)&#123;
    if (root == null) return 0;
    int left = dfs(root.left);
    int right = dfs(root.right);
    int leftPath = root.left != null &amp;&amp; root.left.val == root.val ? left + 1 : 0;
    int rightPath = root.right != null &amp;&amp; root.right.val == root.val ? right + 1 : 0;
    path = Math.max(path, leftPath + rightPath);
    return Math.max(leftPath, rightPath);
&#125;
</code></pre>
<h2 id="13-间隔遍历"><a href="#13-间隔遍历" class="headerlink" title="13. 间隔遍历"></a>13. 间隔遍历</h2><p>337. House Robber III (Medium)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/house-robber-iii/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber-iii/description/">力扣</a></p>
<pre><code class="html">     3
    / \
   2   3
    \   \
     3   1
Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.
</code></pre>
<pre><code class="java">public int rob(TreeNode root) &#123;
    if (root == null) return 0;
    int val1 = root.val;
    if (root.left != null) val1 += rob(root.left.left) + rob(root.left.right);
    if (root.right != null) val1 += rob(root.right.left) + rob(root.right.right);
    int val2 = rob(root.left) + rob(root.right);
    return Math.max(val1, val2);
&#125;
</code></pre>
<h2 id="14-找出二叉树中第二小的节点"><a href="#14-找出二叉树中第二小的节点" class="headerlink" title="14. 找出二叉树中第二小的节点"></a>14. 找出二叉树中第二小的节点</h2><p>671. Second Minimum Node In a Binary Tree (Easy)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/second-minimum-node-in-a-binary-tree/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/description/">力扣</a></p>
<pre><code class="html">Input:
   2
  / \
 2   5
    / \
    5  7

Output: 5
</code></pre>
<p>一个节点要么具有 0 个或 2 个子节点，如果有子节点，那么根节点是最小的节点。</p>
<pre><code class="java">public int findSecondMinimumValue(TreeNode root) &#123;
    if (root == null) return -1;
    if (root.left == null &amp;&amp; root.right == null) return -1;
    int leftVal = root.left.val;
    int rightVal = root.right.val;
    if (leftVal == root.val) leftVal = findSecondMinimumValue(root.left);
    if (rightVal == root.val) rightVal = findSecondMinimumValue(root.right);
    if (leftVal != -1 &amp;&amp; rightVal != -1) return Math.min(leftVal, rightVal);
    if (leftVal != -1) return leftVal;
    return rightVal;
&#125;
</code></pre>
<h1 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h1><p>使用 BFS 进行层次遍历。不需要使用两个队列来分别存储当前层的节点和下一层的节点，因为在开始遍历一层的节点时，当前队列中的节点数就是当前层的节点数，只要控制遍历这么多节点数，就能保证这次遍历的都是当前层的节点。</p>
<h2 id="1-一棵树每层节点的平均数"><a href="#1-一棵树每层节点的平均数" class="headerlink" title="1. 一棵树每层节点的平均数"></a>1. 一棵树每层节点的平均数</h2><p>637. Average of Levels in Binary Tree (Easy)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/average-of-levels-in-binary-tree/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/description/">力扣</a></p>
<pre><code class="java">public List&lt;Double&gt; averageOfLevels(TreeNode root) &#123;
    List&lt;Double&gt; ret = new ArrayList&lt;&gt;();
    if (root == null) return ret;
    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
    queue.add(root);
    while (!queue.isEmpty()) &#123;
        int cnt = queue.size();
        double sum = 0;
        for (int i = 0; i &lt; cnt; i++) &#123;
            TreeNode node = queue.poll();
            sum += node.val;
            if (node.left != null) queue.add(node.left);
            if (node.right != null) queue.add(node.right);
        &#125;
        ret.add(sum / cnt);
    &#125;
    return ret;
&#125;
</code></pre>
<h2 id="2-得到左下角的节点"><a href="#2-得到左下角的节点" class="headerlink" title="2. 得到左下角的节点"></a>2. 得到左下角的节点</h2><p>513. Find Bottom Left Tree Value (Easy)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-bottom-left-tree-value/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/description/">力扣</a></p>
<pre><code class="html">Input:

        1
       / \
      2   3
     /   / \
    4   5   6
       /
      7

Output:
7
</code></pre>
<pre><code class="java">public int findBottomLeftValue(TreeNode root) &#123;
    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
    queue.add(root);
    while (!queue.isEmpty()) &#123;
        root = queue.poll();
        if (root.right != null) queue.add(root.right);
        if (root.left != null) queue.add(root.left);
    &#125;
    return root.val;
&#125;
</code></pre>
<h1 id="前中后序遍历"><a href="#前中后序遍历" class="headerlink" title="前中后序遍历"></a>前中后序遍历</h1><pre><code class="html">    1
   / \
  2   3
 / \   \
4   5   6
</code></pre>
<ul>
<li>层次遍历顺序：[1 2 3 4 5 6]</li>
<li>前序遍历顺序：[1 2 4 5 3 6]</li>
<li>中序遍历顺序：[4 2 5 1 3 6]</li>
<li>后序遍历顺序：[4 5 2 6 3 1]</li>
</ul>
<p>层次遍历使用 BFS 实现，利用的就是 BFS 一层一层遍历的特性；而前序、中序、后序遍历利用了 DFS 实现。</p>
<p>前序、中序、后序遍只是在对节点访问的顺序有一点不同，其它都相同。</p>
<p>① 前序</p>
<pre><code class="java">void dfs(TreeNode root) &#123;
    visit(root);
    dfs(root.left);
    dfs(root.right);
&#125;
</code></pre>
<p>② 中序</p>
<pre><code class="java">void dfs(TreeNode root) &#123;
    dfs(root.left);
    visit(root);
    dfs(root.right);
&#125;
</code></pre>
<p>③ 后序</p>
<pre><code class="java">void dfs(TreeNode root) &#123;
    dfs(root.left);
    dfs(root.right);
    visit(root);
&#125;
</code></pre>
<h2 id="1-非递归实现二叉树的前序遍历"><a href="#1-非递归实现二叉树的前序遍历" class="headerlink" title="1. 非递归实现二叉树的前序遍历"></a>1. 非递归实现二叉树的前序遍历</h2><p>144. Binary Tree Preorder Traversal (Medium)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-preorder-traversal/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/description/">力扣</a></p>
<pre><code class="java">public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;
    List&lt;Integer&gt; ret = new ArrayList&lt;&gt;();
    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();
    stack.push(root);
    while (!stack.isEmpty()) &#123;
        TreeNode node = stack.pop();
        if (node == null) continue;
        ret.add(node.val);
        stack.push(node.right);  // 先右后左，保证左子树先遍历
        stack.push(node.left);
    &#125;
    return ret;
&#125;
</code></pre>
<h2 id="2-非递归实现二叉树的后序遍历"><a href="#2-非递归实现二叉树的后序遍历" class="headerlink" title="2. 非递归实现二叉树的后序遍历"></a>2. 非递归实现二叉树的后序遍历</h2><p>145. Binary Tree Postorder Traversal (Medium)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-postorder-traversal/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/description/">力扣</a></p>
<p>前序遍历为 root -&gt; left -&gt; right，后序遍历为 left -&gt; right -&gt; root。可以修改前序遍历成为 root -&gt; right -&gt; left，那么这个顺序就和后序遍历正好相反。</p>
<pre><code class="java">public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;
    List&lt;Integer&gt; ret = new ArrayList&lt;&gt;();
    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();
    stack.push(root);
    while (!stack.isEmpty()) &#123;
        TreeNode node = stack.pop();
        if (node == null) continue;
        ret.add(node.val);
        stack.push(node.left);
        stack.push(node.right);
    &#125;
    Collections.reverse(ret);
    return ret;
&#125;
</code></pre>
<h2 id="3-非递归实现二叉树的中序遍历"><a href="#3-非递归实现二叉树的中序遍历" class="headerlink" title="3. 非递归实现二叉树的中序遍历"></a>3. 非递归实现二叉树的中序遍历</h2><p>94. Binary Tree Inorder Traversal (Medium)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-inorder-traversal/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/description/">力扣</a></p>
<pre><code class="java">public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;
    List&lt;Integer&gt; ret = new ArrayList&lt;&gt;();
    if (root == null) return ret;
    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();
    TreeNode cur = root;
    while (cur != null || !stack.isEmpty()) &#123;
        while (cur != null) &#123;
            stack.push(cur);
            cur = cur.left;
        &#125;
        TreeNode node = stack.pop();
        ret.add(node.val);
        cur = node.right;
    &#125;
    return ret;
&#125;
</code></pre>
<h1 id="BST"><a href="#BST" class="headerlink" title="BST"></a>BST</h1><p>二叉查找树（BST）：根节点大于等于左子树所有节点，小于等于右子树所有节点。</p>
<p>二叉查找树中序遍历有序。</p>
<h2 id="1-修剪二叉查找树"><a href="#1-修剪二叉查找树" class="headerlink" title="1. 修剪二叉查找树"></a>1. 修剪二叉查找树</h2><p>669. Trim a Binary Search Tree (Easy)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/trim-a-binary-search-tree/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/description/">力扣</a></p>
<pre><code class="html">Input:

    3
   / \
  0   4
   \
    2
   /
  1

  L = 1
  R = 3

Output:

      3
     /
   2
  /
 1
</code></pre>
<p>题目描述：只保留值在 L ~ R 之间的节点</p>
<pre><code class="java">public TreeNode trimBST(TreeNode root, int L, int R) &#123;
    if (root == null) return null;
    if (root.val &gt; R) return trimBST(root.left, L, R);
    if (root.val &lt; L) return trimBST(root.right, L, R);
    root.left = trimBST(root.left, L, R);
    root.right = trimBST(root.right, L, R);
    return root;
&#125;
</code></pre>
<h2 id="2-寻找二叉查找树的第-k-个元素"><a href="#2-寻找二叉查找树的第-k-个元素" class="headerlink" title="2. 寻找二叉查找树的第 k 个元素"></a>2. 寻找二叉查找树的第 k 个元素</h2><p>230. Kth Smallest Element in a BST (Medium)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/description/">力扣</a></p>
<p>中序遍历解法：</p>
<pre><code class="java">private int cnt = 0;
private int val;

public int kthSmallest(TreeNode root, int k) &#123;
    inOrder(root, k);
    return val;
&#125;

private void inOrder(TreeNode node, int k) &#123;
    if (node == null) return;
    inOrder(node.left, k);
    cnt++;
    if (cnt == k) &#123;
        val = node.val;
        return;
    &#125;
    inOrder(node.right, k);
&#125;
</code></pre>
<p>递归解法：</p>
<pre><code class="java">public int kthSmallest(TreeNode root, int k) &#123;
    int leftCnt = count(root.left);
    if (leftCnt == k - 1) return root.val;
    if (leftCnt &gt; k - 1) return kthSmallest(root.left, k);
    return kthSmallest(root.right, k - leftCnt - 1);
&#125;

private int count(TreeNode node) &#123;
    if (node == null) return 0;
    return 1 + count(node.left) + count(node.right);
&#125;
</code></pre>
<h2 id="3-把二叉查找树每个节点的值都加上比它大的节点的值"><a href="#3-把二叉查找树每个节点的值都加上比它大的节点的值" class="headerlink" title="3. 把二叉查找树每个节点的值都加上比它大的节点的值"></a>3. 把二叉查找树每个节点的值都加上比它大的节点的值</h2><p>Convert BST to Greater Tree (Easy)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/convert-bst-to-greater-tree/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/description/">力扣</a></p>
<pre><code class="html">Input: The root of a Binary Search Tree like this:

              5
            /   \
           2     13

Output: The root of a Greater Tree like this:

             18
            /   \
          20     13
</code></pre>
<p>先遍历右子树。</p>
<pre><code class="java">private int sum = 0;

public TreeNode convertBST(TreeNode root) &#123;
    traver(root);
    return root;
&#125;

private void traver(TreeNode node) &#123;
    if (node == null) return;
    traver(node.right);
    sum += node.val;
    node.val = sum;
    traver(node.left);
&#125;
</code></pre>
<h2 id="4-二叉查找树的最近公共祖先"><a href="#4-二叉查找树的最近公共祖先" class="headerlink" title="4. 二叉查找树的最近公共祖先"></a>4. 二叉查找树的最近公共祖先</h2><p>235. Lowest Common Ancestor of a Binary Search Tree (Easy)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/">力扣</a></p>
<pre><code class="html">        _______6______
      /                \
  ___2__             ___8__
 /      \           /      \
0        4         7        9
        /  \
       3   5

For example, the lowest common ancestor (LCA) of nodes 2 and 8 is 6. Another example is LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.
</code></pre>
<pre><code class="java">public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;
    if (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) return lowestCommonAncestor(root.left, p, q);
    if (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) return lowestCommonAncestor(root.right, p, q);
    return root;
&#125;
</code></pre>
<h2 id="5-二叉树的最近公共祖先"><a href="#5-二叉树的最近公共祖先" class="headerlink" title="5. 二叉树的最近公共祖先"></a>5. 二叉树的最近公共祖先</h2><p>236. Lowest Common Ancestor of a Binary Tree (Medium) </p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/description/">力扣</a></p>
<pre><code class="html">       _______3______
      /              \
  ___5__           ___1__
 /      \         /      \
6        2       0        8
        /  \
       7    4

For example, the lowest common ancestor (LCA) of nodes 5 and 1 is 3. Another example is LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.
</code></pre>
<pre><code class="java">public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;
    if (root == null || root == p || root == q) return root;
    TreeNode left = lowestCommonAncestor(root.left, p, q);
    TreeNode right = lowestCommonAncestor(root.right, p, q);
    return left == null ? right : right == null ? left : root;
&#125;
</code></pre>
<h2 id="6-从有序数组中构造二叉查找树"><a href="#6-从有序数组中构造二叉查找树" class="headerlink" title="6. 从有序数组中构造二叉查找树"></a>6. 从有序数组中构造二叉查找树</h2><p>108. Convert Sorted Array to Binary Search Tree (Easy)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/description/">力扣</a></p>
<pre><code class="java">public TreeNode sortedArrayToBST(int[] nums) &#123;
    return toBST(nums, 0, nums.length - 1);
&#125;

private TreeNode toBST(int[] nums, int sIdx, int eIdx)&#123;
    if (sIdx &gt; eIdx) return null;
    int mIdx = (sIdx + eIdx) / 2;
    TreeNode root = new TreeNode(nums[mIdx]);
    root.left =  toBST(nums, sIdx, mIdx - 1);
    root.right = toBST(nums, mIdx + 1, eIdx);
    return root;
&#125;
</code></pre>
<h2 id="7-根据有序链表构造平衡的二叉查找树"><a href="#7-根据有序链表构造平衡的二叉查找树" class="headerlink" title="7. 根据有序链表构造平衡的二叉查找树"></a>7. 根据有序链表构造平衡的二叉查找树</h2><p>109. Convert Sorted List to Binary Search Tree (Medium)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/description/">力扣</a></p>
<pre><code class="html">Given the sorted linked list: [-10,-3,0,5,9],

One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:

      0
     / \
   -3   9
   /   /
 -10  5
</code></pre>
<pre><code class="java">public TreeNode sortedListToBST(ListNode head) &#123;
    if (head == null) return null;
    if (head.next == null) return new TreeNode(head.val);
    ListNode preMid = preMid(head);
    ListNode mid = preMid.next;
    preMid.next = null;  // 断开链表
    TreeNode t = new TreeNode(mid.val);
    t.left = sortedListToBST(head);
    t.right = sortedListToBST(mid.next);
    return t;
&#125;

private ListNode preMid(ListNode head) &#123;
    ListNode slow = head, fast = head.next;
    ListNode pre = head;
    while (fast != null &amp;&amp; fast.next != null) &#123;
        pre = slow;
        slow = slow.next;
        fast = fast.next.next;
    &#125;
    return pre;
&#125;
</code></pre>
<h2 id="8-在二叉查找树中寻找两个节点，使它们的和为一个给定值"><a href="#8-在二叉查找树中寻找两个节点，使它们的和为一个给定值" class="headerlink" title="8. 在二叉查找树中寻找两个节点，使它们的和为一个给定值"></a>8. 在二叉查找树中寻找两个节点，使它们的和为一个给定值</h2><p>653. Two Sum IV - Input is a BST (Easy)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/two-sum-iv-input-is-a-bst/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/description/">力扣</a></p>
<pre><code class="html">Input:

    5
   / \
  3   6
 / \   \
2   4   7

Target = 9

Output: True
</code></pre>
<p>使用中序遍历得到有序数组之后，再利用双指针对数组进行查找。</p>
<p>应该注意到，这一题不能用分别在左右子树两部分来处理这种思想，因为两个待求的节点可能分别在左右子树中。</p>
<pre><code class="java">public boolean findTarget(TreeNode root, int k) &#123;
    List&lt;Integer&gt; nums = new ArrayList&lt;&gt;();
    inOrder(root, nums);
    int i = 0, j = nums.size() - 1;
    while (i &lt; j) &#123;
        int sum = nums.get(i) + nums.get(j);
        if (sum == k) return true;
        if (sum &lt; k) i++;
        else j--;
    &#125;
    return false;
&#125;

private void inOrder(TreeNode root, List&lt;Integer&gt; nums) &#123;
    if (root == null) return;
    inOrder(root.left, nums);
    nums.add(root.val);
    inOrder(root.right, nums);
&#125;
</code></pre>
<h2 id="9-在二叉查找树中查找两个节点之差的最小绝对值"><a href="#9-在二叉查找树中查找两个节点之差的最小绝对值" class="headerlink" title="9. 在二叉查找树中查找两个节点之差的最小绝对值"></a>9. 在二叉查找树中查找两个节点之差的最小绝对值</h2><p>530. Minimum Absolute Difference in BST (Easy)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-absolute-difference-in-bst/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/description/">力扣</a></p>
<pre><code class="html">Input:

   1
    \
     3
    /
   2

Output:

1
</code></pre>
<p>利用二叉查找树的中序遍历为有序的性质，计算中序遍历中临近的两个节点之差的绝对值，取最小值。</p>
<pre><code class="java">private int minDiff = Integer.MAX_VALUE;
private TreeNode preNode = null;

public int getMinimumDifference(TreeNode root) &#123;
    inOrder(root);
    return minDiff;
&#125;

private void inOrder(TreeNode node) &#123;
    if (node == null) return;
    inOrder(node.left);
    if (preNode != null) minDiff = Math.min(minDiff, node.val - preNode.val);
    preNode = node;
    inOrder(node.right);
&#125;
</code></pre>
<h2 id="10-寻找二叉查找树中出现次数最多的值"><a href="#10-寻找二叉查找树中出现次数最多的值" class="headerlink" title="10. 寻找二叉查找树中出现次数最多的值"></a>10. 寻找二叉查找树中出现次数最多的值</h2><p>501. Find Mode in Binary Search Tree (Easy)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-mode-in-binary-search-tree/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/description/">力扣</a></p>
<pre><code class="html">   1
    \
     2
    /
   2

return [2].
</code></pre>
<p>答案可能不止一个，也就是有多个值出现的次数一样多。</p>
<pre><code class="java">private int curCnt = 1;
private int maxCnt = 1;
private TreeNode preNode = null;

public int[] findMode(TreeNode root) &#123;
    List&lt;Integer&gt; maxCntNums = new ArrayList&lt;&gt;();
    inOrder(root, maxCntNums);
    int[] ret = new int[maxCntNums.size()];
    int idx = 0;
    for (int num : maxCntNums) &#123;
        ret[idx++] = num;
    &#125;
    return ret;
&#125;

private void inOrder(TreeNode node, List&lt;Integer&gt; nums) &#123;
    if (node == null) return;
    inOrder(node.left, nums);
    if (preNode != null) &#123;
        if (preNode.val == node.val) curCnt++;
        else curCnt = 1;
    &#125;
    if (curCnt &gt; maxCnt) &#123;
        maxCnt = curCnt;
        nums.clear();
        nums.add(node.val);
    &#125; else if (curCnt == maxCnt) &#123;
        nums.add(node.val);
    &#125;
    preNode = node;
    inOrder(node.right, nums);
&#125;
</code></pre>
<h1 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h1><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5c638d59-d4ae-4ba4-ad44-80bdc30f38dd.jpg"/> </div><br>

<p>Trie，又称前缀树或字典树，用于判断字符串是否存在或者是否具有某种字符串前缀。</p>
<h2 id="1-实现一个-Trie"><a href="#1-实现一个-Trie" class="headerlink" title="1. 实现一个 Trie"></a>1. 实现一个 Trie</h2><p>208. Implement Trie (Prefix Tree) (Medium)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/implement-trie-prefix-tree/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/description/">力扣</a></p>
<pre><code class="java">class Trie &#123;

    private class Node &#123;
        Node[] childs = new Node[26];
        boolean isLeaf;
    &#125;

    private Node root = new Node();

    public Trie() &#123;
    &#125;

    public void insert(String word) &#123;
        insert(word, root);
    &#125;

    private void insert(String word, Node node) &#123;
        if (node == null) return;
        if (word.length() == 0) &#123;
            node.isLeaf = true;
            return;
        &#125;
        int index = indexForChar(word.charAt(0));
        if (node.childs[index] == null) &#123;
            node.childs[index] = new Node();
        &#125;
        insert(word.substring(1), node.childs[index]);
    &#125;

    public boolean search(String word) &#123;
        return search(word, root);
    &#125;

    private boolean search(String word, Node node) &#123;
        if (node == null) return false;
        if (word.length() == 0) return node.isLeaf;
        int index = indexForChar(word.charAt(0));
        return search(word.substring(1), node.childs[index]);
    &#125;

    public boolean startsWith(String prefix) &#123;
        return startWith(prefix, root);
    &#125;

    private boolean startWith(String prefix, Node node) &#123;
        if (node == null) return false;
        if (prefix.length() == 0) return true;
        int index = indexForChar(prefix.charAt(0));
        return startWith(prefix.substring(1), node.childs[index]);
    &#125;

    private int indexForChar(char c) &#123;
        return c - &#39;a&#39;;
    &#125;
&#125;
</code></pre>
<h2 id="2-实现一个-Trie，用来求前缀和"><a href="#2-实现一个-Trie，用来求前缀和" class="headerlink" title="2. 实现一个 Trie，用来求前缀和"></a>2. 实现一个 Trie，用来求前缀和</h2><p>677. Map Sum Pairs (Medium)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/map-sum-pairs/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/map-sum-pairs/description/">力扣</a></p>
<pre><code class="html">Input: insert(&quot;apple&quot;, 3), Output: Null
Input: sum(&quot;ap&quot;), Output: 3
Input: insert(&quot;app&quot;, 2), Output: Null
Input: sum(&quot;ap&quot;), Output: 5
</code></pre>
<pre><code class="java">class MapSum &#123;

    private class Node &#123;
        Node[] child = new Node[26];
        int value;
    &#125;

    private Node root = new Node();

    public MapSum() &#123;

    &#125;

    public void insert(String key, int val) &#123;
        insert(key, root, val);
    &#125;

    private void insert(String key, Node node, int val) &#123;
        if (node == null) return;
        if (key.length() == 0) &#123;
            node.value = val;
            return;
        &#125;
        int index = indexForChar(key.charAt(0));
        if (node.child[index] == null) &#123;
            node.child[index] = new Node();
        &#125;
        insert(key.substring(1), node.child[index], val);
    &#125;

    public int sum(String prefix) &#123;
        return sum(prefix, root);
    &#125;

    private int sum(String prefix, Node node) &#123;
        if (node == null) return 0;
        if (prefix.length() != 0) &#123;
            int index = indexForChar(prefix.charAt(0));
            return sum(prefix.substring(1), node.child[index]);
        &#125;
        int sum = node.value;
        for (Node child : node.child) &#123;
            sum += sum(prefix, child);
        &#125;
        return sum;
    &#125;

    private int indexForChar(char c) &#123;
        return c - &#39;a&#39;;
    &#125;
&#125;
</code></pre>
<div align="center"><img width="320px" src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/githubio/公众号二维码-2.png"></img></div>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><em></em></section><article class="mt-6 comment-container" id="vcomments" data-comment_valine_id="b7rbKQnQFa9DYl1anYfacJRz-gzGzoHsz" data-comment_valine_key="nUuKvGHOJBRylruJLW2Fmekg"></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com//"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/serious198706"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com//"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com//"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> cy198706 2023</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="京ICP备2022033375号" target="_blank" rel="noopener" href="https://beian.miit.gov.cn/">京ICP备2022033375号 </a></p></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>