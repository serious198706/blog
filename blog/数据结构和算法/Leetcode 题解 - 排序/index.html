<!DOCTYPE html><html class="appearance-user-can-set" lang="zh"><head><meta charset="UTF-8"><title>Notex</title><meta name="description" content="Keep low profile, he said."><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="
快速选择
堆
1. Kth Element


桶排序
1. 出现频率最多的 k 个元素
2. 按照字符出现次数对字符串排序


荷兰国旗问题
1. 按颜色进行排序



快速选择用于求解   Kth Element   问题，也就是第 K 个元素的问题。
可以使用快速排序的 partition() 进行实现。需要先打乱数组，否则最坏情况下时间复杂度为 O(N2)。
堆用于求解   TopK Elements   问题，也就是 K 个最小元素的问题。可以维护一个大小为 K 的最小堆，最小堆中的元素就是最小元素。最小堆需要使用大顶堆来实现，大顶堆表示堆顶元素是堆中最大元素。这是因为我们要得到 k 个最小的元素，因此当遍历到一个新的元素时，需要知道这个新元素是否比堆中最大的元素更小，更小的话就把堆中最大元素去.."><script src="//unpkg.com/valine/dist/Valine.min.js"></script><meta name="generator" content="Hexo 5.4.2"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><!-- a(href= url_for("/"))= (theme.user && theme.user.name || config.author) + "'s blog"--><a href="/">Notex</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center"></p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">主页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">主页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9"><span class="toc-text">快速选择</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A0%86"><span class="toc-text">堆</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Kth-Element"><span class="toc-text">1. Kth Element</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A1%B6%E6%8E%92%E5%BA%8F"><span class="toc-text">桶排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%9C%80%E5%A4%9A%E7%9A%84-k-%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-text">1. 出现频率最多的 k 个元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%8C%89%E7%85%A7%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E5%AF%B9%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F"><span class="toc-text">2. 按照字符出现次数对字符串排序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97%E9%97%AE%E9%A2%98"><span class="toc-text">荷兰国旗问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%8C%89%E9%A2%9C%E8%89%B2%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F"><span class="toc-text">1. 按颜色进行排序</span></a></li></ol></li></ol></div><div class="column is-9"><header class="my-4"></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle"></h1><time class="has-text-grey" datetime="2023-01-31T06:58:14.700Z">2023-01-31</time><article class="mt-2 post-content"><ul>
<li><a href="#%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9">快速选择</a></li>
<li><a href="#%E5%A0%86">堆</a><ul>
<li><a href="#1-kth-element">1. Kth Element</a></li>
</ul>
</li>
<li><a href="#%E6%A1%B6%E6%8E%92%E5%BA%8F">桶排序</a><ul>
<li><a href="#1-%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%9C%80%E5%A4%9A%E7%9A%84-k-%E4%B8%AA%E5%85%83%E7%B4%A0">1. 出现频率最多的 k 个元素</a></li>
<li><a href="#2-%E6%8C%89%E7%85%A7%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E5%AF%B9%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F">2. 按照字符出现次数对字符串排序</a></li>
</ul>
</li>
<li><a href="#%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97%E9%97%AE%E9%A2%98">荷兰国旗问题</a><ul>
<li><a href="#1-%E6%8C%89%E9%A2%9C%E8%89%B2%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F">1. 按颜色进行排序</a></li>
</ul>
</li>
</ul>
<h1 id="快速选择"><a href="#快速选择" class="headerlink" title="快速选择"></a>快速选择</h1><p>用于求解   <strong>Kth Element</strong>   问题，也就是第 K 个元素的问题。</p>
<p>可以使用快速排序的 partition() 进行实现。需要先打乱数组，否则最坏情况下时间复杂度为 O(N<sup>2</sup>)。</p>
<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p>用于求解   <strong>TopK Elements</strong>   问题，也就是 K 个最小元素的问题。可以维护一个大小为 K 的最小堆，最小堆中的元素就是最小元素。最小堆需要使用大顶堆来实现，大顶堆表示堆顶元素是堆中最大元素。这是因为我们要得到 k 个最小的元素，因此当遍历到一个新的元素时，需要知道这个新元素是否比堆中最大的元素更小，更小的话就把堆中最大元素去除，并将新元素添加到堆中。所以我们需要很容易得到最大元素并移除最大元素，大顶堆就能很好满足这个要求。</p>
<p>堆也可以用于求解 Kth Element 问题，得到了大小为 k 的最小堆之后，因为使用了大顶堆来实现，因此堆顶元素就是第 k 大的元素。</p>
<p>快速选择也可以求解 TopK Elements 问题，因为找到 Kth Element 之后，再遍历一次数组，所有小于等于 Kth Element 的元素都是 TopK Elements。</p>
<p>可以看到，快速选择和堆排序都可以求解 Kth Element 和 TopK Elements 问题。</p>
<h2 id="1-Kth-Element"><a href="#1-Kth-Element" class="headerlink" title="1. Kth Element"></a>1. Kth Element</h2><p>215. Kth Largest Element in an Array (Medium)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/kth-largest-element-in-an-array/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/description/">力扣</a></p>
<pre><code class="text">Input: [3,2,1,5,6,4] and k = 2
Output: 5
</code></pre>
<p>题目描述：找到倒数第 k 个的元素。</p>
<p><strong>排序</strong>  ：时间复杂度 O(NlogN)，空间复杂度 O(1)</p>
<pre><code class="java">public int findKthLargest(int[] nums, int k) &#123;
    Arrays.sort(nums);
    return nums[nums.length - k];
&#125;
</code></pre>
<p><strong>堆</strong>  ：时间复杂度 O(NlogK)，空间复杂度 O(K)。</p>
<pre><code class="java">public int findKthLargest(int[] nums, int k) &#123;
    PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;(); // 小顶堆
    for (int val : nums) &#123;
        pq.add(val);
        if (pq.size() &gt; k)  // 维护堆的大小为 K
            pq.poll();
    &#125;
    return pq.peek();
&#125;
</code></pre>
<p><strong>快速选择</strong>  ：时间复杂度 O(N)，空间复杂度 O(1)</p>
<pre><code class="java">public int findKthLargest(int[] nums, int k) &#123;
    k = nums.length - k;
    int l = 0, h = nums.length - 1;
    while (l &lt; h) &#123;
        int j = partition(nums, l, h);
        if (j == k) &#123;
            break;
        &#125; else if (j &lt; k) &#123;
            l = j + 1;
        &#125; else &#123;
            h = j - 1;
        &#125;
    &#125;
    return nums[k];
&#125;

private int partition(int[] a, int l, int h) &#123;
    int i = l, j = h + 1;
    while (true) &#123;
        while (a[++i] &lt; a[l] &amp;&amp; i &lt; h) ;
        while (a[--j] &gt; a[l] &amp;&amp; j &gt; l) ;
        if (i &gt;= j) &#123;
            break;
        &#125;
        swap(a, i, j);
    &#125;
    swap(a, l, j);
    return j;
&#125;

private void swap(int[] a, int i, int j) &#123;
    int t = a[i];
    a[i] = a[j];
    a[j] = t;
&#125;
</code></pre>
<h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h1><h2 id="1-出现频率最多的-k-个元素"><a href="#1-出现频率最多的-k-个元素" class="headerlink" title="1. 出现频率最多的 k 个元素"></a>1. 出现频率最多的 k 个元素</h2><p>347. Top K Frequent Elements (Medium)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/top-k-frequent-elements/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/top-k-frequent-elements/description/">力扣</a></p>
<pre><code class="html">Given [1,1,1,2,2,3] and k = 2, return [1,2].
</code></pre>
<p>设置若干个桶，每个桶存储出现频率相同的数。桶的下标表示数出现的频率，即第 i 个桶中存储的数出现的频率为 i。</p>
<p>把数都放到桶之后，从后向前遍历桶，最先得到的 k 个数就是出现频率最多的的 k 个数。</p>
<pre><code class="java">public List&lt;Integer&gt; topKFrequent(int[] nums, int k) &#123;
    Map&lt;Integer, Integer&gt; frequencyForNum = new HashMap&lt;&gt;();
    for (int num : nums) &#123;
        frequencyForNum.put(num, frequencyForNum.getOrDefault(num, 0) + 1);
    &#125;
    List&lt;Integer&gt;[] buckets = new ArrayList[nums.length + 1];
    for (int key : frequencyForNum.keySet()) &#123;
        int frequency = frequencyForNum.get(key);
        if (buckets[frequency] == null) &#123;
            buckets[frequency] = new ArrayList&lt;&gt;();
        &#125;
        buckets[frequency].add(key);
    &#125;
    List&lt;Integer&gt; topK = new ArrayList&lt;&gt;();
    for (int i = buckets.length - 1; i &gt;= 0 &amp;&amp; topK.size() &lt; k; i--) &#123;
        if (buckets[i] == null) &#123;
            continue;
        &#125;
        if (buckets[i].size() &lt;= (k - topK.size())) &#123;
            topK.addAll(buckets[i]);
        &#125; else &#123;
            topK.addAll(buckets[i].subList(0, k - topK.size()));
        &#125;
    &#125;
    return topK;
&#125;
</code></pre>
<h2 id="2-按照字符出现次数对字符串排序"><a href="#2-按照字符出现次数对字符串排序" class="headerlink" title="2. 按照字符出现次数对字符串排序"></a>2. 按照字符出现次数对字符串排序</h2><p>451. Sort Characters By Frequency (Medium)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/sort-characters-by-frequency/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sort-characters-by-frequency/description/">力扣</a></p>
<pre><code class="html">Input:
&quot;tree&quot;

Output:
&quot;eert&quot;

Explanation:
&#39;e&#39; appears twice while &#39;r&#39; and &#39;t&#39; both appear once.
So &#39;e&#39; must appear before both &#39;r&#39; and &#39;t&#39;. Therefore &quot;eetr&quot; is also a valid answer.
</code></pre>
<pre><code class="java">public String frequencySort(String s) &#123;
    Map&lt;Character, Integer&gt; frequencyForNum = new HashMap&lt;&gt;();
    for (char c : s.toCharArray())
        frequencyForNum.put(c, frequencyForNum.getOrDefault(c, 0) + 1);

    List&lt;Character&gt;[] frequencyBucket = new ArrayList[s.length() + 1];
    for (char c : frequencyForNum.keySet()) &#123;
        int f = frequencyForNum.get(c);
        if (frequencyBucket[f] == null) &#123;
            frequencyBucket[f] = new ArrayList&lt;&gt;();
        &#125;
        frequencyBucket[f].add(c);
    &#125;
    StringBuilder str = new StringBuilder();
    for (int i = frequencyBucket.length - 1; i &gt;= 0; i--) &#123;
        if (frequencyBucket[i] == null) &#123;
            continue;
        &#125;
        for (char c : frequencyBucket[i]) &#123;
            for (int j = 0; j &lt; i; j++) &#123;
                str.append(c);
            &#125;
        &#125;
    &#125;
    return str.toString();
&#125;
</code></pre>
<h1 id="荷兰国旗问题"><a href="#荷兰国旗问题" class="headerlink" title="荷兰国旗问题"></a>荷兰国旗问题</h1><p>荷兰国旗包含三种颜色：红、白、蓝。</p>
<p>有三种颜色的球，算法的目标是将这三种球按颜色顺序正确地排列。它其实是三向切分快速排序的一种变种，在三向切分快速排序中，每次切分都将数组分成三个区间：小于切分元素、等于切分元素、大于切分元素，而该算法是将数组分成三个区间：等于红色、等于白色、等于蓝色。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7a3215ec-6fb7-4935-8b0d-cb408208f7cb.png"/> </div><br>


<h2 id="1-按颜色进行排序"><a href="#1-按颜色进行排序" class="headerlink" title="1. 按颜色进行排序"></a>1. 按颜色进行排序</h2><p>75. Sort Colors (Medium)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/sort-colors/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sort-colors/description/">力扣</a></p>
<pre><code class="html">Input: [2,0,2,1,1,0]
Output: [0,0,1,1,2,2]
</code></pre>
<p>题目描述：只有 0/1/2 三种颜色。</p>
<pre><code class="java">public void sortColors(int[] nums) &#123;
    int zero = -1, one = 0, two = nums.length;
    while (one &lt; two) &#123;
        if (nums[one] == 0) &#123;
            swap(nums, ++zero, one++);
        &#125; else if (nums[one] == 2) &#123;
            swap(nums, --two, one);
        &#125; else &#123;
            ++one;
        &#125;
    &#125;
&#125;

private void swap(int[] nums, int i, int j) &#123;
    int t = nums[i];
    nums[i] = nums[j];
    nums[j] = t;
&#125;
</code></pre>
<div align="center"><img width="320px" src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/githubio/公众号二维码-2.png"></img></div>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><em></em></section><article class="mt-6 comment-container" id="vcomments" data-comment_valine_id="b7rbKQnQFa9DYl1anYfacJRz-gzGzoHsz" data-comment_valine_key="nUuKvGHOJBRylruJLW2Fmekg"></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com//"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/serious198706"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com//"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com//"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> cy198706 2023</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="京ICP备2022033375号" target="_blank" rel="noopener" href="https://beian.miit.gov.cn/">京ICP备2022033375号 </a></p></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>