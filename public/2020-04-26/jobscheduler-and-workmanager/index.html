<!DOCTYPE html><html class="appearance-user-can-set" lang="zh"><head><meta charset="UTF-8"><title>Notex</title><meta name="description" content="Keep low profile, he said."><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="这篇文章我们来讲讲 JobScheduler 和 WorkManager。


JobSchedulerJobScheduler 是 Google 在 API 21（Android 5.0）中推出的一种后台执行任务的方式。因为普通的 Service 会在后台一直运行，只有系统资源不足时才会将其回收，哪怕这个 Service 现在没有在做任何事情，这显然会对系统资源造成相当大的浪费，毕竟启动一个 Service 对开发者来说没什么成本是吧？
JobScheduler 提供的是根据某个条件来执行任务，而不是在某个时间来执行。它能确保把你的任务执行了，但是不能告诉你会在什么时候执行。
这让我想起了一句名言：

我会还你钱的，但我没说什么时候还你。

当然，情况没有那么严重。系统只是会智能分配目前所有的用 JobS.."><script src="//unpkg.com/valine/dist/Valine.min.js"></script><meta name="generator" content="Hexo 5.4.2"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><!-- a(href= url_for("/"))= (theme.user && theme.user.name || config.author) + "'s blog"--><a href="/">Notex</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">JobScheduler 和 WorkManager</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">主页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">主页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#JobScheduler"><span class="toc-text">JobScheduler</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JobScheduler-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">JobScheduler 的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA-JobService-%E7%9A%84%E5%AD%90%E7%B1%BB"><span class="toc-text">1. 创建 JobService 的子类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%88%9B%E5%BB%BA-JobInfo"><span class="toc-text">2. 创建 JobInfo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1"><span class="toc-text">3. 提交任务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JobScheduler-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">JobScheduler 实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WorkManager"><span class="toc-text">WorkManager</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/Android"><i class="tag post-item-tag">Android</i></a><a href="/tags/Jetpack"><i class="tag post-item-tag">Jetpack</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">JobScheduler 和 WorkManager</h1><time class="has-text-grey" datetime="2020-04-25T16:00:00.000Z">2020-04-26</time><article class="mt-2 post-content"><p>这篇文章我们来讲讲 JobScheduler 和 WorkManager。</p>
<span id="more"></span>

<h2 id="JobScheduler"><a href="#JobScheduler" class="headerlink" title="JobScheduler"></a>JobScheduler</h2><p>JobScheduler 是 Google 在 API 21（Android 5.0）中推出的一种后台执行任务的方式。因为普通的 Service 会在后台一直运行，只有系统资源不足时才会将其回收，哪怕这个 Service 现在没有在做任何事情，这显然会对系统资源造成相当大的浪费，毕竟启动一个 Service 对开发者来说没什么成本是吧？</p>
<p>JobScheduler 提供的是<strong>根据某个条件来执行任务</strong>，而不是在某个时间来执行。它能确保把你的任务执行了，但是不能告诉你会在什么时候执行。<img class="sticker" src="http://img.doutula.com/production/uploads/image/2017/11/12/20171112500197_UKzaih.jpg" /></p>
<p>这让我想起了一句名言：</p>
<blockquote>
<p>我会还你钱的，但我没说什么时候还你。</p>
</blockquote>
<p>当然，情况没有那么严重。系统只是会<strong>智能分配</strong>目前所有的用 JobScheduler 方式提交的任务，并尝试批量执行，并且能推迟多久就推迟多久。这么说吧，你要是不给这个 Job 指定一个 deadline，那它真的可能会在很久之后才会执行。</p>
<p>那这玩意这么不靠谱，我们为什么还要用它呢？</p>
<p>因为随着 Android 版本的不断更迭，系统也逐渐变得流畅，这背后是对 App 更多的限制：限制后台进程的运行时间、限制反射可调用的接口、限制某些耗电行为、限制你可以接收到的广播。。。Android 必须也要推出一种行之有效的方案，让 App 能够在某种条件下，完成某种任务。JobScheduler 就应运而生了。</p>
<h3 id="JobScheduler-的使用"><a href="#JobScheduler-的使用" class="headerlink" title="JobScheduler 的使用"></a>JobScheduler 的使用</h3><p>要使用 JobScheduler，必须要先了解它的一家人：</p>
<ul>
<li>JobInfo：提交任务时要传递的参数，包含了任务概要、执行条件、deadline 等。</li>
<li>JobService：当系统调度到你这个任务时，要如何处理任务，你要自己去实现。</li>
<li>JobScheduler：用于向系统提交任务。</li>
</ul>
<p>它的使用很简单，可以分为三步：</p>
<h3 id="1-创建-JobService-的子类"><a href="#1-创建-JobService-的子类" class="headerlink" title="1. 创建 JobService 的子类"></a>1. 创建 JobService 的子类</h3><p>JobService 继承自 Service，也是抽象类，所以我们必须要自己写一个子类：</p>
<blockquote>
<p>注意！这是一个 Sevice，意味着它是在<strong>主线程</strong>中被回调的！所以，这里如果要访问网络进行密集、耗时的操作，还是需要另起线程来做。</p>
</blockquote>
<pre><code class="java">public class CustomJobService extends JobService &#123;
    @Override
    public boolean onStartJob(JobParameters params) &#123;
        jobFinished(params, true);
        return true;
    &#125;

    @Override
    public boolean onStopJob(JobParameters params) &#123;
        return false;
    &#125;
&#125;
</code></pre>
<p>它只需要实现两个方法：<code>onStartJob(JobParameters)</code>和<code>onStopJob(JobParameters)</code>。顾名思义，就是任务开始的回调和任务停止的回调。还有一个重要的方法是<code>jobFinished(JobParameters, boolean)</code>，我们解释一下这三个方法。</p>
<ul>
<li><p><code>onStartJob()</code>：传入了 JobParameters 类型的变量，它包含了<code>jobId</code>和提交任务时创建 JobInfo 时传入的 Bundle 等数据。在任务执行完成时，需要调用<code>jobFinished()</code>来告诉系统：我的任务执行完成了。它的返回值是一个 boolean：</p>
<ul>
<li>返回<code>true</code>就是告诉系统，我还在执行任务，一会任务完成了，我会调用<code>jobFinished()</code>来告诉你的。但是，如果在任务执行期间，任务的执行环境发生了变更，比如在提交任务时指定『充电时执行』，但用户这时候把充电线拔掉了，那就会<strong>立刻结束任务</strong>，并调用<code>onStopJob()</code>；</li>
<li>返回<code>false</code>则告诉系统，我执行完了。系统也不会再去调用<code>onStopJob()</code>方法。</li>
</ul>
</li>
<li><p><code>jobFinished()</code>：只能在<code>onStartJob()</code>中调用，这个方法是被 final 修饰的，不能被覆写。它有两个参数，第一个参数是 JobParameters，第二个是 boolean 类型的参数，传入<code>true</code>是希望系统能根据创建任务时的标准<strong>再次将这个任务提上日程</strong>，传入<code>false</code>则相反。</p>
</li>
<li><p><code>onStopJob()</code>：当这个方法被调用时，表示任务要被强制中断了。这通常发生在任务执行条件不满足时。这个方法执行完毕后，系统就会释放 Wakelock。这个方法的返回值也是一个 boolean：如果返回<code>true</code>表示『教练，我想再试试🏀』，教练会在合适的时间再安排你打篮球（大误）；返回<code>false</code>表示『我不行了☠️』，教练扭头就走。但不管你返回什么，任务是肯定会被终止的。</p>
</li>
</ul>
<p>在<code>onStartJob()</code>被调用之前，系统会给 App 绑定一个 Wakelock，以防止系统进入休眠状态，这个 Wakelock 会在你调用<code>jobFinished()</code>或者系统调用<code>onStopJob()</code>时被释放掉。</p>
<h3 id="2-创建-JobInfo"><a href="#2-创建-JobInfo" class="headerlink" title="2. 创建 JobInfo"></a>2. 创建 JobInfo</h3><p>JobInfo 是一个 Parcelable，显然是用于 IPC 的。它采用了 Builder 设计模式来创建实例，使用起来也比较简单：</p>
<pre><code class="java">public static final int JOB_ID = 0;

JobInfo jobInfo = new JobInfo.Builder(
    JOB_ID,
    new ComponentName(context, CustomJobService.class))
        .setRequiredNetWork()
        .setRequireCharging()
        .build();
</code></pre>
<p>可以看到，给这个 JobInfo 设置了要处理任务的类，设置了 jobId，设置了执行任务的条件等。</p>
<p>它的 Builder 中还有很多其他的方法，下面是它所有的方法：</p>
<p><img src="/img/job-1589006675.png"></p>
<h3 id="3-提交任务"><a href="#3-提交任务" class="headerlink" title="3. 提交任务"></a>3. 提交任务</h3><p>JobScheduler 是系统服务，不能直接被实例化，要通过<code>Context.getSystemService()</code>来获取。</p>
<pre><code class="java">JobScheduler js = (JobScheduler) context.getSystemService(Context.JOB_SCHEDULER_SERVICE);
js.schedule(jobInfo);
</code></pre>
<p>至此，一个任务就被『安排上了』。<img class="sticker" src="/img/anpai.jpg" /></p>
<p>JobScheduler 中最常用的是<code>schedule()</code>方法，用于提交任务。多次调用的话，如果系统中已经有相同 jobId 的任务，则会用新的直接替换掉旧任务，如果旧任务当前正在运行，那它<strong>会被终止</strong>。</p>
<p>它还有一个方法是<code>enqueue(JobInfo, JobWorkItem)</code>，用来给某个任务（新任务或者已存在任务皆可）插入工作内容（JobWorkItem）。如果系统中已经有相同 jobId 的任务，则会用新的直接替换旧任务，如果旧任务当前正在运行，传入的 JobWorkItem 会被<strong>插入任务的工作队列</strong>，任务<strong>并不会被终止</strong>。虽然不会终止任务，但还是<strong>强烈建议使用同一个 JobInfo</strong>来插入工作内容，这样，系统就不会分配额外的资源去更改 JobInfo，从而能更专注于执行任务。</p>
<h2 id="JobScheduler-实现原理"><a href="#JobScheduler-实现原理" class="headerlink" title="JobScheduler 实现原理"></a>JobScheduler 实现原理</h2><p>既然是系统服务，那必然是遵循老套路，得有个类似 JobSchedulerService 之类的东西，并且由 system_server 进程启动，我们直接扒 SystemServer 类的代码：</p>
<pre><code class="java">// android.server.SystemServer.java

private void startOtherServices() &#123;
    ...
    traceBeginAndSlog(&quot;StartJobScheduler&quot;);
    mSystemServiceManager.startService(JobSchedulerService.class);
    traceEnd();
    ...
&#125;
</code></pre>
<p>✌️✌️✌️果然如此，接下来就分析一下 JobSchedulerService 的代码：</p>
<pre><code class="java">
</code></pre>
<h2 id="WorkManager"><a href="#WorkManager" class="headerlink" title="WorkManager"></a>WorkManager</h2><p>WorkManager 是 Android Jetpack 中的一个组件。它提供了更为强大的功能，包括：</p>
<ul>
<li>向下兼容到 API 14</li>
<li>可以添加工作条件约束：比如有 Wifi 连接、正在充电等等（这很合适在后台下载 App 的更新包）</li>
<li>可以执行一次性的或者周期性的任务</li>
<li>能够监听和管理已计划的任务</li>
<li>将多个任务链接起来（妙啊）</li>
<li>保证任务一定会被执行，哪怕 App 重启甚至设备重启</li>
<li>遵循手机的省电模式</li>
</ul>
<p>WorkManager 适合运行那种<strong>非即时的、确定要执行</strong>的任务，比如说在某个时间段向后台发送日志、同步数据，或者定期检查 App 版本情况并下载新版本等等。</p>
<p>While a job is running, the system holds a wakelock on behalf of your app. For this reason, you do not need to take any action to guarantee that the device stays awake for the duration of the job.</p>
<p>You do not instantiate this class directly; instead, retrieve it through Context.getSystemService(Context.JOB_SCHEDULER_SERVICE).</p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2020-05-10/service/" title="关于 Service"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">Previous: 关于 Service</span></a><a class="button is-default" href="/2020-04-24/android-optimization/" title="Android 优化浅谈"><span class="has-text-weight-semibold">Next: Android 优化浅谈</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container" id="vcomments" data-comment_valine_id="b7rbKQnQFa9DYl1anYfacJRz-gzGzoHsz" data-comment_valine_key="nUuKvGHOJBRylruJLW2Fmekg"></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com/serious008/"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/serious198706"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com/serious008/"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><a title="zhihu" target="_blank" rel="noopener nofollow" href="//zhihu.com/people/cy198706"><i class="iconfont icon-zhihu"></i></a><!-- 领英--><a title="linkedin" target="_blank" rel="noopener nofollow" href="//www.linkedin.com/in/serious_chen/"><i class="iconfont icon-linkedin"></i></a><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com/serious008/"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> Notex 2023</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="京ICP备2022033375号" target="_blank" rel="noopener" href="https://beian.miit.gov.cn/">京ICP备2022033375号 </a></p></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>