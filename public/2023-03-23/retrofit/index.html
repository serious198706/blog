<!DOCTYPE html><html class="appearance-user-can-set" lang="zh"><head><meta charset="UTF-8"><title>Notex</title><meta name="description" content="Keep low profile, he said."><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="Retrofit 是现在比较常用的网络请求库了，它的可扩展性强，底层网络请求集成了 Okhttp，异步处理可集成 RxJava，内容解析可集成 Gson，Jackson 等。而且全面支持 Restful 请求，并且通过注解的方式，支持链式调用，使用简洁方便。精妙的源码设计模式，内部层次分工明确，解耦性强。
它的使用核心是实现一个 Java 接口，用注解的方式来指定各种网络请求中的字段、方法等。


拿官网的例子来说明：
活生生的例子public interface GitHubService &amp;#123;
  @GET(&amp;quot;users/&amp;#123;user&amp;#125;/repos&amp;quot;)
  Call&amp;lt;List&amp;lt;Repo&amp;gt;&amp;gt; listRepos(@Path(&amp;quot;.."><script src="//unpkg.com/valine/dist/Valine.min.js"></script><meta name="generator" content="Hexo 5.4.2"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><!-- a(href= url_for("/"))= (theme.user && theme.user.name || config.author) + "'s blog"--><a href="/">Notex</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Retrofit 实现原理解析</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">主页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">主页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B4%BB%E7%94%9F%E7%94%9F%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-text">活生生的例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Retrofit-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">Retrofit 实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%81%B5%E9%AD%82-%E2%9D%B6-CallAdapter"><span class="toc-text">灵魂 ❶ CallAdapter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E6%80%A7-%E2%9D%B7-Converter"><span class="toc-text">特性 ❷ Converter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#invoke-%E9%98%B6%E6%AE%B5"><span class="toc-text">invoke 阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BARetrofit%E5%AE%9E%E4%BE%8B%E9%98%B6%E6%AE%B5"><span class="toc-text">创建Retrofit实例阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%8E%A5%E5%8F%A3%E4%BB%A3%E7%90%86%E9%98%B6%E6%AE%B5"><span class="toc-text">创建接口代理阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E4%BB%A3%E7%90%86%E6%9C%BA%E5%88%B6%E9%98%B6%E6%AE%B5"><span class="toc-text">触发代理机制阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E9%98%B6%E6%AE%B5"><span class="toc-text">请求阶段</span></a></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/Android"><i class="tag post-item-tag">Android</i></a><a href="/tags/%E4%B8%89%E6%96%B9%E5%BA%93"><i class="tag post-item-tag">三方库</i></a><a href="/tags/Retrofit"><i class="tag post-item-tag">Retrofit</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">Retrofit 实现原理解析</h1><time class="has-text-grey" datetime="2023-03-22T16:00:00.000Z">2023-03-23</time><article class="mt-2 post-content"><p><a target="_blank" rel="noopener" href="https://square.github.io/retrofit/">Retrofit</a> 是现在比较常用的网络请求库了，它的可扩展性强，底层网络请求集成了 Okhttp，异步处理可集成 RxJava，内容解析可集成 Gson，Jackson 等。而且全面支持 Restful 请求，并且通过注解的方式，支持链式调用，使用简洁方便。<br>精妙的源码设计模式，内部层次分工明确，解耦性强。</p>
<p>它的使用核心是实现一个 Java 接口，用注解的方式来指定各种网络请求中的字段、方法等。</p>
<span id="more"></span>

<p>拿官网的例子来说明：</p>
<h2 id="活生生的例子"><a href="#活生生的例子" class="headerlink" title="活生生的例子"></a>活生生的例子</h2><pre><code class="java">public interface GitHubService &#123;
  @GET(&quot;users/&#123;user&#125;/repos&quot;)
  Call&lt;List&lt;Repo&gt;&gt; listRepos(@Path(&quot;user&quot;) String user);
&#125;
</code></pre>
<p>上面的例子，用了两个注解，分别是<code>@GET</code>和<code>@Path</code>，由字面意思也可以看出，<code>@GET</code>是指该方法是HTTP请求中的GET方法，<code>@Path(&quot;user&quot;)</code>是指将请求URL中的<code>&#123;user&#125;</code>部分替换为传入的<code>user</code>参数。</p>
<p>我们来看看这两个注解的源码：</p>
<pre><code class="java">// retrofit2.http.GET.java

/** Make a GET request. */
@Documented
@Target(METHOD)
@Retention(RUNTIME)
public @interface GET &#123;
  /**
   * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
   * parameter of the method is annotated with &#123;@link Url @Url&#125;.
   * &lt;p&gt;
   * See &#123;@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL&#125; for details of how
   * this is resolved against a base URL to create the full endpoint URL.
   */
  String value() default &quot;&quot;;
&#125;
</code></pre>
<p>它使用了三个元注解，不再多解释。它的<code>value</code>指的是请求中的绝对/相对路径。</p>
<pre><code class="java">// retrofit2.http.Path.java

@Documented
@Retention(RUNTIME)
@Target(PARAMETER)
public @interface Path &#123;
  String value();

  /**
   * Specifies whether the argument value to the annotated method parameter is already URL encoded.
   */
  boolean encoded() default false;
&#125;
</code></pre>
<p>它有两个参数，一个是<code>value</code>，一个是是否已经经过<code>URL encoded</code>。</p>
<p>那么，retrofit是如何将注解使用起来的呢？我们来看看它的原理。</p>
<h2 id="Retrofit-实现原理"><a href="#Retrofit-实现原理" class="headerlink" title="Retrofit 实现原理"></a>Retrofit 实现原理</h2><p>先上一张图，简单了解一下它的整体流程：</p>
<p><img src="/img/27.png"></p>
<p>在创建Retrofit实例时，我们一般会按照下面的方式来创建实例：</p>
<pre><code class="java">Retrofit retrofit = new Retrofit.Builder()
    .baseUrl(&quot;https://api.github.com/&quot;)
    .build();

GitHubService service = retrofit.create(GitHubService.class);
</code></pre>
<p><code>build()</code>方法其实就是Java中比较典型的Builder设计模式，不过多解释，我们直接来看<code>create()</code>的源代码：</p>
<pre><code class="java">// retrofit2.Retrofit.java
@SuppressWarnings(&quot;unchecked&quot;)
public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123;
    // 检查接口可用性
    validateServiceInterface(service);
    // 使用动态代理的方式创建一个 service 的实例
    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;,
        new InvocationHandler() &#123;
            private final Platform platform = Platform.get();
            private final Object[] emptyArgs = new Object[0];

            @Override public @Nullable Object invoke(Object proxy, Method method,
                @Nullable Object[] args) throws Throwable &#123;
                // 如果 method 是 Object 的方法，那么就正常调用
                if (method.getDeclaringClass() == Object.class) &#123;
                    return method.invoke(this, args);
                &#125;
                // 一般情况下 Android 的 Platform.isDefaultMethod() 都会返回 false
                if (platform.isDefaultMethod(method)) &#123;
                    return platform.invokeDefaultMethod(method, service, proxy, args);
                &#125;
                // 所以真正起作用的，还是这一句
                return loadServiceMethod(method).invoke(args != null ? args : emptyArgs);
            &#125;
        &#125;
    );
&#125;
</code></pre>
<p>我们从这几行代码可以看出，Retrofit 是使用了动态代理的方式创建了一个实现service接口的对象，当外部调用 service 接口方法，会调用<code>invoke</code>方法，然后加载当前 method 对应的 ServiceMethod，并调用该 ServiceMethod 的 <code>invoke</code>。ServiceMethod 是个抽象类，那么，这里实际上是调用了 ServiceMethod 某一个实现类的 <code>invoke</code> 方法。具体的我们会在后面分析。</p>
<p>先看看<code>validateServiceInterface()</code>方法：</p>
<pre><code class="java">// retrofit2.Retrofit.java

private void validateServiceInterface(Class&lt;?&gt; service) &#123;
    if (!service.isInterface()) &#123;
      throw new IllegalArgumentException(&quot;API declarations must be interfaces.&quot;);
    &#125;

    // Deque是Java1.6之后加入的『双向队列』，也即能从两个方向向外拿出数据
    Deque&lt;Class&lt;?&gt;&gt; check = new ArrayDeque&lt;&gt;(1);
    check.add(service);
    while (!check.isEmpty()) &#123;
        // 获取该service的类
        Class&lt;?&gt; candidate = check.removeFirst();
        // getTypeParameters() 方法用于获取该类的声明中的参数列表
        // 这里要保证这个接口类没有任何的参数
        if (candidate.getTypeParameters().length != 0) &#123;
            StringBuilder message = new StringBuilder(&quot;Type parameters are unsupported on &quot;)
                .append(candidate.getName());

            if (candidate != service) &#123;
                message.append(&quot; which is an interface of &quot;)
                    .append(service.getName());
            
            throw new IllegalArgumentException(message.toString());
        &#125;

        // 将该service下所有的接口添加到check中
        Collections.addAll(check, candidate.getInterfaces());
    &#125;

    // 如果配置了validateEagerly，则提前加载 method 对应的 ServiceMethod。
    // 此处调用 loadServiceMethod() 方法，其实是在做一个预处理的操作，只是提前创建了一些 ServiceMethod 对象在缓存中。
    if (validateEagerly) &#123;
        Platform platform = Platform.get();
        for (Method method : service.getDeclaredMethods()) &#123;
            if (!platform.isDefaultMethod(method) &amp;&amp; !Modifier.isStatic(method.getModifiers())) &#123;
                loadServiceMethod(method);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>接下来看看在<code>create()</code>和<code>validateServiceInterface()</code>都会调用到的<code>loadServiceMethod()</code>方法：</p>
<pre><code class="java">// 所有的 Method 都被存在一个 ConcurrentHashMap 中，避免同步问题
private final Map&lt;Method, ServiceMethod&lt;?&gt;&gt; serviceMethodCache = new ConcurrentHashMap&lt;&gt;();

// 该方法的主要目的有两个：
// 1. 解析该 method 上的所有注解，并以 method - ServiceMethod 的形式放入缓存中，等待调用
// 2. 根据该 method 找到对应的 ServiceMethod，并返回
ServiceMethod&lt;?&gt; loadServiceMethod(Method method) &#123;
    ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method);
    if (result != null) return result;

    synchronized (serviceMethodCache) &#123;
      result = serviceMethodCache.get(method);
      if (result == null) &#123;
        // 此处 result 已经是 ServiceMethod 实现类 HttpSercieMethod 的实例
        result = ServiceMethod.parseAnnotations(this, method);
        serviceMethodCache.put(method, result);
      &#125;
    &#125;
    return result;
&#125;
</code></pre>
<p>ServiceMethod 是 Retrofit 的一个抽象类，我们来看看它的源代码：</p>
<pre><code class="java">// retrofit2.ServiceMethod.java

abstract class ServiceMethod&lt;T&gt; &#123;
    static &lt;T&gt; ServiceMethod&lt;T&gt; parseAnnotations(Retrofit retrofit, Method method) &#123;
        RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);

        Type returnType = method.getGenericReturnType();
        if (Utils.hasUnresolvableType(returnType)) &#123;
            throw methodError(method,
                &quot;Method return type must not include a type variable or wildcard: %s&quot;, returnType);
        &#125;
        if (returnType == void.class) &#123;
            throw methodError(method, &quot;Service methods cannot return void.&quot;);
        &#125;

        return HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);
    &#125;

    abstract @Nullable T invoke(Object[] args);
&#125;
</code></pre>
<p>RequestFactory是比较重要的一个类，它负责解析注解、构造 request 等，在后面会直接与okhttp进行交互，我们来看看它的源码：</p>
<pre><code class="java">final class RequestFactory &#123;
    static RequestFactory parseAnnotations(Retrofit retrofit, Method method) &#123;
        return new Builder(retrofit, method).build();
    &#125;

    // 储存 request 的一些数据
    private final Method method;
    private final HttpUrl baseUrl;
    final String httpMethod;
    private final @Nullable String relativeUrl;
    private final @Nullable Headers headers;
    private final @Nullable MediaType contentType;
    private final boolean hasBody;
    private final boolean isFormEncoded;
    private final boolean isMultipart;
    private final ParameterHandler&lt;?&gt;[] parameterHandlers;
    final boolean isKotlinSuspendFunction;

    ...

    /**
     * 检查接口中方法上的注解，来构造一个可复用的 service 方法。
     * 这个操作需要调用反射机制，所以每个 service 方法最好只构造一次，然后复用之。
     * Builder 不能复用。
     */
    static final class Builder &#123;
        private static final String PARAM = &quot;[a-zA-Z][a-zA-Z0-9_-]*&quot;;
        private static final Pattern PARAM_URL_REGEX = Pattern.compile(&quot;\\&#123;(&quot; + PARAM + &quot;)\\&#125;&quot;);
        private static final Pattern PARAM_NAME_REGEX = Pattern.compile(PARAM);
        ...
        Builder(Retrofit retrofit, Method method) &#123;
            this.retrofit = retrofit;
            this.method = method;
            // 获取方法上的注解
            this.methodAnnotations = method.getAnnotations();
            // 获取方法上的参数类型
            this.parameterTypes = method.getGenericParameterTypes();
            // 获取参数上的注解
            this.parameterAnnotationsArray = method.getParameterAnnotations();
        &#125;

        RequestFactory build() &#123;
            // 解析 method 上的所有注解
            for (Annotation annotation : methodAnnotations) &#123;
                parseMethodAnnotation(annotation);
            &#125;
            ...
            // 各种 method 注解的检查
            ...
            // 解析 paremater 上的所有注解
            int parameterCount = parameterAnnotationsArray.length;
            parameterHandlers = new ParameterHandler&lt;?&gt;[parameterCount];
            for (int p = 0, lastParameter = parameterCount - 1; p &lt; parameterCount; p++) &#123;
                // 并添加到一个 ParamaterHandler 的 Array 中
                parameterHandlers[p] =
                    parseParameter(p, parameterTypes[p], parameterAnnotationsArray[p], p == lastParameter);
            &#125;
            ...
            // 各种 parameter 注解的检查
            ...
            return new RequestFactory(this);
        &#125;
    &#125;

    // 解析 method 上的注解
    private void parseMethodAnnotation(Annotation annotation) &#123;
        ...
        // 这里的 DELETE GET 等，都是 retrofit 自定义的各种 Http 请求类型的注解
        if (annotation instanceof DELETE) &#123;
            parseHttpMethodAndPath(&quot;DELETE&quot;, ((DELETE) annotation).value(), false);
        &#125; else if (annotation instanceof GET) &#123;
            parseHttpMethodAndPath(&quot;GET&quot;, ((GET) annotation).value(), false);
        &#125; ...

    &#125;

    // 解析 method 上注解的详细数据
    private void parseHttpMethodAndPath(String httpMethod, String value, boolean hasBody) &#123;
        if (this.httpMethod != null) &#123;
            throw methodError(method, &quot;Only one HTTP method is allowed. Found: %s and %s.&quot;,
                this.httpMethod, httpMethod);
        &#125;
        this.httpMethod = httpMethod;
        this.hasBody = hasBody;

        if (value.isEmpty()) &#123;
            return;
        &#125;

        // 获取 URL 的相对路径，如果有 ? 参数的话，就获取一下
        int question = value.indexOf(&#39;?&#39;);
        if (question != -1 &amp;&amp; question &lt; value.length() - 1) &#123;
            // Ensure the query string does not have any named parameters.
            String queryParams = value.substring(question + 1);
            Matcher queryParamMatcher = PARAM_URL_REGEX.matcher(queryParams);
            if (queryParamMatcher.find()) &#123;
            throw methodError(method, &quot;URL query string \&quot;%s\&quot; must not have replace block. &quot;
                + &quot;For dynamic query parameters use @Query.&quot;, queryParams);
            &#125;
        &#125;

        // 拿到注解中的 value，此为 relativeUrl
        this.relativeUrl = value;
        // 解析参数们
        this.relativeUrlParamNames = parsePathParameters(value);
    &#125;

    // 解析参数
    private @Nullable ParameterHandler&lt;?&gt; parseParameter(
        int p, Type parameterType, @Nullable Annotation[] annotations, boolean allowContinuation) &#123;
        ParameterHandler&lt;?&gt; result = null;
        if (annotations != null) &#123;
            for (Annotation annotation : annotations) &#123;
                // 解析参数的注解
                ParameterHandler&lt;?&gt; annotationAction =
                    parseParameterAnnotation(p, parameterType, annotations, annotation);

                if (annotationAction == null) &#123;
                    continue;
                &#125;

                if (result != null) &#123;
                    throw parameterError(method, p,
                        &quot;Multiple Retrofit annotations found, only one allowed.&quot;);
                &#125;

                result = annotationAction;
            &#125;
        &#125;

        if (result == null) &#123;
            if (allowContinuation) &#123;
                try &#123;
                    if (Utils.getRawType(parameterType) == Continuation.class) &#123;
                        isKotlinSuspendFunction = true;
                        return null;
                    &#125;
                &#125; catch (NoClassDefFoundError ignored) &#123;
                &#125;
            &#125;
            throw parameterError(method, p, &quot;No Retrofit annotation found.&quot;);
        &#125;

        return result;
    &#125;

    @Nullable
    private ParameterHandler&lt;?&gt; parseParameterAnnotation(
        int p, Type type, Annotation[] annotations, Annotation annotation) &#123;
        // 这里的 Url Path Query 等，是 retrofit 自定义的注解，通过字符串解析等各种方式，来组成正确的 ParameterHandler
        if (annotation instanceof Url) &#123;
            ...
            return new ParameterHandler.RelativeUrl(method, p);
            ...
        &#125; else if (annotation instanceof Path) &#123;
            ...
            return new ParameterHandler.Path&lt;&gt;(method, p, name, converter, path.encoded());
            ...
        &#125; else if (annotation instanceof Query) &#123;
            // 注意三种不同的返回值
            Class&lt;?&gt; rawParameterType = Utils.getRawType(type);
            gotQuery = true;
            if (Iterable.class.isAssignableFrom(rawParameterType)) &#123;
                if (!(type instanceof ParameterizedType)) &#123;
                    throw parameterError(method, p, rawParameterType.getSimpleName()
                        + &quot; must include generic type (e.g., &quot;
                        + rawParameterType.getSimpleName()
                        + &quot;&lt;String&gt;)&quot;);
                &#125;
                ParameterizedType parameterizedType = (ParameterizedType) type;
                Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
                Converter&lt;?, String&gt; converter =
                    retrofit.stringConverter(iterableType, annotations);
                return new ParameterHandler.Query&lt;&gt;(name, converter, encoded).iterable();
            &#125; else if (rawParameterType.isArray()) &#123;
                Class&lt;?&gt; arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
                Converter&lt;?, String&gt; converter =
                    retrofit.stringConverter(arrayComponentType, annotations);
                return new ParameterHandler.Query&lt;&gt;(name, converter, encoded).array();
            &#125; else &#123;
                Converter&lt;?, String&gt; converter =
                    retrofit.stringConverter(type, annotations);
                return new ParameterHandler.Query&lt;&gt;(name, converter, encoded);
            &#125;
        &#125; else if (annotation instanceof Header) &#123;
            ...
            return new ParameterHandler.Header&lt;&gt;(name, converter);
            ...
        &#125; else if (annotation instanceof Field) &#123;
            ...
            return new ParameterHandler.Field&lt;&gt;(name, converter, encoded);
            ...
        &#125; else if (annotation instanceof Body) &#123;
            ...
            return new ParameterHandler.Body&lt;&gt;(method, p, converter);
        &#125;

        ...

        return null; // Not a Retrofit annotation.
    &#125;
&#125;
</code></pre>
<p>从这几部分代码可以看出，最后RequestFactory的实例中，包含的是：</p>
<ul>
<li>HTTP 请求的 BaseUrl</li>
<li>HTTP 请求的 RelativeUrl</li>
<li>HTTP 请求的方法</li>
<li>HTTP 请求的参数列表（可选）</li>
<li>HTTP 请求的 Body（可选）</li>
<li>HTTP 请求的 Headers（可选）</li>
<li>ParameterHandler 的 Array</li>
</ul>
<p>这ParameterHandler是什么呢？我们来看看它的代码：</p>
<pre><code class="java">// retrofit2.ParameterHandler.java

abstract class ParameterHandler&lt;T&gt; &#123;
    abstract void apply(RequestBuilder builder, @Nullable T value) throws IOException;

    final ParameterHandler&lt;Iterable&lt;T&gt;&gt; iterable() &#123;
        return new ParameterHandler&lt;Iterable&lt;T&gt;&gt;() &#123;
            @Override void apply(RequestBuilder builder, @Nullable Iterable&lt;T&gt; values)
                throws IOException &#123;
                if (values == null) return; // Skip null values.

                for (T value : values) &#123;
                    ParameterHandler.this.apply(builder, value);
                &#125;
            &#125;
        &#125;;
    &#125;

    final ParameterHandler&lt;Object&gt; array() &#123;
        return new ParameterHandler&lt;Object&gt;() &#123;
            @Override void apply(RequestBuilder builder, @Nullable Object values) throws IOException &#123;
                if (values == null) return; // Skip null values.

                for (int i = 0, size = Array.getLength(values); i &lt; size; i++) &#123;
                    //noinspection unchecked
                    ParameterHandler.this.apply(builder, (T) Array.get(values, i));
                &#125;
            &#125;
        &#125;;
    &#125;

    // 一个 ParameterHandler的具体实现类
    // 包含 Method 和 index
    static final class RelativeUrl extends ParameterHandler&lt;Object&gt; &#123;
        private final Method method;
        private final int p;

        RelativeUrl(Method method, int p) &#123;
            this.method = method;
            this.p = p;
        &#125;

        @Override void apply(RequestBuilder builder, @Nullable Object value) &#123;
            if (value == null) &#123;
                throw Utils.parameterError(method, p, &quot;@Url parameter is null.&quot;);
            &#125;
            builder.setRelativeUrl(value);
        &#125;
    &#125;
&#125;
</code></pre>
<p>可以看出，每一种 retrofit 自定义的注解（GET、POST、FIELD、Path）等，最终都会转化成一个 ParameterHandler 的实例，并实现 <code>apply()</code> 方法。<code>apply()</code>方法中会传入 RequestBuild 的实例，这是产生 Request 的倒数第二步。</p>
<p>好，说了这么一大圈，我们还是得回到 ServiceMethod 类中。</p>
<p>生成了 RequestFactory 实例后，利用这个实例，又调用了 <code>HttpServiceMethod.parseAnnotations()</code>方法，我们来看看这个类，以及其包含的方法：</p>
<pre><code class="java">// retrofit2.HttpServiceMethod.java

/** Adapts an invocation of an interface method into an HTTP call. */
// 这是 ServiceMethod 的唯一实现类
abstract class HttpServiceMethod&lt;ResponseT, ReturnT&gt; extends ServiceMethod&lt;ReturnT&gt; &#123;
      
      static &lt;ResponseT, ReturnT&gt; HttpServiceMethod&lt;ResponseT, ReturnT&gt; parseAnnotations(
        Retrofit retrofit, Method method, RequestFactory requestFactory) &#123;
        boolean isKotlinSuspendFunction = requestFactory.isKotlinSuspendFunction;
        boolean continuationWantsResponse = false;
        boolean continuationBodyNullable = false;

        Annotation[] annotations = method.getAnnotations();
        Type adapterType;
        ...
        // ❶ 一个比较核心的方法，也是 retrofit 的灵魂所在，我们在后面要详细解释
        CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter =
            createCallAdapter(retrofit, method, adapterType, annotations);
        Type responseType = callAdapter.responseType();
        
        ...
        // 各种检查
        ...

        // ❷ retrofit 的另一个重要特性『Converters』，可以自动反序列化返回的数据
        Converter&lt;ResponseBody, ResponseT&gt; responseConverter =
            createResponseConverter(retrofit, method, responseType);

        okhttp3.Call.Factory callFactory = retrofit.callFactory;
        
        if (!isKotlinSuspendFunction) &#123;
            return new CallAdapted&lt;&gt;(requestFactory, callFactory, responseConverter, callAdapter);
        &#125; else if (continuationWantsResponse) &#123;
            // 与 kotlin 协程有关的一些东西，后面再讲
            // noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.
            return (HttpServiceMethod&lt;ResponseT, ReturnT&gt;) new SuspendForResponse&lt;&gt;(requestFactory,
                callFactory, responseConverter, (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter);
        &#125; else &#123;
            // 与 kotlin 协程有关的一些东西，后面再讲
            // noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.
            return (HttpServiceMethod&lt;ResponseT, ReturnT&gt;) new SuspendForBody&lt;&gt;(requestFactory,
                callFactory, responseConverter, (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter,
                continuationBodyNullable);
        &#125;
    &#125;

    private static &lt;ResponseT, ReturnT&gt; CallAdapter&lt;ResponseT, ReturnT&gt; createCallAdapter(
        Retrofit retrofit, Method method, Type returnType, Annotation[] annotations) &#123;
        try &#123;
            // noinspection unchecked
            return (CallAdapter&lt;ResponseT, ReturnT&gt;) retrofit.callAdapter(returnType, annotations);
        &#125; catch (RuntimeException e) &#123; // Wide exception range because factories are user code.
            throw methodError(method, e, &quot;Unable to create call adapter for %s&quot;, returnType);
        &#125;
    &#125;

    private static &lt;ResponseT&gt; Converter&lt;ResponseBody, ResponseT&gt; createResponseConverter(
        Retrofit retrofit, Method method, Type responseType) &#123;
        Annotation[] annotations = method.getAnnotations();
        try &#123;
            return retrofit.responseBodyConverter(responseType, annotations);
        &#125; catch (RuntimeException e) &#123; // Wide exception range because factories are user code.
            throw methodError(method, e, &quot;Unable to create converter for %s&quot;, responseType);
        &#125;
    &#125;

    // 在 Retrofit.create() 方法的最后一句，调用的 invoke()，其实就是调用的这里
    @Override final @Nullable ReturnT invoke(Object[] args) &#123;
        Call&lt;ResponseT&gt; call = new OkHttpCall&lt;&gt;(requestFactory, args, callFactory, responseConverter);
        return adapt(call, args);
    &#125;

    // 抽象方法，由 CallAdapted、SuspendForResponse、SuspendForBody 来实现
    protected abstract @Nullable ReturnT adapt(Call&lt;ResponseT&gt; call, Object[] args);

    static final class CallAdapted&lt;ResponseT, ReturnT&gt; extends HttpServiceMethod&lt;ResponseT, ReturnT&gt; &#123;
        private final CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter;

        CallAdapted(RequestFactory requestFactory, okhttp3.Call.Factory callFactory,
            Converter&lt;ResponseBody, ResponseT&gt; responseConverter,
            CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter) &#123;
        super(requestFactory, callFactory, responseConverter);
            this.callAdapter = callAdapter;
        &#125;

        @Override protected ReturnT adapt(Call&lt;ResponseT&gt; call, Object[] args) &#123;
            return callAdapter.adapt(call);
        &#125;
    &#125;

    static final class SuspendForResponse&lt;ResponseT&gt; extends HttpServiceMethod&lt;ResponseT, Object&gt; &#123;
        private final CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt; callAdapter;

        SuspendForResponse(RequestFactory requestFactory, okhttp3.Call.Factory callFactory,
            Converter&lt;ResponseBody, ResponseT&gt; responseConverter,
            CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt; callAdapter) &#123;
        super(requestFactory, callFactory, responseConverter);
            this.callAdapter = callAdapter;
        &#125;

        @Override protected Object adapt(Call&lt;ResponseT&gt; call, Object[] args) &#123;
            call = callAdapter.adapt(call);

            //noinspection unchecked Checked by reflection inside RequestFactory.
            Continuation&lt;Response&lt;ResponseT&gt;&gt; continuation =
                (Continuation&lt;Response&lt;ResponseT&gt;&gt;) args[args.length - 1];

            // See SuspendForBody for explanation about this try/catch.
            try &#123;
                return KotlinExtensions.awaitResponse(call, continuation);
            &#125; catch (Exception e) &#123;
                return KotlinExtensions.suspendAndThrow(e, continuation);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>HttpServiceMethod类的主要功能，是创建了一个 CallAdapter 对象，这个对象是用来把 OkHttpCall 适配为我们定义的方法的返回值类型的；创建 Converter 对象，用于把 ResponseBody 转换为我们最终需要的类型；生成 HttpServiceMethod 的三种派生类其中一种的实例，返回并放到 <code>serviceMethodCashe</code> 中。</p>
<p>上面的代码中有两处比较重要的地方，用序号标注了出来，我们来单独讲讲：</p>
<h2 id="灵魂-❶-CallAdapter"><a href="#灵魂-❶-CallAdapter" class="headerlink" title="灵魂 ❶ CallAdapter"></a>灵魂 ❶ CallAdapter</h2><p>跟着<code>retrofit.callAdapter()</code>向下走，我们看到了它的代码：</p>
<pre><code class="java">// retrofit2.Retrofit.java

public CallAdapter&lt;?, ?&gt; callAdapter(Type returnType, Annotation[] annotations) &#123;
    return nextCallAdapter(null, returnType, annotations);
&#125;

public CallAdapter&lt;?, ?&gt; nextCallAdapter(@Nullable CallAdapter.Factory skipPast, Type returnType,
      Annotation[] annotations) &#123;
    ...
    // callAdapterFactories 在 Builder.build() 中添加，见下
    int start = callAdapterFactories.indexOf(skipPast) + 1;
    for (int i = start, count = callAdapterFactories.size(); i &lt; count; i++) &#123;
        CallAdapter&lt;?, ?&gt; adapter = callAdapterFactories.get(i).get(returnType, annotations, this);
        if (adapter != null) &#123;
            return adapter;
        &#125;
    &#125;

    // 如果在上面还没有 return，则处理一些错误
    ...
&#125;

public static final class Builder &#123;
    Builder(Retrofit retrofit) &#123;
        // 不要添加默认的、build() 方法里添加的的平台相关的 CallAdapter
        for (int i = 0,
            size = retrofit.callAdapterFactories.size() - platform.defaultCallAdapterFactoriesSize();
            i &lt; size; i++) &#123;
            callAdapterFactories.add(retrofit.callAdapterFactories.get(i));
        &#125;
    &#125;

    public Retrofit build() &#123;
        ...
        // 初始化 okhttpclient 等等
        ...
        // 执行器
        Executor callbackExecutor = this.callbackExecutor;
        if (callbackExecutor == null) &#123;
            callbackExecutor = platform.defaultCallbackExecutor();
        &#125;
        // 添加平台相关的 CallAdapter
        List&lt;CallAdapter.Factory&gt; callAdapterFactories = new ArrayList&lt;&gt;(this.callAdapterFactories);
        callAdapterFactories.addAll(platform.defaultCallAdapterFactories(callbackExecutor));
        ...
        // 返回 Retrofit 实例
        return new Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories),
            unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);
    &#125;
&#125;
</code></pre>
<p>再看看Platform.defaultCallAdapterFactories()做了些什么：</p>
<pre><code class="java">// retrofit.Platform.java

List&lt;? extends CallAdapter.Factory&gt; defaultCallAdapterFactories(
    @Nullable Executor callbackExecutor) &#123;
    DefaultCallAdapterFactory executorFactory = new DefaultCallAdapterFactory(callbackExecutor);

    // Android 中 Build.VERSION.SDK_INT &gt;= 24 时，hasJava8Types会被置为true
    return hasJava8Types
        ? asList(CompletableFutureCallAdapterFactory.INSTANCE, executorFactory)
        : singletonList(executorFactory);
&#125;
</code></pre>
<p>然后我们看看 DefautCallAdapterFactory 类，顾名思义，它是创建 CallAdapter 的一个工厂类：</p>
<pre><code class="java">// retrofit2.DefaultCallAdapterFactory.java

final class DefaultCallAdapterFactory extends CallAdapter.Factory &#123;
    ...
    @Override public @Nullable CallAdapter&lt;?, ?&gt; get(
        Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;
        if (getRawType(returnType) != Call.class) &#123;
            return null;
        &#125;
        if (!(returnType instanceof ParameterizedType)) &#123;
            throw new IllegalArgumentException(
                &quot;Call return type must be parameterized as Call&lt;Foo&gt; or Call&lt;? extends Foo&gt;&quot;);
        &#125;
        final Type responseType = Utils.getParameterUpperBound(0, (ParameterizedType) returnType);

        final Executor executor = Utils.isAnnotationPresent(annotations, SkipCallbackExecutor.class)
            ? null
            : callbackExecutor;

        return new CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123;
            @Override public Type responseType() &#123;
                return responseType;
            &#125;

            @Override public Call&lt;Object&gt; adapt(Call&lt;Object&gt; call) &#123;
                return executor == null
                    ? call
                    : new ExecutorCallbackCall&lt;&gt;(executor, call);
            &#125;
        &#125;;
    &#125;
    ...
&#125;
</code></pre>
<p>CallAdapter 的实现类终于处是找到了，但是它的 <code>adapt()</code> 方法才是真正起作用的方法。从上到下，调用到 <code>adapt()</code> 的时候，返回的是一个ExcutorCallbackCall的实例。</p>
<h2 id="特性-❷-Converter"><a href="#特性-❷-Converter" class="headerlink" title="特性 ❷ Converter"></a>特性 ❷ Converter</h2><p>跟着<code>retrofit.responseBodyConverter()</code>方法往下走，我们看到了它的代码：</p>
<pre><code class="java">// retrofit2.Retrofit.java

public &lt;T&gt; Converter&lt;ResponseBody, T&gt; responseBodyConverter(Type type, Annotation[] annotations) &#123;
    return nextResponseBodyConverter(null, type, annotations);
&#125;


public &lt;T&gt; Converter&lt;ResponseBody, T&gt; nextResponseBodyConverter(
    @Nullable Converter.Factory skipPast, Type type, Annotation[] annotations) &#123;
    ...
    int start = converterFactories.indexOf(skipPast) + 1;
    for (int i = start, count = converterFactories.size(); i &lt; count; i++) &#123;
        Converter&lt;ResponseBody, ?&gt; converter =
            converterFactories.get(i).responseBodyConverter(type, annotations, this);
        if (converter != null) &#123;
        //noinspection unchecked
        return (Converter&lt;ResponseBody, T&gt;) converter;
        &#125;
    &#125;
&#125;

public static final class Builder &#123;
    Builder(Retrofit retrofit) &#123;
        // 不要添加默认的、build() 方法里添加的的平台相关的 BuiltIntConverters
        for (int i = 1,
            size = retrofit.converterFactories.size() - platform.defaultConverterFactoriesSize();
            i &lt; size; i++) &#123;
            converterFactories.add(retrofit.converterFactories.get(i));
        &#125;
    &#125;

    public Retrofit build() &#123;
        ...
        // 初始化 okhttoclient 等等
        ...
        List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(
            1 + this.converterFactories.size() + platform.defaultConverterFactoriesSize());

        // 先添加内置的 converter，里面实现了多个转换器包括把字节流转换成 ResponseBody，
        // ResponseBody 转换为 java 中的 Void 或者 Kotlin 中的 Unit 时关闭流的操作等
        converterFactories.add(new BuiltInConverters());
        // 有自定义的就添加自定义，
        // 比如我们常用的 GsonConverterFactory 
        converterFactories.addAll(this.converterFactories);
        // 平台默认的 converter
        converterFactories.addAll(platform.defaultConverterFactories());

        // 返回 Retrofit 实例
        return new Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories),
            unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);
    &#125;
&#125;
</code></pre>
<pre><code class="java">// retrofit2.Platform.java

List&lt;? extends Converter.Factory&gt; defaultConverterFactories() &#123;
    // SDK 版本小于24，就没有默认的 converter
    return hasJava8Types
        ? singletonList(OptionalConverterFactory.INSTANCE)
        : emptyList();
&#125;
</code></pre>
<p>可以看到，与 CallAdapter 的生成方式几乎一模一样。</p>
<h2 id="invoke-阶段"><a href="#invoke-阶段" class="headerlink" title="invoke 阶段"></a>invoke 阶段</h2><p>OK，所有初始化完成，接下来进入调用阶段，我们接着文章开头的例子，来看一下调用的入口：</p>
<pre><code class="java">...
GitHubService service = retrofit.create(GitHubService.class);
Call&lt;List&lt;Repo&gt;&gt; call = service.listRepos(&quot;notex&quot;);
call.enqueue(new Callback&lt;List&lt;Repo&gt;&gt;() &#123;
    @Override 
    public void onResponse(Call&lt;List&lt;Repo&gt;&gt; call, Response&lt;List&lt;Repo&gt;&gt; response) &#123;
    &#125;

    @Override 
    public void onFailure(Call&lt;List&lt;Repo&gt;&gt; call, Throwable t) &#123;
    &#125;
&#125;);
</code></pre>
<p>那么，我们就以<code>enqueue()</code>方法为入口，看看调用的流程是怎样的。</p>
<p>刚才经过我们的分析，目前的<code>call</code>变量应该是一个 ExecutorCallbackCall 的实例，我们来看看它的代码：</p>
<pre><code class="java">// retrofit2.DefaultCallAdapterFactory.java

static final class ExecutorCallbackCall&lt;T&gt; implements Call&lt;T&gt; &#123;
    final Executor callbackExecutor;
    final Call&lt;T&gt; delegate;

    ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123;
        this.callbackExecutor = callbackExecutor;
        this.delegate = delegate;
    &#125;

    @Override 
    public void enqueue(final Callback&lt;T&gt; callback) &#123;
        Objects.requireNonNull(callback, &quot;callback == null&quot;);

        delegate.enqueue(new Callback&lt;T&gt;() &#123;
        @Override 
        public void onResponse(Call&lt;T&gt; call, final Response&lt;T&gt; response) &#123;
            callbackExecutor.execute(() -&gt; &#123;
            if (delegate.isCanceled()) &#123;
                // Emulate OkHttp&#39;s behavior of throwing/delivering an IOException on cancellation.
                callback.onFailure(ExecutorCallbackCall.this, new IOException(&quot;Canceled&quot;));
            &#125; else &#123;
                callback.onResponse(ExecutorCallbackCall.this, response);
            &#125;
            &#125;);
        &#125;

        @Override 
        public void onFailure(Call&lt;T&gt; call, final Throwable t) &#123;
            callbackExecutor.execute(() -&gt; callback.onFailure(ExecutorCallbackCall.this, t));
        &#125;
        &#125;);
    &#125;

    @Override 
    public boolean isExecuted() &#123;
        return delegate.isExecuted();
    &#125;

    @Override 
    public Response&lt;T&gt; execute() throws IOException &#123;
        return delegate.execute();
    &#125;

    @Override 
    public void cancel() &#123;
        delegate.cancel();
    &#125;

    @Override 
    public boolean isCanceled() &#123;
        return delegate.isCanceled();
    &#125;

    @SuppressWarnings(&quot;CloneDoesntCallSuperClone&quot;) // Performing deep clone.
    @Override 
    public Call&lt;T&gt; clone() &#123;
        return new ExecutorCallbackCall&lt;&gt;(callbackExecutor, delegate.clone());
    &#125;

    @Override 
    public Request request() &#123;
        return delegate.request();
    &#125;

    @Override 
    public Timeout timeout() &#123;
        return delegate.timeout();
    &#125;
&#125;
</code></pre>
<p><code>delegate</code> 是 OkHttpCall 对象，使用过 OkHttp 的应该知道它的 <code>enqueue</code> 是执行在子线程的，所以 ExecutorCallbackCall 为我们做的就是把在子线程的回调中，通过 MainThreadExecutor 在主线程中调用 <code>retrofit2.Callback</code> 的回调。当然这个 <code>enqueue</code> 还不是真正的 OkHttp 的 <code>enqueue</code>，它做了封装。</p>
<p>接着就看看<code>OkHttpCall.enqueue()</code>方法：</p>
<pre><code class="java">// retrofit2.OkhttpCall.java
 @Override 
 public void enqueue(final Callback&lt;T&gt; callback) &#123;
    ...
    okhttp3.Call call;
    Throwable failure;

    synchronized (this) &#123;
        if (executed) throw new IllegalStateException(&quot;Already executed.&quot;);
        executed = true;

        call = rawCall;
        failure = creationFailure;
        if (call == null &amp;&amp; failure == null) &#123;
            try &#123;
                // createRawCall() 方法见下
                call = rawCall = createRawCall();
            &#125; catch (Throwable t) &#123;
                throwIfFatal(t);
                failure = creationFailure = t;
            &#125;
        &#125;
    &#125;

    if (failure != null) &#123;
        callback.onFailure(this, failure);
        return;
    &#125;

    if (canceled) &#123;
        call.cancel();
    &#125;

    // 这里才是真正调用到了 Okhttp.enqueue()
    call.enqueue(new okhttp3.Callback() &#123;
        @Override 
        public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) &#123;
            Response&lt;T&gt; response;
            try &#123;
                response = parseResponse(rawResponse);
            &#125; catch (Throwable e) &#123;
                throwIfFatal(e);
                callFailure(e);
                return;
            &#125;

            try &#123;
                callback.onResponse(OkHttpCall.this, response);
            &#125; catch (Throwable t) &#123;
                throwIfFatal(t);
                t.printStackTrace(); // TODO this is not great
            &#125;
        &#125;

        @Override 
        public void onFailure(okhttp3.Call call, IOException e) &#123;
            callFailure(e);
        &#125;

        private void callFailure(Throwable e) &#123;
            try &#123;
                callback.onFailure(OkHttpCall.this, e);
            &#125; catch (Throwable t) &#123;
                throwIfFatal(t);
                t.printStackTrace(); // TODO this is not great
            &#125;
        &#125;
    &#125;);
&#125;


private okhttp3.Call createRawCall() throws IOException &#123;
    okhttp3.Call call = callFactory.newCall(requestFactory.create(args));
    if (call == null) &#123;
        throw new NullPointerException(&quot;Call.Factory returned null.&quot;);
    &#125;
    return call;
&#125;
</code></pre>
<p>看到这里，不禁感叹，Retrofit 的工厂模式真是应用得出神入化，无论是 Call，还是 Request，全部用工厂模式来创建。</p>
<p>在上面我们讲过，RequestFactory 的一个重要功能是 <code>parseAnnotation()</code>，现在它的另一个重要功能来了——构建 Request。</p>
<pre><code class="java">// retrofit2.RequestFactory.java

okhttp3.Request create(Object[] args) throws IOException &#123;
    @SuppressWarnings(&quot;unchecked&quot;) // It is an error to invoke a method with the wrong arg types.
    // 还记得 parseAnnotations() 方法吗，解析出来的 parameterHandlers 此处派上用场了
    ParameterHandler&lt;Object&gt;[] handlers = (ParameterHandler&lt;Object&gt;[]) parameterHandlers;

    int argumentCount = args.length;
    if (argumentCount != handlers.length) &#123;
        throw new IllegalArgumentException(&quot;Argument count (&quot; + argumentCount
            + &quot;) doesn&#39;t match expected count (&quot; + handlers.length + &quot;)&quot;);
    &#125;

    RequestBuilder requestBuilder = new RequestBuilder(httpMethod, baseUrl, relativeUrl,
        headers, contentType, hasBody, isFormEncoded, isMultipart);

    if (isKotlinSuspendFunction) &#123;
        // The Continuation is the last parameter and the handlers array contains null at that index.
        argumentCount--;
    &#125;

    List&lt;Object&gt; argumentList = new ArrayList&lt;&gt;(argumentCount);
    for (int p = 0; p &lt; argumentCount; p++) &#123;
        argumentList.add(args[p]);
        handlers[p].apply(requestBuilder, args[p]);
    &#125;

    return requestBuilder.get()
        .tag(Invocation.class, new Invocation(method, argumentList))
        .build();
    &#125;
&#125;
</code></pre>
<p>此时，有了 Request，就可以真正地调用<code>Okhttp.enqueue()</code>方法来进行请求了。</p>
<p>在有了正确的回调结果后，还需要有一步<code>response = parseResponse(rawResponse)</code>来解析数据，我们看看它是如何做的：</p>
<pre><code class="java">Response&lt;T&gt; parseResponse(okhttp3.Response rawResponse) throws IOException &#123;
    ResponseBody rawBody = rawResponse.body();

    // Remove the body&#39;s source (the only stateful object) so we can pass the response along.
    rawResponse = rawResponse.newBuilder()
        .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))
        .build();

    int code = rawResponse.code();
    if (code &lt; 200 || code &gt;= 300) &#123;
        try &#123;
        // Buffer the entire body to avoid future I/O.
        ResponseBody bufferedBody = Utils.buffer(rawBody);
        return Response.error(bufferedBody, rawResponse);
        &#125; finally &#123;
        rawBody.close();
        &#125;
    &#125;

    if (code == 204 || code == 205) &#123;
        rawBody.close();
        return Response.success(null, rawResponse);
    &#125;

    ExceptionCatchingResponseBody catchingBody = new ExceptionCatchingResponseBody(rawBody);
    try &#123;
        T body = responseConverter.convert(catchingBody);
        return Response.success(body, rawResponse);
    &#125; catch (RuntimeException e) &#123;
        // If the underlying source threw an exception, propagate that rather than indicating it was
        // a runtime exception.
        catchingBody.throwIfCaught();
        throw e;
    &#125;
&#125;
</code></pre>
<p>回调操作，这里还是在子线程，通过 ExecutorCallbackCall 里面的流程，调用到主线程，到这里我们就真正的走过了一次 Retrofit 从 create 创建 Call 到发送请求，然后到回调主线程的操作了。</p>
<p>至此，整个 Retrofit 的一次完整的流程便完成了，我们使用下面一张图来总结一下：</p>
<p><img src="/img/28.png"></p>
<h3 id="创建Retrofit实例阶段"><a href="#创建Retrofit实例阶段" class="headerlink" title="创建Retrofit实例阶段"></a>创建Retrofit实例阶段</h3><ol>
<li>调用<code>new Retrofit.Builder().build()</code></li>
<li>Retrofit 类在<code>build()</code>方法中有如下步骤：<ol>
<li>创建 OkHttpClient 实例</li>
<li>MainThreadExecutor 实例</li>
<li>调用<code>Platform.defaultCallAdapterFactories()</code>方法创建 CallAdapter</li>
<li>调用<code>Platform.defaultConverterFactoriesSize()</code>方法创建 Converter</li>
<li>新建并返回 Retrofit 实例</li>
</ol>
</li>
</ol>
<h3 id="创建接口代理阶段"><a href="#创建接口代理阶段" class="headerlink" title="创建接口代理阶段"></a>创建接口代理阶段</h3><ol>
<li>调用<code>Retrofit.create()</code>方法创建接口实例</li>
<li>在<code>Retrofit.create()</code>方法中有如下步骤：<ol>
<li>检查接口</li>
<li>调用<code>loadServiceMethod()</code>方法</li>
<li>创建一个方法代理并返回</li>
</ol>
</li>
<li>在<code>loadServiceMethod()</code>方法中有如下步骤：<ol>
<li>解析注解</li>
<li>解析参数</li>
<li>生成 RequestFactory 实例</li>
<li>调用<code>HttpServiceMethod.parseAnnotations()</code>方法</li>
</ol>
</li>
<li>在<code>HttpServiceMethod.parseAnnotations()</code>方法中有如下步骤：<ol>
<li>调用<code>createCallAdapter()</code>方法，从 Retrofit 实例的 callAdapterFactories 中拿取 CallAdapter</li>
<li>返回 HttpServiceMethod 的派生类 CallAdapted | SuspendForResponse | SuspendForBody 的实例</li>
</ol>
</li>
<li>将上一步返回的实例添加到缓存中等待读取和调用</li>
</ol>
<h3 id="触发代理机制阶段"><a href="#触发代理机制阶段" class="headerlink" title="触发代理机制阶段"></a>触发代理机制阶段</h3><ol>
<li>调用接口方法，触发代理机制</li>
<li>在代理的<code>invoke()</code>方法被调用时，有如下步骤：<ol>
<li>使用<code>loadServiceMethod()</code>获取该方法对应的ServiceMethod</li>
<li>调用<code>ServiceMethod.invoke()</code>方法</li>
<li>调用<code>HttpServiceMethod.invoke()</code>方法</li>
<li>调用 HttpServiceMethod 的<code>adapt()</code>方法，其派生类之一的<code>adapt()</code>方法被调用</li>
<li><code>CallAdapter.adapt()</code>被调用</li>
<li>返回 ExecutorCallbackCall 实例</li>
</ol>
</li>
</ol>
<h3 id="请求阶段"><a href="#请求阶段" class="headerlink" title="请求阶段"></a>请求阶段</h3><ol>
<li> 调用<code>ExecutorCallbackCall.enqueue()</code>方法发起请求</li>
<li> 在<code>ExecutorCallbackCall.enqueue()</code>方法中有如下步骤：</li>
</ol>
<ol>
<li>创建 Request 实例，并调用<code>callFactory.newCall(Request)</code>方法创建 RealCall 实例</li>
<li>调用<code>RealCall.enqueue()</code>方法，使用 okhttp 发起请求</li>
<li> 回调到主线程</li>
<li> 解析并利用 Converter 反序列化返回的结果</li>
<li> 回调到调用者</li>
</ol>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2023-06-15/jetpack-compose-side-effects/" title="Jetpack Compose Side Effects"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">Previous: Jetpack Compose Side Effects</span></a><a class="button is-default" href="/2023-03-18/openai/" title="OpenAI"><span class="has-text-weight-semibold">Next: OpenAI</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container" id="vcomments" data-comment_valine_id="b7rbKQnQFa9DYl1anYfacJRz-gzGzoHsz" data-comment_valine_key="nUuKvGHOJBRylruJLW2Fmekg"></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com/serious008/"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/serious198706"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com/serious008/"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><a title="zhihu" target="_blank" rel="noopener nofollow" href="//zhihu.com/people/cy198706"><i class="iconfont icon-zhihu"></i></a><!-- 领英--><a title="linkedin" target="_blank" rel="noopener nofollow" href="//www.linkedin.com/in/serious_chen/"><i class="iconfont icon-linkedin"></i></a><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com/serious008/"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> Notex 2023</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="京ICP备2022033375号" target="_blank" rel="noopener" href="https://beian.miit.gov.cn/">京ICP备2022033375号 </a></p></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>