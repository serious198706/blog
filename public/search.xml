<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>透读源码之 OkHttp</title>
      <link href="/2023-03-14/okhttp/"/>
      <url>/2023-03-14/okhttp/</url>
      
        <content type="html"><![CDATA[<p>做 Android 开发的同学们几乎没有不知道 OkHttp 这个网络请求库的了。这个库可以帮我们完成几乎所有类型的、涵盖几乎所有需求的网络请求。</p><p>它与大家耳熟能详的 LeakCanary、Retrofit 一样来自大名鼎鼎的 <a href="https://square.github.io/">Square 公司</a>，截至本文写下时，该库在 Github 上已有 43.7k 的 Start 数量。</p><span id="more"></span><h3 id="一、OkHttp-解决了什么问题"><a href="#一、OkHttp-解决了什么问题" class="headerlink" title="一、OkHttp 解决了什么问题"></a>一、OkHttp 解决了什么问题</h3><p>从库的名字不难看出，OkHttp 解决的是网络问题。在 Android 开发中，网络问题自古以来便是开发者比较头疼的问题。</p><p>在互联网时代，几乎没有任何应用可以完全脱离互联网使用，良好的网络通信设计，对衡量一款 APP 的质量来说，无疑是尤为重要的加分项。</p><p>在上古时期(🙅‍♂️)，Android 开发者们还在使用 <code>HttpUrlConnection</code> 来实现网络请求，不必引入三方代码，原始且简单。但也正是因为原始，一些高级功能就要自己实现。甚至在 Android2.2 之前还有 Bug，需要禁用连接池以正常使用 inputstream，所以 Google 接下来引入了 <code>HttpClient</code>。它解决了一些使用和维护上的问题，但这个库饱受开发者和维护者诟病，其属于 Apache 组织，API 复杂多变，并且不易扩展，所以被 Google 弃之敝屣。</p><p>于是一个易用、可维护、可拓展、稳定性高的网络请求库在此时就应运而生。它就是 OkHttp。</p><p>OkHttp 针对的不只是 Android，它对 Java 程序也有封装，其实从根本上来说，它是一个基于传输层（还记得网络的7层架构吗？）实现应用层协议的网络框架，而不仅是一个 Http 请求的库。</p><p>目前来说，很多公司都已经在使用 OkHttp 当做默认的网络请求库，一些著名的三方库也已经默认使用 OkHttp 来做网络请求，你在集成它的同时，它也会默默地帮你把 OkHttp 集成进项目中。</p><p>总的来说，OkHttp 解决的，就是网络开发中的各种 API 使用繁琐、可定制可拓展性不高、高级功能要自己造轮子的问题。</p><p>按照官方文档来看，它还提供了连接池，实现 GZIP 格式传输，重复请求的缓存等。并且新版的 OkHttp 已经支持 TLS1.3 协议(<a href="https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E6%80%A7%E5%8D%94%E5%AE%9A">神马是TLS？</a>)，以及多 IP 地址轮询功能。OkHttp 提供丰富又简易的 API，支付同步/异步的调用，并且有着完善的回调机制供开发者使用。</p><h3 id="二、代码结构"><a href="#二、代码结构" class="headerlink" title="二、代码结构"></a>二、代码结构</h3><p>本文以 OkHttp 5.0.0-SNAPSHOT 代码做为示例。</p><p>Clone 一下 OkHttp 的源码，可以看到 OkHttp 的 module 有很多，如下图所示：</p><p><img src="/img/okhttp-1.png"></p><p>我们依次简单介绍一下各个 module。</p><ol><li><code>buildSrc</code>: 项目打包时的一些脚本，可以略过。</li><li><code>logging-interceptor</code>: 日志拦截器。负责记录网络请求和返回内容并打印日志，帮助记录与排查问题。使用方法如下：</li></ol><pre><code class="groovy">    implementation(&quot;com.squareup.okhttp3:logging-interceptor:4.10.0&quot;)</code></pre><pre><code class="kotlin">    val logging = HttpLoggingInterceptor()    logging.setLevel(HttpLoggingInterceptor.Level.BASIC)    val client = OkHttpClient.Builder()        .addInterceptor(logging)        .build()</code></pre><ol start="3"><li><code>mockwebserver(3/3-juni4/3-junit5)</code>: 模拟服务器，一般用于本地的模拟 API 请求测试，针对不同的 junit 版本做出了适配。使用方法如下：</li></ol><pre><code class="groovy">    testImplementation(&quot;com.squareup.okhttp3:mockwebserver:4.10.0&quot;)</code></pre><pre><code class="kotlin">    @Throws(Exception::class)    fun test() &#123;        // 创建 MokWebServer 的实例。每个单元测试都可以创建不同的实例。        val server = MockWebServer()        // 计划一些回应消息        server.enqueue(MockResponse(body = &quot;hello, world!&quot;))        server.enqueue(MockResponse(body = &quot;sup, bra?&quot;))        server.enqueue(MockResponse(body = &quot;yo dog&quot;))        // 启动服务        server.start()        val baseUrl: okhttp3.HttpUrl = server.url(&quot;/v1/chat/&quot;)        // 模拟请求        val chat = Chat(baseUrl)        chat.loadMore()        assertEquals(&quot;hello, world!&quot;, chat.messages())        chat.loadMore()        chat.loadMore()        assertEquals(        &quot;&quot;&quot;            hello, world!            sup, bra?            yo dog            &quot;&quot;&quot;.trimIndent(), chat.messages()        )        // 可选：确定你的应用请求了正确路径        val request1 = server.takeRequest()        assert(&quot;/v1/chat/messages/&quot; == request1.path)        assert(request1.getHeader(&quot;Authorization&quot;) != null)        val request2 = server.takeRequest()        assert(&quot;/v1/chat/messages/2&quot; == request2.path)        val request3 = server.takeRequest()        assert(&quot;/v1/chat/messages/3&quot; == request3.path)        // 关闭服务        server.shutdown()    &#125;</code></pre><p>这部分代码我们在之后会再进行介绍。</p><ol start="4"><li><code>okcurl</code>: 一些测试指令。</li><li><code>okhttp</code>: 核心代码，同时包含一些测试，是我们主要要阅读的部分。我们会在后面详细阅读。</li><li><code>okhttp-android</code>: 针对 Android 系统增加的一些文件，主要是一些 Extension 方法，以及 Android 上的 DNS 解析器。</li><li><code>okhttp-bom</code>: 针对 Gradle 的<a href="https://docs.gradle.org/6.2/userguide/platforms.html#sub:bom_import">BOM(Bill-of-Materials)</a>特性的编译脚本，能够让 gradle 支持如下写法：</li></ol><pre><code class="groovy">    dependencies &#123;       // define a BOM and its version       implementation(platform(&quot;com.squareup.okhttp3:okhttp-bom:4.10.0&quot;))       // define any required OkHttp artifacts without version       implementation(&quot;com.squareup.okhttp3:okhttp&quot;)       implementation(&quot;com.squareup.okhttp3:logging-interceptor&quot;)    &#125;</code></pre><ol start="8"><li><code>okhttp-brotli</code>: 使用 <a href="https://github.com/google/brotli">Brotli 压缩算法</a> 制作的拦截器。主要用来实现网络传输中的 GZip 压缩。它依赖了 brotli 库。使用方法如下：</li></ol><pre><code class="groovy">    implementation(&quot;com.squareup.okhttp3:okhttp-brotli:4.10.0&quot;)</code></pre><pre><code class="kotlin">    val client = OkHttpClient.Builder()        .addInterceptor(BrotliInterceptor.INSTANCE)        .build() </code></pre><ol start="9"><li><code>okhttp-coroutines</code>: 该 module 用来支持 Kotlin 的协程。</li><li><code>okhttp-dnsoverhttps</code>: 对 <a href="https://zh.wikipedia.org/wiki/DNS_over_HTTPS">DNS over HTTPS</a> 的实现。</li><li><code>okhttp-hpacktests</code>: 一些测试，用来验证 OkHttp 对于 HPACK 功能的实现。</li><li><code>okhttp-sse</code>: 实验性功能，可以接受服务端发送的事件。本质上是添加了 <code>Accept:text/event-stream</code> 的 Header 来实现的。但目前也只是实验性功能，实现方式随时可能变化。</li><li><code>okhttp-testing-support</code>: 供 OkHttp 工程内部使用的测试用例。</li><li><code>okhttp-tls</code>: 提供了一些让开发者可以使用 TLS 功能的 API。如 <a href="https://square.github.io/okhttp/4.x/okhttp-tls/okhttp3.tls/-held-certificate/">HeldCertificate</a> 和 <a href="https://square.github.io/okhttp/4.x/okhttp-tls/okhttp3.tls/-handshake-certificates/">HandshakeCertificate</a>。</li><li><code>okhttp-urlconnection</code>: 从 <code>java.net</code> 包中集成了 <code>Authenticator</code> 和 <code>CookieHandler</code>。主要用于测试。</li><li><code>samples</code>: 一些使用例子。初次使用建议先从 Samples 看起，可以了解一些初级用法和高级用法。但大多数时候，官网的教程足以涵盖绝大多数需求。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 三方库 </tag>
            
            <tag> OkHttp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>透读源码之开篇</title>
      <link href="/2023-03-14/thesourcecode/"/>
      <url>/2023-03-14/thesourcecode/</url>
      
        <content type="html"><![CDATA[<p>在开发中，学会如何写出优质的代码很重要，学会使用三方库也很重要，但更重要的，是研习别人写代码的方式，然后从中学到些什么。</p><p>现在就业竞争环境相当激烈，自己没点本事，还真的没法拿捏住各种奇葩的面试官，面试官最喜欢问的问题就是：<strong>你读过哪些开源库的源代码呢？</strong></p><p>他们在问这个问题的时候，在考验你技术水平的同时，也在看，你是否有自主学习的动力，是否能阅读一个体系完善的结构性的代码，是否能理解并转化成自己的知识并使用。</p><p>那么，阅读开源代码就尤其重要，无论是拿来充实自己，还是拿来震慑(bushi)面试官，都是一把利器。</p><span id="more"></span><p>我们读源码时，最主要的基本方向是这三个：</p><ol><li>它解决了什么问题</li><li>针对特定的问题，它是如何解决的</li><li>它有哪些闪光点是值得我们学习的</li></ol><p>简单讲一下这三个方向。</p><h3 id="1-这个库解决了什么问题"><a href="#1-这个库解决了什么问题" class="headerlink" title="1. 这个库解决了什么问题"></a>1. 这个库解决了什么问题</h3><p>显页易见，每个轮子被制造出来，就是为了解决某个问题，我们需要知道的，就是这个库<strong>主要</strong>解决了什么问题，<strong>顺带</strong>解决了什么问题，如此一来，就可以带着疑问去读代码。</p><p>拿 <a href="https://bumptech.github.io/glide/">Glide</a> 这个著名的图片加载库来举个例子。</p><h4 id="Glide-主要解决了什么问题？"><a href="#Glide-主要解决了什么问题？" class="headerlink" title="Glide 主要解决了什么问题？"></a>Glide 主要解决了什么问题？</h4><p>从 Glide 的官方文档来看，它是一个快速、高效的图片加载库，并且提供了简洁易用的 API 供开发者调用。在保证性能的同时，还提供了高拓展性的图片解码管道（decode pipeline）。它甚至可以拉取和解码视频的缩略图，展示 GIF 图片，并支持网络请求拦截器。如果你喜欢，你甚至可以将它的网络请求部分替换成 Volley 或者 OkHttp。</p><p>Glide 的<strong>主要</strong>目标在于让列表中的图片滑动起来不卡顿，但它也<strong>同时</strong>能帮你解决图片加载时的其他问题，比如本地图片加载、远程拉取加载、裁剪等等。</p><pre><code>可以看到，这个阶段的内容主要来自于库的官方文档。</code></pre><h4 id="Glide-是如何实现它的主要目标的？"><a href="#Glide-是如何实现它的主要目标的？" class="headerlink" title="Glide 是如何实现它的主要目标的？"></a>Glide 是如何实现它的主要目标的？</h4><p>我们知道，开发时的大部分时间，图片加载都可以使用 <code>imageView.setImageResource(resId)</code> 或者 <code>imageView.setImageBitmap(bitmap)</code> 来搞定，那 Glide 究竟做了些什么，来替代这两句代码呢？</p><pre><code>通过读源码，我相信我们一定能找到这个问题的答案。此处不赘述，后面会有详细的文章。</code></pre><h4 id="Glide-是如何实现它的次要目标的？"><a href="#Glide-是如何实现它的次要目标的？" class="headerlink" title="Glide 是如何实现它的次要目标的？"></a>Glide 是如何实现它的次要目标的？</h4><p>先不提本地图片加载，远程图片加载其实令我们很头痛，图片下载、图片保存、图片缓存、大小适配、错误重试、断点续传。。。每一个都是我们需要考虑的问题。</p><p>那么在保证性能的前提下，Glide 是如何解决这些次要的问题的呢？</p><pre><code>还是要通过阅读源代码，来找到这个问题的答案。此处亦不赘述，后面会有详细的文章。</code></pre><h3 id="2-针对上述几个问题的方式，它的解决方式是什么。"><a href="#2-针对上述几个问题的方式，它的解决方式是什么。" class="headerlink" title="2. 针对上述几个问题的方式，它的解决方式是什么。"></a>2. 针对上述几个问题的方式，它的解决方式是什么。</h3><p>主要问题是，解决列表图片滑动不卡顿的问题，在读源码的过程中，我们可以轻易地发现 <code>RequestBuilder</code>、<code>RequestManager</code> 这样的管理模块，将所有图片的加载变为一个个的请求，进行调度与管理，从而让每一次图片的加载与展示变得有序且高效。</p><p>次要问题我们举其中一个例子——缓存。Glide 使用了<strong>四级缓存</strong>来完成缓存功能，活动资源(Active Resources)、内存缓存(Memory Cache)、资源缓存(Resource)、数据文件缓存(Data)。每增加一级缓存，都会让加载图片的速度有一个保障，同样地，也必须要设计好代码的架构，否则有可能会弄巧成拙。</p><h3 id="3-Glide-源码中有什么闪光点值得我们学习吗？"><a href="#3-Glide-源码中有什么闪光点值得我们学习吗？" class="headerlink" title="3. Glide 源码中有什么闪光点值得我们学习吗？"></a>3. Glide 源码中有什么闪光点值得我们学习吗？</h3><p>有，当然有。Glide 运用了大量的工厂模式及Builder模式，是我们平时可能不太会用到，但是用起来就会事半功倍的一些开发技巧。</p><p>通过上面的三个大问题，基本就可以将源码拆解并读明白。</p><p>在读源码时，我们不要急于纠结各种细节，可以以先整体后局部的思路去读，太过纠结细节反面会阻挡你的脚步，也许在读到某个地方的时候，你突然就能明白刚才的某个困扰你的点是怎么搞定的了。</p><p>那么，我们《透读源码》系列的开山之作，就由此拉开序幕，大家鼓掌！！</p><p>最后附上《透读源码》系列的目录，方便快速查看。</p><ul><li><a href="/2023-03-14/okhttp">透读源码之 OkHttp</a></li><li><a href="/glide">透读源码之 Glide</a></li><li><a href="/retrofit">透读源码之 Retrofit</a></li><li><a href="/activitymanager">透读源码之 ActivityManager</a></li><li><a href="/leakcanary">透读源码之 LeakCanary</a></li></ul><p><code>return 0;</code></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 三方库 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter 为什么这么丝滑？</title>
      <link href="/2023-01-31/flutter-intro/"/>
      <url>/2023-01-31/flutter-intro/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.aliyun.com/article/651005">Flutter之禅 内存优化篇</a><br><a href="https://juejin.im/collection/5db25bcff265da06a19a304e">Flutter 完整实战详解</a><br><a href="https://github.com/flutter/flutter">flutter 源码</a><br><a href="https://www.jianshu.com/p/b56531850655">埋点</a><br><a href="https://www.jianshu.com/u/cf5c0e4b1111">闲鱼技术</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于 Leak Canary</title>
      <link href="/2023-01-31/leakcanary/"/>
      <url>/2023-01-31/leakcanary/</url>
      
        <content type="html"><![CDATA[<blockquote><p>“A small leak will sink a great ship.” - Benjamin Franklin</p></blockquote><p>这篇文章来讲讲著名的第三方内存泄漏检测工具 - LeakCanary。</p><blockquote><p>注：本文源代码基于 leakcanary-android:2.3</p></blockquote><span id="more"></span><p>LeakCanary 的使用非常简单，我们一笔带过：</p><pre><code>dependencies &#123;  // debugImplementation because LeakCanary should only run in debug builds.  debugImplementation &#39;com.squareup.leakcanary:leakcanary-android:2.3&#39;&#125;</code></pre><p>配置完 gradle 依赖后，任何代码都不用写，就能直接生效。</p><p>神奇吗？神奇就对了。</p><p>官方文档上提到，LeakCanary 能够自动检测下面几种对象：</p><ul><li>销毁之后的 Activity 实例</li><li>销毁之后的 Fragment 实例</li><li>销毁之后的 Fragment View 实例</li><li>清除之后的 ViewModel 实例</li></ul><p>在这几种行为发生后，LeanCanary 会做四个步骤来帮助我们分析是否有内存泄漏：</p><ol><li>检查是否有被保留下的对象</li><li>Dump Heap</li><li>分析 HPROF 文件</li><li>对泄漏的部分进行分类</li></ol><p>我们来按步骤分析分析它的源码，看它究竟是如何做到的。</p><h2 id="检查要被保留的对象"><a href="#检查要被保留的对象" class="headerlink" title="检查要被保留的对象"></a>检查要被保留的对象</h2><p>LeanCanary 会监测 Android 组件（并不是全部）的生命周期，在它们销毁的时候，会检测它们是否出现了内存泄漏。</p><p>这些对象会被传递到一个 ObjectWatcher 类，它使用 WeakReference 来持有这些实例。当然，你也可以使用这个类来自己观察某个对象是否出现了泄漏。</p><p>它的代码如下所示：</p><pre><code class="kotlin">/** * [ObjectWatcher] can be passed objects to [watch]. It will create [KeyedWeakReference] instances * that reference watches objects, and check if those references have been cleared as expected on * the [checkRetainedExecutor] executor. If not, these objects are considered retained and * [ObjectWatcher] will then notify the [onObjectRetainedListener] on that executor thread. * * [checkRetainedExecutor] is expected to run its tasks on a background thread, with a significant * to give the GC the opportunity to identify weakly reachable objects. * * [ObjectWatcher] is thread safe. */// Thread safe by locking on all methods, which is reasonably efficient given how often// these methods are accessed.class ObjectWatcher constructor(  private val clock: Clock,  private val checkRetainedExecutor: Executor,  /**   * Calls to [watch] will be ignored when [isEnabled] returns false   */  private val isEnabled: () -&gt; Boolean = &#123; true &#125;) &#123;  private val onObjectRetainedListeners = mutableSetOf&lt;OnObjectRetainedListener&gt;()  /**   * References passed to [watch].   */  private val watchedObjects = mutableMapOf&lt;String, KeyedWeakReference&gt;()  private val queue = ReferenceQueue&lt;Any&gt;()  ...  /**   * Returns the objects that are currently considered retained. Useful for logging purposes.   * Be careful with those objects and release them ASAP as you may creating longer lived leaks   * then the one that are already there.   */  val retainedObjects: List&lt;Any&gt;    @Synchronized get() &#123;      removeWeaklyReachableObjects()      val instances = mutableListOf&lt;Any&gt;()      for (weakReference in watchedObjects.values) &#123;        if (weakReference.retainedUptimeMillis != -1L) &#123;          val instance = weakReference.get()          if (instance != null) &#123;            instances.add(instance)          &#125;        &#125;      &#125;      return instances    &#125;  ...  /**   * Watches the provided [watchedObject].   *   * @param description Describes why the object is watched.   */  @Synchronized fun watch(    watchedObject: Any,    description: String  ) &#123;    if (!isEnabled()) &#123;      return    &#125;    removeWeaklyReachableObjects()    val key = UUID.randomUUID()        .toString()    val watchUptimeMillis = clock.uptimeMillis()    val reference =      KeyedWeakReference(watchedObject, key, description, watchUptimeMillis, queue)    SharkLog.d &#123;      &quot;Watching &quot; +          (if (watchedObject is Class&lt;*&gt;) watchedObject.toString() else &quot;instance of $&#123;watchedObject.javaClass.name&#125;&quot;) +          (if (description.isNotEmpty()) &quot; ($description)&quot; else &quot;&quot;) +          &quot; with key $key&quot;    &#125;    watchedObjects[key] = reference    checkRetainedExecutor.execute &#123;      moveToRetained(key)    &#125;  &#125;  ...&#125;</code></pre><p>可以看到，ObjectWatcher 内部有这么几个重要的东西：</p><ul><li><code>onObjectRetainedListeners</code>，使用者可以手动添加 OnObjectRetainedListener，当有对象被保留时，可以接收到回调；</li><li><code>watchedObjects</code>，持有对要观察的对象的 WeakReference。可以看到 LeakCanary 使用了 KeyedWeakReference，它是 WeakReference 的子类，添加了一个字段用于保存对象被观测的时长；</li><li><code>queue</code>，<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ref/ReferenceQueue.html">ReferenceQueue</a>，这是 Java 中的特性，当内存中对象的可达性发生变化时，GC 会将变化的对象添加到这个队列中；</li><li><code>retainedObjects</code>，可能会发生内存泄漏的对象就保存在这个 List 中，供后续分析使用。</li></ul><p>默认情况下，LeakCanary 会将应用中的 Activity、Fragment 等组件注册到 ObjectWatcher 中，那么问题来了，是在何时注册的？</p><p>通过扒拉代码，我发现了位于 leakcanary/internal/ 中的这个类：AppWatcherInstaller。我们看一下它的代码：</p><pre><code class="kotlin">/** * Content providers are loaded before the application class is created. [AppWatcherInstaller] is * used to install [leakcanary.AppWatcher] on application start. */internal sealed class AppWatcherInstaller : ContentProvider() &#123;  ...  override fun onCreate(): Boolean &#123;    val application = context!!.applicationContext as Application    InternalAppWatcher.install(application)    return true  &#125;  ...&#125;</code></pre><p>厉害了，利用了 Content Provider 会早于 Application 类加载的这个特性，在 <code>onCreate()</code> 方法中调用了 <code>InternalAppWatcher.install()</code> 方法进行初始化的工作：</p><pre><code class="kotlin">internal object InternalAppWatcher &#123;  private val onAppWatcherInstalled: (Application) -&gt; Unit  ...  init &#123;    val internalLeakCanary = try &#123;      val leakCanaryListener = Class.forName(&quot;leakcanary.internal.InternalLeakCanary&quot;)      leakCanaryListener.getDeclaredField(&quot;INSTANCE&quot;).get(null)    &#125; catch (ignored: Throwable) &#123;      NoLeakCanary    &#125;    @kotlin.Suppress(&quot;UNCHECKED_CAST&quot;)    onAppWatcherInstalled = internalLeakCanary as (Application) -&gt; Unit  &#125;  ...  val objectWatcher = ObjectWatcher(      clock = clock,      checkRetainedExecutor = checkRetainedExecutor,      isEnabled = &#123; AppWatcher.config.enabled &#125;  )  fun install(application: Application) &#123;    SharkLog.logger = DefaultCanaryLog()    checkMainThread()    if (this::application.isInitialized) &#123;      return    &#125;    InternalAppWatcher.application = application    val configProvider = &#123; AppWatcher.config &#125;    ActivityDestroyWatcher.install(application, objectWatcher, configProvider)    FragmentDestroyWatcher.install(application, objectWatcher, configProvider)    onAppWatcherInstalled(application)  &#125;  ...  private fun checkMainThread() &#123;    if (Looper.getMainLooper().thread !== Thread.currentThread()) &#123;      throw UnsupportedOperationException(          &quot;Should be called from the main thread, not $&#123;Thread.currentThread()&#125;&quot;      )    &#125;  &#125;  ...&#125;</code></pre><p><code>InternalAppWatcher.install()</code> 方法中，首先检查了当前代码是否运行在主线程上，如果不是，则抛出异常；然后分别调用了 ActivityDestroyWatcher 和 FragmentDestroyWatcher 的 <code>install()</code> 方法，当这些事情都做完后，用了一个秀儿的方法，给 <code>internalLeakCanary</code> 这个成员变量赋值。</p><p><img src="https://s3.ax1x.com/2020/12/11/rAhsB9.md.jpg"></p><p>来看 ActivityDestroyWatcher：</p><pre><code class="kotlin">internal class ActivityDestroyWatcher private constructor(  private val objectWatcher: ObjectWatcher,  private val configProvider: () -&gt; Config) &#123;  private val lifecycleCallbacks =    object : Application.ActivityLifecycleCallbacks by noOpDelegate() &#123;      override fun onActivityDestroyed(activity: Activity) &#123;        if (configProvider().watchActivities) &#123;          objectWatcher.watch(              activity, &quot;$&#123;activity::class.java.name&#125; received Activity#onDestroy() callback&quot;          )        &#125;      &#125;    &#125;  companion object &#123;    fun install(      application: Application,      objectWatcher: ObjectWatcher,      configProvider: () -&gt; Config    ) &#123;      val activityDestroyWatcher = ActivityDestroyWatcher(objectWatcher, configProvider)      application.registerActivityLifecycleCallbacks(activityDestroyWatcher.lifecycleCallbacks)    &#125;  &#125;&#125;</code></pre><p>它的功能非常简单，直接创建 ActivityDestroyWatcher 的实例，并利用 Application 中的 ActivityLifecycleCallbacks 接口，接收 Activity 的 <code>onActivityDestroyed()</code> 回调，然后将 Activity 交给 ObjectWatcher。</p><blockquote><p>kotlin 中的 by 一般用于实现委托机制，在这里的功能相当于可以省略掉其他的回调的代码。<br>noOpDelegate 的代码如下：</p><pre><code class="kotlin">inline fun &lt;reified T : Any&gt; noOpDelegate(): T &#123;    val javaClass = T::class.java    val noOpHandler = InvocationHandler &#123; _, _, _ -&gt;      // no op    &#125;    return Proxy.newProxyInstance(        javaClass.classLoader, arrayOf(javaClass), noOpHandler    ) as T  &#125;</code></pre></blockquote><p>FragmentDestroyWatcher 稍微复杂一些：</p><pre><code class="kotlin">internal object FragmentDestroyWatcher &#123;  private const val ANDROIDX_FRAGMENT_CLASS_NAME = &quot;androidx.fragment.app.Fragment&quot;  private const val ANDROIDX_FRAGMENT_DESTROY_WATCHER_CLASS_NAME = &quot;leakcanary.internal.AndroidXFragmentDestroyWatcher&quot;  // Using a string builder to prevent Jetifier from changing this string to Android X Fragment  @Suppress(&quot;VariableNaming&quot;, &quot;PropertyName&quot;)  private val ANDROID_SUPPORT_FRAGMENT_CLASS_NAME = StringBuilder(&quot;android.&quot;).append(&quot;support.v4.app.Fragment&quot;).toString()  private const val ANDROID_SUPPORT_FRAGMENT_DESTROY_WATCHER_CLASS_NAME = &quot;leakcanary.internal.AndroidSupportFragmentDestroyWatcher&quot;  fun install(    application: Application,    objectWatcher: ObjectWatcher,    configProvider: () -&gt; AppWatcher.Config  ) &#123;    val fragmentDestroyWatchers = mutableListOf&lt;(Activity) -&gt; Unit&gt;()    if (SDK_INT &gt;= O) &#123;      fragmentDestroyWatchers.add(          AndroidOFragmentDestroyWatcher(objectWatcher, configProvider)      )    &#125;    getWatcherIfAvailable(        ANDROIDX_FRAGMENT_CLASS_NAME,        ANDROIDX_FRAGMENT_DESTROY_WATCHER_CLASS_NAME,        objectWatcher,        configProvider    )?.let &#123;      fragmentDestroyWatchers.add(it)    &#125;    getWatcherIfAvailable(        ANDROID_SUPPORT_FRAGMENT_CLASS_NAME,        ANDROID_SUPPORT_FRAGMENT_DESTROY_WATCHER_CLASS_NAME,        objectWatcher,        configProvider    )?.let &#123;      fragmentDestroyWatchers.add(it)    &#125;    if (fragmentDestroyWatchers.size == 0) &#123;      return    &#125;    application.registerActivityLifecycleCallbacks(object : Application.ActivityLifecycleCallbacks by noOpDelegate() &#123;      override fun onActivityCreated(activity: Activity, savedInstanceState: Bundle?) &#123;        for (watcher in fragmentDestroyWatchers) &#123;          watcher(activity)        &#125;      &#125;    &#125;)  &#125;  private fun getWatcherIfAvailable(    fragmentClassName: String,    watcherClassName: String,    objectWatcher: ObjectWatcher,    configProvider: () -&gt; AppWatcher.Config  ): ((Activity) -&gt; Unit)? &#123;    return if (classAvailable(fragmentClassName) &amp;&amp;        classAvailable(watcherClassName)    ) &#123;      val watcherConstructor = Class.forName(watcherClassName)          .getDeclaredConstructor(ObjectWatcher::class.java, Function0::class.java)      @Suppress(&quot;UNCHECKED_CAST&quot;)      watcherConstructor.newInstance(objectWatcher, configProvider) as (Activity) -&gt; Unit    &#125; else &#123;      null    &#125;  &#125;  private fun classAvailable(className: String): Boolean &#123;    return try &#123;      Class.forName(className)      true    &#125; catch (e: Throwable) &#123;      // e is typically expected to be a ClassNotFoundException      // Unfortunately, prior to version 25.0.2 of the support library the      // FragmentManager.FragmentLifecycleCallbacks class was a non static inner class.      // Our AndroidSupportFragmentDestroyWatcher class is compiled against the static version of      // the FragmentManager.FragmentLifecycleCallbacks class, leading to the      // AndroidSupportFragmentDestroyWatcher class being rejected and a NoClassDefFoundError being      // thrown here. So we&#39;re just covering our butts here and catching everything, and assuming      // any throwable means &quot;can&#39;t use this&quot;. See https://github.com/square/leakcanary/issues/1662      false    &#125;  &#125;&#125;</code></pre><p>对 Fragment 的监控是主要采用了两个类：<code>leakcanary.internal.AndroidXFragmentDestroyWatcher</code> 和 <code>leakcanary.internal.AndroidSupportFragmentDestroyWatcher</code>。这两个类的实现方式相同，都是 lambda 表达式，我们只看其中一个：</p><pre><code class="kotlin">internal class AndroidXFragmentDestroyWatcher(  private val objectWatcher: ObjectWatcher,  private val configProvider: () -&gt; Config) : (Activity) -&gt; Unit &#123;  private val fragmentLifecycleCallbacks = object : FragmentManager.FragmentLifecycleCallbacks() &#123;    override fun onFragmentCreated(      fm: FragmentManager,      fragment: Fragment,      savedInstanceState: Bundle?    ) &#123;      ViewModelClearedWatcher.install(fragment, objectWatcher, configProvider)    &#125;    override fun onFragmentViewDestroyed(      fm: FragmentManager,      fragment: Fragment    ) &#123;      val view = fragment.view      if (view != null &amp;&amp; configProvider().watchFragmentViews) &#123;        objectWatcher.watch(            view, &quot;$&#123;fragment::class.java.name&#125; received Fragment#onDestroyView() callback &quot; +            &quot;(references to its views should be cleared to prevent leaks)&quot;        )      &#125;    &#125;    override fun onFragmentDestroyed(      fm: FragmentManager,      fragment: Fragment    ) &#123;      if (configProvider().watchFragments) &#123;        objectWatcher.watch(            fragment, &quot;$&#123;fragment::class.java.name&#125; received Fragment#onDestroy() callback&quot;        )      &#125;    &#125;  &#125;  override fun invoke(activity: Activity) &#123;    if (activity is FragmentActivity) &#123;      val supportFragmentManager = activity.supportFragmentManager      supportFragmentManager.registerFragmentLifecycleCallbacks(fragmentLifecycleCallbacks, true)      ViewModelClearedWatcher.install(activity, objectWatcher, configProvider)    &#125;  &#125;&#125;</code></pre><p>利用了 FragmentManager 中的 FragmentLifecycleCallbacks 接口实现了对 Fragment 生命周期的监听，同时还对 ViewModel 的销毁事件做了监听。</p><p>当 Activity 走完自己的 <code>onDestroy()</code> 方法后，Watcher 中的 watch() 方法会被执行（上方代码），然后，利用了 Executor （注意，该 Executor 是在主线程上跑的）开始执行<code>moveToRetained(key)</code>代码：</p><pre><code class="kotlin">@Synchronized private fun moveToRetained(key: String) &#123;  removeWeaklyReachableObjects()  val retainedRef = watchedObjects[key]  if (retainedRef != null) &#123;    retainedRef.retainedUptimeMillis = clock.uptimeMillis()    onObjectRetainedListeners.forEach &#123; it.onObjectRetained() &#125;  &#125;&#125;</code></pre><p>首先移除了所有在 GC 后依旧有可达性的对象，如果全部都移除了，<code>retainedRef</code> 就是 <code>null</code>，则不会触发回调，证明没有内存泄漏；如果移除不了，说明有内存泄漏，开始进行下一步：Dump Heap。</p><h2 id="Dump-Heap"><a href="#Dump-Heap" class="headerlink" title="Dump Heap"></a>Dump Heap</h2><p>书接上文，Watcher 开始回调所有的 <code>onObjectRetainedListeners</code>。这些 Listeners 是在何时被添加的呢？</p><p>我们回到初始化的部分，也即<code>InternalAppWatcher.install()</code>，其中有这样的代码：</p><pre><code class="kotlin">init &#123;    val internalLeakCanary = try &#123;      val leakCanaryListener = Class.forName(&quot;leakcanary.internal.InternalLeakCanary&quot;)      leakCanaryListener.getDeclaredField(&quot;INSTANCE&quot;).get(null)    &#125; catch (ignored: Throwable) &#123;      NoLeakCanary    &#125;    @kotlin.Suppress(&quot;UNCHECKED_CAST&quot;)    onAppWatcherInstalled = internalLeakCanary as (Application) -&gt; Unit  &#125;</code></pre><p>当 <code>onAppWatcherInstalled</code> 这个 Lambda 表达式被执行时，<code>leakcanary.internal.InternalLeakCanary</code> 这个类会被初始化，我们看一下这个类：</p><pre><code class="kotlin">internal object InternalLeakCanary : (Application) -&gt; Unit, OnObjectRetainedListener &#123;  private lateinit var heapDumpTrigger: HeapDumpTrigger  lateinit var application: Application  override fun invoke(application: Application) &#123;    this.application = application    checkRunningInDebuggableBuild()    AppWatcher.objectWatcher.addOnObjectRetainedListener(this)    val heapDumper = AndroidHeapDumper(application, leakDirectoryProvider)    val gcTrigger = GcTrigger.Default    val configProvider = &#123; LeakCanary.config &#125;    val handlerThread = HandlerThread(LEAK_CANARY_THREAD_NAME)    handlerThread.start()    val backgroundHandler = Handler(handlerThread.looper)    heapDumpTrigger = HeapDumpTrigger(        application, backgroundHandler, AppWatcher.objectWatcher, gcTrigger, heapDumper,        configProvider    )    application.registerVisibilityListener &#123; applicationVisible -&gt;      this.applicationVisible = applicationVisible      heapDumpTrigger.onApplicationVisibilityChanged(applicationVisible)    &#125;    registerResumedActivityListener(application)    addDynamicShortcut(application)    disableDumpHeapInTests()  &#125;  ...  override fun onObjectRetained() &#123;    if (this::heapDumpTrigger.isInitialized) &#123;      heapDumpTrigger.onObjectRetained()    &#125;  &#125;  fun onDumpHeapReceived(forceDump: Boolean) &#123;    if (this::heapDumpTrigger.isInitialized) &#123;      heapDumpTrigger.onDumpHeapReceived(forceDump)    &#125;  &#125;  ...&#125;</code></pre><p>好家伙，我 TM 直接好家伙，这居然又是个 Lambda 表达式，话不多说，直接看 <code>invoke()</code> 回调部分中，有 <code>AppWatcher.objectWatcher.addOnObjectRetainedListener(this)</code> 这样一句，将自己做为被回调方添加到了 watcher 中，那么上面的 <code>onObjectRetainedListener</code> 就找到了实现者。</p><p>可以看到，调用了 <code>heapDumpTrigger.onObjectRetained()</code> 方法，我们去看看这里做了什么。</p><pre><code class="kotlin">fun onObjectRetained() &#123;    scheduleRetainedObjectCheck(        reason = &quot;found new object retained&quot;,        rescheduling = false    )&#125;</code></pre><p>可以看到只是很简单地调用了 <code>scheduleRetainedObjectCheck()</code> 方法：</p><pre><code class="kotlin">private fun scheduleRetainedObjectCheck(  reason: String,  rescheduling: Boolean,  delayMillis: Long = 0L) &#123;  val checkCurrentlyScheduledAt = checkScheduledAt  if (checkCurrentlyScheduledAt &gt; 0) &#123;    val scheduledIn = checkCurrentlyScheduledAt - SystemClock.uptimeMillis()    SharkLog.d &#123; &quot;Ignoring request to check for retained objects ($reason), already scheduled in $&#123;scheduledIn&#125;ms&quot; &#125;    return  &#125; else &#123;    val verb = if (rescheduling) &quot;Rescheduling&quot; else &quot;Scheduling&quot;    val delay = if (delayMillis &gt; 0) &quot; in $&#123;delayMillis&#125;ms&quot; else &quot;&quot;    SharkLog.d &#123; &quot;$verb check for retained objects$&#123;delay&#125; because $reason&quot; &#125;  &#125;  checkScheduledAt = SystemClock.uptimeMillis() + delayMillis  backgroundHandler.postDelayed(&#123;    checkScheduledAt = 0    checkRetainedObjects(reason)  &#125;, delayMillis)&#125;</code></pre><p>记录了时间戳之后，开始在子线程中执行 <code>checkRetainedObjects(reason)</code> 方法：</p><pre><code class="kotlin">private fun checkRetainedObjects(reason: String) &#123;  ...  val now = SystemClock.uptimeMillis()  val elapsedSinceLastDumpMillis = now - lastHeapDumpUptimeMillis  if (elapsedSinceLastDumpMillis &lt; WAIT_BETWEEN_HEAP_DUMPS_MILLIS) &#123;    onRetainInstanceListener.onEvent(DumpHappenedRecently)    showRetainedCountNotification(        objectCount = retainedReferenceCount,        contentText = application.getString(R.string.leak_canary_notification_retained_dump_wait)    )    scheduleRetainedObjectCheck(        reason = &quot;previous heap dump was $&#123;elapsedSinceLastDumpMillis&#125;ms ago (&lt; $&#123;WAIT_BETWEEN_HEAP_DUMPS_MILLIS&#125;ms)&quot;,        rescheduling = true,        delayMillis = WAIT_BETWEEN_HEAP_DUMPS_MILLIS - elapsedSinceLastDumpMillis    )    return  &#125;  SharkLog.d &#123; &quot;Check for retained objects found $retainedReferenceCount objects, dumping the heap&quot; &#125;  dismissRetainedCountNotification()  dumpHeap(retainedReferenceCount, retry = true)  ...&#125;</code></pre><p>首次运行时，<code>lastHeapDumpUptimeMillis</code> 为 <code>0</code>，所以代码会执行到 <code>dumpHeap(retainedReferenceCount, retry = true)</code>，而后续执行时，如果两次执行的间隔过小（60秒），则直接展示通知，不再 dump heap。</p><pre><code class="kotlin">private fun dumpHeap(retainedReferenceCount: Int, retry: Boolean) &#123;  saveResourceIdNamesToMemory()  val heapDumpUptimeMillis = SystemClock.uptimeMillis()  KeyedWeakReference.heapDumpUptimeMillis = heapDumpUptimeMillis  val heapDumpFile = heapDumper.dumpHeap()  if (heapDumpFile == null) &#123;    if (retry) &#123;      SharkLog.d &#123; &quot;Failed to dump heap, will retry in $WAIT_AFTER_DUMP_FAILED_MILLIS ms&quot; &#125;      scheduleRetainedObjectCheck(          reason = &quot;failed to dump heap&quot;,          rescheduling = true,          delayMillis = WAIT_AFTER_DUMP_FAILED_MILLIS      )    &#125; else &#123;      SharkLog.d &#123; &quot;Failed to dump heap, will not automatically retry&quot; &#125;    &#125;    showRetainedCountNotification(        objectCount = retainedReferenceCount,        contentText = application.getString(            R.string.leak_canary_notification_retained_dump_failed        )    )    return  &#125;  lastDisplayedRetainedObjectCount = 0  lastHeapDumpUptimeMillis = SystemClock.uptimeMillis()  objectWatcher.clearObjectsWatchedBefore(heapDumpUptimeMillis)  HeapAnalyzerService.runAnalysis(application, heapDumpFile)&#125;</code></pre><p>可以看到，这里关键的一步是 <code>heapDumper.dumpHeap()</code> 方法，这里 dump 出来的内存数据会直接供后面的 HeapAnalyzerService 使用。此处的 <code>heapDumper</code> 是一个 AndroidHeapDumper 的实例，我们看一下它的代码：</p><pre><code class="kotlin">internal class AndroidHeapDumper(  context: Context,  private val leakDirectoryProvider: LeakDirectoryProvider) : HeapDumper &#123;  private val context: Context = context.applicationContext  private val mainHandler: Handler = Handler(Looper.getMainLooper())  override fun dumpHeap(): File? &#123;    val heapDumpFile = leakDirectoryProvider.newHeapDumpFile() ?: return null    val waitingForToast = FutureResult&lt;Toast?&gt;()    showToast(waitingForToast)    if (!waitingForToast.wait(5, SECONDS)) &#123;      SharkLog.d &#123; &quot;Did not dump heap, too much time waiting for Toast.&quot; &#125;      return null    &#125;    val notificationManager =      context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager    if (Notifications.canShowNotification) &#123;      val dumpingHeap = context.getString(R.string.leak_canary_notification_dumping)      val builder = Notification.Builder(context)          .setContentTitle(dumpingHeap)      val notification = Notifications.buildNotification(context, builder, LEAKCANARY_LOW)      notificationManager.notify(R.id.leak_canary_notification_dumping_heap, notification)    &#125;    val toast = waitingForToast.get()    return try &#123;      Debug.dumpHPROFData(heapDumpFile.absolutePath)      if (heapDumpFile.length() == 0L) &#123;        SharkLog.d &#123; &quot;Dumped heap file is 0 byte length&quot; &#125;        null      &#125; else &#123;        heapDumpFile      &#125;    &#125; catch (e: Exception) &#123;      SharkLog.d(e) &#123; &quot;Could not dump heap&quot; &#125;      // Abort heap dump      null    &#125; finally &#123;      cancelToast(toast)      notificationManager.cancel(R.id.leak_canary_notification_dumping_heap)    &#125;  &#125;  private fun showToast(waitingForToast: FutureResult&lt;Toast?&gt;) &#123;    mainHandler.post(Runnable &#123;      val resumedActivity = InternalLeakCanary.resumedActivity      if (resumedActivity == null) &#123;        waitingForToast.set(null)        return@Runnable      &#125;      val toast = Toast(resumedActivity)      val iconSize = resumedActivity.resources.getDimensionPixelSize(          R.dimen.leak_canary_toast_icon_size      )      toast.setGravity(Gravity.CENTER_VERTICAL, 0, -iconSize)      toast.duration = Toast.LENGTH_LONG      // Inflating with application context: https://github.com/square/leakcanary/issues/1385      val inflater = LayoutInflater.from(context)      toast.view = inflater.inflate(R.layout.leak_canary_heap_dump_toast, null)      toast.show()      val toastIcon = toast.view.findViewById&lt;View&gt;(R.id.leak_canary_toast_icon)      toastIcon.translationY = -iconSize.toFloat()      toastIcon          .animate()          .translationY(0f)          .setListener(object : AnimatorListenerAdapter() &#123;            override fun onAnimationEnd(animation: Animator) &#123;              waitingForToast.set(toast)            &#125;          &#125;)    &#125;)  &#125;  private fun cancelToast(toast: Toast?) &#123;    if (toast == null) &#123;      return    &#125;    mainHandler.post &#123; toast.cancel() &#125;  &#125;&#125;</code></pre><p>dump 的过程比较简单，可以分为四步：</p><ol><li>创建一个 HPROF 文件，用于存储内存信息；</li><li>展示一个通知方便开发者点击察看；</li><li>展示一个 toast 告诉开发者有内存泄漏并请等待；</li><li>调用 <code>Debug.dumpHPROFData()</code> 方法写入文件。</li></ol><p><code>Debug.dumpHPROFData()</code> 方法是 Android 提供的一个方法，会将 HPROF 信息存储到指定的路径中，同时可能会引起一次 GC。</p><p>生成 HPROF 文件之后，就来到了重头戏，第三步——分析 HPROF 文件。</p><h2 id="分析-HPROF-文件"><a href="#分析-HPROF-文件" class="headerlink" title="分析 HPROF 文件"></a>分析 HPROF 文件</h2><p>上面提到了，分析 HPROF 文件使用的是 HeapAnalyzerService 这个服务，我们来看一下它的实现方法。</p><p>HeapAnalyzerService 本质上是一个 IntentService，它继承自 leakcanary.internal.ForegoundService，而 ForegroundService 又继承自 IntentService。</p><pre><code class="kotlin">internal class HeapAnalyzerService : ForegroundService(    HeapAnalyzerService::class.java.simpleName,    R.string.leak_canary_notification_analysing,    R.id.leak_canary_notification_analyzing_heap), OnAnalysisProgressListener &#123;    override fun onHandleIntentInForeground(intent: Intent?) &#123;    if (intent == null || !intent.hasExtra(HEAPDUMP_FILE_EXTRA)) &#123;      SharkLog.d &#123; &quot;HeapAnalyzerService received a null or empty intent, ignoring.&quot; &#125;      return    &#125;    // Since we&#39;re running in the main process we should be careful not to impact it.    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND)    val heapDumpFile = intent.getSerializableExtra(HEAPDUMP_FILE_EXTRA) as File    val config = LeakCanary.config    val heapAnalysis = if (heapDumpFile.exists()) &#123;      analyzeHeap(heapDumpFile, config)    &#125; else &#123;      missingFileFailure(heapDumpFile)    &#125;    onAnalysisProgress(REPORTING_HEAP_ANALYSIS)    config.onHeapAnalyzedListener.onHeapAnalyzed(heapAnalysis)  &#125;  ...  companion object &#123;    private const val HEAPDUMP_FILE_EXTRA = &quot;HEAPDUMP_FILE_EXTRA&quot;    private const val PROGUARD_MAPPING_FILE_NAME = &quot;leakCanaryObfuscationMapping.txt&quot;    fun runAnalysis(      context: Context,      heapDumpFile: File    ) &#123;      val intent = Intent(context, HeapAnalyzerService::class.java)      intent.putExtra(HEAPDUMP_FILE_EXTRA, heapDumpFile)      startForegroundService(context, intent)    &#125;    private fun startForegroundService(      context: Context,      intent: Intent    ) &#123;      if (SDK_INT &gt;= 26) &#123;        context.startForegroundService(intent)      &#125; else &#123;        // Pre-O behavior.        context.startService(intent)      &#125;    &#125;  &#125;&#125;</code></pre><p>在调用了 <code>HeapAnalyzerService.runAnalysis()</code> 方法之后，就启动了这个前台服务，最终会调用回 <code>onHandleIntentInForeground()</code> 方法，紧接着，在调低进程优先级后，调用了 <code>analyzeHeap()</code> 方法；</p><pre><code class="kotlin">private fun analyzeHeap(  heapDumpFile: File,  config: Config): HeapAnalysis &#123;  val heapAnalyzer = HeapAnalyzer(this)  val proguardMappingReader = try &#123;    ProguardMappingReader(assets.open(PROGUARD_MAPPING_FILE_NAME))  &#125; catch (e: IOException) &#123;    null  &#125;  return heapAnalyzer.analyze(      heapDumpFile = heapDumpFile,      leakingObjectFinder = config.leakingObjectFinder,      referenceMatchers = config.referenceMatchers,      computeRetainedHeapSize = config.computeRetainedHeapSize,      objectInspectors = config.objectInspectors,      metadataExtractor = config.metadataExtractor,      proguardMapping = proguardMappingReader?.readProguardMapping()  )&#125;</code></pre><p>此处新建了 HeapAnalyzer 的实例并进行 HPROF 文件的处理。</p><p>Leakcanary 在分析 HPROF 文件方面进行了一次变革，之前使用的是第三方库 <a href="https://github.com/square/haha">HAHA</a>，后来又着手开发了自己的库叫 <a href="https://square.github.io/leakcanary/shark/">Shark</a>。接下来就开始使用到自己的 Shark 库了，HeapAnalyzer 就是这个库中的类。</p><pre><code class="kotlin">class HeapAnalyzer constructor(  private val listener: OnAnalysisProgressListener) &#123;  ...  /**   * Searches the heap dump for leaking instances and then computes the shortest strong reference   * path from those instances to the GC roots.   */  fun analyze(    heapDumpFile: File,    leakingObjectFinder: LeakingObjectFinder,    referenceMatchers: List&lt;ReferenceMatcher&gt; = emptyList(),    computeRetainedHeapSize: Boolean = false,    objectInspectors: List&lt;ObjectInspector&gt; = emptyList(),    metadataExtractor: MetadataExtractor = MetadataExtractor.NO_OP,    proguardMapping: ProguardMapping? = null  ): HeapAnalysis &#123;    ...    return try &#123;      listener.onAnalysisProgress(PARSING_HEAP_DUMP)      Hprof.open(heapDumpFile)          .use &#123; hprof -&gt;            val graph = HprofHeapGraph.indexHprof(hprof, proguardMapping)            val helpers = FindLeakInput(graph, referenceMatchers, computeRetainedHeapSize, objectInspectors)            helpers.analyzeGraph(                metadataExtractor, leakingObjectFinder, heapDumpFile, analysisStartNanoTime            )          &#125;    &#125; catch (exception: Throwable) &#123;      HeapAnalysisFailure(          heapDumpFile, System.currentTimeMillis(), since(analysisStartNanoTime),          HeapAnalysisException(exception)      )    &#125;  &#125;&#125;</code></pre><p>在这篇文章中就不具体展开 Shark 对于 HPROF 文件的解析了，有空单开一篇文章讲一讲。</p><p>总之，在分析完 HRPOF 文件后，返回分析结果，并交给 <code>config.onHeapAnalyzedListener.onHeapAnalyzed(heapAnalysis)</code>。</p><p>这个 Config 有必要提一下，它是个贯穿始终的角色，里面存储了 N 多的全局变量，是一个 data 类，开发者可以使用 <code>copy()</code> 方法修改 Leakcanary 的默认配置，或者自定义解析器、各种 Listener 等等。此处的 <code>onHeapAnalyzedListener</code> 是在 config 中已经被预定义好的：</p><pre><code class="kotlin">/**  * Called on a background thread when the heap analysis is complete.  * If you want leaks to be added to the activity that lists leaks, make sure to delegate  * calls to a [DefaultOnHeapAnalyzedListener].  *  * Defaults to [DefaultOnHeapAnalyzedListener]  */val onHeapAnalyzedListener: OnHeapAnalyzedListener = DefaultOnHeapAnalyzedListener.create(),</code></pre><p>我们看一下它的 <code>onHeapAnalyzed()</code> 方法：</p><pre><code class="kotlin">class DefaultOnHeapAnalyzedListener(private val application: Application) : OnHeapAnalyzedListener &#123;  private val mainHandler = Handler(Looper.getMainLooper())  override fun onHeapAnalyzed(heapAnalysis: HeapAnalysis) &#123;    SharkLog.d &#123; &quot;$heapAnalysis&quot; &#125;    val id = LeaksDbHelper(application).writableDatabase.use &#123; db -&gt;      HeapAnalysisTable.insert(db, heapAnalysis)    &#125;    val (contentTitle, screenToShow) = when (heapAnalysis) &#123;      is HeapAnalysisFailure -&gt; application.getString(          R.string.leak_canary_analysis_failed      ) to HeapAnalysisFailureScreen(id)      is HeapAnalysisSuccess -&gt; &#123;        val retainedObjectCount = heapAnalysis.allLeaks.sumBy &#123; it.leakTraces.size &#125;        val leakTypeCount = heapAnalysis.applicationLeaks.size + heapAnalysis.libraryLeaks.size        application.getString(            R.string.leak_canary_analysis_success_notification, retainedObjectCount, leakTypeCount        ) to HeapDumpScreen(id)      &#125;    &#125;    if (InternalLeakCanary.formFactor == TV) &#123;      showToast(heapAnalysis)      printIntentInfo()    &#125; else &#123;      showNotification(screenToShow, contentTitle)    &#125;  &#125;&#125;</code></pre><p>不考虑我们是 TV 的情况，会展示一个通知：</p><pre><code class="kotlin">private fun showNotification(  screenToShow: Screen,  contentTitle: String) &#123;  val pendingIntent = LeakActivity.createPendingIntent(      application, arrayListOf(HeapDumpsScreen(), screenToShow)  )  val contentText = application.getString(R.string.leak_canary_notification_message)  Notifications.showNotification(      application, contentTitle, contentText, pendingIntent,      R.id.leak_canary_notification_analysis_result,      LEAKCANARY_MAX  )&#125;</code></pre><p>点击这个通知，就会进入 LeakActivity。LeakActivity 就会完整展示内存泄漏的 Reference 路径，方便开发者查找问题。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 源码解析 </tag>
            
            <tag> leakcanary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 Android 动画的一切</title>
      <link href="/2023-01-31/android-animation/"/>
      <url>/2023-01-31/android-animation/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 启动过程分析</title>
      <link href="/2023-01-31/android-boot/"/>
      <url>/2023-01-31/android-boot/</url>
      
        <content type="html"><![CDATA[<p>难道你不好奇 Android 系统是怎样启动的吗？</p><span id="more"></span><p>我们都知道，Android 是基于 Linux 系统的，但是由于 Android 属于嵌入式设备，并没有像 PC 那样的 BIOS 程序。 取而代之的是 Bootloader —— <strong>系统启动加载器</strong>。 它类似于 BIOS，在系统加载前，用以<strong>初始化硬件设备</strong>，<strong>建立内存空间的映像图</strong>，为最终<strong>调用系统内核</strong>准备好环境。 在 Android 里没有硬盘，而是 ROM，它类似于硬盘存放操作系统，用户程序等。 ROM 跟硬盘一样也会划分为不同的区域，用于放置不同的程序，在 Android 中主要划分为一下几个分区：</p><ul><li>/boot：存放引导程序，包括内核和内存操作程序</li><li>/system：相当于电脑c盘，存放Android系统及系统应用</li><li>/recovery：恢复分区，可以进入该分区进行系统恢复</li><li>/data：用户数据区，包含了用户的数据：联系人、短信、设置、用户安装的程序</li><li>/cache：安卓系统缓存区，保存系统最常访问的数据和应用程序</li><li>/misc：包含一些杂项内容，如系统设置和系统功能启用禁用设置</li><li>/sdcard：用户自己的存储区，可以存放照片，音乐，视频等文件</li></ul><p>那么，Bootloader 是如何被加载的呢？跟 PC 启动过程类似，当开机通电时首先会加载 Bootloader，Bootloader 回读取 ROM 找到操作系统并将 Linux 内核加载到 RAM 中。</p><p>下图是一个 Android 系统启动的流程图：</p><p><img src="/img/68.png"></p><p>当 Linux 内核启动后会初始化各种软硬件环境，加载驱动程序，挂载根文件系统，Linux 内核加载的最后阶段会启动执行第一个用户空间进程 init 进程。</p><h2 id="init-进程"><a href="#init-进程" class="headerlink" title="init 进程"></a>init 进程</h2><p><img src="/img/69.png"></p><p>init 是 Linux 系统中用户空间的第一个进程(pid=1)，Kernel 启动后会调用 /system/core/init/Init.cpp 的<code>main()</code>方法。<br>首先初始化 Kernel log，创建一块共享的内存空间，加载 /default.prop 文件，解析 init.rc 文件。</p><h3 id="init-rc-文件"><a href="#init-rc-文件" class="headerlink" title="init.rc 文件"></a>init.rc 文件</h3><p>init.rc 文件是 Android 系统的重要配置文件，位于 /system/core/rootdir/ 目录中。 主要功能是定义了系统启动时需要执行的一系列 action 及执行特定动作、设置环境变量和属性和执行特定的 service。</p><p>init.rc 脚本文件配置了一些重要的服务，init 进程通过创建子进程启动这些服务，这里创建的 service 都属于 native 服务，运行在 Linux 空间，通过 socket 向上层提供特定的服务，并以守护进程的方式运行在后台。</p><p>通过 init.rc 脚本系统启动了以下几个重要的服务：</p><ul><li>service_manager：启动 binder IPC，管理所有的 Android 系统服务</li><li>mountd：设备安装 Daemon，负责设备安装及状态通知</li><li>debuggerd：启动 debug system，处理调试进程的请求</li><li>rild：启动 radio interface layer daemon 服务，处理电话相关的事件和请求</li><li>media_server：启动 AudioFlinger，MediaPlayerService 和 CameraService，负责多媒体播放相关的功能，包括音视频解码</li><li>surface_flinger：启动 SurfaceFlinger 负责显示输出</li><li>zygote：进程孵化器，启动 Android Java VMRuntime 和启动 systemserver，负责 Android 应用进程的孵化工作</li></ul><p>在这个阶段你可以在设备的屏幕上看到 “Android” logo 了。</p><p>以上工作执行完，init 进程就会进入 loop 状态。</p><h2 id="service-manager-进程"><a href="#service-manager-进程" class="headerlink" title="service_manager 进程"></a>service_manager 进程</h2><p>ServiceManager 是 Binder IPC 通信过程中的守护进程，本身也是一个 Binder 服务。ServiceManager 进程主要是启动 Binder，提供服务的查询和注册。</p><h2 id="surface-flinger-进程"><a href="#surface-flinger-进程" class="headerlink" title="surface_flinger 进程"></a>surface_flinger 进程</h2><p>SurfaceFlinger 负责图像绘制，是应用 UI 的基础，其功能是合成所有 Surface 并渲染到显示设备。SurfaceFlinger 进程主要是启动 FrameBuffer，初始化显示系统。</p><h2 id="media-server-进程"><a href="#media-server-进程" class="headerlink" title="media_server 进程"></a>media_server 进程</h2><p>MediaServer 进程主要是启动 AudioFlinger 音频服务，CameraService 相机服务。负责处理音频解析播放，相机相关的处理。</p><h2 id="Zygote-进程"><a href="#Zygote-进程" class="headerlink" title="Zygote 进程"></a>Zygote 进程</h2><p>Zygote 进程孵化了所有的 Android 应用进程，是 Android Framework 的基础，该进程的启动也标志着 Framework 框架初始化启动的开始。</p><p>Zygote 服务进程的主要功能：</p><ul><li>注册底层功能的 JNI 函数到虚拟机</li><li>预加载 Java 类和资源</li><li>fork 并启动 system_server 核心进程</li><li>作为守护进程监听处理“孵化新进程”的请求</li><li>当 Zygote 进程启动后, 便会执行到 frameworks/base/cmds/app_process/App_main.cpp 文件的<code>main()</code>方法</li></ul><p>然后 Zygote 进程会进入 loop 状态，等待下次 fork 进程。</p><h2 id="system-server-进程"><a href="#system-server-进程" class="headerlink" title="system_server 进程"></a>system_server 进程</h2><p>system_server 进程 由 Zygote 进程 fork 而来。接下来看下 system_server 启动过程。</p><p><a href="https://android.googlesource.com/platform/frameworks/base/+/master/services/java/com/android/server/SystemServer.java">查看SystemServer.java全部代码</a></p><pre><code class="java">//首先会调用 ZygoteInit.startSystemServer() 方法ZygoteInit.startSystemServer()  //fork 子进程 system_server，进入 system_server 进程。ZygoteInit.handleSystemServerProcess()  //设置当前进程名为“system_server”，创建 PathClassLoader 类加载器。RuntimeInit.zygoteInit()    //重定向 log 输出，通用的初始化（设置默认异常捕捉方法，时区等），初始化 Zygote -&gt; nativeZygoteInit()。nativeZygoteInit()  //方法经过层层调用，会进入 app_main.cpp 中的 onZygoteInit() 方法。app_main::onZygoteInit()// 启动新 Binder 线程。applicationInit()   //方法经过层层调用，会抛出异常 ZygoteInit.MethodAndArgsCaller(m, argv), ZygoteInit.main() 会捕捉该异常。ZygoteInit.main()   //开启 DDMS 功能，preload() 加载资源，预加载 OpenGL，调用 SystemServer.main() 方法。SystemServer.main() //先初始化 SystemServer 对象，再调用对象的 run() 方法。SystemServer.run()  //准备主线程 looper，加载 android_servers.so 库，该库包含的源码在 frameworks/base/services/ 目录下。</code></pre><p>system_server 进程启动后将初始化系统上下文（设置主题），创建系统服务管理 SystemServiceManager，然后启动各种系统服务：</p><pre><code class="java">startBootstrapServices(); // 启动引导服务//该方法主要启动服务 ActivityManagerService，PowerManagerService，LightsService，DisplayManagerService，PackageManagerService，UserManagerService。//设置 ActivityManagerService，启动传感器服务。startCoreServices();      // 启动核心服务//该方法主要//启动服务 BatteryService 用于统计电池电量，需要 LightService。//启动服务 UsageStatsService，用于统计应用使用情况。//启动服务 WebViewUpdateService。startOtherServices();     // 启动其他服务//该方法主要启动服务 InputManagerService，WindowManagerService。//等待 ServiceManager，SurfaceFlinger启动完成，然后显示启动界面。//启动服务 StatusBarManagerService，//准备好 window, power, package, display 服务：//    - WindowManagerService.systemReady()//    - PowerManagerService.systemReady()//    - PackageManagerService.systemReady()//    - DisplayManagerService.systemReady()</code></pre><p>所有的服务启动完成后会注册到 ServiceManager。<br>ActivityManagerService 服务启动完成后，会进入<code>ActivityManagerService.systemReady()</code>，然后启动 SystemUI，WebViewFactory，Watchdog，最后启动桌面 Launcher App。</p><p>最后会进入循环<code>Looper.loop()</code>。</p><h2 id="ActivityManagerService-启动"><a href="#ActivityManagerService-启动" class="headerlink" title="ActivityManagerService 启动"></a>ActivityManagerService 启动</h2><p>启动桌面 Launcher App 需要等待 ActivityManagerService 启动完成。我们来看下 ActivityManagerService 启动过程。</p><pre><code class="java">ActivityManagerService(Context) //创建名为“ActivityManager”的前台线程，并获取mHandler。//通过 UiThread 类，创建名为“android.ui”的线程。//创建前台广播和后台广播接收器。//创建目录 /data/system。//创建服务 BatteryStatsService。ActivityManagerService.start()  //启动电池统计服务，创建 LocalService，并添加到 LocalServices。ActivityManagerService.startOtherServices() -&gt; installSystemProviders()//安装所有的系统 Provider。ActivityManagerService.systemReady()//恢复最近任务栏的 task。//启动 WebView，SystemUI，开启 Watchdog，启动桌面 Launcher App。//发送系统广播。</code></pre><p>启动桌面 Launcher App，首先会通过 Zygote 进程 fork 一个新进程作为 App 进程，然后创建 Application，创建启动 Activity，最后用户才会看到桌面。</p><h2 id="完整启动过程"><a href="#完整启动过程" class="headerlink" title="完整启动过程"></a>完整启动过程</h2><p><img src="/img/70.png"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于懒加载</title>
      <link href="/2023-01-31/lazy-load/"/>
      <url>/2023-01-31/lazy-load/</url>
      
        <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5adcb0e36fb9a07aa7673fbc"></a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 开发技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 Instrumentation</title>
      <link href="/2023-01-31/instrumentation/"/>
      <url>/2023-01-31/instrumentation/</url>
      
        <content type="html"><![CDATA[<p>Instrumentation 的英文意思是『仪表』，但在 Android 中的功能可不是『仪表』。</p><span id="more"></span><p>它其实是 Android 系统里的一套控制方法，或者叫『钩子』。这些『钩子』可以在正常的生命周期（正常是由操作系统控制的)之外控制Android控件的运行，其实指的就是Instrumentation类提供的各种流程控制方法。我们看一点源码就知道了：</p><pre><code class="java">public class Instrumentation &#123;    private ActivityThread mThread = null;    private MessageQueue mMessageQueue = null;    private Context mInstrContext;    private Context mAppContext;    private ComponentName mComponent;    private Thread mRunner;    ...    public void callActivityOnCreate(Activity activity, Bundle icicle) &#123;        prePerformCreate(activity);        activity.performCreate(icicle);        postPerformCreate(activity);    &#125;    ...    public void callActivityOnResume(Activity activity) &#123;        activity.mResumed = true;        activity.onResume();                if (mActivityMonitors != null) &#123;            synchronized (mSync) &#123;                final int N = mActivityMonitors.size();                for (int i=0; i&lt;N; i++) &#123;                    final ActivityMonitor am = mActivityMonitors.get(i);                    am.match(activity, activity, activity.getIntent());                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><p>看起来像不像静态代理？</p><p><img src="http://img.doutula.com/production/uploads/image/2019/11/17/20191117993281_HImBdo.jpg"></p><p>它会在 Activity 的生命周期方法执行时加一个钩子，用来做一些监听的工作。</p><p>Activity 的实例也是由 Instrumentation 创建的，在 ActivityThread 中：</p><pre><code class="java">private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;    activity = mInstrumentation.newActivity(        cl, component.getClassName(), r.intent);&#125;</code></pre><p>Instumentation 说了，我创建的 Activity 实例，我要是不监听着点，那还不完蛋了。所以它一般用来进行测试，用来实现 Activity 生命周期钩子、获取 Activity 中的 View 等等。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于 MotionLayout</title>
      <link href="/2023-01-31/motionlayout/"/>
      <url>/2023-01-31/motionlayout/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 ListView 的渲染、缓存及优化</title>
      <link href="/2023-01-31/listview-optimization/"/>
      <url>/2023-01-31/listview-optimization/</url>
      
        <content type="html"><![CDATA[<p>ListView 优化是老生常谈的事情，虽然现在有 RycyclerView 可以完美替代 ListView，但是了解 ListView 的渲染、缓存及优化，也并不是什么坏事。</p><span id="more"></span><h2 id="ListView-与它的朋友们"><a href="#ListView-与它的朋友们" class="headerlink" title="ListView 与它的朋友们"></a>ListView 与它的朋友们</h2><p>ListView 继承自 AbsListView，AbsListView 继承自 AdapterView，AdapterView 继承自 ViewGroup，它们也有各自的派生类。它们的关系如下图所示：</p><p><img src="/img/listview-1589441712.png"></p><p>AdapterView 是一个抽象类，它一个可以由内部元素来决定如何展现的 ViewGroup。它内部包含了对内部 View 的管理和基本事件处理，比如<code>addView()</code>、<code>removeView()</code>、<code>setOnItemClickListener()</code>等等。</p><p>AbsListView 也是一个抽象类，它是被用来展示大量数据的一个基类，而且它并没有指定展示的样式，完全由派生类来实现，比如网格、列表、瀑布流等，完全由子类来决定展示的样式。它负责处理内部 View 的渲染、缓存、回收等。</p><h2 id="AbsListView"><a href="#AbsListView" class="headerlink" title="AbsListView"></a>AbsListView</h2><p>AbsListView 中有一个类，叫做 RecycleBin，意为回收站。我们看看它的注释：</p><blockquote><p>The RecycleBin facilitates reuse of views across layouts. The RecycleBin has two levels of storage: ActiveViews and ScrapViews. ActiveViews are those views which were onscreen at the start of a layout. By construction, they are displaying current information. At the end of layout, all views in ActiveViews are demoted to ScrapViews. ScrapViews are old views that could potentially be used by the adapter to avoid allocating views unnecessarily.</p></blockquote><p>机翻一下：回收站机制可以实现 View 的重用。回收站有两个级别的存储：活动的 View （ActiveViews）和废弃的 View（ScrapViews）。ActiveViews 是指在 layout 过程的开始时显示在屏幕上的 View。刚开始构建时，它们会显示当前的信息，在 layout 结束时，所有的 ActiveViews 会被降级为 ScrapViews。<strong>ScrapViews 是将来有可能会被 adater 重复利用的</strong>，所以为了避免被不必要的 View 重建，将它们缓存起来。</p><p>我们来简单看看它的代码：</p><pre><code class="java">class RecycleBin &#123;    @UnsupportedAppUsage    private RecyclerListener mRecyclerListener;    private int mFirstActivePosition;    private View[] mActiveViews = new View[0];    // 未排序的 View，可以被 adapter 当作 converter view 来使用    // 这里是一个包含 ArrayList 的数组，不同的 ViewType 会存储到不同的 ArrayList 中    private ArrayList&lt;View&gt;[] mScrapViews;    private int mViewTypeCount;    private ArrayList&lt;View&gt; mCurrentScrap;    private ArrayList&lt;View&gt; mSkippedScrap;    private SparseArray&lt;View&gt; mTransientStateViews;    private LongSparseArray&lt;View&gt; mTransientStateViewsById;    public void markChildrenDirty() &#123;        if (mViewTypeCount == 1) &#123;            final ArrayList&lt;View&gt; scrap = mCurrentScrap;            final int scrapCount = scrap.size();            for (int i = 0; i &lt; scrapCount; i++) &#123;                scrap.get(i).forceLayout();            &#125;        &#125; else &#123;            final int typeCount = mViewTypeCount;            for (int i = 0; i &lt; typeCount; i++) &#123;                final ArrayList&lt;View&gt; scrap = mScrapViews[i];                final int scrapCount = scrap.size();                for (int j = 0; j &lt; scrapCount; j++) &#123;                    scrap.get(j).forceLayout();                &#125;            &#125;        &#125;        if (mTransientStateViews != null) &#123;            final int count = mTransientStateViews.size();            for (int i = 0; i &lt; count; i++) &#123;                mTransientStateViews.valueAt(i).forceLayout();            &#125;        &#125;        if (mTransientStateViewsById != null) &#123;            final int count = mTransientStateViewsById.size();            for (int i = 0; i &lt; count; i++) &#123;                mTransientStateViewsById.valueAt(i).forceLayout();            &#125;        &#125;    &#125;    ...    // 清除 ScrapViews    @UnsupportedAppUsage    void clear() &#123;        ...    &#125;    // 将 AbsListView 中所有的 children 填充到 ActiveViews    // firstActivePosition 指的是第一个可见 view 被添加时在 mActiveView 数组中的 position    void fillActiveViews(int childCount, int firstActivePosition) &#123;        // 如果当前数组过小，则要新建一个数组        if (mActiveViews.length &lt; childCount) &#123;            mActiveViews = new View[childCount];        &#125;        // 记录外部（由 AbsListView 的派生类，如 ListView）传入的 firstActivePosition        mFirstActivePosition = firstActivePosition;        // 我没弄明白这里为什么要再新建一个数组变量指向 mActiveViews 内存        // 有明白的同学可以留言告诉我        final View[] activeViews = mActiveViews;        for (int i = 0; i &lt; childCount; i++) &#123;            View child = getChildAt(i);            AbsListView.LayoutParams lp = (AbsListView.LayoutParams) child.getLayoutParams();            // 莫要将 footer 和 header view 添加到 ScrapViews 中            if (lp != null &amp;&amp; lp.viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) &#123;                activeViews[i] = child;                // 记录位置，setupChild() 方法就不会将它的状态重置了，具体看下面的 setupChild() 方法                lp.scrappedFromPosition = firstActivePosition + i;            &#125;        &#125;    &#125;    // 获取 ActiveView，某个 ActiveView 被获取后，就会从 mActiveViews 中被移除    View getActiveView(int position) &#123;        int index = position - mFirstActivePosition;        final View[] activeViews = mActiveViews;        if (index &gt;=0 &amp;&amp; index &lt; activeViews.length) &#123;            final View match = activeViews[index];            activeViews[index] = null;            return match;        &#125;        return null;    &#125;    // 获取正在转变状态的 View    View getTransientStateView(int position) &#123;        if (mAdapter != null &amp;&amp; mAdapterHasStableIds &amp;&amp; mTransientStateViewsById != null) &#123;            long id = mAdapter.getItemId(position);            View result = mTransientStateViewsById.get(id);            mTransientStateViewsById.remove(id);            return result;        &#125;        if (mTransientStateViews != null) &#123;            final int index = mTransientStateViews.indexOfKey(position);            if (index &gt;= 0) &#123;                View result = mTransientStateViews.valueAt(index);                mTransientStateViews.removeAt(index);                return result;            &#125;        &#125;        return null;    &#125;    ...    // 获取 ScrapView，这些 View 们是未排序的    View getScrapView(int position) &#123;        // 根据位置获取 ViewType        final int whichScrap = mAdapter.getItemViewType(position);        if (whichScrap &lt; 0) &#123;            return null;        &#125;        // 如果只有一种 ViewType，那就直接获取        if (mViewTypeCount == 1) &#123;            return retrieveFromScrap(mCurrentScrap, position);        // 如果有多种 ViewType，那要从对应的 ScrapViews 列表中获取        &#125; else if (whichScrap &lt; mScrapViews.length) &#123;            return retrieveFromScrap(mScrapViews[whichScrap], position);        &#125;        return null;    &#125;    // 如果列表中的数据没有变化或者 adapter 有稳定的 ID，变化状态的 view 将会保留它们的状态以便后面获取    void addScrapView(View scrap, int position) &#123;        final AbsListView.LayoutParams lp = (AbsListView.LayoutParams) scrap.getLayoutParams();        // 无法回收，连个 LayoutParams 都没有        if (lp == null) &#123;            return;        &#125;        lp.scrappedFromPosition = position;        // 移除但不要将 header 或者 footer 废弃掉        final int viewType = lp.viewType;        if (!shouldRecycleViewType(viewType)) &#123;            // 无法回收。如果它不是 header 或者 footer 的话（它们有特殊的处理方式，应该被忽略），            // 就给它跳过，等回头把它 detach 掉。            if (viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) &#123;                // 加入 detach 列表                getSkippedScrap().add(scrap);            &#125;            return;        &#125;        // View 中的方法，用于将 View 中的 callback 等移除        scrap.dispatchStartTemporaryDetach();        notifyViewAccessibilityStateChangedIfNeeded(                AccessibilityEvent.CONTENT_CHANGE_TYPE_SUBTREE);        // 不要废弃掉瞬态的 View        final boolean scrapHasTransientState = scrap.hasTransientState();        if (scrapHasTransientState) &#123;            if (mAdapter != null &amp;&amp; mAdapterHasStableIds) &#123;                // If the adapter has stable IDs, we can reuse the view for                // the same data.                if (mTransientStateViewsById == null) &#123;                    mTransientStateViewsById = new LongSparseArray&lt;&gt;();                &#125;                mTransientStateViewsById.put(lp.itemId, scrap);            &#125; else if (!mDataChanged) &#123;                // If the data hasn&#39;t changed, we can reuse the views at                // their old positions.                if (mTransientStateViews == null) &#123;                    mTransientStateViews = new SparseArray&lt;&gt;();                &#125;                mTransientStateViews.put(position, scrap);            &#125; else &#123;                // Otherwise, we&#39;ll have to remove the view and start over.                clearScrapForRebind(scrap);                getSkippedScrap().add(scrap);            &#125;        &#125; else &#123;            clearScrapForRebind(scrap);            if (mViewTypeCount == 1) &#123;                mCurrentScrap.add(scrap);            &#125; else &#123;                mScrapViews[viewType].add(scrap);            &#125;            if (mRecyclerListener != null) &#123;                mRecyclerListener.onMovedToScrapHeap(scrap);            &#125;        &#125;    &#125;    private ArrayList&lt;View&gt; getSkippedScrap() &#123;        if (mSkippedScrap == null) &#123;            mSkippedScrap = new ArrayList&lt;&gt;();        &#125;        return mSkippedScrap;    &#125;    void removeSkippedScrap() &#123;        if (mSkippedScrap == null) &#123;            return;        &#125;        final int count = mSkippedScrap.size();        for (int i = 0; i &lt; count; i++) &#123;            removeDetachedView(mSkippedScrap.get(i), false);        &#125;        mSkippedScrap.clear();    &#125;    // 将 mActiveViews 中剩余的 View 移到 mScrapViews 中    void scrapActiveViews() &#123;        final View[] activeViews = mActiveViews;        final boolean hasListener = mRecyclerListener != null;        final boolean multipleScraps = mViewTypeCount &gt; 1;        ArrayList&lt;View&gt; scrapViews = mCurrentScrap;        final int count = activeViews.length;        for (int i = count - 1; i &gt;= 0; i--) &#123;            final View victim = activeViews[i];            if (victim != null) &#123;                final AbsListView.LayoutParams lp                        = (AbsListView.LayoutParams) victim.getLayoutParams();                final int whichScrap = lp.viewType;                activeViews[i] = null;                if (victim.hasTransientState()) &#123;                    // Store views with transient state for later use.                    victim.dispatchStartTemporaryDetach();                    if (mAdapter != null &amp;&amp; mAdapterHasStableIds) &#123;                        if (mTransientStateViewsById == null) &#123;                            mTransientStateViewsById = new LongSparseArray&lt;View&gt;();                        &#125;                        long id = mAdapter.getItemId(mFirstActivePosition + i);                        mTransientStateViewsById.put(id, victim);                    &#125; else if (!mDataChanged) &#123;                        if (mTransientStateViews == null) &#123;                            mTransientStateViews = new SparseArray&lt;View&gt;();                        &#125;                        mTransientStateViews.put(mFirstActivePosition + i, victim);                    &#125; else if (whichScrap != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) &#123;                        // The data has changed, we can&#39;t keep this view.                        removeDetachedView(victim, false);                    &#125;                &#125; else if (!shouldRecycleViewType(whichScrap)) &#123;                    // Discard non-recyclable views except headers/footers.                    if (whichScrap != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) &#123;                        removeDetachedView(victim, false);                    &#125;                &#125; else &#123;                    // Store everything else on the appropriate scrap heap.                    if (multipleScraps) &#123;                        scrapViews = mScrapViews[whichScrap];                    &#125;                    lp.scrappedFromPosition = mFirstActivePosition + i;                    removeDetachedView(victim, false);                    scrapViews.add(victim);                    if (hasListener) &#123;                        mRecyclerListener.onMovedToScrapHeap(victim);                    &#125;                &#125;            &#125;        &#125;        pruneScrapViews();    &#125;    // layout 过程的最后，所有暂时被 detach 掉的 View 要么应该被重新 attach，或者完全被 detach。这个方法能保证在    // scrap 列表中的所有 View 都被 detach 掉    void fullyDetachScrapViews() &#123;        final int viewTypeCount = mViewTypeCount;        final ArrayList&lt;View&gt;[] scrapViews = mScrapViews;        for (int i = 0; i &lt; viewTypeCount; ++i) &#123;            final ArrayList&lt;View&gt; scrapPile = scrapViews[i];            for (int j = scrapPile.size() - 1; j &gt;= 0; j--) &#123;                final View view = scrapPile.get(j);                if (view.isTemporarilyDetached()) &#123;                    removeDetachedView(view, false);                &#125;            &#125;        &#125;    &#125;    // 确保 scrap 列表的大小不要超过 active 列表的大小，因为有时 adapter 可能会不回收 view。    // 同时移除所有缓存的已经不再拥有瞬态的瞬态 view    private void pruneScrapViews() &#123;        final int maxViews = mActiveViews.length;        final int viewTypeCount = mViewTypeCount;        final ArrayList&lt;View&gt;[] scrapViews = mScrapViews;        for (int i = 0; i &lt; viewTypeCount; ++i) &#123;            final ArrayList&lt;View&gt; scrapPile = scrapViews[i];            int size = scrapPile.size();            while (size &gt; maxViews) &#123;                scrapPile.remove(--size);            &#125;        &#125;        final SparseArray&lt;View&gt; transViewsByPos = mTransientStateViews;        if (transViewsByPos != null) &#123;            for (int i = 0; i &lt; transViewsByPos.size(); i++) &#123;                final View v = transViewsByPos.valueAt(i);                if (!v.hasTransientState()) &#123;                    removeDetachedView(v, false);                    transViewsByPos.removeAt(i);                    i--;                &#125;            &#125;        &#125;        final LongSparseArray&lt;View&gt; transViewsById = mTransientStateViewsById;        if (transViewsById != null) &#123;            for (int i = 0; i &lt; transViewsById.size(); i++) &#123;                final View v = transViewsById.valueAt(i);                if (!v.hasTransientState()) &#123;                    removeDetachedView(v, false);                    transViewsById.removeAt(i);                    i--;                &#125;            &#125;        &#125;    &#125;    void reclaimScrapViews(List&lt;View&gt; views) &#123;        if (mViewTypeCount == 1) &#123;            views.addAll(mCurrentScrap);        &#125; else &#123;            final int viewTypeCount = mViewTypeCount;            final ArrayList&lt;View&gt;[] scrapViews = mScrapViews;            for (int i = 0; i &lt; viewTypeCount; ++i) &#123;                final ArrayList&lt;View&gt; scrapPile = scrapViews[i];                views.addAll(scrapPile);            &#125;        &#125;    &#125;    /**        * Updates the cache color hint of all known views.        *        * @param color The new cache color hint.        */    void setCacheColorHint(int color) &#123;        if (mViewTypeCount == 1) &#123;            final ArrayList&lt;View&gt; scrap = mCurrentScrap;            final int scrapCount = scrap.size();            for (int i = 0; i &lt; scrapCount; i++) &#123;                scrap.get(i).setDrawingCacheBackgroundColor(color);            &#125;        &#125; else &#123;            final int typeCount = mViewTypeCount;            for (int i = 0; i &lt; typeCount; i++) &#123;                final ArrayList&lt;View&gt; scrap = mScrapViews[i];                final int scrapCount = scrap.size();                for (int j = 0; j &lt; scrapCount; j++) &#123;                    scrap.get(j).setDrawingCacheBackgroundColor(color);                &#125;            &#125;        &#125;        // Just in case this is called during a layout pass        final View[] activeViews = mActiveViews;        final int count = activeViews.length;        for (int i = 0; i &lt; count; ++i) &#123;            final View victim = activeViews[i];            if (victim != null) &#123;                victim.setDrawingCacheBackgroundColor(color);            &#125;        &#125;    &#125;    private View retrieveFromScrap(ArrayList&lt;View&gt; scrapViews, int position) &#123;        final int size = scrapViews.size();        if (size &gt; 0) &#123;            // See if we still have a view for this position or ID.            // Traverse backwards to find the most recently used scrap view            for (int i = size - 1; i &gt;= 0; i--) &#123;                final View view = scrapViews.get(i);                final AbsListView.LayoutParams params =                        (AbsListView.LayoutParams) view.getLayoutParams();                if (mAdapterHasStableIds) &#123;                    final long id = mAdapter.getItemId(position);                    if (id == params.itemId) &#123;                        return scrapViews.remove(i);                    &#125;                &#125; else if (params.scrappedFromPosition == position) &#123;                    final View scrap = scrapViews.remove(i);                    clearScrapForRebind(scrap);                    return scrap;                &#125;            &#125;            final View scrap = scrapViews.remove(size - 1);            clearScrapForRebind(scrap);            return scrap;        &#125; else &#123;            return null;        &#125;    &#125;    private void clearScrap(final ArrayList&lt;View&gt; scrap) &#123;        final int scrapCount = scrap.size();        for (int j = 0; j &lt; scrapCount; j++) &#123;            removeDetachedView(scrap.remove(scrapCount - 1 - j), false);        &#125;    &#125;    private void clearScrapForRebind(View view) &#123;        view.clearAccessibilityFocus();        view.setAccessibilityDelegate(null);    &#125;    private void removeDetachedView(View child, boolean animate) &#123;        child.setAccessibilityDelegate(null);        AbsListView.this.removeDetachedView(child, animate);    &#125;&#125; </code></pre><p>这个类中比较重要的方法就是对于 View 当前状态的管理方法，有下面几个：</p><ul><li><code>fillActiveViews(int childCount, int firstActivePosition)</code>：这个方法会将 AbsListView 中所有的子 View 添加到 mActiveViews 数组中。<code>childCount</code>指子 View 的个数，<code>firstActivePosition</code>指第一个可见元素的 position。</li><li><code>getActiveView(int position)</code>：从<code>mActiveViews</code>中获取 View。当 View 被获取后，就会从<code>mActiveViews</code>中移除，再次访问就会返回<code>null</code>，这意味着 ActiveView 无法复用。</li><li><code>addScrapView(View view, int position)</code>：将 ScrapView 缓存到<code>mScrapViews</code>中。mScrapViews 是一个 ArrayList 数组，这个数组中按 ViewType 分类并存储，如果有3种 ViewType，数组中就会有3个 ArrayList。这些缓存都是无序的。</li><li><code>getScrapView(int position)</code>：从缓存中取出一个 View。</li></ul><p>AbsListView 也会有自己的 measure、layout、draw 过程，但是 draw 过程在 AbsListView 中没有实现，在 ListView 中也没有实现，也即它的绘制全部交给子 View 来做，我们只看它的<code>onMeasure()</code>和<code>onLayout</code>。</p><h3 id="AbsListView-的onMesaure"><a href="#AbsListView-的onMesaure" class="headerlink" title="AbsListView 的onMesaure()"></a>AbsListView 的<code>onMesaure()</code></h3><p>话不多说，我们直接看看它的代码：</p><pre><code class="java">@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;    // mSelector 是一个 Drawable，用来绘制 selector    if (mSelector == null) &#123;        useDefaultSelector();    &#125;    final Rect listPadding = mListPadding;    listPadding.left = mSelectionLeftPadding + mPaddingLeft;    listPadding.top = mSelectionTopPadding + mPaddingTop;    listPadding.right = mSelectionRightPadding + mPaddingRight;    listPadding.bottom = mSelectionBottomPadding + mPaddingBottom;    // Check if our previous measured size was at a point where we should scroll later.    if (mTranscriptMode == TRANSCRIPT_MODE_NORMAL) &#123;        final int childCount = getChildCount();        final int listBottom = getHeight() - getPaddingBottom();        final View lastChild = getChildAt(childCount - 1);        final int lastBottom = lastChild != null ? lastChild.getBottom() : listBottom;        mForceTranscriptScroll = mFirstPosition + childCount &gt;= mLastHandledItemCount &amp;&amp;                lastBottom &lt;= listBottom;    &#125;&#125;</code></pre><p>可见 measure 过程没什么特殊的，只是确定了一些 padding 值。</p><h3 id="AbsListView-的onLayout"><a href="#AbsListView-的onLayout" class="headerlink" title="AbsListView 的onLayout()"></a>AbsListView 的<code>onLayout()</code></h3><p>这个是 AbsListView 的重头戏。下面我们即将会讲到的 <strong>ListView 中是没有<code>onLayout</code>方法的</strong>，也就是说，它的 layout 过程，完全由父类 AbsListView 来实现。</p><pre><code class="java">/**    * Subclasses should NOT override this method but    *  &#123;@link #layoutChildren()&#125; instead.    */@Overrideprotected void onLayout(boolean changed, int l, int t, int r, int b) &#123;    super.onLayout(changed, l, t, r, b);    mInLayout = true;    final int childCount = getChildCount();    // 如果 AbsListView 的大小或 position 发生了变化，则要强制所有的子 View 重新 layout    if (changed) &#123;        for (int i = 0; i &lt; childCount; i++) &#123;            getChildAt(i).forceLayout();        &#125;        // 回收站将 ScrapViews 也全部执行 forceLayout        mRecycler.markChildrenDirty();    &#125;    // 让所有子 View 进行 layout 过程    layoutChildren();    mOverscrollMax = (b - t) / OVERSCROLL_LIMIT_DIVISOR;    // TODO: Move somewhere sane. This doesn&#39;t belong in onLayout().    if (mFastScroll != null) &#123;        mFastScroll.onItemCountChanged(getChildCount(), mItemCount);    &#125;    mInLayout = false;&#125;</code></pre><p>注释中我们看到：<strong>子类不要覆写这个方法，应该覆写<code>layoutChildren()</code>方法</strong>。待会我们会详解 ListView 对这个方法的覆写。</p><h2 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h2><p>ListView 继承了 AbsListView，并实现了自己的 measure、layout 过程</p><h3 id="ListView-的onMesaure"><a href="#ListView-的onMesaure" class="headerlink" title="ListView 的onMesaure()"></a>ListView 的<code>onMesaure()</code></h3><pre><code class="java">@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;    // Sets up mListPadding    super.onMeasure(widthMeasureSpec, heightMeasureSpec);    final int widthMode = MeasureSpec.getMode(widthMeasureSpec);    final int heightMode = MeasureSpec.getMode(heightMeasureSpec);    int widthSize = MeasureSpec.getSize(widthMeasureSpec);    int heightSize = MeasureSpec.getSize(heightMeasureSpec);    int childWidth = 0;    int childHeight = 0;    int childState = 0;    mItemCount = mAdapter == null ? 0 : mAdapter.getCount();    if (mItemCount &gt; 0 &amp;&amp; (widthMode == MeasureSpec.UNSPECIFIED            || heightMode == MeasureSpec.UNSPECIFIED)) &#123;        final View child = obtainView(0, mIsScrap);        // Lay out child directly against the parent measure spec so that        // we can obtain exected minimum width and height.        measureScrapChild(child, 0, widthMeasureSpec, heightSize);        childWidth = child.getMeasuredWidth();        childHeight = child.getMeasuredHeight();        childState = combineMeasuredStates(childState, child.getMeasuredState());        if (recycleOnMeasure() &amp;&amp; mRecycler.shouldRecycleViewType(                ((LayoutParams) child.getLayoutParams()).viewType)) &#123;            mRecycler.addScrapView(child, 0);        &#125;    &#125;    if (widthMode == MeasureSpec.UNSPECIFIED) &#123;        widthSize = mListPadding.left + mListPadding.right + childWidth +                getVerticalScrollbarWidth();    &#125; else &#123;        widthSize |= (childState &amp; MEASURED_STATE_MASK);    &#125;    if (heightMode == MeasureSpec.UNSPECIFIED) &#123;        heightSize = mListPadding.top + mListPadding.bottom + childHeight +                getVerticalFadingEdgeLength() * 2;    &#125;    if (heightMode == MeasureSpec.AT_MOST) &#123;        // TODO: after first layout we should maybe start at the first visible position, not 0        heightSize = measureHeightOfChildren(widthMeasureSpec, 0, NO_POSITION, heightSize, -1);    &#125;    // 调用 View 的 setMeasuredDimension 来保存测量结果    setMeasuredDimension(widthSize, heightSize);    mWidthMeasureSpec = widthMeasureSpec;&#125;</code></pre><p>由上面的代码可以看到，measure 过程比较简单，只是判断了一下目前自身设置的 MeasureSpec，来决定自身的大小。</p><h3 id="ListView-的layoutChildren"><a href="#ListView-的layoutChildren" class="headerlink" title="ListView 的layoutChildren()"></a>ListView 的<code>layoutChildren()</code></h3><p>上面说过了，ListView 不能覆写<code>onLayout()</code>方法，而是覆写<code>layoutChildren()</code>方法来对自身进行 layout 过程，我们来看看它的代码：</p><pre><code class="java">@Overrideprotected void layoutChildren() &#123;    // mBlockLayoutRequests 是 AdapterView 中的成员变量，用来标识当前是否正在 layout 过程中    final boolean blockLayoutRequests = mBlockLayoutRequests;    if (blockLayoutRequests) &#123;        return;    &#125;    mBlockLayoutRequests = true;    try &#123;        // 先调用 AbsListView 的 layoutChildren() 方法（虽然是未实现）        super.layoutChildren();        // 刷新，在 layout 完成之后调用 draw 过程        invalidate();        if (mAdapter == null) &#123;            resetList();            invokeOnItemScrollListener();            return;        &#125;        final int childrenTop = mListPadding.top;        final int childrenBottom = mBottom - mTop - mListPadding.bottom;        final int childCount = getChildCount();        int index = 0;        int delta = 0;        View sel;        View oldSel = null;        View oldFirst = null;        View newSel = null;        // 记录处于 select mode 的 item        switch (mLayoutMode) &#123;            case LAYOUT_SET_SELECTION:                index = mNextSelectedPosition - mFirstPosition;                if (index &gt;= 0 &amp;&amp; index &lt; childCount) &#123;                    newSel = getChildAt(index);                &#125;                break;            case LAYOUT_FORCE_TOP:            case LAYOUT_FORCE_BOTTOM:            case LAYOUT_SPECIFIC:            case LAYOUT_SYNC:                break;            case LAYOUT_MOVE_SELECTION:            default:                // Remember the previously selected view                index = mSelectedPosition - mFirstPosition;                if (index &gt;= 0 &amp;&amp; index &lt; childCount) &#123;                    oldSel = getChildAt(index);                &#125;                // Remember the previous first child                oldFirst = getChildAt(0);                if (mNextSelectedPosition &gt;= 0) &#123;                    delta = mNextSelectedPosition - mSelectedPosition;                &#125;                // Caution: newSel might be null                newSel = getChildAt(index + delta);        &#125;        // 如果在 layout 过程中 adapter 中的数据发生了变化        boolean dataChanged = mDataChanged;        if (dataChanged) &#123;            // AbsListView 中的方法，用来确定是哪条数据发生了改变            handleDataChanged();        &#125;        // 如果是空数据，就清除所有可见的 view，将各种数据全部重置，然后返回        if (mItemCount == 0) &#123;            resetList();            invokeOnItemScrollListener();            return;        &#125; else if (mItemCount != mAdapter.getCount()) &#123;            throw new IllegalStateException(&quot;The content of the adapter has changed but &quot;                    + &quot;ListView did not receive a notification. Make sure the content of &quot;                    + &quot;your adapter is not modified from a background thread, but only from &quot;                    + &quot;the UI thread. Make sure your adapter calls notifyDataSetChanged() &quot;                    + &quot;when its content changes. [in ListView(&quot; + getId() + &quot;, &quot; + getClass()                    + &quot;) with Adapter(&quot; + mAdapter.getClass() + &quot;)]&quot;);        &#125;        setSelectedPositionInt(mNextSelectedPosition);        // 处理一些 accessibility 相关的        AccessibilityNodeInfo accessibilityFocusLayoutRestoreNode = null;        View accessibilityFocusLayoutRestoreView = null;        int accessibilityFocusPosition = INVALID_POSITION;        // Remember which child, if any, had accessibility focus. This must        // occur before recycling any views, since that will clear        // accessibility focus.        final ViewRootImpl viewRootImpl = getViewRootImpl();        if (viewRootImpl != null) &#123;            final View focusHost = viewRootImpl.getAccessibilityFocusedHost();            if (focusHost != null) &#123;                final View focusChild = getAccessibilityFocusedChild(focusHost);                if (focusChild != null) &#123;                    if (!dataChanged || isDirectChildHeaderOrFooter(focusChild)                            || (focusChild.hasTransientState() &amp;&amp; mAdapterHasStableIds)) &#123;                        // The views won&#39;t be changing, so try to maintain                        // focus on the current host and virtual view.                        accessibilityFocusLayoutRestoreView = focusHost;                        accessibilityFocusLayoutRestoreNode = viewRootImpl                                .getAccessibilityFocusedVirtualView();                    &#125;                    // If all else fails, maintain focus at the same                    // position.                    accessibilityFocusPosition = getPositionForView(focusChild);                &#125;            &#125;        &#125;        // 处理焦点相关        View focusLayoutRestoreDirectChild = null;        View focusLayoutRestoreView = null;        // Take focus back to us temporarily to avoid the eventual call to        // clear focus when removing the focused child below from messing        // things up when ViewAncestor assigns focus back to someone else.        final View focusedChild = getFocusedChild();        if (focusedChild != null) &#123;            // TODO: in some cases focusedChild.getParent() == null            // We can remember the focused view to restore after re-layout            // if the data hasn&#39;t changed, or if the focused position is a            // header or footer.            if (!dataChanged || isDirectChildHeaderOrFooter(focusedChild)                    || focusedChild.hasTransientState() || mAdapterHasStableIds) &#123;                focusLayoutRestoreDirectChild = focusedChild;                // Remember the specific view that had focus.                focusLayoutRestoreView = findFocus();                if (focusLayoutRestoreView != null) &#123;                    // Tell it we are going to mess with it.                    focusLayoutRestoreView.dispatchStartTemporaryDetach();                &#125;            &#125;            requestFocus();        &#125;        // 将所有 View 扔到回收站，这些 View 有可能会被重用        final int firstPosition = mFirstPosition;        final RecycleBin recycleBin = mRecycler;        if (dataChanged) &#123;            for (int i = 0; i &lt; childCount; i++) &#123;                recycleBin.addScrapView(getChildAt(i), firstPosition+i);            &#125;        &#125; else &#123;            recycleBin.fillActiveViews(childCount, firstPosition);        &#125;        // 将所有的子 View 的 parent 置为 null，并将 View 置为 null        detachAllViewsFromParent();        recycleBin.removeSkippedScrap();        switch (mLayoutMode) &#123;            case LAYOUT_SET_SELECTION:                if (newSel != null) &#123;                    sel = fillFromSelection(newSel.getTop(), childrenTop, childrenBottom);                &#125; else &#123;                    sel = fillFromMiddle(childrenTop, childrenBottom);                &#125;                break;            case LAYOUT_SYNC:                sel = fillSpecific(mSyncPosition, mSpecificTop);                break;            case LAYOUT_FORCE_BOTTOM:                sel = fillUp(mItemCount - 1, childrenBottom);                adjustViewsUpOrDown();                break;            case LAYOUT_FORCE_TOP:                mFirstPosition = 0;                sel = fillFromTop(childrenTop);                adjustViewsUpOrDown();                break;            case LAYOUT_SPECIFIC:                final int selectedPosition = reconcileSelectedPosition();                sel = fillSpecific(selectedPosition, mSpecificTop);                /**                    * When ListView is resized, FocusSelector requests an async selection for the                    * previously focused item to make sure it is still visible. If the item is not                    * selectable, it won&#39;t regain focus so instead we call FocusSelector                    * to directly request focus on the view after it is visible.                    */                if (sel == null &amp;&amp; mFocusSelector != null) &#123;                    final Runnable focusRunnable = mFocusSelector                            .setupFocusIfValid(selectedPosition);                    if (focusRunnable != null) &#123;                        post(focusRunnable);                    &#125;                &#125;                break;            case LAYOUT_MOVE_SELECTION:                sel = moveSelection(oldSel, newSel, delta, childrenTop, childrenBottom);                break;            // 在 ListView 的第一次 layout 过程中，childCount = 0            default:                if (childCount == 0) &#123;                    // mStackFromBottom 为 true 时，表示整个 ListView 是倒着填充的                    if (!mStackFromBottom) &#123;                        final int position = lookForSelectablePosition(0, true);                        setSelectedPositionInt(position);                        // 主要的填充方法                        sel = fillFromTop(childrenTop);                    &#125; else &#123;                        final int position = lookForSelectablePosition(mItemCount - 1, false);                        setSelectedPositionInt(position);                        sel = fillUp(mItemCount - 1, childrenBottom);                    &#125;                &#125; else &#123;                    // 如果已经有 View 了，那就只填充特定位置的 View                    if (mSelectedPosition &gt;= 0 &amp;&amp; mSelectedPosition &lt; mItemCount) &#123;                        sel = fillSpecific(mSelectedPosition,                                oldSel == null ? childrenTop : oldSel.getTop());                    &#125; else if (mFirstPosition &lt; mItemCount) &#123;                        sel = fillSpecific(mFirstPosition,                                oldFirst == null ? childrenTop : oldFirst.getTop());                    &#125; else &#123;                        sel = fillSpecific(0, childrenTop);                    &#125;                &#125;                break;        &#125;        ...    &#125; finally &#123;        ...        // 允许进行下一次 layout        if (!blockLayoutRequests) &#123;            mBlockLayoutRequests = false;        &#125;    &#125;&#125;</code></pre><p>可见，在 layout 过程中，会处理一些 Accessibility 和焦点方面的事情，最后开始判断 ListView 的类型和子 View 数量。在初次 layout 时，ListView 中必然不会添加进子 View，所以此时 childCount 为 0，在填充时会调用<code>fillFromTop()</code>方法：</p><pre><code class="java">private View fillFromTop(int nextTop) &#123;    mFirstPosition = Math.min(mFirstPosition, mSelectedPosition);    mFirstPosition = Math.min(mFirstPosition, mItemCount - 1);    if (mFirstPosition &lt; 0) &#123;        mFirstPosition = 0;    &#125;    return fillDown(mFirstPosition, nextTop);&#125;private View fillDown(int pos, int nextTop) &#123;    View selectedView = null;    int end = (mBottom - mTop);    if ((mGroupFlags &amp; CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) &#123;        end -= mListPadding.bottom;    &#125;    while (nextTop &lt; end &amp;&amp; pos &lt; mItemCount) &#123;        // is this the selected item?        boolean selected = pos == mSelectedPosition;        View child = makeAndAddView(pos, nextTop, true, mListPadding.left, selected);        nextTop = child.getBottom() + mDividerHeight;        if (selected) &#123;            selectedView = child;        &#125;        pos++;    &#125;    setVisibleRangeHint(mFirstPosition, mFirstPosition + getChildCount() - 1);    return selectedView;&#125;</code></pre><p>可见在<code>fillDown()</code>方法中，使用了循环的方式将子 View 都创建出来，具体的操作还是交给了<code>makeAndAddView()</code>方法：</p><pre><code class="java">private View makeAndAddView(int position, int y, boolean flow, int childrenLeft,        boolean selected) &#123;    if (!mDataChanged) &#123;        // 这里尝试从回收站中拿出已经渲染过的 View，初次获取时，必为 null        final View activeView = mRecycler.getActiveView(position);        if (activeView != null) &#123;            // 如果在回收站中找到了对应的 View，就直接给它放到对应的位置上            setupChild(activeView, position, y, flow, childrenLeft, selected, true);            return activeView;        &#125;    &#125;    // 新建一个 View，或者是将一个未使用的 View convert 一下（如果可能的话）    final View child = obtainView(position, mIsScrap);    // 放到对应的位置上    setupChild(child, position, y, flow, childrenLeft, selected, mIsScrap[0]);    return child;&#125;</code></pre><p>这里会尝试先获取回收站中对应的 View，在首次 layout 时肯定获取到的是<code>null</code>，就会调用<code>obtainView()</code>来创建一个 View，这个方法由 AbsListView 来实现：</p><pre><code class="java">// AbsListView.javaView obtainView(int position, boolean[] outMetadata) &#123;    Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;obtainView&quot;);    outMetadata[0] = false;    final View transientView = mRecycler.getTransientStateView(position);  // 1    if (transientView != null) &#123;        final LayoutParams params = (LayoutParams) transientView.getLayoutParams();        // If the view type hasn&#39;t changed, attempt to re-bind the data.        if (params.viewType == mAdapter.getItemViewType(position)) &#123;            final View updatedView = mAdapter.getView(position, transientView, this); //2            // If we failed to re-bind the data, scrap the obtained view.            if (updatedView != transientView) &#123;                setItemViewLayoutParams(updatedView, position);                mRecycler.addScrapView(updatedView, position);            &#125;        &#125;        outMetadata[0] = true;        // Finish the temporary detach started in addScrapView().        transientView.dispatchFinishTemporaryDetach();        return transientView;    &#125;    final View scrapView = mRecycler.getScrapView(position);  // 3    final View child = mAdapter.getView(position, scrapView, this);  // 4    if (scrapView != null) &#123;        if (child != scrapView) &#123;            // Failed to re-bind the data, return scrap to the heap.            mRecycler.addScrapView(scrapView, position);  // 5        &#125; else if (child.isTemporarilyDetached()) &#123;            outMetadata[0] = true;            // Finish the temporary detach started in addScrapView().            child.dispatchFinishTemporaryDetach();        &#125;    &#125;    if (mCacheColorHint != 0) &#123;        child.setDrawingCacheBackgroundColor(mCacheColorHint);    &#125;    if (child.getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) &#123;        child.setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);    &#125;    setItemViewLayoutParams(child, position);    if (AccessibilityManager.getInstance(mContext).isEnabled()) &#123;        if (mAccessibilityDelegate == null) &#123;            mAccessibilityDelegate = new ListItemAccessibilityDelegate();        &#125;        if (child.getAccessibilityDelegate() == null) &#123;            child.setAccessibilityDelegate(mAccessibilityDelegate);        &#125;    &#125;    Trace.traceEnd(Trace.TRACE_TAG_VIEW);    return child;&#125;</code></pre><p>这个方法是各种 ListView 及其派生类中最重要的方法了，我们来详细解释一下。</p><ol><li>检查回收站中是否有瞬态的 View，如果有的话，尝试重新绑定数据；如果没有的话，就直接扔掉，重新创建。</li><li>如果在上一步中获取到了瞬态 View，并且之前存储的 ViewType 与 Adapter 中存储的 ViewType 相同的话，就直接把瞬态 View 交给 Adapter，重新绑定数据。</li><li>如果在第1步中没有获取到瞬态 View，则尝试从 ScrapViews 中获取，看有没有被废弃的 View。</li><li>拿着上一步获取的 ScrapView，交给 Adapter 绑定数据。</li><li>如果获取的 ScrapView 和 Adapter 绑定数据后的 View 是同一个实例（复用），则将这个 View 添加到 ScrapViews 中。</li><li>返回 Adapter 绑定数据后的 View。</li></ol><p>这里还有个比较重要的方法：<code>mAdapter.getView()</code>，眼熟吗？这不就是我们平时在开发时要覆写的方法之一吗，我们平时会这样写：</p><pre><code class="java">@Overridepublic View getView(int position, View convertView, ViewGroup parent) &#123;    Person person = getItem(position);    View view;    if (convertView == null) &#123;        view = LayoutInflater.from(getContext()).inflate(resourceId, null);    &#125; else &#123;        view = convertView;    &#125;    ImageView avatar = (ImageView) view.findViewById(R.id.iv_avatar);    TextView name = (TextView) view.findViewById(R.id.tv_name);    avatar.setImageResource(person.getImageId());    name.setText(person.getName());    return view;&#125;</code></pre><p>这下能明白复用的<code>convertView</code>是哪儿来的了吗？它如果是<code>null</code>的话，说明是初次 layout 过程，如果不是<code>null</code>的话，说明它是瞬态 View 或者是 ScrapView。这也是 ListView 优化处之一——复用<code>convertView</code>，节省掉用 LayoutInflater 重新渲染的过程。</p><p>当然，在初次 layout 过程中，所有的<code>convertView</code>必然为<code>null</code>，也即全部为 LayoutInflater 渲染，会比较耗时。</p><p>我们继续回到<code>makeAndAddView()</code>方法中，下面还有个比较重要的方法是<code>setupChild()</code>：</p><pre><code class="java">  private void setupChild(View child, int position, int y, boolean flowDown, int childrenLeft,            boolean selected, boolean isAttachedToWindow) &#123;    Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;setupListItem&quot;);    final boolean isSelected = selected &amp;&amp; shouldShowSelector();    final boolean updateChildSelected = isSelected != child.isSelected();    final int mode = mTouchMode;    final boolean isPressed = mode &gt; TOUCH_MODE_DOWN &amp;&amp; mode &lt; TOUCH_MODE_SCROLL            &amp;&amp; mMotionPosition == position;    final boolean updateChildPressed = isPressed != child.isPressed();    final boolean needToMeasure = !isAttachedToWindow || updateChildSelected            || child.isLayoutRequested();    // Respect layout params that are already in the view. Otherwise make    // some up...    AbsListView.LayoutParams p = (AbsListView.LayoutParams) child.getLayoutParams();    if (p == null) &#123;        p = (AbsListView.LayoutParams) generateDefaultLayoutParams();    &#125;    p.viewType = mAdapter.getItemViewType(position);    p.isEnabled = mAdapter.isEnabled(position);    // Set up view state before attaching the view, since we may need to    // rely on the jumpDrawablesToCurrentState() call that occurs as part    // of view attachment.    if (updateChildSelected) &#123;        child.setSelected(isSelected);    &#125;    if (updateChildPressed) &#123;        child.setPressed(isPressed);    &#125;    if (mChoiceMode != CHOICE_MODE_NONE &amp;&amp; mCheckStates != null) &#123;        if (child instanceof Checkable) &#123;            ((Checkable) child).setChecked(mCheckStates.get(position));        &#125; else if (getContext().getApplicationInfo().targetSdkVersion                &gt;= android.os.Build.VERSION_CODES.HONEYCOMB) &#123;            child.setActivated(mCheckStates.get(position));        &#125;    &#125;    if ((isAttachedToWindow &amp;&amp; !p.forceAdd) || (p.recycledHeaderFooter            &amp;&amp; p.viewType == AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER)) &#123;        attachViewToParent(child, flowDown ? -1 : 0, p);        // If the view was previously attached for a different position,        // then manually jump the drawables.        if (isAttachedToWindow                &amp;&amp; (((AbsListView.LayoutParams) child.getLayoutParams()).scrappedFromPosition)                        != position) &#123;            child.jumpDrawablesToCurrentState();        &#125;    &#125; else &#123;        p.forceAdd = false;        if (p.viewType == AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER) &#123;            p.recycledHeaderFooter = true;        &#125;        addViewInLayout(child, flowDown ? -1 : 0, p, true);        // add view in layout will reset the RTL properties. We have to re-resolve them        child.resolveRtlPropertiesIfNeeded();    &#125;    if (needToMeasure) &#123;        final int childWidthSpec = ViewGroup.getChildMeasureSpec(mWidthMeasureSpec,                mListPadding.left + mListPadding.right, p.width);        final int lpHeight = p.height;        final int childHeightSpec;        if (lpHeight &gt; 0) &#123;            childHeightSpec = MeasureSpec.makeMeasureSpec(lpHeight, MeasureSpec.EXACTLY);        &#125; else &#123;            childHeightSpec = MeasureSpec.makeSafeMeasureSpec(getMeasuredHeight(),                    MeasureSpec.UNSPECIFIED);        &#125;        child.measure(childWidthSpec, childHeightSpec);    &#125; else &#123;        cleanupLayoutState(child);    &#125;    final int w = child.getMeasuredWidth();    final int h = child.getMeasuredHeight();    final int childTop = flowDown ? y : y - h;    if (needToMeasure) &#123;        final int childRight = childrenLeft + w;        final int childBottom = childTop + h;        child.layout(childrenLeft, childTop, childRight, childBottom);    &#125; else &#123;        child.offsetLeftAndRight(childrenLeft - child.getLeft());        child.offsetTopAndBottom(childTop - child.getTop());    &#125;    if (mCachingStarted &amp;&amp; !child.isDrawingCacheEnabled()) &#123;        child.setDrawingCacheEnabled(true);    &#125;    Trace.traceEnd(Trace.TRACE_TAG_VIEW);&#125;</code></pre><p>这部分代码的核心是<code>attachViewToParent()</code>和<code>addViewInLayout()</code>方法，代表着将 View 正式加入 ListView 中。</p><p><a href="https://blog.csdn.net/guolin_blog/article/details/44996879">看看这个，日后继续写吧</a><br><a href="https://www.jianshu.com/p/01f161cb498c">看看这个</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 性能优化 </tag>
            
            <tag> ListView </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>View 事件分发机制</title>
      <link href="/2023-01-31/view-event-dispatch/"/>
      <url>/2023-01-31/view-event-dispatch/</url>
      
        <content type="html"><![CDATA[<p>这篇文章来梳理一下 Android 最令人头疼的基本元素——事件机制。</p><span id="more"></span><h2 id="事件序列"><a href="#事件序列" class="headerlink" title="事件序列"></a>事件序列</h2><p>当用户点击屏幕里View或者ViewGroup的时候，将会产生一个事件对象，这个事件对象就是MotionEvent对象，这个对象记录了事件的类型，触摸的位置，以及触摸的时间等。MotionEvent里面定义了事件的类型，其实很容易理解，因为用户可以在屏幕触摸，滑动，离开屏幕动作，分别对应：</p><ul><li>MotionEvent.ACTION_DOWN：用户触摸View &amp; ViewGroup</li><li>MotionEvent.ACTION_MOVE：用户手指移动View &amp; ViewGroup</li><li>MotionEvent.ACTION_UP：用户手指离开屏幕</li><li>MotionEvent.ACTION_CANCEL：事件退出了，不是用户导致的</li></ul><p>因此用户在触摸屏幕到离开屏幕会产生一系列事件：</p><pre><code>ACTION_DOWN -&gt; ACTION_MOVE(0个或者多个) -&gt; ACTION_UP</code></pre><p>如下图：<br><img src="https://s3.ax1x.com/2020/12/09/rCptjP.png" alt="事件序列"></p><h2 id="事件传递的顺序"><a href="#事件传递的顺序" class="headerlink" title="事件传递的顺序"></a>事件传递的顺序</h2><p>事件传递的顺序如下：</p><pre><code>InputManageSystem -&gt; WindowInputEventReceiver(ViewRootImpl) -&gt; DecorView -&gt; Activity -&gt; DecorView -&gt; 子View</code></pre><p>如果所有的 View 都没有消耗事件，那最后事件会传回到 Activity，由 Activity 处理（也即 Activity 的<code>onTouchEvent()</code>方法被调用）。</p><pre><code>子View --&gt; DecorView --&gt; Activity</code></pre><p>由 DecorView 向下，事件的传递还算清晰，没有太多的疑问。那最关键的是，触摸事件是怎么产生并交给 DecorView 的呢？</p><p>我们知道，触摸屏幕，首先肯定是硬件产生的一个电信号，但是我们能接触到的触摸事件直接就到了 MotionEvent，那么这个 MotionEvent 在哪里产生？</p><p>其实这个过程是在 Framework 层做的处理。</p><p>屏幕对应 Android 来说，担任了<strong>键盘</strong>的作用，就是我们计算机组成的输入设备。我们知道 Android 是基于 Linux 系统的，当我们的输入设备可用时（对当前的例子来说——触摸屏），我们对触摸屏进行操作，Linux 就会收到相应的<strong>硬件中断</strong>，然后将中断加工成原始的<strong>输入事件</strong>并写入相应的<strong>设备节点</strong>中。而 Android 的输入系统所做的事情概括起来说就是监控这些设备节点，当某个设备节点有数据可读时，将数据读出并进行一系列的翻译加工，然后在所有的窗口中找到合适的事件接收者，并派发给它。这里所说的 Android 输入系统，就是 InputManagerService（IMS），它和我们熟知的 ActivityManagerService（AMS）一样，作为系统服务，都是在 ServiceServer 中被创建。</p><p>根据 <a href="/activity/">Activity、Window 和 View 之间的关系</a>，我们知道，Activity 在创建时，会创建对应的 PhoneWindow，创建完成之后，会同时创建 ViewRootImpl 实例，在这个实例的 <code>setView()</code> 方法中，会将该 Window 与 IMS 进行关联，关联的方式是创建 InputChannel 实例并通过 Binder 通信的方式把 PhoneWindow 和 InputChannel 一起扔给 IMS，IMS 去进行注册。待有事件发生，就会有所回调，而回调的一个关键类是下面即将会提到的 WindowInputEventReceiver。</p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>WindowInputEventReceiver 是 ViewRootImpl 中的一个子类。它的其中一个功能是搭建 DecorView 与 IMS 之间的桥梁。 在 <code>ViewRootImpl.setView()</code> 中，有如下代码：</p><pre><code class="java">public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView, int userId) &#123;    ...    // Schedule the first layout -before- adding to the window    // manager, to make sure we do the relayout before receiving    // any other events from the system.    requestLayout();                // 1    InputChannel inputChannel = null;    if ((mWindowAttributes.inputFeatures            &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) &#123;        inputChannel = new InputChannel();          // 2    &#125;    ...    try &#123;        ...        res = mWindowSession.addToDisplayAsUser(mWindow, mSeq, mWindowAttributes,                            getHostVisibility(), mDisplay.getDisplayId(), userId, mTmpFrame,                            mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,                            mAttachInfo.mDisplayCutout, inputChannel,                            mTempInsets, mTempControls);        // 3        ...    &#125;    ...    if (inputChannel != null) &#123;        ...        mInputEventReceiver = new WindowInputEventReceiver(inputChannel, Looper.myLooper());  // 4    &#125;&#125;</code></pre><ol><li>准备开始进行 layout 阶段；</li><li>创建 InputChannel 实例，注意，此时并未初始化该实例；</li><li>将 PhoneWindow 实例和 InputChannel 实例都通过 Binder 扔给 Session（mWindowSession 是 IWindowSession 类型的，其对应的实现为 Session 类，位于 com/android/server/wm/Session.java），Session 通过一系列操作将 PhoneWindow 与 InputChannel 绑定。值得一提的是，在绑定之前，才会利用 <code>InputChannel.openChannelPair(name)</code> 方法创建两个 InputChannel，一个是 Server 端，用于发布事件；一个是 Client 端，用于消耗事件，然后将新创建的 Client 端直接 <code>transferTo()</code> 到步骤 2 中创建的实例，从而完成其初始化的操作。</li><li>注册 WindowInputEventReceiver，当 InputChannel 有消息过来的时候，立刻回调它的 <code>onInputEvent()</code> 方法。</li></ol><p>需要注意的是，在创建 WindowInputEventReceiver 实例的时候，也给它了一个主线程的 Looper，这意味着，事件的接收和后续分发，都是在主线程上进行的，这也是为什么触摸事件不能做太复杂的操作的原因——会卡住主线程。</p><p>由 WindowInputEventReceiver 的<code>onInputEvent()</code>方法层层向下走，我们最终可以找到 ViewRootImpl.java 中，有这么一个方法：</p><pre><code class="java">// ViewRootImpl.javaView mView;private int processPointerEvent(QueuedInputEvent q) &#123;    final MotionEvent event = (MotionEvent)q.mEvent;    ...     boolean handled = mView.dispatchPointerEvent(event);    ...    return handled ? FINISH_HANDLED : FORWARD;&#125;</code></pre><p>此处的<code>mView</code>，是在<code>ViewRootImpl.setView()</code>中赋值的，这个方法做了很多的重要工作，我会在<a href="/viewrootimpl/">关于 ViewRootImpl</a>一文中进行详解。这个<code>setView()</code>方法，是在<code>WindowManagerGlobal.addView()</code>中被调用的。而<code>WindowManagerGlobal.addView()</code>又是在<code>WindowManagerImpl.addView()</code>中被调用的，这个方法，又是在<code>Activity.makeVisible()</code>方法中调用的，于是我们找到了上面代码中<code>mView</code>的出处：</p><pre><code class="java">// android.app.Activity.javaView mDecor = null;void makeVisible() &#123;    if (!mWindowAdded) &#123;        ViewManager wm = getWindowManager();        wm.addView(mDecor, getWindow().getAttributes());        mWindowAdded = true;    &#125;    mDecor.setVisibility(View.VISIBLE);&#125;</code></pre><p>原来就是 DecorView 啊。到此，事件终于稳稳地交给了我们的 DecorView。</p><p>接下来在 DecorView.java 中找找<code>dispatchPointerEvent()</code>。WTF？没找到？表着急，那肯定在 ViewGroup.java 里。WTF？没找到？表着急，那肯定在 View.java 里。</p><pre><code class="java">// View.java@UnsupportedAppUsagepublic final boolean dispatchPointerEvent(MotionEvent event) &#123;    if (event.isTouchEvent()) &#123;        return dispatchTouchEvent(event);    &#125; else &#123;        return dispatchGenericMotionEvent(event);    &#125;&#125;</code></pre><p>由此引出下面的部分。</p><h2 id="三个重要的方法"><a href="#三个重要的方法" class="headerlink" title="三个重要的方法"></a>三个重要的方法</h2><p>事件分发中有3个比较重要的入口方法，分别是：</p><ul><li><code>public boolean dispatchTouchEvent(MotionEvent event)</code></li><li><code>public boolean onTouchEvent(MotionEvent event)</code></li><li><code>public boolean onInterceptTouchEvent(MotionEvent ev)</code>。</li></ul><p>先来看看这几个方法的调用关系：<br><em><img src="/img/15.png" alt="事件分发机制图"></em></p><p>上图中绿色线条表示默认的事件处理流程，即我们没有做任何处理，事件会按照绿色线条所示的方向由Activity -&gt; …ViewGroup… -&gt; View -&gt; …ViewGroup… -&gt; Activity 这个U型图进行传递。即一直默认调用<code>super.xxx</code>方法。</p><p>黑色线条表示默认Activity -&gt;…ViewGroup… -&gt; View -&gt;…ViewGroup… -&gt; Activity 这个U型图的任一节点中（不包括<code>onInterceptTouchEvent</code>）返回了true，事件即结束，不再向下一节点传递。</p><p>红色线条表示一些特殊情况，尤其是ViewGroup，<code>ViewGroup.onInterceptTouchEvent()</code>表示询问当前ViewGroup是否需要拦截此事件即要不要处理，为什么要『多此一举』呢，因为<code>ViewGroup.dispatchTouchEvent()</code>这个函数的特殊，从上图可知，该函数返回true，是消费事件，返回false是交由上一级的ViewGroup或者Activity的<code>onTouchEvent()</code>。那么它怎么向下传递事件或者想把事件交给自己的<code>onTouchEvent</code>处理呢，所以ViewGroup多了个<code>onInterceptTouchEvent</code>（View是没有该函数的），<code>onInterceptTouchEvent</code>起到作用的是分流。<code>onInterceptTouchEvent</code>返回<code>false</code>或者返回<code>super.xxx</code>是向下级View或者ViewGroup传递，返回<code>true</code>呢是把事件交给自己的onTouchEvent处理。</p><p>接上节，刚才事件交给了 DecorView，但是无奈最后还是在 View 中找到 <code>dispatchPointerEvent()</code> 方法，我们看看这个事件是怎么个走向：</p><h3 id="dispatchTouchEvent"><a href="#dispatchTouchEvent" class="headerlink" title="dispatchTouchEvent"></a><code>dispatchTouchEvent</code></h3><p><code>dispatchTouchEvent</code>方法用来进行事件的分发。事件传递到当前 View/ViewGroup 时，这个方法就会被调用。<code>dispatchTouchEvent</code>方法里面包含了具体的事件分发逻辑，返回结果受当前 View 的<code>onTouchEvent</code>方法和下级 View 的<code>dispatchTouchEvent</code>方法的影响。</p><p>因为 DecorView 继承自 ViewGroup，所以我们先看ViewGroup是如何通过<code>dispatchTouchEvent</code>分发事件的：</p><pre><code class="java">// ViewGroup.java @Override    public boolean dispatchTouchEvent(MotionEvent ev) &#123;        if (mInputEventConsistencyVerifier != null) &#123;            mInputEventConsistencyVerifier.onTouchEvent(ev, 1);        &#125;        // If the event targets the accessibility focused view and this is it, start        // normal event dispatch. Maybe a descendant is what will handle the click.        if (ev.isTargetAccessibilityFocus() &amp;&amp; isAccessibilityFocusedViewOrHost()) &#123;            ev.setTargetAccessibilityFocus(false);        &#125;        boolean handled = false;        if (onFilterTouchEventForSecurity(ev)) &#123;            final int action = ev.getAction();            final int actionMasked = action &amp; MotionEvent.ACTION_MASK;            // Handle an initial down.            if (actionMasked == MotionEvent.ACTION_DOWN) &#123;                // Throw away all previous state when starting a new touch gesture.                // The framework may have dropped the up or cancel event for the previous gesture                // due to an app switch, ANR, or some other state change.                cancelAndClearTouchTargets(ev);                resetTouchState();            &#125;            // Check for interception.            final boolean intercepted;            if (actionMasked == MotionEvent.ACTION_DOWN                    || mFirstTouchTarget != null) &#123;                final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;                if (!disallowIntercept) &#123;                    intercepted = onInterceptTouchEvent(ev); // 判断是否要拦截事件                    ev.setAction(action); // restore action in case it was changed                &#125; else &#123;                    intercepted = false;                &#125;            &#125; else &#123;                // There are no touch targets and this action is not an initial down                // so this view group continues to intercept touches.                intercepted = true;            &#125;            // If intercepted, start normal event dispatch. Also if there is already            // a view that is handling the gesture, do normal event dispatch.            if (intercepted || mFirstTouchTarget != null) &#123;                ev.setTargetAccessibilityFocus(false);            &#125;            // Check for cancelation.            final boolean canceled = resetCancelNextUpFlag(this)                    || actionMasked == MotionEvent.ACTION_CANCEL;            // Update list of touch targets for pointer down, if needed.            final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0;            TouchTarget newTouchTarget = null;            boolean alreadyDispatchedToNewTouchTarget = false;            // 在这里寻找合适的子view并派发事件            if (!canceled &amp;&amp; !intercepted) &#123;                // If the event is targeting accessibility focus we give it to the                // view that has accessibility focus and if it does not handle it                // we clear the flag and dispatch the event to all children as usual.                // We are looking up the accessibility focused host to avoid keeping                // state since these events are very rare.                View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()                        ? findChildWithAccessibilityFocus() : null;                if (actionMasked == MotionEvent.ACTION_DOWN                        || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)                        || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;                    final int actionIndex = ev.getActionIndex(); // always 0 for down                    final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex)                            : TouchTarget.ALL_POINTER_IDS;                    // Clean up earlier touch targets for this pointer id in case they                    // have become out of sync.                    removePointersFromTouchTargets(idBitsToAssign);                    final int childrenCount = mChildrenCount;                    if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123;                        final float x = ev.getX(actionIndex);                        final float y = ev.getY(actionIndex);                        // Find a child that can receive the event.                        // Scan children from front to back.                        final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList();                        final boolean customOrder = preorderedList == null                                &amp;&amp; isChildrenDrawingOrderEnabled();                        final View[] children = mChildren;                        for (int i = childrenCount - 1; i &gt;= 0; i--) &#123;                            final int childIndex = getAndVerifyPreorderedIndex(                                    childrenCount, i, customOrder);                            final View child = getAndVerifyPreorderedView(                                    preorderedList, children, childIndex);                            // If there is a view that has accessibility focus we want it                            // to get the event first and if not handled we will perform a                            // normal dispatch. We may do a double iteration but this is                            // safer given the timeframe.                            if (childWithAccessibilityFocus != null) &#123;                                if (childWithAccessibilityFocus != child) &#123;                                    continue;                                &#125;                                childWithAccessibilityFocus = null;                                i = childrenCount - 1;                            &#125;                            if (!child.canReceivePointerEvents()                                    || !isTransformedTouchPointInView(x, y, child, null)) &#123;                                ev.setTargetAccessibilityFocus(false);                                continue;                            &#125;                            newTouchTarget = getTouchTarget(child);                            if (newTouchTarget != null) &#123;                                // Child is already receiving touch within its bounds.                                // Give it the new pointer in addition to the ones it is handling.                                newTouchTarget.pointerIdBits |= idBitsToAssign;                                break;                            &#125;                            resetCancelNextUpFlag(child);                            if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123;                                // Child wants to receive touch within its bounds.                                mLastTouchDownTime = ev.getDownTime();                                if (preorderedList != null) &#123;                                    // childIndex points into presorted list, find original index                                    for (int j = 0; j &lt; childrenCount; j++) &#123;                                        if (children[childIndex] == mChildren[j]) &#123;                                            mLastTouchDownIndex = j;                                            break;                                        &#125;                                    &#125;                                &#125; else &#123;                                    mLastTouchDownIndex = childIndex;                                &#125;                                mLastTouchDownX = ev.getX();                                mLastTouchDownY = ev.getY();                                newTouchTarget = addTouchTarget(child, idBitsToAssign);                                alreadyDispatchedToNewTouchTarget = true;                                break;                            &#125;                            // The accessibility focus didn&#39;t handle the event, so clear                            // the flag and do a normal dispatch to all children.                            ev.setTargetAccessibilityFocus(false);                        &#125;                        if (preorderedList != null) preorderedList.clear();                    &#125;                    if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) &#123;                        // Did not find a child to receive the event.                        // Assign the pointer to the least recently added target.                        newTouchTarget = mFirstTouchTarget;                        while (newTouchTarget.next != null) &#123;                            newTouchTarget = newTouchTarget.next;                        &#125;                        newTouchTarget.pointerIdBits |= idBitsToAssign;                    &#125;                &#125;            &#125;            // Dispatch to touch targets.            if (mFirstTouchTarget == null) &#123;                // No touch targets so treat this as an ordinary view.                handled = dispatchTransformedTouchEvent(ev, canceled, null,                        TouchTarget.ALL_POINTER_IDS);            &#125; else &#123;                // Dispatch to touch targets, excluding the new touch target if we already                // dispatched to it.  Cancel touch targets if necessary.                TouchTarget predecessor = null;                TouchTarget target = mFirstTouchTarget;                while (target != null) &#123;                    final TouchTarget next = target.next;                    if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;                        handled = true;                    &#125; else &#123;                        final boolean cancelChild = resetCancelNextUpFlag(target.child)                                || intercepted;                        if (dispatchTransformedTouchEvent(ev, cancelChild,                                target.child, target.pointerIdBits)) &#123;                            handled = true;                        &#125;                        if (cancelChild) &#123;                            if (predecessor == null) &#123;                                mFirstTouchTarget = next;                            &#125; else &#123;                                predecessor.next = next;                            &#125;                            target.recycle();                            target = next;                            continue;                        &#125;                    &#125;                    predecessor = target;                    target = next;                &#125;            &#125;            // Update list of touch targets for pointer up or cancel, if needed.            if (canceled                    || actionMasked == MotionEvent.ACTION_UP                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;                resetTouchState();            &#125; else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123;                final int actionIndex = ev.getActionIndex();                final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex);                removePointersFromTouchTargets(idBitsToRemove);            &#125;        &#125;        if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) &#123;            mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);        &#125;        return handled;    &#125;</code></pre><p>简单总结，就是：</p><ol><li>先判断是否要拦截（通过<code>onInterceptTouchEvent()</code>方法），如果不拦截，那就寻找合适的子view进行事件的派发，也既调用子view的<code>dispatchTouchEvent()</code>。如果有任何一个子view消费了此次事件，即<code>dispatchTouchEvent()</code>返回了<code>true</code>，那派发中止，并返回true，表示事件已经被消费。如果没有任何一个子view消费此次事件，即<code>dispatchTouchEvent()</code>返回了<code>false</code>，那ViewGroup就自己处理此次事件，调用父类View的<code>onTouchEvent()</code>。如果最后还未消耗，那就会一直向上返回，直到Activity的<code>onTouchEvent()</code>。</li><li>如果要拦截，那就会直接调用自己父类View的<code>onTouchEvent()</code>。</li></ol><p>上一部分的代码里我们也也看到，<code>dispatchPointerEvent</code>直接调用了<code>dispatchTouchEvent(event)</code>，而DecorView又重写了这个方法。</p><p>所以我们看看<code>DecorView.dispatchTouchEvent()</code>做了些啥：</p><pre><code class="java">// DecorView.java@Overridepublic boolean dispatchTouchEvent(MotionEvent ev) &#123;    final Window.Callback cb = mWindow.getCallback();    return cb != null &amp;&amp; !mWindow.isDestroyed() &amp;&amp; mFeatureId &lt; 0            ? cb.dispatchTouchEvent(ev) : super.dispatchTouchEvent(ev);&#125;</code></pre><p>Callback来自于Window.java：</p><pre><code class="java">// Window.javapublic final Callback getCallback() &#123;    return mCallback;&#125;</code></pre><pre><code class="java">// Callback.java:public interface Callback &#123;    ...    public boolean dispatchTouchEvent(MotionEvent event);    ...&#125;</code></pre><p>那既然有<code>getCallback()</code>就肯定有<code>setCallback()</code>，我们找一下。<br><img src="/img/14.png" alt="Callback调用者"></p><p>在<code>Activity.attach()</code>方法中找到了<code>window.setCallback(this)</code>：</p><pre><code class="java">// Activity.java@UnsupportedAppUsagefinal void attach(Context context, ActivityThread aThread,        Instrumentation instr, IBinder token, int ident,        Application application, Intent intent, ActivityInfo info,        CharSequence title, Activity parent, String id,        NonConfigurationInstances lastNonConfigurationInstances,        Configuration config, String referrer, IVoiceInteractor voiceInteractor,        Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken) &#123;    ...    mWindow.setCallback(this);      ...&#125;</code></pre><p>所以说，MotionEvent最终又是传递到了Activity，<code>cb.dispatchTouchEvent(ev)</code>也就是相当于<code>Activity.dispatchTouchEvent()</code>。</p><p>那么来看看Activity是怎么处理的：</p><pre><code class="java">    // Activty.java    /**     * 被调用来处理触摸屏幕的事件。     * 你可以覆写此方法以在事件分发到window之前拦截所有的事件。     * 不过要确保调用此处的实现保证触摸事件都被正常处理。      *     * @param ev The touch screen event.     *     * @return boolean Return true if this event was consumed.     */    public boolean dispatchTouchEvent(MotionEvent ev) &#123;        if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;            onUserInteraction();        &#125;        if (getWindow().superDispatchTouchEvent(ev)) &#123;            return true;        &#125;        return onTouchEvent(ev);    &#125;</code></pre><p>Activity又调用了<code>getWindow().superDispatchTouchEvent(ev)</code>也就是PhoneWindow。</p><pre><code class="java">// PhoneWindow.java@Overridepublic boolean superDispatchTouchEvent(MotionEvent event) &#123;        // 兜兜转转一大圈，还是把事件交给我们的DecorView，        // DecorView继承自FrameLayout，FrameLayout呢又继承自ViewGroup，        // 所以作为一个ViewGroup，DecorView继续向其子View派发事件，其流程在文章的开头就已经给了        return mDecor.superDispatchTouchEvent(event);&#125;</code></pre><p>这里又调用了DecorView的superDispatchTouchEvent(event)：</p><pre><code class="java">// DecorView.javapublic boolean superDispatchTouchEvent(MotionEvent event) &#123;    return super.dispatchTouchEvent(event);&#125;</code></pre><p>这里就是直接继承自ViewGroup的<code>dispatchTouchEvent(MotionEvent ev)</code>方法，也就是说，事件从 DecorView 传递到Activity，最终又回到 DecorView，最后按照分发机制分发到ViewGroup再到所有的子View。</p><p>兜兜转转一大圈我们神经都被绕弯了:joy: 。在这里总结一下，当我们触摸（点击）屏幕时，Android输入系统InputManagerService通过对事件的加工处理再找到合适的 Window 接收者并通过 InputChannel 向 Window 派发加工后的事件，并触发 WindowInputEventReceiver 的<code>onInputEvent</code>的调用，由此产生后面一系列的调用，把事件派发给整个控件树的根 DecorView 。而 DecorView 又上演了一出偷梁换柱的把戏，先把事件交给 Activity 处理，在 Activity 中又把事件交还给了我们的 DecorView 。自此沿着控件树自上向下依次派发事件。如果最后没有任何 View 处理此次点击事件，则 Activity 再来做最后的处理。</p><p>那就继续看看View的事件分发：</p><pre><code class="java">// View.java/*** 将触摸屏幕的手势事件向下传递给目标 view，如果当前 view 是目标 view的话，就传递给当前 view。** @param event The motion event to be dispatched.* @return 如果事件被处理（消耗），就返回 true，否则返回 false。*/public boolean dispatchTouchEvent(MotionEvent event) &#123;    // If the event should be handled by accessibility focus first.    if (event.isTargetAccessibilityFocus()) &#123;        // We don&#39;t have focus or no virtual descendant has it, do not handle the event.        if (!isAccessibilityFocusedViewOrHost()) &#123;            return false;        &#125;        // We have focus and got the event, then use normal event dispatch.        event.setTargetAccessibilityFocus(false);    &#125;    boolean result = false;    if (mInputEventConsistencyVerifier != null) &#123;        mInputEventConsistencyVerifier.onTouchEvent(event, 0);    &#125;    final int actionMasked = event.getActionMasked();    if (actionMasked == MotionEvent.ACTION_DOWN) &#123;        // Defensive cleanup for new gesture        stopNestedScroll();    &#125;    // 这里决定了该 view 是否要消耗此次事件。    //    // 1. 如果该 view 有`TouchListener`的话，交给它的派生类的 `onTouch` 实现去决定是否要消耗事件。    // 2. 如果没有 `TouchListener`，那么就看 view 自己处理 touchEvent 事件之后，是否要消耗掉该事件。     if (onFilterTouchEventForSecurity(event)) &#123;        if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123;            result = true;        &#125;        //noinspection SimplifiableIfStatement        ListenerInfo li = mListenerInfo;        if (li != null &amp;&amp; li.mOnTouchListener != null                &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED                &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123;            result = true;        &#125;        if (!result &amp;&amp; onTouchEvent(event)) &#123;            result = true;        &#125;    &#125;    if (!result &amp;&amp; mInputEventConsistencyVerifier != null) &#123;        mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);    &#125;    // Clean up after nested scrolls if this is the end of a gesture;    // also cancel it if we tried an ACTION_DOWN but we didn&#39;t want the rest    // of the gesture.    if (actionMasked == MotionEvent.ACTION_UP ||            actionMasked == MotionEvent.ACTION_CANCEL ||            (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) &#123;        stopNestedScroll();    &#125;    return result;&#125;</code></pre><h3 id="onTouchEvent"><a href="#onTouchEvent" class="headerlink" title="onTouchEvent"></a><code>onTouchEvent</code></h3><p>该方法在<code>View.dispatchTouchEvent()</code>方法中调用，用来处理点击事件，返回结果表示是否消耗当前事件，如果不消耗，则在同一个事件序列中，当前View无法再次接收到事件。例如一个<code>Button</code>设置为 <code>android:enabled=&quot;false&quot;</code>，那从 ACTION_DOWN 开始，就不消耗该事件，那么后面的 ACTION_MOVE、ACTION_UP等事件也就不会再接收到了。这是由一个叫<code>mIgnoreNextUpEvent</code>的变量控制的。</p><p>还是来看看它的代码：</p><pre><code class="java">// View.java/**    * 实现这个方法来处理屏幕触摸手势事件。    *     * 如果这个方法被用来检测点击动作，那你最好使用 performClick() 方法来触发此次点击事件。    * 这样做能保证它是一个高度一致性的系统行为，包括：    *    * · 遵守点击音效的设置    * · 分发 OnClickListener    * · 当启用 accessibity 时，正确处理 AccessibilityNodeInfo 中的 ACTION_CLICK 事件    *    * @param event The motion event.    * @return 如果事件被处理（消耗），就返回 true，否则返回 false。    */public boolean onTouchEvent(MotionEvent event) &#123;    final float x = event.getX();    final float y = event.getY();    final int viewFlags = mViewFlags;    final int action = event.getAction();    final boolean clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE            || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)            || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;    if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;        if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123;            setPressed(false);        &#125;        mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;        // A disabled view that is clickable still consumes the touch        // events, it just doesn&#39;t respond to them.        return clickable;    &#125;    if (mTouchDelegate != null) &#123;        if (mTouchDelegate.onTouchEvent(event)) &#123;            return true;        &#125;    &#125;    if (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) &#123;        switch (action) &#123;            case MotionEvent.ACTION_UP:                mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;                if ((viewFlags &amp; TOOLTIP) == TOOLTIP) &#123;                    handleTooltipUp();                &#125;                if (!clickable) &#123;                    removeTapCallback();                    removeLongPressCallback();                    mInContextButtonPress = false;                    mHasPerformedLongPress = false;                    mIgnoreNextUpEvent = false;                    break;                &#125;                boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0;                if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) &#123;                    // take focus if we don&#39;t have it already and we should in                    // touch mode.                    boolean focusTaken = false;                    if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123;                        focusTaken = requestFocus();                    &#125;                    if (prepressed) &#123;                        // The button is being released before we actually                        // showed it as pressed.  Make it show the pressed                        // state now (before scheduling the click) to ensure                        // the user sees it.                        setPressed(true, x, y);                    &#125;                    if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123;                        // This is a tap, so remove the longpress check                        removeLongPressCallback();                        // Only perform take click actions if we were in the pressed state                        if (!focusTaken) &#123;                            // Use a Runnable and post this rather than calling                            // performClick directly. This lets other visual state                            // of the view update before click actions start.                            if (mPerformClick == null) &#123;                                mPerformClick = new PerformClick();                            &#125;                            if (!post(mPerformClick)) &#123;                                performClickInternal();                            &#125;                        &#125;                    &#125;                    if (mUnsetPressedState == null) &#123;                        mUnsetPressedState = new UnsetPressedState();                    &#125;                    if (prepressed) &#123;                        postDelayed(mUnsetPressedState,                                ViewConfiguration.getPressedStateDuration());                    &#125; else if (!post(mUnsetPressedState)) &#123;                        // If the post failed, unpress right now                        mUnsetPressedState.run();                    &#125;                    removeTapCallback();                &#125;                mIgnoreNextUpEvent = false;                break;            case MotionEvent.ACTION_DOWN:                if (event.getSource() == InputDevice.SOURCE_TOUCHSCREEN) &#123;                    mPrivateFlags3 |= PFLAG3_FINGER_DOWN;                &#125;                mHasPerformedLongPress = false;                if (!clickable) &#123;                    checkForLongClick(                            ViewConfiguration.getLongPressTimeout(),                            x,                            y,                            TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__LONG_PRESS);                    break;                &#125;                if (performButtonActionOnTouchDown(event)) &#123;                    break;                &#125;                // Walk up the hierarchy to determine if we&#39;re inside a scrolling container.                boolean isInScrollingContainer = isInScrollingContainer();                // For views inside a scrolling container, delay the pressed feedback for                // a short period in case this is a scroll.                if (isInScrollingContainer) &#123;                    mPrivateFlags |= PFLAG_PREPRESSED;                    if (mPendingCheckForTap == null) &#123;                        mPendingCheckForTap = new CheckForTap();                    &#125;                    mPendingCheckForTap.x = event.getX();                    mPendingCheckForTap.y = event.getY();                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());                &#125; else &#123;                    // Not inside a scrolling container, so show the feedback right away                    setPressed(true, x, y);                    checkForLongClick(                            ViewConfiguration.getLongPressTimeout(),                            x,                            y,                            TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__LONG_PRESS);                &#125;                break;            case MotionEvent.ACTION_CANCEL:                if (clickable) &#123;                    setPressed(false);                &#125;                removeTapCallback();                removeLongPressCallback();                mInContextButtonPress = false;                mHasPerformedLongPress = false;                mIgnoreNextUpEvent = false;                mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;                break;            case MotionEvent.ACTION_MOVE:                if (clickable) &#123;                    drawableHotspotChanged(x, y);                &#125;                final int motionClassification = event.getClassification();                final boolean ambiguousGesture =                        motionClassification == MotionEvent.CLASSIFICATION_AMBIGUOUS_GESTURE;                int touchSlop = mTouchSlop;                if (ambiguousGesture &amp;&amp; hasPendingLongPressCallback()) &#123;                    final float ambiguousMultiplier =                            ViewConfiguration.getAmbiguousGestureMultiplier();                    if (!pointInView(x, y, touchSlop)) &#123;                        // The default action here is to cancel long press. But instead, we                        // just extend the timeout here, in case the classification                        // stays ambiguous.                        removeLongPressCallback();                        long delay = (long) (ViewConfiguration.getLongPressTimeout()                                * ambiguousMultiplier);                        // Subtract the time already spent                        delay -= event.getEventTime() - event.getDownTime();                        checkForLongClick(                                delay,                                x,                                y,                                TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__LONG_PRESS);                    &#125;                    touchSlop *= ambiguousMultiplier;                &#125;                // Be lenient about moving outside of buttons                if (!pointInView(x, y, touchSlop)) &#123;                    // Outside button                    // Remove any future long press/tap checks                    removeTapCallback();                    removeLongPressCallback();                    if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123;                        setPressed(false);                    &#125;                    mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;                &#125;                final boolean deepPress =                        motionClassification == MotionEvent.CLASSIFICATION_DEEP_PRESS;                if (deepPress &amp;&amp; hasPendingLongPressCallback()) &#123;                    // process the long click action immediately                    removeLongPressCallback();                    checkForLongClick(                            0 /* send immediately */,                            x,                            y,                            TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__DEEP_PRESS);                &#125;                break;        &#125;        return true;    &#125;    return false;&#125;</code></pre><h3 id="onInterceptTouchEvent"><a href="#onInterceptTouchEvent" class="headerlink" title="onInterceptTouchEvent"></a><code>onInterceptTouchEvent</code></h3><p><code>onInterceptTouchEvent()</code>方法在<code>ViewGroup.dispatchTouchEvent()</code>方法内部被调用，用来判断是否拦截某个事件。如果当前ViewGroup拦截了某个事件，那么在同一个事件序列当中，此方法不会被再次调用，返回结果表示是否拦截当前事件。这个方法只有ViewGroup中有，View中没有。</p><pre><code class="java">/**    * 实现该方法来拦截所有的触摸事件。这能让你监测所有发送到子view的事件，并且得到该事件的所有信息。    *    * 使用该方法的时候要小心，因为它与View.onTouchEvent()有着相当复杂的交互。    * 事件会按照下面的顺序被接收：    *    * · 按下事件(ACTION_DOWN)    * · 按下事件要么被该ViewGroup的某个子view处理，要么就进到你自己的onTouchEvent()方法去处理；    *   这意味着你在覆写onTouchEvent()时要返回 true，才能接收到接下来其他的事件（而不是由父view来接收处理)。    *   这个方法返回 true时，你不会接收到来自 onInterceptTouchEvent() 的任何事件，    *   并且接下来的触摸事件就会正常发生。    * · 只要这个方法返回了 false，接下来的事件（直到ACTION_UP并包括ACTION_UP事件）都会先经过    *   onInterceptTouchEvent，再被发送到目标view的 onTouchEvent。    * · 如果这儿返回了 true，后面就不会接收到相同的事件了（除了ACTION_CANCEL），后续的事件将被传递到你自己的 onTouchEvent()    *   并且不会再经过这儿。子view将不会再接收到任何事件。    *    * @param ev The motion event being dispatched down the hierarchy.    * @return Return true to steal motion events from the children and have    * them dispatched to this ViewGroup through onTouchEvent().    * The current target will receive an ACTION_CANCEL event, and no further    * messages will be delivered here.    */public boolean onInterceptTouchEvent(MotionEvent ev) &#123;    if (ev.isFromSource(InputDevice.SOURCE_MOUSE)            &amp;&amp; ev.getAction() == MotionEvent.ACTION_DOWN            &amp;&amp; ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY)            &amp;&amp; isOnScrollbarThumb(ev.getX(), ev.getY())) &#123;        return true;    &#125;    return false;&#125;</code></pre><p><code>onInterceptTouchEvent</code>起到作用的是分流。<code>onInterceptTouchEvent</code>返回<code>false</code>或者返回<code>super.xxx</code>是向下级View或者ViewGroup传递，返回<code>true</code>呢是把事件交给自己的<code>onTouchEvent</code>处理。</p><p>ViewGroup默认不拦截任何事件。</p><p>到此，关于事件分发的机制，就差不多了。</p><h2 id="其他几个需要注意的点"><a href="#其他几个需要注意的点" class="headerlink" title="其他几个需要注意的点"></a>其他几个需要注意的点</h2><h3 id="requestDisallowInterceptTouchEvent方法"><a href="#requestDisallowInterceptTouchEvent方法" class="headerlink" title="requestDisallowInterceptTouchEvent方法"></a>requestDisallowInterceptTouchEvent方法</h3><p><code>requestDisallowInterceptTouchEvent</code>方法用于影响父元素的事件拦截策略，<code>requestDisallowInterceptTouchEvent(true)</code>，表示不允许父元素拦截事件，这样事件就会传递给子View。一般这个方法子View用的多，可以用来处理滑动冲突问题。</p><h3 id="onTouchListener、onTouchEvent、onClickListener的优先级"><a href="#onTouchListener、onTouchEvent、onClickListener的优先级" class="headerlink" title="onTouchListener、onTouchEvent、onClickListener的优先级"></a>onTouchListener、onTouchEvent、onClickListener的优先级</h3><ol><li><p><code>onTouchListener</code>和<code>onTouchEvent</code>都在<code>dispatchTouchEvent</code>方法中被调用，<code>onClickListener</code>在<code>onTouchEvent</code>方法中被调用；</p></li><li><p><code>onTouchListener</code>的优先级高于<code>onTouchEvent</code>方法，如果<code>onTouchListener</code>的<code>onTouch</code>方法返回<code>true</code>，则<code>onTouchEvent</code>方法不会被调用，当然<code>onClickListener</code>就更不会被调用了；</p></li><li><p>在<code>onTouchEvent</code>方法中，如果当前View设置了<code>onClickListener</code>，那么<code>onClickListener</code>的<code>onClick</code>方法会被调用；</p></li><li><p>只要View的<code>clickable</code>和<code>long_clickable</code>有一个为<code>true</code>，View就会消耗当前事件，也就是说<code>onTouchEvent</code>方法最后会返回<code>true</code>。</p></li><li><p>View的<code>long_clickable</code>属性默认为<code>false</code>，而<code>clickable</code>属性和具体的View有关，可点击的View的<code>clickable</code>属性为<code>true</code>，不可点击的View的<code>clickable</code>属性为<code>false</code>。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Android Framework </tag>
            
            <tag> View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ViewRootImpl 解析</title>
      <link href="/2023-01-31/viewrootimpl/"/>
      <url>/2023-01-31/viewrootimpl/</url>
      
        <content type="html"><![CDATA[<p>之前反复提到过的DecorView不是整个View树的根吗？怎么又出来一个看起来像是『根』的东西？</p><p>我们看看ViewRootImpl的代码，就能明白Android为什么要添加两个『根』在树上。</p><span id="more"></span><p>我们先看看<code>requestLayout()</code>方法究竟在做什么：</p><pre><code class="java">// ViewRoomImpl.java@Overridepublic void requestLayout() &#123;    if (!mHandlingLayoutInLayoutRequest) &#123;        checkThread();  // 检查操作线程是否为创建线程        mLayoutRequested = true;        scheduleTraversals();    &#125;&#125;void scheduleTraversals() &#123;    if (!mTraversalScheduled) &#123;        mTraversalScheduled = true;        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();        mChoreographer.postCallback(                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);        if (!mUnbufferedInputDispatch) &#123;            scheduleConsumeBatchedInput();        &#125;        notifyRendererOfFramePending();        pokeDrawLockIfNeeded();    &#125;&#125;final class TraversalRunnable implements Runnable &#123;    @Override    public void run() &#123;        doTraversal();    &#125;&#125;void doTraversal() &#123;    if (mTraversalScheduled) &#123;        mTraversalScheduled = false;        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);        if (mProfile) &#123;            Debug.startMethodTracing(&quot;ViewAncestor&quot;);        &#125;        performTraversals();        if (mProfile) &#123;            Debug.stopMethodTracing();            mProfile = false;        &#125;    &#125;&#125;</code></pre><p>好，看到一个Android中一个比较重要的方法<code>performTraversals()</code>，实现了View树的『从根到叶』的遍历。ViewRootImpl中接收的各种变化，如来自WMS的窗口属性变化、来自控件树的尺寸变化以及重绘请求等都引发<code>performTraversals()</code>的调用，并在其中完成处理。View类及其子类的<code>onMeasure()</code>、<code>onLayout()</code>、<code>onDraw()</code>等回调也都是在该方法执行的过程中直接或间接的引发。该函数可谓是是ViewRootImpl的『心跳』。我们就来看一下这个方法。</p><pre><code class="java">private void performTraversals() &#123;    ...    boolean windowSizeMayChange = false;    boolean surfaceChanged = false;    WindowManager.LayoutParams lp = mWindowAttributes;    // I. pre-measure阶段    // 这两个变量就是DecorViewSPEC_SIZE的候选    int desiredWindowWidth;    int desiredWindowHeight;    ...    Rect frame = mWinFrame;    // 是否是『第一次遍历』    // 在ViewRootImpl的生命周期里，会有很多次的『遍历』，第一次的 desiredWindowWidth / desiredWindowHeight    // 与之后的 desiredWindowWidth / desiredWindowHeight 的测量方式是不一样的    if (mFirst) &#123;        mFullRedrawNeeded = true;        mLayoutRequested = true;        final Configuration config = mContext.getResources().getConfiguration();        if (shouldUseDisplaySize(lp)) &#123;            // NOTE -- system code, won&#39;t try to do compat mode.            Point size = new Point();            mDisplay.getRealSize(size);            desiredWindowWidth = size.x;            desiredWindowHeight = size.y;        &#125; else &#123;            // 第1次“遍历”的测量，采用了应用可以使用的最大尺寸作为SPEC_SIZE的候选            desiredWindowWidth = mWinFrame.width();            desiredWindowHeight = mWinFrame.height();        &#125;        ...    &#125; else &#123;        // 在非第1次遍历的情况下，会采用窗口的最新尺寸作为SPEC_SIZE的候选        desiredWindowWidth = frame.width();        desiredWindowHeight = frame.height();        //如果窗口的最新尺寸与ViewRootImpl中的现有尺寸不同，说明WMS单方面改变了窗口的尺寸，将导致下面三个结果        if (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) &#123;        //需要完整的重绘以适应新的窗口尺寸        mFullRedrawNeeded = true;        //需要对控件树重新布局        mLayoutRequested = true;        //控件树可能拒绝接受新的窗口尺寸，可能需要窗口在布局阶段尝试设置新的窗口尺寸。只是尝试嘛，尝试而已        windowSizeMayChange = true;        &#125;    &#125;    ...    boolean layoutRequested = mLayoutRequested &amp;&amp; (!mStopped || mReportNextDraw);    if (layoutRequested) &#123;        final Resources res = mView.getContext().getResources();        if (mFirst) &#123;            ...        &#125; else &#123;            // 检查WMS是否单方面改变了一些参数，标记下来，然后作为之后是否进行控件布局的条件之一            // 如果窗口的width或height被指定为WRAP_CONTENT时。表示该窗口为悬浮窗口            if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT                    || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) &#123;                // 标记一下，WMS单方面改变了一些参数                windowSizeMayChange = true;                if (shouldUseDisplaySize(lp)) &#123;                    // NOTE -- system code, won&#39;t try to do compat mode.                    Point size = new Point();                    mDisplay.getRealSize(size);                    desiredWindowWidth = size.x;                    desiredWindowHeight = size.y;                &#125; else &#123;                    Configuration config = res.getConfiguration();                    desiredWindowWidth = dipToPx(config.screenWidthDp);                    desiredWindowHeight = dipToPx(config.screenHeightDp);                &#125;            &#125;        &#125;        // 测量        windowSizeMayChange |= measureHierarchy(host, lp, res,                desiredWindowWidth, desiredWindowHeight);    &#125;    ...    if (layoutRequested) &#123;        // 如果后面还有layout的请求的话，用这个FLAG来标记，然后再重新来一次layout        // 所以现在先置为false        mLayoutRequested = false;    &#125;    boolean windowShouldResize = layoutRequested &amp;&amp; windowSizeMayChange        &amp;&amp; ((mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight())            || (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT &amp;&amp;                    frame.width() &lt; desiredWindowWidth &amp;&amp; frame.width() != mWidth)            || (lp.height == ViewGroup.LayoutParams.WRAP_CONTENT &amp;&amp;                    frame.height() &lt; desiredWindowHeight &amp;&amp; frame.height() != mHeight));    windowShouldResize |= mDragResizing &amp;&amp; mResizeMode == RESIZE_MODE_FREEFORM;    ...    // I. pre-measure阶段结束    // II. 窗口layout阶段    if (mFirst || windowShouldResize || insetsChanged ||            viewVisibilityChanged || params != null || mForceNextWindowRelayout) &#123;        ...        boolean hadSurface = mSurface.isValid();        try &#123;            ...            relayoutResult = relayoutWindow(params, viewVisibility, insetsPending);            ...        &#125; catch (RemoteException e) &#123;        &#125;        ...        // II. 窗口layout阶段结束        // III. measure阶段        if (!mStopped || mReportNextDraw) &#123;            boolean focusChangedDueToTouchMode = ensureTouchModeLocally(                    (relayoutResult&amp;WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != 0);            if (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth()                    || mHeight != host.getMeasuredHeight() || contentInsetsChanged ||                    updatedConfiguration) &#123;                int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);                int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);                if (DEBUG_LAYOUT) Log.v(mTag, &quot;Ooops, something changed!  mWidth=&quot;                        + mWidth + &quot; measuredWidth=&quot; + host.getMeasuredWidth()                        + &quot; mHeight=&quot; + mHeight                        + &quot; measuredHeight=&quot; + host.getMeasuredHeight()                        + &quot; coveredInsetsChanged=&quot; + contentInsetsChanged);                // 这里其实就是调用了View.measure()方法                performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);                // Implementation of weights from WindowManager.LayoutParams                // We just grow the dimensions as needed and re-measure if                // needs be                int width = host.getMeasuredWidth();                int height = host.getMeasuredHeight();                boolean measureAgain = false;                if (lp.horizontalWeight &gt; 0.0f) &#123;                    width += (int) ((mWidth - width) * lp.horizontalWeight);                    childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(width,                            MeasureSpec.EXACTLY);                    measureAgain = true;                &#125;                if (lp.verticalWeight &gt; 0.0f) &#123;                    height += (int) ((mHeight - height) * lp.verticalWeight);                    childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(height,                            MeasureSpec.EXACTLY);                    measureAgain = true;                &#125;                if (measureAgain) &#123;                    if (DEBUG_LAYOUT) Log.v(mTag,                            &quot;And hey let&#39;s measure once more: width=&quot; + width                            + &quot; height=&quot; + height);                    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);                &#125;                layoutRequested = true;            &#125;        &#125;    &#125; else &#123;        // Not the first pass and no window/insets/visibility change but the window        // may have moved and we need check that and if so to update the left and right        // in the attach info. We translate only the window frame since on window move        // the window manager tells us only for the new frame but the insets are the        // same and we do not want to translate them more than once.        maybeHandleWindowMove(frame);    &#125;    if (surfaceSizeChanged) &#123;        updateBoundsSurface();    &#125;    // III. measure阶段结束    // IV. layout阶段开始    final boolean didLayout = layoutRequested &amp;&amp; (!mStopped || mReportNextDraw);    ...    if (didLayout) &#123;        // 进行layout过程        performLayout(lp, mWidth, mHeight);        // By this point all views have been sized and positioned        // We can compute the transparent area        if ((host.mPrivateFlags &amp; View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) &#123;            // start out transparent            // TODO: AVOID THAT CALL BY CACHING THE RESULT?            host.getLocationInWindow(mTmpLocation);            mTransparentRegion.set(mTmpLocation[0], mTmpLocation[1],                    mTmpLocation[0] + host.mRight - host.mLeft,                    mTmpLocation[1] + host.mBottom - host.mTop);            host.gatherTransparentRegion(mTransparentRegion);            if (mTranslator != null) &#123;                mTranslator.translateRegionInWindowToScreen(mTransparentRegion);            &#125;            if (!mTransparentRegion.equals(mPreviousTransparentRegion)) &#123;                mPreviousTransparentRegion.set(mTransparentRegion);                mFullRedrawNeeded = true;                // reconfigure window manager                try &#123;                    mWindowSession.setTransparentRegion(mWindow, mTransparentRegion);                &#125; catch (RemoteException e) &#123;                &#125;            &#125;        &#125;        if (DBG) &#123;            System.out.println(&quot;======================================&quot;);            System.out.println(&quot;performTraversals -- after setFrame&quot;);            host.debug();        &#125;    &#125;    // IV. layout阶段结束    // V. draw过程开始    boolean cancelDraw = mAttachInfo.mTreeObserver.dispatchOnPreDraw() || !isViewVisible;    if (!cancelDraw) &#123;        if (mPendingTransitions != null &amp;&amp; mPendingTransitions.size() &gt; 0) &#123;            for (int i = 0; i &lt; mPendingTransitions.size(); ++i) &#123;                mPendingTransitions.get(i).startChangingAnimations();            &#125;            mPendingTransitions.clear();        &#125;        performDraw();    &#125; else &#123;        if (isViewVisible) &#123;            // Try again            scheduleTraversals();        &#125; else if (mPendingTransitions != null &amp;&amp; mPendingTransitions.size() &gt; 0) &#123;            for (int i = 0; i &lt; mPendingTransitions.size(); ++i) &#123;                mPendingTransitions.get(i).endChangingAnimations();            &#125;            mPendingTransitions.clear();        &#125;    &#125;    mIsInTraversal = false;    // V. draw过程结束&#125;</code></pre><p>好吧，我承认，这是我见过的最长的方法了。只能给它分为几个重要阶段，并提炼一下，无法进行太详细的分析了。</p><p>I. pre-measure阶段</p><p>这是第一个阶段，它会对控件树进行第一次测量。在此阶段中将会计算出控件树为显示其内容所需的尺寸，即期望的窗口尺寸。在这个阶段中View及其子类的<code>onMeasure()</code>方法将会沿着控件树依次得到回调。</p><p>预测量也是一次完整的测量过程，它与最终测量的区别仅在于参数不同而已。实际的测量工作是在View或其子类的<code>onMeasure()</code>方法中完成，并且其测量结果需要受限于来自其父控件的指示。这个指示由<code>onMeasure()</code>方法中的两个参数进行传达：<code>widthSpec</code>和<code>heightSpec</code>。它们是被称为MeasureSpec的复合整型变量，用于指导控件对自身进行测量。它又两个分量，结构如下表：</p><table class="table is-bordered is-narrow">    <thead>        <tr>            <th><abbr>32, 31</abbr></th>            <th><abbr>30 ... 1</abbr></th>        </tr>    </thead>    <tbody>        <tr>            <td>SPEC_MODE</td>            <td>SPEC_SIZE</td>        </tr>    </tbody></table><p>其实就是个32位的整型，高2位用于储存它的类型，后30位用于储存它的内容。</p><p>I、II、III三个阶段可知预测量时的SPEC_SIZE按照如下原则进行取值：</p><ul><li>第一次“遍历”时，使用可用的最大尺寸作为SPEC_SIZE的候选</li><li>此窗口是一个悬浮窗口时，即LayoutParams.width/height其中之一被指定为WRAP_CONTENT时，使用可用的最大尺寸作为SPEC_SIZE的候选</li><li>其他情况下，使用窗口最新尺寸作为SPEC_SIZE的候选</li></ul>]]></content>
      
      
      <categories>
          
          <category> Development </category>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Android Framework </tag>
            
            <tag> View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Retrofit 实现原理解析</title>
      <link href="/2023-01-31/retrofit/"/>
      <url>/2023-01-31/retrofit/</url>
      
        <content type="html"><![CDATA[<p><a href="https://square.github.io/retrofit/">Retrofit</a> 是现在比较常用的网络请求库了，它的可扩展性强，底层网络请求集成了 Okhttp，异步处理可集成 RxJava，内容解析可集成 Gson，Jackson 等。而且全面支持 Restful 请求，并且通过注解的方式，支持链式调用，使用简洁方便。<br>精妙的源码设计模式，内部层次分工明确，解耦性强。</p><p>它的使用核心是实现一个 Java 接口，用注解的方式来指定各种网络请求中的字段、方法等。</p><span id="more"></span><p>拿官网的例子来说明：</p><h2 id="活生生的例子"><a href="#活生生的例子" class="headerlink" title="活生生的例子"></a>活生生的例子</h2><pre><code class="java">public interface GitHubService &#123;  @GET(&quot;users/&#123;user&#125;/repos&quot;)  Call&lt;List&lt;Repo&gt;&gt; listRepos(@Path(&quot;user&quot;) String user);&#125;</code></pre><p>上面的例子，用了两个注解，分别是<code>@GET</code>和<code>@Path</code>，由字面意思也可以看出，<code>@GET</code>是指该方法是HTTP请求中的GET方法，<code>@Path(&quot;user&quot;)</code>是指将请求URL中的<code>&#123;user&#125;</code>部分替换为传入的<code>user</code>参数。</p><p>我们来看看这两个注解的源码：</p><pre><code class="java">// retrofit2.http.GET.java/** Make a GET request. */@Documented@Target(METHOD)@Retention(RUNTIME)public @interface GET &#123;  /**   * A relative or absolute path, or full URL of the endpoint. This value is optional if the first   * parameter of the method is annotated with &#123;@link Url @Url&#125;.   * &lt;p&gt;   * See &#123;@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL&#125; for details of how   * this is resolved against a base URL to create the full endpoint URL.   */  String value() default &quot;&quot;;&#125;</code></pre><p>它使用了三个元注解，不再多解释。它的<code>value</code>指的是请求中的绝对/相对路径。</p><pre><code class="java">// retrofit2.http.Path.java@Documented@Retention(RUNTIME)@Target(PARAMETER)public @interface Path &#123;  String value();  /**   * Specifies whether the argument value to the annotated method parameter is already URL encoded.   */  boolean encoded() default false;&#125;</code></pre><p>它有两个参数，一个是value，一个是是否已经经过URL encoded。</p><p>那么，retrofit是如何将注解使用起来的呢？我们来看看它的原理。</p><h2 id="Retrofit-实现原理"><a href="#Retrofit-实现原理" class="headerlink" title="Retrofit 实现原理"></a>Retrofit 实现原理</h2><p>先上一张图，简单了解一下它的整体流程：</p><p><img src="/img/27.png"></p><p>在创建Retrofit实例时，我们一般会按照下面的方式来创建实例：</p><pre><code class="java">Retrofit retrofit = new Retrofit.Builder()    .baseUrl(&quot;https://api.github.com/&quot;)    .build();GitHubService service = retrofit.create(GitHubService.class);</code></pre><p><code>build()</code>方法其实就是Java中比较典型的Builder设计模式，不过多解释，我们直接来看<code>create()</code>的源代码：</p><pre><code class="java">// retrofit2.Retrofit.java@SuppressWarnings(&quot;unchecked&quot;)public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123;    // 检查接口可用性    validateServiceInterface(service);    // 使用动态代理的方式创建一个 service 的实例    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;,        new InvocationHandler() &#123;            private final Platform platform = Platform.get();            private final Object[] emptyArgs = new Object[0];            @Override public @Nullable Object invoke(Object proxy, Method method,                @Nullable Object[] args) throws Throwable &#123;                // 如果 method 是 Object 的方法，那么就正常调用                if (method.getDeclaringClass() == Object.class) &#123;                    return method.invoke(this, args);                &#125;                // 一般情况下 Android 的 Platform.isDefaultMethod() 都会返回 false                if (platform.isDefaultMethod(method)) &#123;                    return platform.invokeDefaultMethod(method, service, proxy, args);                &#125;                // 所以真正起作用的，还是这一句                return loadServiceMethod(method).invoke(args != null ? args : emptyArgs);            &#125;        &#125;    );&#125;</code></pre><p>我们从这几行代码可以看出，Retrofit 是使用了动态代理的方式创建了一个实现service接口的对象，当外部调用 service 接口方法，会调用invoke方法，然后加载当前 method 对应的 ServiceMethod，并调用该 ServiceMethod 的 invoke。ServiceMethod 是个抽象类，那么，这里实际上是调用了 ServiceMethod 某一个实现类的 invoke 方法。具体的我们会在后面分析。</p><p>先看看<code>validateServiceInterface()</code>方法：</p><pre><code class="java">// retrofit2.Retrofit.javaprivate void validateServiceInterface(Class&lt;?&gt; service) &#123;    if (!service.isInterface()) &#123;      throw new IllegalArgumentException(&quot;API declarations must be interfaces.&quot;);    &#125;    // Deque是Java1.6之后加入的『双向队列』，也即能从两个方向向外拿出数据    Deque&lt;Class&lt;?&gt;&gt; check = new ArrayDeque&lt;&gt;(1);    check.add(service);    while (!check.isEmpty()) &#123;        // 获取该service的类        Class&lt;?&gt; candidate = check.removeFirst();        // getTypeParameters() 方法用于获取该类的声明中的参数列表        // 这里要保证这个接口类没有任何的参数        if (candidate.getTypeParameters().length != 0) &#123;            StringBuilder message = new StringBuilder(&quot;Type parameters are unsupported on &quot;)                .append(candidate.getName());            if (candidate != service) &#123;                message.append(&quot; which is an interface of &quot;)                    .append(service.getName());                        throw new IllegalArgumentException(message.toString());        &#125;        // 将该service下所有的接口添加到check中        Collections.addAll(check, candidate.getInterfaces());    &#125;    // 如果配置了validateEagerly，则提前加载 method 对应的 ServiceMethod。    // 此处调用 loadServiceMethod() 方法，其实是在做一个预处理的操作，只是提前创建了一些 ServiceMethod 对象在缓存中。    if (validateEagerly) &#123;        Platform platform = Platform.get();        for (Method method : service.getDeclaredMethods()) &#123;            if (!platform.isDefaultMethod(method) &amp;&amp; !Modifier.isStatic(method.getModifiers())) &#123;                loadServiceMethod(method);            &#125;        &#125;    &#125;&#125;</code></pre><p>接下来看看在<code>create()</code>和<code>validateServiceInterface()</code>都会调用到的<code>loadServiceMethod()</code>方法：</p><pre><code class="java">// 所有的 Method 都被存在一个 ConcurrentHashMap 中，避免同步问题private final Map&lt;Method, ServiceMethod&lt;?&gt;&gt; serviceMethodCache = new ConcurrentHashMap&lt;&gt;();// 该方法的主要目的有两个：// 1. 解析该 method 上的所有注解，并以 method - ServiceMethod 的形式放入缓存中，等待调用// 2. 根据该 method 找到对应的 ServiceMethod，并返回ServiceMethod&lt;?&gt; loadServiceMethod(Method method) &#123;    ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method);    if (result != null) return result;    synchronized (serviceMethodCache) &#123;      result = serviceMethodCache.get(method);      if (result == null) &#123;        // 此处 result 已经是 ServiceMethod 实现类 HttpSercieMethod 的实例        result = ServiceMethod.parseAnnotations(this, method);        serviceMethodCache.put(method, result);      &#125;    &#125;    return result;&#125;</code></pre><p>ServiceMethod 是 Retrofit 的一个抽象类，我们来看看它的源代码：</p><pre><code class="java">// retrofit2.ServiceMethod.javaabstract class ServiceMethod&lt;T&gt; &#123;    static &lt;T&gt; ServiceMethod&lt;T&gt; parseAnnotations(Retrofit retrofit, Method method) &#123;        RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);        Type returnType = method.getGenericReturnType();        if (Utils.hasUnresolvableType(returnType)) &#123;            throw methodError(method,                &quot;Method return type must not include a type variable or wildcard: %s&quot;, returnType);        &#125;        if (returnType == void.class) &#123;            throw methodError(method, &quot;Service methods cannot return void.&quot;);        &#125;        return HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);    &#125;    abstract @Nullable T invoke(Object[] args);&#125;</code></pre><p>RequestFactory是比较重要的一个类，它负责解析注解、构造 request 等，在后面会直接与okhttp进行交互，我们来看看它的源码：</p><pre><code class="java">final class RequestFactory &#123;    static RequestFactory parseAnnotations(Retrofit retrofit, Method method) &#123;        return new Builder(retrofit, method).build();    &#125;    // 储存 request 的一些数据    private final Method method;    private final HttpUrl baseUrl;    final String httpMethod;    private final @Nullable String relativeUrl;    private final @Nullable Headers headers;    private final @Nullable MediaType contentType;    private final boolean hasBody;    private final boolean isFormEncoded;    private final boolean isMultipart;    private final ParameterHandler&lt;?&gt;[] parameterHandlers;    final boolean isKotlinSuspendFunction;    ...    /**     * 检查接口中方法上的注解，来构造一个可复用的 service 方法。     * 这个操作需要调用反射机制，所以每个 service 方法最好只构造一次，然后复用之。     * Builder 不能复用。     */    static final class Builder &#123;        private static final String PARAM = &quot;[a-zA-Z][a-zA-Z0-9_-]*&quot;;        private static final Pattern PARAM_URL_REGEX = Pattern.compile(&quot;\\&#123;(&quot; + PARAM + &quot;)\\&#125;&quot;);        private static final Pattern PARAM_NAME_REGEX = Pattern.compile(PARAM);        ...        Builder(Retrofit retrofit, Method method) &#123;            this.retrofit = retrofit;            this.method = method;            // 获取方法上的注解            this.methodAnnotations = method.getAnnotations();            // 获取方法上的参数类型            this.parameterTypes = method.getGenericParameterTypes();            // 获取参数上的注解            this.parameterAnnotationsArray = method.getParameterAnnotations();        &#125;        RequestFactory build() &#123;            // 解析 method 上的所有注解            for (Annotation annotation : methodAnnotations) &#123;                parseMethodAnnotation(annotation);            &#125;            ...            // 各种 method 注解的检查            ...            // 解析 paremater 上的所有注解            int parameterCount = parameterAnnotationsArray.length;            parameterHandlers = new ParameterHandler&lt;?&gt;[parameterCount];            for (int p = 0, lastParameter = parameterCount - 1; p &lt; parameterCount; p++) &#123;                // 并添加到一个 ParamaterHandler 的 Array 中                parameterHandlers[p] =                    parseParameter(p, parameterTypes[p], parameterAnnotationsArray[p], p == lastParameter);            &#125;            ...            // 各种 parameter 注解的检查            ...            return new RequestFactory(this);        &#125;    &#125;    // 解析 method 上的注解    private void parseMethodAnnotation(Annotation annotation) &#123;        ...        // 这里的 DELETE GET 等，都是 retrofit 自定义的各种 Http 请求类型的注解        if (annotation instanceof DELETE) &#123;            parseHttpMethodAndPath(&quot;DELETE&quot;, ((DELETE) annotation).value(), false);        &#125; else if (annotation instanceof GET) &#123;            parseHttpMethodAndPath(&quot;GET&quot;, ((GET) annotation).value(), false);        &#125; ...    &#125;    // 解析 method 上注解的详细数据    private void parseHttpMethodAndPath(String httpMethod, String value, boolean hasBody) &#123;        if (this.httpMethod != null) &#123;            throw methodError(method, &quot;Only one HTTP method is allowed. Found: %s and %s.&quot;,                this.httpMethod, httpMethod);        &#125;        this.httpMethod = httpMethod;        this.hasBody = hasBody;        if (value.isEmpty()) &#123;            return;        &#125;        // 获取 URL 的相对路径，如果有 ? 参数的话，就获取一下        int question = value.indexOf(&#39;?&#39;);        if (question != -1 &amp;&amp; question &lt; value.length() - 1) &#123;            // Ensure the query string does not have any named parameters.            String queryParams = value.substring(question + 1);            Matcher queryParamMatcher = PARAM_URL_REGEX.matcher(queryParams);            if (queryParamMatcher.find()) &#123;            throw methodError(method, &quot;URL query string \&quot;%s\&quot; must not have replace block. &quot;                + &quot;For dynamic query parameters use @Query.&quot;, queryParams);            &#125;        &#125;        // 拿到注解中的 value，此为 relativeUrl        this.relativeUrl = value;        // 解析参数们        this.relativeUrlParamNames = parsePathParameters(value);    &#125;    // 解析参数    private @Nullable ParameterHandler&lt;?&gt; parseParameter(        int p, Type parameterType, @Nullable Annotation[] annotations, boolean allowContinuation) &#123;        ParameterHandler&lt;?&gt; result = null;        if (annotations != null) &#123;            for (Annotation annotation : annotations) &#123;                // 解析参数的注解                ParameterHandler&lt;?&gt; annotationAction =                    parseParameterAnnotation(p, parameterType, annotations, annotation);                if (annotationAction == null) &#123;                    continue;                &#125;                if (result != null) &#123;                    throw parameterError(method, p,                        &quot;Multiple Retrofit annotations found, only one allowed.&quot;);                &#125;                result = annotationAction;            &#125;        &#125;        if (result == null) &#123;            if (allowContinuation) &#123;                try &#123;                    if (Utils.getRawType(parameterType) == Continuation.class) &#123;                        isKotlinSuspendFunction = true;                        return null;                    &#125;                &#125; catch (NoClassDefFoundError ignored) &#123;                &#125;            &#125;            throw parameterError(method, p, &quot;No Retrofit annotation found.&quot;);        &#125;        return result;    &#125;    @Nullable    private ParameterHandler&lt;?&gt; parseParameterAnnotation(        int p, Type type, Annotation[] annotations, Annotation annotation) &#123;        // 这里的 Url Path Query 等，是 retrofit 自定义的注解，通过字符串解析等各种方式，来组成正确的 ParameterHandler        if (annotation instanceof Url) &#123;            ...            return new ParameterHandler.RelativeUrl(method, p);            ...        &#125; else if (annotation instanceof Path) &#123;            ...            return new ParameterHandler.Path&lt;&gt;(method, p, name, converter, path.encoded());            ...        &#125; else if (annotation instanceof Query) &#123;            // 注意三种不同的返回值            Class&lt;?&gt; rawParameterType = Utils.getRawType(type);            gotQuery = true;            if (Iterable.class.isAssignableFrom(rawParameterType)) &#123;                if (!(type instanceof ParameterizedType)) &#123;                    throw parameterError(method, p, rawParameterType.getSimpleName()                        + &quot; must include generic type (e.g., &quot;                        + rawParameterType.getSimpleName()                        + &quot;&lt;String&gt;)&quot;);                &#125;                ParameterizedType parameterizedType = (ParameterizedType) type;                Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);                Converter&lt;?, String&gt; converter =                    retrofit.stringConverter(iterableType, annotations);                return new ParameterHandler.Query&lt;&gt;(name, converter, encoded).iterable();            &#125; else if (rawParameterType.isArray()) &#123;                Class&lt;?&gt; arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());                Converter&lt;?, String&gt; converter =                    retrofit.stringConverter(arrayComponentType, annotations);                return new ParameterHandler.Query&lt;&gt;(name, converter, encoded).array();            &#125; else &#123;                Converter&lt;?, String&gt; converter =                    retrofit.stringConverter(type, annotations);                return new ParameterHandler.Query&lt;&gt;(name, converter, encoded);            &#125;        &#125; else if (annotation instanceof Header) &#123;            ...            return new ParameterHandler.Header&lt;&gt;(name, converter);            ...        &#125; else if (annotation instanceof Field) &#123;            ...            return new ParameterHandler.Field&lt;&gt;(name, converter, encoded);            ...        &#125; else if (annotation instanceof Body) &#123;            ...            return new ParameterHandler.Body&lt;&gt;(method, p, converter);        &#125;        ...        return null; // Not a Retrofit annotation.    &#125;&#125;</code></pre><p>从这几部分代码可以看出，最后RequestFactory的实例中，包含的是：</p><ul><li>HTTP 请求的 BaseUrl</li><li>HTTP 请求的 RelativeUrl</li><li>HTTP 请求的方法</li><li>HTTP 请求的参数列表（可选）</li><li>HTTP 请求的 Body（可选）</li><li>HTTP 请求的 Headers（可选）</li><li>ParameterHandler 的 Array</li></ul><p>这ParameterHandler是什么呢？我们来看看它的代码：</p><pre><code class="java">// retrofit2.ParameterHandler.javaabstract class ParameterHandler&lt;T&gt; &#123;    abstract void apply(RequestBuilder builder, @Nullable T value) throws IOException;    final ParameterHandler&lt;Iterable&lt;T&gt;&gt; iterable() &#123;        return new ParameterHandler&lt;Iterable&lt;T&gt;&gt;() &#123;            @Override void apply(RequestBuilder builder, @Nullable Iterable&lt;T&gt; values)                throws IOException &#123;                if (values == null) return; // Skip null values.                for (T value : values) &#123;                    ParameterHandler.this.apply(builder, value);                &#125;            &#125;        &#125;;    &#125;    final ParameterHandler&lt;Object&gt; array() &#123;        return new ParameterHandler&lt;Object&gt;() &#123;            @Override void apply(RequestBuilder builder, @Nullable Object values) throws IOException &#123;                if (values == null) return; // Skip null values.                for (int i = 0, size = Array.getLength(values); i &lt; size; i++) &#123;                    //noinspection unchecked                    ParameterHandler.this.apply(builder, (T) Array.get(values, i));                &#125;            &#125;        &#125;;    &#125;    // 一个 ParameterHandler的具体实现类    // 包含 Method 和 index    static final class RelativeUrl extends ParameterHandler&lt;Object&gt; &#123;        private final Method method;        private final int p;        RelativeUrl(Method method, int p) &#123;            this.method = method;            this.p = p;        &#125;        @Override void apply(RequestBuilder builder, @Nullable Object value) &#123;            if (value == null) &#123;                throw Utils.parameterError(method, p, &quot;@Url parameter is null.&quot;);            &#125;            builder.setRelativeUrl(value);        &#125;    &#125;&#125;</code></pre><p>可以看出，每一种 retrofit 自定义的注解（GET、POST、FIELD、Path）等，最终都会转化成一个 ParameterHandler 的实例，并实现 <code>apply()</code> 方法。<code>apply()</code>方法中会传入 RequestBuild 的实例，这是产生 Request 的倒数第二步。</p><p>好，说了这么一大圈，我们还是得回到 ServiceMethod 类中。</p><p>生成了 RequestFactory 实例后，利用这个实例，又调用了 <code>HttpServiceMethod.parseAnnotations()</code>方法，我们来看看这个类，以及其包含的方法：</p><pre><code class="java">// retrofit2.HttpServiceMethod.java/** Adapts an invocation of an interface method into an HTTP call. */// 这是 ServiceMethod 的唯一实现类abstract class HttpServiceMethod&lt;ResponseT, ReturnT&gt; extends ServiceMethod&lt;ReturnT&gt; &#123;            static &lt;ResponseT, ReturnT&gt; HttpServiceMethod&lt;ResponseT, ReturnT&gt; parseAnnotations(        Retrofit retrofit, Method method, RequestFactory requestFactory) &#123;        boolean isKotlinSuspendFunction = requestFactory.isKotlinSuspendFunction;        boolean continuationWantsResponse = false;        boolean continuationBodyNullable = false;        Annotation[] annotations = method.getAnnotations();        Type adapterType;        ...        // ❶ 一个比较核心的方法，也是 retrofit 的灵魂所在，我们在后面要详细解释        CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter =            createCallAdapter(retrofit, method, adapterType, annotations);        Type responseType = callAdapter.responseType();                ...        // 各种检查        ...        // ❷ retrofit 的另一个重要特性『Converters』，可以自动反序列化返回的数据        Converter&lt;ResponseBody, ResponseT&gt; responseConverter =            createResponseConverter(retrofit, method, responseType);        okhttp3.Call.Factory callFactory = retrofit.callFactory;                if (!isKotlinSuspendFunction) &#123;            return new CallAdapted&lt;&gt;(requestFactory, callFactory, responseConverter, callAdapter);        &#125; else if (continuationWantsResponse) &#123;            // 与 kotlin 协程有关的一些东西，后面再讲            // noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.            return (HttpServiceMethod&lt;ResponseT, ReturnT&gt;) new SuspendForResponse&lt;&gt;(requestFactory,                callFactory, responseConverter, (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter);        &#125; else &#123;            // 与 kotlin 协程有关的一些东西，后面再讲            // noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.            return (HttpServiceMethod&lt;ResponseT, ReturnT&gt;) new SuspendForBody&lt;&gt;(requestFactory,                callFactory, responseConverter, (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter,                continuationBodyNullable);        &#125;    &#125;    private static &lt;ResponseT, ReturnT&gt; CallAdapter&lt;ResponseT, ReturnT&gt; createCallAdapter(        Retrofit retrofit, Method method, Type returnType, Annotation[] annotations) &#123;        try &#123;            // noinspection unchecked            return (CallAdapter&lt;ResponseT, ReturnT&gt;) retrofit.callAdapter(returnType, annotations);        &#125; catch (RuntimeException e) &#123; // Wide exception range because factories are user code.            throw methodError(method, e, &quot;Unable to create call adapter for %s&quot;, returnType);        &#125;    &#125;    private static &lt;ResponseT&gt; Converter&lt;ResponseBody, ResponseT&gt; createResponseConverter(        Retrofit retrofit, Method method, Type responseType) &#123;        Annotation[] annotations = method.getAnnotations();        try &#123;            return retrofit.responseBodyConverter(responseType, annotations);        &#125; catch (RuntimeException e) &#123; // Wide exception range because factories are user code.            throw methodError(method, e, &quot;Unable to create converter for %s&quot;, responseType);        &#125;    &#125;    // 在 Retrofit.create() 方法的最后一句，调用的 invoke()，其实就是调用的这里    @Override final @Nullable ReturnT invoke(Object[] args) &#123;        Call&lt;ResponseT&gt; call = new OkHttpCall&lt;&gt;(requestFactory, args, callFactory, responseConverter);        return adapt(call, args);    &#125;    // 抽象方法，由 CallAdapted、SuspendForResponse、SuspendForBody 来实现    protected abstract @Nullable ReturnT adapt(Call&lt;ResponseT&gt; call, Object[] args);    static final class CallAdapted&lt;ResponseT, ReturnT&gt; extends HttpServiceMethod&lt;ResponseT, ReturnT&gt; &#123;        private final CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter;        CallAdapted(RequestFactory requestFactory, okhttp3.Call.Factory callFactory,            Converter&lt;ResponseBody, ResponseT&gt; responseConverter,            CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter) &#123;        super(requestFactory, callFactory, responseConverter);            this.callAdapter = callAdapter;        &#125;        @Override protected ReturnT adapt(Call&lt;ResponseT&gt; call, Object[] args) &#123;            return callAdapter.adapt(call);        &#125;    &#125;    static final class SuspendForResponse&lt;ResponseT&gt; extends HttpServiceMethod&lt;ResponseT, Object&gt; &#123;        private final CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt; callAdapter;        SuspendForResponse(RequestFactory requestFactory, okhttp3.Call.Factory callFactory,            Converter&lt;ResponseBody, ResponseT&gt; responseConverter,            CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt; callAdapter) &#123;        super(requestFactory, callFactory, responseConverter);            this.callAdapter = callAdapter;        &#125;        @Override protected Object adapt(Call&lt;ResponseT&gt; call, Object[] args) &#123;            call = callAdapter.adapt(call);            //noinspection unchecked Checked by reflection inside RequestFactory.            Continuation&lt;Response&lt;ResponseT&gt;&gt; continuation =                (Continuation&lt;Response&lt;ResponseT&gt;&gt;) args[args.length - 1];            // See SuspendForBody for explanation about this try/catch.            try &#123;                return KotlinExtensions.awaitResponse(call, continuation);            &#125; catch (Exception e) &#123;                return KotlinExtensions.suspendAndThrow(e, continuation);            &#125;        &#125;    &#125;&#125;</code></pre><p>HttpServiceMethod类的主要功能，是创建了一个 CallAdapter 对象，这个对象是用来把 OkHttpCall 适配为我们定义的方法的返回值类型的；创建 Converter 对象，用于把 ResponseBody 转换为我们最终需要的类型；生成 HttpServiceMethod 的三种派生类其中一种的实例，返回并放到 serviceMethodCashe 中。</p><p>上面的代码中有两处比较重要的地方，用序号标注了出来，我们来单独讲讲：</p><h2 id="灵魂-❶-CallAdapter"><a href="#灵魂-❶-CallAdapter" class="headerlink" title="灵魂 ❶ CallAdapter"></a>灵魂 ❶ CallAdapter</h2><p>跟着<code>retrofit.callAdapter()</code>向下走，我们看到了它的代码：</p><pre><code class="java">// retrofit2.Retrofit.javapublic CallAdapter&lt;?, ?&gt; callAdapter(Type returnType, Annotation[] annotations) &#123;    return nextCallAdapter(null, returnType, annotations);&#125;public CallAdapter&lt;?, ?&gt; nextCallAdapter(@Nullable CallAdapter.Factory skipPast, Type returnType,      Annotation[] annotations) &#123;    ...    // callAdapterFactories 在 Builder.build() 中添加，见下    int start = callAdapterFactories.indexOf(skipPast) + 1;    for (int i = start, count = callAdapterFactories.size(); i &lt; count; i++) &#123;        CallAdapter&lt;?, ?&gt; adapter = callAdapterFactories.get(i).get(returnType, annotations, this);        if (adapter != null) &#123;            return adapter;        &#125;    &#125;    // 如果在上面还没有 return，则处理一些错误    ...&#125;public static final class Builder &#123;    Builder(Retrofit retrofit) &#123;        // 不要添加默认的、build() 方法里添加的的平台相关的 CallAdapter        for (int i = 0,            size = retrofit.callAdapterFactories.size() - platform.defaultCallAdapterFactoriesSize();            i &lt; size; i++) &#123;            callAdapterFactories.add(retrofit.callAdapterFactories.get(i));        &#125;    &#125;    public Retrofit build() &#123;        ...        // 初始化 okhttoclient 等等        ...        // 执行器        Executor callbackExecutor = this.callbackExecutor;        if (callbackExecutor == null) &#123;            callbackExecutor = platform.defaultCallbackExecutor();        &#125;        // 添加平台相关的 CallAdapter        List&lt;CallAdapter.Factory&gt; callAdapterFactories = new ArrayList&lt;&gt;(this.callAdapterFactories);        callAdapterFactories.addAll(platform.defaultCallAdapterFactories(callbackExecutor));        ...        // 返回 Retrofit 实例        return new Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories),            unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);    &#125;&#125;</code></pre><p>再看看Platform.defaultCallAdapterFactories()做了些什么：</p><pre><code class="java">// retrofit.Platform.javaList&lt;? extends CallAdapter.Factory&gt; defaultCallAdapterFactories(    @Nullable Executor callbackExecutor) &#123;    DefaultCallAdapterFactory executorFactory = new DefaultCallAdapterFactory(callbackExecutor);    // Android 中 Build.VERSION.SDK_INT &gt;= 24 时，hasJava8Types会被置为true    return hasJava8Types        ? asList(CompletableFutureCallAdapterFactory.INSTANCE, executorFactory)        : singletonList(executorFactory);&#125;</code></pre><p>然后我们看看 DefautCallAdapterFactory 类，顾名思义，它是创建 CallAdapter 的一个工厂类：</p><pre><code class="java">// retrofit2.DefaultCallAdapterFactory.javafinal class DefaultCallAdapterFactory extends CallAdapter.Factory &#123;    ...    @Override public @Nullable CallAdapter&lt;?, ?&gt; get(        Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;        if (getRawType(returnType) != Call.class) &#123;            return null;        &#125;        if (!(returnType instanceof ParameterizedType)) &#123;            throw new IllegalArgumentException(                &quot;Call return type must be parameterized as Call&lt;Foo&gt; or Call&lt;? extends Foo&gt;&quot;);        &#125;        final Type responseType = Utils.getParameterUpperBound(0, (ParameterizedType) returnType);        final Executor executor = Utils.isAnnotationPresent(annotations, SkipCallbackExecutor.class)            ? null            : callbackExecutor;        return new CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123;            @Override public Type responseType() &#123;                return responseType;            &#125;            @Override public Call&lt;Object&gt; adapt(Call&lt;Object&gt; call) &#123;                return executor == null                    ? call                    : new ExecutorCallbackCall&lt;&gt;(executor, call);            &#125;        &#125;;    &#125;    ...&#125;</code></pre><p>CallAdapter 的实现类终于处是找到了，但是它的 adapt() 方法才是真正起作用的方法。从上到下，调用到<code>adapt()</code>的时候，返回的是一个ExcutorCallbackCall的实例。</p><h2 id="特性-❷-Converter"><a href="#特性-❷-Converter" class="headerlink" title="特性 ❷ Converter"></a>特性 ❷ Converter</h2><p>跟着<code>retrofit.responseBodyConverter()</code>方法往下走，我们看到了它的代码：</p><pre><code class="java">// retrofit2.Retrofit.javapublic &lt;T&gt; Converter&lt;ResponseBody, T&gt; responseBodyConverter(Type type, Annotation[] annotations) &#123;    return nextResponseBodyConverter(null, type, annotations);&#125;public &lt;T&gt; Converter&lt;ResponseBody, T&gt; nextResponseBodyConverter(    @Nullable Converter.Factory skipPast, Type type, Annotation[] annotations) &#123;    ...    int start = converterFactories.indexOf(skipPast) + 1;    for (int i = start, count = converterFactories.size(); i &lt; count; i++) &#123;        Converter&lt;ResponseBody, ?&gt; converter =            converterFactories.get(i).responseBodyConverter(type, annotations, this);        if (converter != null) &#123;        //noinspection unchecked        return (Converter&lt;ResponseBody, T&gt;) converter;        &#125;    &#125;&#125;public static final class Builder &#123;    Builder(Retrofit retrofit) &#123;        // 不要添加默认的、build() 方法里添加的的平台相关的 BuiltIntConverters        for (int i = 1,            size = retrofit.converterFactories.size() - platform.defaultConverterFactoriesSize();            i &lt; size; i++) &#123;            converterFactories.add(retrofit.converterFactories.get(i));        &#125;    &#125;    public Retrofit build() &#123;        ...        // 初始化 okhttoclient 等等        ...        List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(            1 + this.converterFactories.size() + platform.defaultConverterFactoriesSize());        // 先添加内置的 converter，里面实现了多个转换器包括把字节流转换成 ResponseBody，        // ResponseBody 转换为 java 中的 Void 或者 Kotlin 中的 Unit 时关闭流的操作等        converterFactories.add(new BuiltInConverters());        // 有自定义的就添加自定义，        // 比如我们常用的 GsonConverterFactory         converterFactories.addAll(this.converterFactories);        // 平台默认的 converter        converterFactories.addAll(platform.defaultConverterFactories());        // 返回 Retrofit 实例        return new Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories),            unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);    &#125;&#125;</code></pre><pre><code class="java">// retrofit2.Platform.javaList&lt;? extends Converter.Factory&gt; defaultConverterFactories() &#123;    // SDK 版本小于24，就没有默认的 converter    return hasJava8Types        ? singletonList(OptionalConverterFactory.INSTANCE)        : emptyList();&#125;</code></pre><p>可以看到，与 CallAdapter 的生成方式几乎一模一样。</p><h2 id="invoke-阶段"><a href="#invoke-阶段" class="headerlink" title="invoke 阶段"></a>invoke 阶段</h2><p>OK，所有初始化完成，接下来进入调用阶段，我们接着文章开头的例子，来看一下调用的入口：</p><pre><code class="java">...GitHubService service = retrofit.create(GitHubService.class);Call&lt;List&lt;Repo&gt;&gt; call = service.listRepos(&quot;cy198706&quot;);call.enqueue(new Callback&lt;List&lt;Repo&gt;&gt;() &#123;    @Override     public void onResponse(Call&lt;List&lt;Repo&gt;&gt; call, Response&lt;List&lt;Repo&gt;&gt; response) &#123;    &#125;    @Override     public void onFailure(Call&lt;List&lt;Repo&gt;&gt; call, Throwable t) &#123;    &#125;&#125;);</code></pre><p>那么，我们就以<code>enqueue()</code>方法为入口，看看调用的流程是怎样的。</p><p>刚才经过我们的分析，目前的<code>call</code>变量应该是一个 ExecutorCallbackCall 的实例，我们来看看它的代码：</p><pre><code class="java">// retrofit2.DefaultCallAdapterFactory.javastatic final class ExecutorCallbackCall&lt;T&gt; implements Call&lt;T&gt; &#123;    final Executor callbackExecutor;    final Call&lt;T&gt; delegate;    ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123;        this.callbackExecutor = callbackExecutor;        this.delegate = delegate;    &#125;    @Override     public void enqueue(final Callback&lt;T&gt; callback) &#123;        Objects.requireNonNull(callback, &quot;callback == null&quot;);        delegate.enqueue(new Callback&lt;T&gt;() &#123;        @Override         public void onResponse(Call&lt;T&gt; call, final Response&lt;T&gt; response) &#123;            callbackExecutor.execute(() -&gt; &#123;            if (delegate.isCanceled()) &#123;                // Emulate OkHttp&#39;s behavior of throwing/delivering an IOException on cancellation.                callback.onFailure(ExecutorCallbackCall.this, new IOException(&quot;Canceled&quot;));            &#125; else &#123;                callback.onResponse(ExecutorCallbackCall.this, response);            &#125;            &#125;);        &#125;        @Override         public void onFailure(Call&lt;T&gt; call, final Throwable t) &#123;            callbackExecutor.execute(() -&gt; callback.onFailure(ExecutorCallbackCall.this, t));        &#125;        &#125;);    &#125;    @Override     public boolean isExecuted() &#123;        return delegate.isExecuted();    &#125;    @Override     public Response&lt;T&gt; execute() throws IOException &#123;        return delegate.execute();    &#125;    @Override     public void cancel() &#123;        delegate.cancel();    &#125;    @Override     public boolean isCanceled() &#123;        return delegate.isCanceled();    &#125;    @SuppressWarnings(&quot;CloneDoesntCallSuperClone&quot;) // Performing deep clone.    @Override     public Call&lt;T&gt; clone() &#123;        return new ExecutorCallbackCall&lt;&gt;(callbackExecutor, delegate.clone());    &#125;    @Override     public Request request() &#123;        return delegate.request();    &#125;    @Override     public Timeout timeout() &#123;        return delegate.timeout();    &#125;&#125;</code></pre><p>delegate 是 OkHttpCall 对象，使用过 OkHttp 的应该知道它的 enqueue 是执行在子线程的，所以 ExecutorCallbackCall 为我们做的就是把在子线程的回调中，通过 MainThreadExecutor 在主线程中调用 retrofit2.Callback 的回调。当然这个 enqueue 还不是真正的 OkHttp 的 enqueue，它做了封装。</p><p>接着就看看<code>OkHttpCall.enqueue()</code>方法：</p><pre><code class="java">// retrofit2.OkhttpCall.java @Override  public void enqueue(final Callback&lt;T&gt; callback) &#123;    ...    okhttp3.Call call;    Throwable failure;    synchronized (this) &#123;        if (executed) throw new IllegalStateException(&quot;Already executed.&quot;);        executed = true;        call = rawCall;        failure = creationFailure;        if (call == null &amp;&amp; failure == null) &#123;            try &#123;                // createRawCall() 方法见下                call = rawCall = createRawCall();            &#125; catch (Throwable t) &#123;                throwIfFatal(t);                failure = creationFailure = t;            &#125;        &#125;    &#125;    if (failure != null) &#123;        callback.onFailure(this, failure);        return;    &#125;    if (canceled) &#123;        call.cancel();    &#125;    // 这里才是真正调用到了 Okhttp.enqueue()    call.enqueue(new okhttp3.Callback() &#123;        @Override         public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) &#123;            Response&lt;T&gt; response;            try &#123;                response = parseResponse(rawResponse);            &#125; catch (Throwable e) &#123;                throwIfFatal(e);                callFailure(e);                return;            &#125;            try &#123;                callback.onResponse(OkHttpCall.this, response);            &#125; catch (Throwable t) &#123;                throwIfFatal(t);                t.printStackTrace(); // TODO this is not great            &#125;        &#125;        @Override         public void onFailure(okhttp3.Call call, IOException e) &#123;            callFailure(e);        &#125;        private void callFailure(Throwable e) &#123;            try &#123;                callback.onFailure(OkHttpCall.this, e);            &#125; catch (Throwable t) &#123;                throwIfFatal(t);                t.printStackTrace(); // TODO this is not great            &#125;        &#125;    &#125;);&#125;private okhttp3.Call createRawCall() throws IOException &#123;    okhttp3.Call call = callFactory.newCall(requestFactory.create(args));    if (call == null) &#123;        throw new NullPointerException(&quot;Call.Factory returned null.&quot;);    &#125;    return call;&#125;</code></pre><p>看到这里，不禁感叹，Retrofit 的工厂模式真是应用得出神入化，无论是 Call，还是 Request，全部用工厂模式来创建。</p><p>在上面我们讲过，RequestFactory 的一个重要功能是 <code>parseAnnotation()</code>，现在它的另一个重要功能来了——构建 Request。</p><pre><code class="java">// retrofit2.RequestFactory.javaokhttp3.Request create(Object[] args) throws IOException &#123;    @SuppressWarnings(&quot;unchecked&quot;) // It is an error to invoke a method with the wrong arg types.    // 还记得 parseAnnotations() 方法吗，解析出来的 parameterHandlers 此处派上用场了    ParameterHandler&lt;Object&gt;[] handlers = (ParameterHandler&lt;Object&gt;[]) parameterHandlers;    int argumentCount = args.length;    if (argumentCount != handlers.length) &#123;        throw new IllegalArgumentException(&quot;Argument count (&quot; + argumentCount            + &quot;) doesn&#39;t match expected count (&quot; + handlers.length + &quot;)&quot;);    &#125;    RequestBuilder requestBuilder = new RequestBuilder(httpMethod, baseUrl, relativeUrl,        headers, contentType, hasBody, isFormEncoded, isMultipart);    if (isKotlinSuspendFunction) &#123;        // The Continuation is the last parameter and the handlers array contains null at that index.        argumentCount--;    &#125;    List&lt;Object&gt; argumentList = new ArrayList&lt;&gt;(argumentCount);    for (int p = 0; p &lt; argumentCount; p++) &#123;        argumentList.add(args[p]);        handlers[p].apply(requestBuilder, args[p]);    &#125;    return requestBuilder.get()        .tag(Invocation.class, new Invocation(method, argumentList))        .build();    &#125;&#125;</code></pre><p>此时，有了 Request，就可以真正地调用<code>Okhttp.enqueue()</code>方法来进行请求了。</p><p>在有了正确的回调结果后，还需要有一步<code>response = parseResponse(rawResponse)</code>来解析数据，我们看看它是如何做的：</p><pre><code class="java">Response&lt;T&gt; parseResponse(okhttp3.Response rawResponse) throws IOException &#123;    ResponseBody rawBody = rawResponse.body();    // Remove the body&#39;s source (the only stateful object) so we can pass the response along.    rawResponse = rawResponse.newBuilder()        .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))        .build();    int code = rawResponse.code();    if (code &lt; 200 || code &gt;= 300) &#123;        try &#123;        // Buffer the entire body to avoid future I/O.        ResponseBody bufferedBody = Utils.buffer(rawBody);        return Response.error(bufferedBody, rawResponse);        &#125; finally &#123;        rawBody.close();        &#125;    &#125;    if (code == 204 || code == 205) &#123;        rawBody.close();        return Response.success(null, rawResponse);    &#125;    ExceptionCatchingResponseBody catchingBody = new ExceptionCatchingResponseBody(rawBody);    try &#123;        T body = responseConverter.convert(catchingBody);        return Response.success(body, rawResponse);    &#125; catch (RuntimeException e) &#123;        // If the underlying source threw an exception, propagate that rather than indicating it was        // a runtime exception.        catchingBody.throwIfCaught();        throw e;    &#125;&#125;</code></pre><p>回调操作，这里还是在子线程，通过 ExecutorCallbackCall 里面的流程，调用到主线程，到这里我们就真正的走过了一次 Retrofit 从 create 创建 Call 到发送请求，然后到回调主线程的操作了。</p><p>至此，整个 Retrofit 的一次完整的流程便完成了，我们使用下面一张图来总结一下：</p><p><img src="/img/28.png"></p><h3 id="创建Retrofit实例阶段"><a href="#创建Retrofit实例阶段" class="headerlink" title="创建Retrofit实例阶段"></a>创建Retrofit实例阶段</h3><ol><li>调用<code>new Retrofit.Builder().build()</code></li><li>Retrofit 类在<code>build()</code>方法中有如下步骤：<ol><li>创建 OkHttpClient 实例</li><li>MainThreadExecutor 实例</li><li>调用<code>Platform.defaultCallAdapterFactories()</code>方法创建 CallAdapter</li><li>调用<code>Platform.defaultConverterFactoriesSize()</code>方法创建 Converter</li><li>新建并返回 Retrofit 实例</li></ol></li></ol><h3 id="创建接口代理阶段"><a href="#创建接口代理阶段" class="headerlink" title="创建接口代理阶段"></a>创建接口代理阶段</h3><ol><li>调用<code>Retrofit.create()</code>方法创建接口实例</li><li>在<code>Retrofit.create()</code>方法中有如下步骤：<ol><li>检查接口</li><li>调用<code>loadServiceMethod()</code>方法</li><li>创建一个方法代理并返回</li></ol></li><li>在<code>loadServiceMethod()</code>方法中有如下步骤：<ol><li>解析注解</li><li>解析参数</li><li>生成 RequestFactory 实例</li><li>调用<code>HttpServiceMethod.parseAnnotations()</code>方法</li></ol></li><li>在<code>HttpServiceMethod.parseAnnotations()</code>方法中有如下步骤：<ol><li>调用<code>createCallAdapter()</code>方法，从 Retrofit 实例的 callAdapterFactories 中拿取 CallAdapter</li><li>返回 HttpServiceMethod 的派生类 CallAdapted | SuspendForResponse | SuspendForBody 的实例</li></ol></li><li>将上一步返回的实例添加到缓存中等待读取和调用</li></ol><h3 id="触发代理机制阶段"><a href="#触发代理机制阶段" class="headerlink" title="触发代理机制阶段"></a>触发代理机制阶段</h3><ol><li>调用接口方法，触发代理机制</li><li>在代理的<code>invoke()</code>方法被调用时，有如下步骤：<ol><li>使用<code>loadServiceMethod()</code>获取该方法对应的ServiceMethod</li><li>调用<code>ServiceMethod.invoke()</code>方法</li><li>调用<code>HttpServiceMethod.invoke()</code>方法</li><li>调用 HttpServiceMethod 的<code>adapt()</code>方法，其派生类之一的<code>adapt()</code>方法被调用</li><li><code>CallAdapter.adapt()</code>被调用</li><li>返回 ExecutorCallbackCall 实例</li></ol></li></ol><h3 id="请求阶段"><a href="#请求阶段" class="headerlink" title="请求阶段"></a>请求阶段</h3><ol><li> 调用<code>ExecutorCallbackCall.enqueue()</code>方法发起请求</li><li> 在<code>ExecutorCallbackCall.enqueue()</code>方法中有如下步骤：</li></ol><ol><li>创建 Request 实例，并调用<code>callFactory.newCall(Request)</code>方法创建 RealCall 实例</li><li>调用<code>RealCall.enqueue()</code>方法，使用 okhttp 发起请求</li><li> 回调到主线程</li><li> 解析并利用 Converter 反序列化返回的结果</li><li> 回调到调用者</li></ol>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 三方库 </tag>
            
            <tag> Retrofit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 屏幕适配</title>
      <link href="/2023-01-31/android-screen-adaptation/"/>
      <url>/2023-01-31/android-screen-adaptation/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/onelikeone/p/9583446.html">看这篇</a><br><a href="https://www.jianshu.com/p/759375113de9">和这篇</a></p>]]></content>
      
      
      <categories>
          
          <category> Development </category>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 适配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于插件化</title>
      <link href="/2023-01-31/pluginazation/"/>
      <url>/2023-01-31/pluginazation/</url>
      
        <content type="html"><![CDATA[<p>插件化几乎是现在 Android 开发工程师的必备技能之一了。在前几年，Android 的安全机制不是很完善的时候，插件化的确大放异彩了一段时间，但是随着 Android 变得越来越安全，插件化的风头也有所收敛。从最初只支持 Activity 的动态加载发展到可以完全模拟 app 运行时的沙箱系统，插件化的技术也一步步趋于成熟。</p><span id="more"></span><h2 id="一、发展历史"><a href="#一、发展历史" class="headerlink" title="一、发展历史"></a>一、发展历史</h2><p>插件化技术最初源于免安装运行apk的想法，这个免安装的 apk 可以理解为插件。支持插件化的 app 可以在运行时加载和运行插件，这样便可以将 app 中一些不常用的功能模块做成插件，一方面减小了安装包的大小，另一方面可以实现 app 功能的动态扩展。想要实现插件化，主要是解决下面三个问题：</p><ul><li>插件中代码的加载和与主工程的互相调用</li><li>插件中资源的加载和与主工程的互相访问</li><li>四大组件生命周期的管理</li></ul><p>下面是比较出名的几个开源的插件化框架，按照出现的时间排序。研究它们的实现原理，可以大致看出插件化技术的发展，根据实现原理我把这几个框架划分成了三代。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/tnZGrhTk4dfxmHLtbLMzmQMjmjhjWq2XeJ1qLUic0kGzLIzr2n3pv5Emich2bYibQLrCic1oibAUWUEwibP1sePxyeUQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1"></p><p>第一代：dynamic-load-apk最早使用 ProxyActivity 这种静态代理技术，由 ProxyActivity 去控制插件中 PluginActivity 的生命周期。该种方式缺点明显，插件中的 activity 必须继承 PluginActivity，开发时要小心处理 context。而 DroidPlugin 通过 Hook 系统服务的方式启动插件中的 Activity，使得开发插件的过程和开发普通的 app 没有什么区别，但是由于 hook 过多系统服务，异常复杂且不够稳定。</p><p>第二代：为了同时达到插件开发的低侵入性（像开发普通 app 一样开发插件）和框架的稳定性，在实现原理上都是趋近于选择尽量少的 hook，并通过在 manifest 中预埋一些组件实现对四大组件的插件化。另外各个框架根据其设计思想都做了不同程度的扩展，其中 Small 更是做成了一个跨平台，组件化的开发框架。</p><p>第三代：VirtualApp 比较厉害，能够完全模拟 app 的运行环境，能够实现 app 的免安装运行和双开技术。Atlas 是阿里开源出来的一个结合组件化和热修复技术的一个 app 基础框架，其广泛的应用与阿里系的各个 app，其号称是一个容器化框架。</p><p>下面详细介绍插件化框架的原理，分别对应着实现插件化的三个核心问题。</p><h2 id="二、基本原理"><a href="#二、基本原理" class="headerlink" title="二、基本原理"></a>二、基本原理</h2><p>在探索基本原理之前，我们先看一张 Android Apk 打包的流程图：</p><p><img src="/img/682616-20191129131701331-804618503.png"></p><p>基本分为7个阶段：</p><ol><li><p>打包资源文件，生成R.java文件</p><p>打包资源的工具是aapt，在这个过程中，项目中的AndroidManifest.xml文件和布局文件XML都会编译，然后生成相应的R.java，另外AndroidManifest.xml会被aapt编译成二进制。存放在APP的res目录下的资源，该类资源在APP打包前大多会被编译，变成二进制文件，并会为每个该类文件赋予一个resource id。对于该类资源的访问，应用层代码则是通过resource id进行访问的。Android应用在编译过程中aapt工具会对资源文件进行编译，并生成一个resource.arsc文件，resource.arsc文件相当于一个文件索引表，记录了很多跟资源相关的信息。</p></li><li><p>处理aidl文件，生成相应的Java文件</p><p>aidl工具解析接口定义文件然后生成相应的Java代码接口供程序调用。如果在项目没有使用到aidl文件，则可以跳过这一步。</p></li><li><p>编译项目源代码，生成class文件</p><p>项目中所有的Java代码，包括R.java和.aidl文件，都会变Java编译器（javac）编译成.class文件，生成的class文件位于工程中的bin/classes目录下。</p></li><li><p>转换所有的class文件，生成classes.dex文件</p><p>dex工具生成可供Android系统Dalvik虚拟机执行的classes.dex文件，任何第三方的libraries和.class文件都会被转换成.dex文件。dx工具的主要工作是将Java字节码转成成Dalvik字节码、压缩常量池、消除冗余信息等。</p></li><li><p>打包生成APK文件</p><p>所有没有编译的资源，如images、assets目录下资源（该类文件是一些原始文件，APP打包时并不会对其进行编译，而是直接打包到APP中，对于这一类资源文件的访问，应用层代码需要通过文件名对其进行访问）；编译过的资源和.dex文件都会被apkbuilder工具打包到最终的.apk文件中。</p></li><li><p>对APK文件进行签名</p><p>一旦APK文件生成，它必须被签名才能被安装在设备上。在开发过程中，主要用到的就是两种签名的keystore。一种是用于调试的debug.keystore，它主要用于调试，在Eclipse或者Android Studio中直接run以后跑在手机上的就是使用的debug.keystore。另一种就是用于发布正式版本的keystore。</p></li><li><p>对签名后的APK文件进行对齐处理</p><p>如果你发布的apk是正式版的话，就必须对APK进行对齐处理，用到的工具是 zipalign。对齐的主要过程是将APK包中所有的资源文件距离文件起始偏移为4字节整数倍，这样通过内存映射访问apk文件时的速度会更快。对齐的作用就是减少运行时内存的使用。</p></li></ol><p>那么，其实插件化的突破口，就在生成的 .dex 文件和 Compiled Resources 文件里。</p><h3 id="1-类加载"><a href="#1-类加载" class="headerlink" title="1. 类加载"></a>1. 类加载</h3><p>我们都知道，Java 中类的加载使用的是 ClassLoader，它负责将 <strong>*.class 加载为内存中的 Class 对象</strong>。它的加载机制为『<strong>双亲委派</strong>』，即能交给父类加载器去加载的，绝不自行加载。这一点我们可以从它的源码中看出：</p><pre><code class="java">public abstract class ClassLoader &#123;    ...    // 父 class loader 的委托    // 注意：VM 将该变量的偏移量硬编码了，所以新的成员变量必须要声明在这个变量之后    private final ClassLoader parent;    ...        protected Class&lt;?&gt; loadClass(String name, boolean resolve)                 throws ClassNotFoundException &#123;            // 第一步，先检查是否已经被加载了            Class&lt;?&gt; c = findLoadedClass(name);            if (c == null) &#123;                try &#123;                    if (parent != null) &#123;                        // 这里使用了『双亲委托』机制，递归调用父类的 loadClass 方法                        c = parent.loadClass(name, false);                    &#125; else &#123;                        c = findBootstrapClassOrNull(name);                    &#125;                &#125; catch (ClassNotFoundException e) &#123;                &#125;                if (c == null) &#123;                    // 如果还没找到，就调用 findClass 方法来找到类                    c = findClass(name);                &#125;            &#125;            return c;    &#125;</code></pre><p>双亲委派机制有两个作用：</p><ol><li>防止重复加载同一个 class 。通过委托去向上面问一问，加载过了，就不用再加载一遍。保证数据安全。</li><li>保证核心 class 不能被篡改。通过委托方式，不会去篡改核心 class，即使篡改也不会去加载，即使加载了也不会是同一个 class 对象了。不同的加载器加载同一个 class 也不是同一个 Class 对象。这样保证了 Class 执行安全。</li></ol><p>在 Android 中 ClassLoader 有多个派生类，如下图所示：</p><p><img src="/img/65.png"></p><p>其中最常用也最重要的两个类，就是 DexClassLoader 和 PathClassLoader 了。它们都继承自 BaseDexClassLoader。我们先来看看 DexClassLoader 的代码：</p><p>DexClassLoader：</p><pre><code class="java">public class DexClassLoader extends BaseDexClassLoader &#123;    // 四个参数分别是：    // dexPath：包含 dex 文件的 jar 包或 apk 文件的路径    // optimizedDirectory：dex 文件释放目录/缓存目录，必须为应用的 private 目录，不能为空    // librarySearchPath：native 库的路径，可以为空    // parent： 父类加载器（用于双亲委派）    public DexClassLoader(String dexPath, String optimizedDirectory,            String librarySearchPath, ClassLoader parent) &#123;        super(dexPath, null, librarySearchPath, parent);    &#125;&#125;</code></pre><p>DexClassLoader 的主要功能如下：</p><ul><li>用于加载包含 *.dex 文件的 jar 包或 apk 文件</li><li>要求一个<strong>应用私有可写的目录去缓存编译的 class 文件</strong></li><li><strong>不允许加载外部存储空间的文件</strong>，以防注入攻击</li></ul><p>从 API 26 开始，<code>optimizedDirectory</code>将不再起作用，这个字段将会被废除掉。</p><p>PathClassLoader：</p><pre><code class="java">public class PathClassLoader extends BaseDexClassLoader &#123;    public PathClassLoader(String dexPath, ClassLoader parent) &#123;        super((String)null, (File)null, (String)null, (ClassLoader)null);        throw new RuntimeException(&quot;Stub!&quot;);    &#125;    // 三个参数分别是：    // dexPath：包含 dex 文件的 jar 包或 apk 文件的路径    // librarySearchPath：native 库的路径，可以为空    // parent： 父类加载器（用于双亲委派）    public PathClassLoader(String dexPath, String librarySearchPath, ClassLoader parent) &#123;        super((String)null, (File)null, (String)null, (ClassLoader)null);    &#125;&#125;</code></pre><p>无论哪种动态加载，加载的<strong>可执行文件一定要存放在内部存储</strong>。DexClassLoader 可以指定自己的<code>optimizedDirectory</code>，所以它可以加载外部的 dex ，最终这个 dex 会被<strong>复制到内部路径</strong>的<code>optimizedDirectory</code>中；而 PathClassLoader 没有<code>optimizedDirectory</code>，所以它只能加载内部的 dex，这些大都是存在系统中已经安装过的 apk 里面的。PathClassLoader 在 ART 虚拟机上可以加载未安装的 apk 的 dex ，在 Dalvik 则不行。</p><h3 id="2-资源加载"><a href="#2-资源加载" class="headerlink" title="2. 资源加载"></a>2. 资源加载</h3><p>Android 中的资源分为两类：</p><p>第一类是 res 目录下存放的可编辑的资源文件，这类文件在编译时系统会自动在R文件中生成资源文件的16进制值。例如：</p><pre><code class="java">public final class R &#123;    public static final class anim &#123;　　　　  public static final int abc_fade_in=0x7f050000; 　　　　 public static final int abc_fade_in=0x7f050000;　　　　  ...     &#125; &#125;</code></pre><p>平时开发时，访问这类资源比较简单，只要用<code>Context.getResource()</code>方法即可。</p><p>第二类是 assets 目录下存放的资源文件。APK 打包时并不会处理这些资源，而是直接将其打包，所以我们不能直接访问，只能用<code>AssetManager.open()</code>方法来实现对 assets 目录下资源文件的访问。如下：</p><pre><code class="java">Resource resource = getResource();AssetsManager am = getResource().getAssets();InputStream is  = getResource().getAssets().open(&quot;filename&quot;);</code></pre><p>通过对这两类资源的分析，我们可以初步做出一个结论：我们能使用的 Resources 类是一个很重要的类，通过此类提供的相关 API ，我们能操作资源的加载。</p><p>谈及资源插件化，我们不得不对 AssetsManager 的 API 多说一些。</p><p>AssetsManager 中有一个<code>addAssetsPath(String Path)</code>方法，App 启动的时候就会将当前的 apk 路径传进去，接下来 AssetsManager 和 Resources 就能访问当前 apk 的所有资源了。</p><p>AssetsManager 的<code>addAssetsPath</code>方法不对外，但是我们可以通过反射的方式，把插件 apk 的路径传到这个方法，这样就把插件的资源添加到一个资源池中了。App 有几个插件，我们就调用几次<code>addAssetsPath</code>方法，把插件的资源都塞到池子里。</p><p>举个栗子，比如在插件的 apk 里存在一个名为<code>plugin_s_1</code>的字符串，我们看看如何在宿主中访问它。</p><p>先理顺一下思路：</p><ol><li>先要创建 AssetManager 对象，读取插件中的资源</li><li>用 DexClassLoader 加载插件，并生成该插件对应的 ClassLoader</li><li>反射获取插件中的类，并将其实例化，就可以让插件类读取插件资源了</li></ol><p>写成代码可以如下：</p><pre><code class="java">public class MainActivity extends Activity &#123;    private AssetManager mAssetManager;    private Resources mResources;    private Resources.Theme mTheme;    private String dexPath = null;    //apk文件地址    private File fileRelease = null;  //释放目录    protected DexClassLoader classLoader = null;    private String pluginName = &quot;plugin1.apk&quot;;    TextView mTextView;    @Override    protected void attachBaseContext(Context newBase) &#123;        super.attachBaseContext(newBase);        // 在attachBaseContext时就拷贝插件文件，以便后面进行操作        extractAssets(newBase, pluginName);    &#125;    @SuppressLint(&quot;NewApi&quot;)    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        File extractFile = this.getFileStreamPath(pluginName);        dexPath = extractFile.getPath();        fileRelease = getDir(&quot;dex&quot;, 0);        // 新建 DexClassLoader        classLoader = new DexClassLoader(dexPath, fileRelease.getAbsolutePath(), null, getClassLoader());        mTextView = findViewById(R.id.tv);        // 对资源文件的调用        findViewById(R.id.btn).setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View v) &#123;                loadResources();                try &#123;                    Class mLoadClassDynamic = classLoader.loadClass(&quot;com.plugin1.Dynamic&quot;);                    Object dynamicObject = mLoadClassDynamic.newInstance();                    IDynamic dynamic = (IDynamic) dynamicObject;                    String content = dynamic.getStringForResId(MainActivity.this);                    mTextView.setText(content);                    Toast.makeText(getApplicationContext(), content + &quot;&quot;, Toast.LENGTH_LONG).show();                &#125; catch (Exception e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;);    &#125;    protected void loadResources() &#123;        try &#123;            AssetManager assetManager = AssetManager.class.newInstance();            Method addAssetPath = assetManager.getClass().getMethod(&quot;addAssetPath&quot;, String.class);            addAssetPath.invoke(assetManager, dexPath);            mAssetManager = assetManager;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        Resources superRes = super.getResources();        superRes.getDisplayMetrics();        superRes.getConfiguration();        mResources = new Resources(mAssetManager, superRes.getDisplayMetrics(), superRes.getConfiguration());        mTheme = mResources.newTheme();        mTheme.setTo(super.getTheme());    &#125;    @Override    public AssetManager getAssets() &#123;        return mAssetManager == null ? super.getAssets() : mAssetManager;    &#125;    @Override    public Resources getResources() &#123;        return mResources == null ? super.getResources() : mResources;    &#125;    @Override    public Resources.Theme getTheme() &#123;        return mTheme == null ? super.getTheme() : mTheme;    &#125;    /**     * 把Assets里面得文件复制到 /data/data/files 目录下     *     * @param context     * @param sourceName     */    public static void extractAssets(Context context, String sourceName) &#123;        AssetManager am = context.getAssets();        InputStream is = null;        FileOutputStream fos = null;        try &#123;            is = am.open(sourceName);            File extractFile = context.getFileStreamPath(sourceName);            fos = new FileOutputStream(extractFile);            byte[] buffer = new byte[1024];            int count = 0;            while ((count = is.read(buffer)) &gt; 0) &#123;                fos.write(buffer, 0, count);            &#125;            fos.flush();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            closeSilently(is);            closeSilently(fos);        &#125;    &#125;    private static void closeSilently(Closeable closeable) &#123;        if (closeable == null) &#123;            return;        &#125;        try &#123;            closeable.close();        &#125; catch (Throwable e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p>基于这个思路，我们可以尝试使用插件资源替换当前显示的内容，实现换肤效果，核心思想是一样的，这里就不过多赘述了。</p><h2 id="三、组件生命周期的管理"><a href="#三、组件生命周期的管理" class="headerlink" title="三、组件生命周期的管理"></a>三、组件生命周期的管理</h2><p>Android 中的四大组件的生命周期是由系统管理的，我们可以不去理会，但是在插件中，我们仅仅是构造出一个实例是没用的，我们还需要接管它的生命周期。其中 Activity 的生命周期最为复杂，使用的也最多，我们来以此为例讲一下插件化如何管理组件的生命周期。</p><p>插件化管理组件生命周期大致分为下面两种方式：</p><h3 id="ProxyActivity"><a href="#ProxyActivity" class="headerlink" title="ProxyActivity"></a>ProxyActivity</h3><p>通过<strong>代理方式</strong>来管理插件中组件的生命周期。这种方式最早由 dynamic-load-apk 提出，它的思路是在主工程中做一个 ProxyActivity，启动插件中的 Activity 时会先启动 ProxyActivity，并在其中创建 Activity，并同步生命周期，如下图：</p><p><img src="https://pic1.zhimg.com/80/v2-9cb17820f51c69637de66afc0105b664_720w.jpg"></p><p>具体过程如下：</p><ol><li>首先需要通过<strong>统一的入口（如上图中的 PluginManager）启动插件 Activity</strong>，其内部会将启动的插件Activity信息保存下来，并将 intent 替换为启动 ProxyActivity 的intent。</li><li>ProxyActivity 根据插件的信息拿到该插件的 ClassLoader 和 Resource，通过反射创建 PluginActivity 并调用其<code>onCreate()</code>方法。</li><li>PluginActivty 调用的<code>setContentView()</code>被重写了，会去调用 ProxyActivty 的<code>setContentView()</code>。由于 ProxyActivity 重写了<code>getResource()</code>返回的是插件的 Resource，所以<code>setContentView()</code>能够访问到插件中的资源。同样<code>findViewById()</code>也是调用ProxyActivity 的。</li><li>在 ProxyActivity 中执行生命周期方法时，会调用 PluginActivity 相应的生命周期方法。</li></ol><p>在实现这种方式时，ProxyActivity 中需要重写<code>getResouces()</code>、<code>getAssets()</code>、<code>getClassLoader()</code>方法返回插件的相应对象。生命周期函数以及和用户交互相关函数，如<code>onResume()</code>、<code>onStop()</code>、<code>onBackPressed()</code>等需要转发给插件 Activity。同时，PluginActivity 中所有与 Context 的相关的方法，如<code>setContentView()</code>、<code>getLayoutInflater()</code>、<code>getSystemService()</code>等都需要调用 ProxyActivity 中的相应方法。</p><p>缺点：这种方式，插件中的所有 Activity 必须继承自 PluginActivity，开发的侵入性强。如果某个 Activity 还需要特别的启动模式，那还需要自己管理 Activity 栈，实现起来很复杂。插件中如果要用到 Context，必须由宿主来实现。</p><p>在 dynamic-load-apk 之后，很少有插件化方案会这么做了。</p><h3 id="Hook-Activity"><a href="#Hook-Activity" class="headerlink" title="Hook Activity"></a>Hook Activity</h3><p>我们先看看系统是如何启动 Activity 的：</p><p><img src="https://pic3.zhimg.com/80/v2-99654057a348ceea14bb63b9f789795a_720w.jpg"></p><p>简单描述一下步骤。</p><ol><li>某处调用<code>startActivity()</code>方法，实际会调用<code>Instrumentation.execStartActivity()</code>方法。</li><li>通过跨进程的 binder 调用，进入到 ActivityManagerService 中，其内部会处理 Activity 栈。之后又通过跨进程调用进入到 Activity2所在的进程中。</li><li>ApplicationThread 是一个 binder 对象，其运行在 binder 线程池中，内部包含一个 H 类，该类继承于类 Handler。ApplicationThread 将启动 Activity2 的信息通过 H 对象发送给主线程。</li><li>主线程拿到 Activity2 的信息后，执行<code>Instrumentation.newActivity()</code>方法，其内通过 ClassLoader 反射创建 Activity2 实例。</li></ol><p>如果是这种方案，我们需要关心两个问题：</p><ul><li>插件中的 Activity没有在 AndroidManifest 中注册，如何绕过检测；</li><li>如何构造Activity实例，同步生命周期。</li></ul><p>解决方案有很多种，我们以 VirtualApk 为例，思路如下：</p><ol><li>先在 Manifest 中<strong>预埋 StubActivity</strong>，启动时 hook 上图第1步，将 Intent 的目标 Activity 替换成 StubActivity。</li><li>hook 第10步，通过插件的 ClassLoader 反射创建插件 Activity</li><li>之后 Activity 的所有生命周期回调都会通知给插件 Activity</li></ol><p>VirtualAPK 在初始化时会调用<code>hookInstrumentationAndHandler()</code>，该方法hook了系统的 Instrumentaiton 类，由上文可知该类和Activity的启动息息相关：</p><pre><code class="java">protected void hookInstrumentationAndHandler() &#123;    try &#123;        ActivityThread activityThread = ActivityThread.currentActivityThread();        Instrumentation baseInstrumentation = activityThread.getInstrumentation();        final VAInstrumentation instrumentation = createInstrumentation(baseInstrumentation);                Reflector.with(activityThread).field(&quot;mInstrumentation&quot;).set(instrumentation);        Handler mainHandler = Reflector.with(activityThread).method(&quot;getHandler&quot;).call();        Reflector.with(mainHandler).field(&quot;mCallback&quot;).set(instrumentation);        this.mInstrumentation = instrumentation;        Log.d(TAG, &quot;hookInstrumentationAndHandler succeed : &quot; + mInstrumentation);    &#125; catch (Exception e) &#123;        Log.w(TAG, e);    &#125;&#125;</code></pre><p>该段代码将主线程中的<code>mInstrumentation</code>对象替换成了自定义的 VAInstrumentation 类。在启动和创建插件 Activity 时，VAInstrumentation 都会偷偷做一些手脚，我们简单看看：</p><pre><code class="java">@Overridepublic ActivityResult execStartActivity(Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode) &#123;    injectIntent(intent);    return mBase.execStartActivity(who, contextThread, token, target, intent, requestCode);&#125;...@Overridepublic void callActivityOnCreate(Activity activity, Bundle icicle, PersistableBundle persistentState) &#123;    injectActivity(activity);    mBase.callActivityOnCreate(activity, icicle, persistentState);&#125;</code></pre><p>偷梁换柱的工作如下：</p><pre><code class="java">protected void injectIntent(Intent intent) &#123;    // 将 Intent 转换为显式 Intent    mPluginManager.getComponentsHandler().transformIntentToExplicitAsNeeded(intent);    // 如果 Component 为 null，说明是隐式 Intent    if (intent.getComponent() != null) &#123;        Log.i(TAG, String.format(&quot;execStartActivity[%s : %s]&quot;, intent.getComponent().getPackageName(), intent.getComponent().getClassName()));        // resolve intent with Stub Activity if needed        this.mPluginManager.getComponentsHandler().markIntentIfNeeded(intent);    &#125;&#125;...protected void injectActivity(Activity activity) &#123;    final Intent intent = activity.getIntent();    if (PluginUtil.isIntentFromPlugin(intent)) &#123;        Context base = activity.getBaseContext();        try &#123;            LoadedPlugin plugin = this.mPluginManager.getLoadedPlugin(intent);            Reflector.with(base).field(&quot;mResources&quot;).set(plugin.getResources());            Reflector reflector = Reflector.with(activity);            reflector.field(&quot;mBase&quot;).set(plugin.createPluginContext(activity.getBaseContext()));            reflector.field(&quot;mApplication&quot;).set(plugin.getApplication());            // set screenOrientation            ActivityInfo activityInfo = plugin.getActivityInfo(PluginUtil.getComponent(intent));            if (activityInfo.screenOrientation != ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED) &#123;                activity.setRequestedOrientation(activityInfo.screenOrientation);            &#125;            // for native activity            ComponentName component = PluginUtil.getComponent(intent);            Intent wrapperIntent = new Intent(intent);            wrapperIntent.setClassName(component.getPackageName(), component.getClassName());            activity.setIntent(wrapperIntent);                    &#125; catch (Exception e) &#123;            Log.w(TAG, e);        &#125;    &#125;&#125;</code></pre><p>用这种方式欺骗了系统，让系统误以为这是个正常的 Activity，在 Activity 栈中也会出现这个插件 Activity。同时，为了让这个插件 Activity 能够正常运行，还需要做一些替换工作，如 Resource、Context、Application 等。之后，生命周期事件会由 AMS 传递给插件 Activity 的实例。</p><h2 id="四、比较知名的插件化库"><a href="#四、比较知名的插件化库" class="headerlink" title="四、比较知名的插件化库"></a>四、比较知名的插件化库</h2><p>现在已经有很多成熟的插件化库了，简单介绍几个。</p><h3 id="1-DynamicLoadApk"><a href="#1-DynamicLoadApk" class="headerlink" title="1. DynamicLoadApk"></a>1. DynamicLoadApk</h3><p>这是一个非常著名的动态加载库。作者是比较有名的 Android 专家任玉刚。它的设计思路如下图：</p><p><img src="/img/66.png"></p><p>它总体上分为四个模块：</p><ol><li>DLPluginManager。插件管理模块，负责插件的加载、管理以及启动插件组件。</li><li>Proxy。代理组件模块，目前包括 DLProxyActivity(代理 Activity)、DLProxyFragmentActivity(代理 FragmentActivity)、DLProxyService(代理 Service)。</li><li>ProxyImpl。代理组件公用逻辑模块，与 Proxy 不同的是，这部分并不是一个组件，而是负责构建、加载插件组件的管理器。这些 ProxyImpl 通过反射得到插件组件，然后将插件与 Proxy 组件建立关联，最后调用插件组件的 onCreate 函数进行启动。</li><li>Base Plugin。插件组件的基类模块，目前包括 DLBasePluginActivity(插件 Activity 的基类)、DLBasePluginFragmentActivity(插件 FragmentActivity 的基类)、DLBasePluginService(插件 Service 的基类)。</li></ol><p>它的调用流程如下：</p><p><img src="/img/67.png"></p><p>上面是调用插件 Activity 的流程图，其他组件调用流程类似。</p><ol><li>首先通过 DLPluginManager 的<code>loadApk()</code>方法加载插件，这步每个插件只需调用一次。</li><li>通过 DLPluginManager 的<code>startPluginActivity()</code>方法启动代理 Activity。</li><li>代理 Activity 启动过程中构建、启动插件 Activity。</li></ol><p>但是由于 Android P 之后，系统禁止调用私有 API（经过 @hide 修饰的方法），这个库也就渐渐的失去了它的能力。</p><h3 id="2-Small"><a href="#2-Small" class="headerlink" title="2. Small"></a>2. Small</h3><p>它采取的方式与 Virtual 类似，也是先在 AndroidManifest 中埋下一个特殊命名的 Activity 来欺骗 Instrumentation，用以获得生命周期。然后通过替换 Instrumentation 的方式来创建新 Activity 的实例。</p><h3 id="3-rePlugin"><a href="#3-rePlugin" class="headerlink" title="3. rePlugin"></a>3. rePlugin</h3><p>这是 360 公司研发的插件化系统。它选择了 hook 系统的 ClassLoader，当启动 Activity 时，如果判断要启动的 Activity 是插件 Activity，会通过插件中的 ClassLoader 来创建相应的对象。同时，它为了保证系统的稳定性，选择了少 hook，并没有 hook <code>startActivity()</code>方法，而是重写了<code>startActivity()</code>。所以，插件 Activity 也必须要继承自一个类似 PluginActivity 的基类。</p>]]></content>
      
      
      <categories>
          
          <category> Development </category>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 插件化 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于组件化</title>
      <link href="/2023-01-31/componentization/"/>
      <url>/2023-01-31/componentization/</url>
      
        <content type="html"><![CDATA[<p>随着APP版本不断的迭代，新功能的不断增加，业务也会变的越来越复杂，APP业务模块的数量有可能还会继续增加，而且每个模块的代码也变的越来越多，这样发展下去单一工程下的APP架构势必会影响开发效率，增加项目的维护成本，每个工程师都要熟悉如此之多的代码，将很难进行多人协作开发，而且Android项目在编译代码的时候电脑会非常卡，又因为单一工程下代码耦合严重，每修改一处代码后都要重新编译打包测试，导致非常耗时，最重要的是这样的代码想要做单元测试根本无从下手，所以必须要有更灵活的架构代替过去单一的工程架构。</p><span id="more"></span><h2 id="为什么采用组件化"><a href="#为什么采用组件化" class="headerlink" title="为什么采用组件化"></a>为什么采用组件化</h2><p>我们从两个角度来分析这个问题。</p><h3 id="单一工程模式开发的痛点"><a href="#单一工程模式开发的痛点" class="headerlink" title="单一工程模式开发的痛点"></a>单一工程模式开发的痛点</h3><ol><li><p>对工程的任意修改调试都要编译整个工程，效率十分低下。</p><p>做APP开发时，我们需要经常在手机或模拟器上进行调试，而每次调试都需要对整个工程进行编译，然后安装在手机上运行。即便你只是改了一句代码，或是UI调整了一个像素点，同样需要完整的编译工程。当工程代码越来越多时，编译也会越来越慢，你可以想象一下我修改了某句代码，编译一下需要等待4、5分钟才能成功运行的场景么，那简直让人崩溃，严重影响了开发效率（想起曾经用eclipse开发Android时，各种转菊花，卡顿得让人想死的心都有）。</p></li><li><p>不利于多人团队协同开发。</p><p>早期一个APP可能就1、2个人来开发，但是随着业务的扩张，我们可能会发展到一个团队来开发一个APP，少则4、5个人，多则10几个人甚至更多。像手机淘宝、微信、支付宝这些巨无霸APP，他们的APP开发人员估计起码有数百个。</p><p>以10人团队为例，如果10个人都是基于同一个工程的代码拉分支进行开发，每人的开发任务虽然不同，但是都能修改整个工程的任意地方。为了适应自己的需求，团队内某人改了某句代码，但是这个改动又有可能影响别人的开发，这样开发人员之间势必要花更多的时间去沟通和协调，没法专注自己的功能点。最后进行10个人的代码合并时，有过这方面经历的人，就知道这是一件多么痛苦的事情，解决冲突解决得你要怀疑人生。</p></li><li><p>无法做到功能复用。</p><p>我曾经做过一个项目，每个开通这个业务的城市，都要做一个单独的APP，初期我们只开通了3、4个城市，需要同时发布3、4个APP，这些APP大概6、70%功能是相同的，但是都需要加入地方定制功能。如果你每个APP都采用单一工程模式开发，刚开始你可能每个工程都有同样的代码存在，只需要复制拷贝一下就行，但是如果有需求要对这些进行修改时，你必须得每个工程都逐一修改一遍，然后每个APP都测试一遍，工作量直接翻了数倍。</p></li><li><p>业务模块间耦合严重。</p><p>采用单一工程模式开发项目，到最后势必会造成业务模块高度耦合，可以说是你中有我、我中有你，修改任何业务都有可能导致牵一发而动全身，这显然是不利于后期项目功能维护以及迭代开发的。</p></li></ol><h3 id="组件化开发的优点"><a href="#组件化开发的优点" class="headerlink" title="组件化开发的优点"></a>组件化开发的优点</h3><ol><li>极大提高工程编译速度。进行组件化拆分后，每个业务或者功能都是一个单独的工程，这个单独的工程可以独立编译运行，拆分后的工程通常都比较小，代码量也比较少，我再也不用像以前编译一下得等待好几分钟了。</li><li>业务模块解耦，有利于多人团队协作开发。业务组件之间不能相互引用，每个组件都把对应的业务功能收敛在一个工程里，彼此互不打扰。 在多人团队里，每个人只负责自己的业务模块，他对业务功能的增删改查，都只限定在自己的这个业务模块里，不会影响其他人的业务，他代码质量的好坏也只会影响到自己的业务模块；对测试来说，也十分方便，大部分情况下，我们只需要着重测试修改过的业务组件即可，而不用老是进行全部回归测试。</li><li>组件化是功能重用的基石。业务组件类似一个个积木一样，我们可以用积木搭建出不同的房子，同理我们也可以创建多个不同的APP。我们只需要维护好每个组件，需要用到该组件的功能时，一建引用集成就可以了。</li></ol><p>当然，这并不是说组件化开发只有优点没有缺点，例如：</p><ul><li>组件化开发前期可能要花费更多的时间来进行模块拆分；</li><li>一个人的小项目完全没必要组件化开发，那样只会给自己带来更多的工作量；</li><li>组件化可能会带来更多重复的代码；</li><li>组件化需要良好的架构设计，包括怎么拆分业务，组件之间怎么通信等等，需要有个高水平的架构师统筹全局，经验不足的同学盲目进行组件化反而会适得其反，带来更多的麻烦。</li></ul><h2 id="组件化架构设计"><a href="#组件化架构设计" class="headerlink" title="组件化架构设计"></a>组件化架构设计</h2><p>在进行组件化开发之前，一定要设计好构架方案，一般来说，会分为至少4层：APP壳工程、常规业务组件层、基础/公共业务组件层和基础功能组件层。</p><p>下面一个图示意了一个工程的典型分层：</p><p><img src="../img/64.png"></p><p>我们来从下往上分析一下这样分层的思路。</p><ul><li><p><strong>基础功能组件层</strong></p><p>这一层的功能都是最基础的功能，通常不包含任何业务逻辑，也可以说这些组件是一些通用的工具类。例如日志记录组件，它只是提供了日志记录的能力，你要记录什么样的日志，它并不关心；例如基础UI组件，它是一个全局通用的 UI 资源库；例如网络服务组件，它封装了网络的请求能力，等等。</p></li><li><p><strong>基础业务组件层</strong></p><p>这一层层组件是对一些系统通用的业务能力进行封装的组件。例如公共业务组件里，可以封装 BaseActivity、BaseFragment 等；例如分享能力组件，我封装了微信、QQ、微博等的分享能力，其他业务只要集成该组件就能进行相关分享；例如共享公共数据组件，可以封装应用能够全局访问的数据，如用户登录信息等。</p></li><li><p><strong>常规业务组件</strong></p><p>该层的组件就是我们真正的业务组件了。我们通常按照功能模块来划分业务组件，例如注册登录、用户个人中心、APP的首页模块等。这里的每个业务组件都是一个小的APP，它必须可以单独编译，单独打包成APK在手机上运行。</p></li><li><p><strong>核心管理组件</strong></p><p>主要包括路由服务组件、组件生命周期管理组件。路由主要是为了解决组件间通信问题，而组件生命周期管理主要是为了解决组件的初始化等问题。</p></li><li><p><strong>APP壳工程</strong></p><p>壳工程依赖了需要集成的业务组件，它可能只有一些配置文件，没有任何代码逻辑。根据你的需要选择集成你的业务组件，不同的业务组件就组成了不同的 APP。</p></li></ul><p>在组件之间必须遵循以下规则：</p><ul><li>只能上层组件引用下层组件，不能反向依赖，否则可能会出现循环依赖的情况</li><li>同一层组件之前不能相互依赖，这是为了组件间彻底解耦合</li></ul><h2 id="组件间的通信问题"><a href="#组件间的通信问题" class="headerlink" title="组件间的通信问题"></a>组件间的通信问题</h2><p>在组件化实施的过程中，必然会遇到几个问题，比如：</p><blockquote><p>怎么从这个组件跳转到另一个组件的页面<br>组件之间怎么传递数据<br>怎么获取其他组件的数据或服务<br>组件怎么通知其他组件响应某个事件</p></blockquote><p>这些问题可以统统定义为：组件之间的通信问题。</p><p>我们来按照使用场景来分析一下。</p><h3 id="页面跳转"><a href="#页面跳转" class="headerlink" title="页面跳转"></a>页面跳转</h3><p>在单一工程中，页面跳转可以直接用<code>startActivity()</code>方法跳转页面。但是组件化之后，同一组件层的组件是不能相互依赖的，也就是说无法再通过<code>startActivity()</code>来进行跳转了。这就必须要引用一个新的思路：页面路由。</p><p>路由框架现在成熟的有很多了，比如<a href="https://tech.meituan.com/meituan_waimai_android_open_source_routing_framework.html">美团的WMRouter</a>和<a href="https://github.com/alibaba/ARouter">阿里的ARouter</a>。</p><p>路由框架的核心原理都是一样的，我们来简单分析一下。</p><p>实现思路是专门抽取一个 Module 作为路由服务，每个组件声明自己提供的服务 Service API，这些 Service 都是一些接口，组件负责将这些  Service 实现并注册到一个统一的路由 Router 中去，如果要使用某个组件的功能，只需要向 Router 请求这个 Service 的实现，具体的实现细节我们全然不关心，只要能返回我们需要的结果就可以了。看起来是不是有点像 Flutter 的路由？</p><h3 id="数据传递"><a href="#数据传递" class="headerlink" title="数据传递"></a>数据传递</h3><p>有了路由系统，数据传递自然也可以交给路由系统。举个例子：</p><p>我有一个路由，URI为：</p><pre><code>myscheme://custompath/pageA?param1=*&amp;param2=*</code></pre><p>param1 和 param2 自然就可以做为参数传入目标组件。</p><h3 id="数据共享、事件响应"><a href="#数据共享、事件响应" class="headerlink" title="数据共享、事件响应"></a>数据共享、事件响应</h3><p>数据共享和事件响应可以采用 EventBus 来实现，但是 EventBus 在组件化开发时，一定要注意事件名的命名，组件事件名最好有规范的定义方式，避免不同人员开发时出现冲突，日后不好维护。</p><p>当然如<a href="https://tech.meituan.com/meituan_waimai_android_open_source_routing_framework.html">美团的WMRouter</a>也有比较成熟的 ServiceLoader 的技术方案，提供服务共享、数据共享。</p><h2 id="组件的生命周期管理"><a href="#组件的生命周期管理" class="headerlink" title="组件的生命周期管理"></a>组件的生命周期管理</h2><p>每个Android应用启动时，都会先创建一个 Application。通常在 Application 里我们会做一些应用初始化的操作，常见的有第三方 SDK 初始化。在应用组件化之后，组件与壳工程是隔离开来的，但是组件有时候也需要获取应用的 Application，也需要在应用启动时进行初始化。这就涉及到组件的生命周期管理问题。</p><ol><li>抽象出一个类似Application的类，它模拟了Application的几个主要方法：</li></ol><pre><code class="java">public abstract class BaseAppLike &#123;    public static final int MAX_PRIORITY = 10;    public static final int MIN_PRIORITY = 1;    public static final int NORM_PRIORITY = 5;    /**     * 返回组件的优先级，优先级范围为[1-10]，10为最高，1为最低，默认优先级是5     *     * @return     */    public int getPriority() &#123;        return NORM_PRIORITY;    &#125;    /**     * 应用初始化     *     * @param context     */    public abstract void onCreate(Context context);    public abstract void onTerminate();&#125;</code></pre><p>而组件内部都要实现一个继承 BaseAppLike 的类，并将其当做 Application 的容器。组件可以在这里获取 Application 实例、执行启动时的初始化等等。</p><p>这时我们假设有三个组件 ModuleA、ModuleB、ModuleC，这三个组件内部分别有 ModuleAAppLike、ModuleBAppLike、ModuleCAppLike，那么在壳工程中，初始化时可以这样做：</p><pre><code class="java">class MyApplication extends Application &#123;    @Override    public void onCreate() &#123;        super.onCreate();        ModuleAAppLike moduleA = new ModuleAAppLike();        ModuleBAppLike moduleB = new ModuleBAppLike();        ModuleCAppLike moduleC = new ModuleCAppLike();        moduleA.onCreate(this);        moduleB.onCreate(this);        moduleC.onCreate(this);    &#125;   &#125;</code></pre><p>这样会不会有问题？有。</p><h3 id="组件初始化的顺序"><a href="#组件初始化的顺序" class="headerlink" title="组件初始化的顺序"></a>组件初始化的顺序</h3><p>前面介绍过，上层业务组件是依赖下层业务组件的，如果下层组件在应用启动时也需要初始化，那么我们在加载组件时，必然要先加载下层组件，否则加载上层组件时可能会出现问题。但是组件这么多，我们怎么确定要先加载谁后加载谁呢，当然你可以手动维护，代码里写死，但是当业务越来越多、时间越来越久，肯定不灵活，你新加一个业务组件进来，你都需要确定组件初始化先后顺序。所以，我们必须有个机制来确定组件初始化先后顺序。</p><p>类似线程优先级一样， 为每个组件定义了一个优先级，通过重写<code>getPriority()</code>方法可以设置组件的优先级。优先级范围从[1-10]，默认优先级都为5，下层组件或需要先初始化的组件，优先级设置高一点。这样我们在加载组件的时候，先对所有组件的优先级进行排序，优先级高的排前面，然后再按顺序进行加载组件，就可解决这个问题了。</p>]]></content>
      
      
      <categories>
          
          <category> Development </category>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 组件化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>View 的绘制流程</title>
      <link href="/2023-01-31/view-draw-mechanism/"/>
      <url>/2023-01-31/view-draw-mechanism/</url>
      
        <content type="html"><![CDATA[<h1 id="View的绘制流程"><a href="#View的绘制流程" class="headerlink" title="View的绘制流程"></a>View的绘制流程</h1><h2 id="View树的绘制流程"><a href="#View树的绘制流程" class="headerlink" title="View树的绘制流程"></a>View树的绘制流程</h2><p>当 Activity 接收到焦点的时候，它会被请求绘制布局。该请求由 Android Framework 处理。绘制是从根节点开始，对布局树进行 measure 和 draw。整个 View 树的绘图流程在 ViewRoot 类的<code>performTraversals()</code>函数展开，该函数所做的工作可简单概况为<strong>是否需要重新计算视图大小</strong>（measure）、<strong>是否需要重新安置视图的位置</strong>（layout）、以及<strong>是否需要重绘</strong>（draw），流程图如下：</p><p><img src="/img/1.png" alt="View的绘制流程图"></p><span id="more"></span><h2 id="View-绘制流程函数调用链"><a href="#View-绘制流程函数调用链" class="headerlink" title="View 绘制流程函数调用链"></a>View 绘制流程函数调用链</h2><p><img style="width: 50%; text-align: center" src="/img/2.png"></img></p><p>值得注意的是，用户主动调用<code>invalidate()</code>请求重绘 View 树，即 draw 过程，假如视图发生大小没有变化就不会调用<code>layout()</code>，并且只绘制那些调用了<code>invalidate()</code>方法的 View。</p><p>但是当布局变化的时候，比如方向变化，尺寸的变化，会调用<code>requestLayout()</code>方法。在自定义的视图中，如果某些情况下希望重新测量尺寸大小，应该手动去调用该方法，它会触发<code>measure()</code>和<code>layout()</code>，但不会进行<code>draw</code>。</p><p>从整体上来看<code>Measure</code>和<code>Layout</code>两个步骤的执行：</p><p><img src="/img/3.png" alt="View的绘制流程图"></p><p>树的遍历是有序的，由父视图到子视图，每一个<code>ViewGroup</code>负责测绘它所有的子视图，而最底层的<code>View</code>会负责测绘自身。</p><p><code>Draw</code>的执行流程：</p><p><img src="/img/4.png" alt="Draw流程"></p><h2 id="Measure过程分析"><a href="#Measure过程分析" class="headerlink" title="Measure过程分析"></a><code>Measure</code>过程分析</h2><p><code>measure</code>过程是在调用<code>measure(int, int)</code>方法，从上到下有序的测量<code>View</code>，在<code>measure</code>过程的最后，每个视图存储了自己的尺寸大小和测量规格。</p><p><code>layout</code>过程是在调用<code>layout(int, int, int, int)</code>方法，也是自上而下进行遍历。在该过程中，每个父视图会根据<code>measure</code>过程得到的尺寸来摆放自己的子视图。</p><p><code>measure</code>过程会为一个<code>View</code>及所有子节点的<code>mMeasuredWidth</code>和<code>mMeasuredHeight</code>变量赋值，该值可以通过 <code>getMeasuredWidth()</code>和<code>getMeasuredHeight()</code>方法获得。而且这两个值必须在父<code>View</code>约束范围之内，这样才可以保证所有的父<code>View</code>都接收所有子<code>View</code>的测量。如果子<code>View</code>对于<code>measure</code>得到的大小不满意的时候，父<code>View</code>会介入并设置测量规则进行第二次<code>measure</code>。</p><p>比如，父<code>View</code>可以先根据未给定的<code>dimension</code>去测量每一个子<code>View</code>，如果最终子<code>View</code>的未约束尺寸太大或者太小的时候，父<code>View</code>就会使用一个确切的大小再次对子<code>View</code>进行<code>measure</code>。</p><p>根据上面的流程，我们来看看源码：</p><p><a href="../../source/android/ViewGroup.java"><code>ViewGroup.java</code></a>:</p><pre><code class="java">    /**     * 告诉所有子 view：给你们个 MeasureSpec，去自个儿测量自个儿的大小切！     * PS: 如果谁的状态是 GONE，那你们就别搞了！     *     * @param widthMeasureSpec      * @param heightMeasureSpec     */    protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) &#123;        final int size = mChildrenCount;        final View[] children = mChildren;        for (int i = 0; i &lt; size; ++i) &#123;            final View child = children[i];            if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123;                measureChild(child, widthMeasureSpec, heightMeasureSpec);            &#125;        &#125;    &#125;</code></pre><p>看看<code>measureChild</code>是如何做的：</p><pre><code class="java">    /**     * 调用子 view 的 measure 方法来测量，根据父类的给的 MeasureSpec 和自己的 padding 值，     * 让 getChildMeasureSpec() 去获取具体的 MeasureSpec。     *      * @param child      * @param parentWidthMeasureSpec     * @param parentHeightMeasureSpec     */    protected void measureChild(View child, int parentWidthMeasureSpec,            int parentHeightMeasureSpec) &#123;        final LayoutParams lp = child.getLayoutParams();        final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,                mPaddingLeft + mPaddingRight, lp.width);        final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,                mPaddingTop + mPaddingBottom, lp.height);        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);    &#125;</code></pre><p>最复杂的工作：<code>getChildMeasureSpec()</code>:</p><pre><code class="java">    /**     * 简单来说，就是根据某个方向的 父view 的 MeasureSpec 的值和 padding 和 childDimension，     * 来决定这个 view 的 MeasureSpec: 一个int值     *     * @param spec The requirements for this view     * @param padding The padding of this view for the current dimension and     *        margins, if applicable     * @param childDimension How big the child wants to be in the current     *        dimension     * @return a MeasureSpec integer for the child     */    public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123;        int specMode = MeasureSpec.getMode(spec);        int specSize = MeasureSpec.getSize(spec);        int size = Math.max(0, specSize - padding);        int resultSize = 0;        int resultMode = 0;        switch (specMode) &#123;        // Parent has imposed an exact size on us        case MeasureSpec.EXACTLY:            if (childDimension &gt;= 0) &#123;                resultSize = childDimension;                resultMode = MeasureSpec.EXACTLY;            &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123;                // Child wants to be our size. So be it.                resultSize = size;                resultMode = MeasureSpec.EXACTLY;            &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123;                // Child wants to determine its own size. It can&#39;t be                // bigger than us.                resultSize = size;                resultMode = MeasureSpec.AT_MOST;            &#125;            break;        // Parent has imposed a maximum size on us        case MeasureSpec.AT_MOST:            if (childDimension &gt;= 0) &#123;                // Child wants a specific size... so be it                resultSize = childDimension;                resultMode = MeasureSpec.EXACTLY;            &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123;                // Child wants to be our size, but our size is not fixed.                // Constrain child to not be bigger than us.                resultSize = size;                resultMode = MeasureSpec.AT_MOST;            &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123;                // Child wants to determine its own size. It can&#39;t be                // bigger than us.                resultSize = size;                resultMode = MeasureSpec.AT_MOST;            &#125;            break;        // Parent asked to see how big we want to be        case MeasureSpec.UNSPECIFIED:            if (childDimension &gt;= 0) &#123;                // Child wants a specific size... let him have it                resultSize = childDimension;                resultMode = MeasureSpec.EXACTLY;            &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123;                // Child wants to be our size... find out how big it should                // be                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;                resultMode = MeasureSpec.UNSPECIFIED;            &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123;                // Child wants to determine its own size.... find out how                // big it should be                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;                resultMode = MeasureSpec.UNSPECIFIED;            &#125;            break;        &#125;        //noinspection ResourceType        return MeasureSpec.makeMeasureSpec(resultSize, resultMode);    &#125;</code></pre><p>获取到了子<code>view</code>的<code>MeasureSpec</code>，然后就会进入 <code>View.java</code>:</p><pre><code class="java">    /**     * 调用该方法来获取一个view到底该有多大。父视图提供width与height约束信息     *     * 测量过程中，实际的测量结果会由 onMeasure(int, int) 这个方法返回。     * 也就是说，只有 onMeasure(int, int) 这个方法能被子类覆写。     *     * @param widthMeasureSpec 水平方向父类强加的Measure需求     * @param heightMeasureSpec 垂直方向父类强加的Measure需求     *     */    public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123;        boolean optical = isLayoutModeOptical(this);        if (optical != isLayoutModeOptical(mParent)) &#123;            Insets insets = getOpticalInsets();            int oWidth  = insets.left + insets.right;            int oHeight = insets.top  + insets.bottom;            widthMeasureSpec  = MeasureSpec.adjust(widthMeasureSpec,  optical ? -oWidth  : oWidth);            heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight);        &#125;        // Suppress sign extension for the low bytes        long key = (long) widthMeasureSpec &lt;&lt; 32 | (long) heightMeasureSpec &amp; 0xffffffffL;        if (mMeasureCache == null) mMeasureCache = new LongSparseLongArray(2);        final boolean forceLayout = (mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT;        // Optimize layout by avoiding an extra EXACTLY pass when the view is        // already measured as the correct size. In API 23 and below, this        // extra pass is required to make LinearLayout re-distribute weight.        final boolean specChanged = widthMeasureSpec != mOldWidthMeasureSpec                || heightMeasureSpec != mOldHeightMeasureSpec;        final boolean isSpecExactly = MeasureSpec.getMode(widthMeasureSpec) == MeasureSpec.EXACTLY                &amp;&amp; MeasureSpec.getMode(heightMeasureSpec) == MeasureSpec.EXACTLY;        final boolean matchesSpecSize = getMeasuredWidth() == MeasureSpec.getSize(widthMeasureSpec)                &amp;&amp; getMeasuredHeight() == MeasureSpec.getSize(heightMeasureSpec);        final boolean needsLayout = specChanged                &amp;&amp; (sAlwaysRemeasureExactly || !isSpecExactly || !matchesSpecSize);        if (forceLayout || needsLayout) &#123;            // first clears the measured dimension flag            mPrivateFlags &amp;= ~PFLAG_MEASURED_DIMENSION_SET;            resolveRtlPropertiesIfNeeded();            int cacheIndex = forceLayout ? -1 : mMeasureCache.indexOfKey(key);            if (cacheIndex &lt; 0 || sIgnoreMeasureCache) &#123;                // measure ourselves, this should set the measured dimension flag back                // 这里返回了测量结果                onMeasure(widthMeasureSpec, heightMeasureSpec);                mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;            &#125; else &#123;                long value = mMeasureCache.valueAt(cacheIndex);                // Casting a long to int drops the high 32 bits, no mask needed                setMeasuredDimensionRaw((int) (value &gt;&gt; 32), (int) value);                mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;            &#125;            // flag not set, setMeasuredDimension() was not invoked, we raise            // an exception to warn the developer            if ((mPrivateFlags &amp; PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) &#123;                throw new IllegalStateException(&quot;View with id &quot; + getId() + &quot;: &quot;                        + getClass().getName() + &quot;#onMeasure() did not set the&quot;                        + &quot; measured dimension by calling&quot;                        + &quot; setMeasuredDimension()&quot;);            &#125;            mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;        &#125;        mOldWidthMeasureSpec = widthMeasureSpec;        mOldHeightMeasureSpec = heightMeasureSpec;        mMeasureCache.put(key, ((long) mMeasuredWidth) &lt;&lt; 32 |                (long) mMeasuredHeight &amp; 0xffffffffL); // suppress sign extension    &#125;</code></pre><p>我们再来看看<code>onMeasure(int, int)</code>:</p><pre><code class="java">    /**     * 测量view自身和它的内容来确定view的width和height。该方法由 measure(int, int) 调用     * 并且应该被子类覆写，来获取准确且高效的测量结果。     *     * 注意：在覆写该方法的时候，你必须调用 setMeasuredDimension(int, int) 方法来存储该 view 的 width 和 height。     * 如果不这么干的话，将会触发 IllegalStateException 异常。直接调用父类的 onMeasure(int, int) 无效。     *     * 基类实现测量时，默认使用的是背景的 size，除非 MeasureSpec 提供了一个更大的 size。     * 子类应该在覆写 onMeasure(int, int) 时提供它的内容的精确测量方法     *     * 如果该方法被覆写，子类应确保测量的 width 和 height 要大于 view 的最小 width 和最小 height，     * 可以分别通过 getSuggestedMinimumWidth() 和 getSuggestedMinimumHeight() 来获取     *     * @param widthMeasureSpec 水平方向父类强加的Measure需求     * @param heightMeasureSpec 垂直方向父类强加的Measure需求     *      */    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;        setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),                getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));    &#125;</code></pre><p>至此，<code>measure</code>过程结束。</p><h2 id="Layout过程分析"><a href="#Layout过程分析" class="headerlink" title="Layout过程分析"></a><code>Layout</code>过程分析</h2><p>首先要明确的是，子<code>View</code>的具体位置都是相对于父<code>View</code>而言的。</p><p>在<code>layout</code>过程中，子<code>View</code>会调用<code>getMeasuredWidth()</code>和<code>getMeasuredHeight()</code>方法获取到<code>measure</code>过程得到的<code>mMeasuredWidth</code>和<code>mMeasuredHeight</code>，做为自己的<code>width</code>和<code>height</code>。然后调用每一个子<code>View</code>的<code>layout(l, t, r, b)</code>函数，来确定每个子<code>View</code>在父<code>View</code>中的位置。</p><p><strong>注意，<code>View</code>的<code>onLayout</code>方法为空实现，而<code>ViewGroup</code>的<code>onLayout</code>为<code>abstract</code>，因此，如果自定义的 View 要继承 ViewGroup 时，必须实现<code>onLayout</code>函数。</strong></p><p><a href="../../source/android/View.java"><code>View.java</code></a></p><p>首先看看<code>View</code>类的<code>layout()</code>方法：</p><pre><code class="java">    /**     * 将 size 和 position 应用到该 view 和它所有的子孙 view 中     *      * 这是 layout 机制的第二阶段（第一阶段当然是 measure啦）。     * 在这个阶段里，每个父 view 会调用所有子 view 的 layout() 方法来给它们指定 position。     * 一般情况下会使用存储在子 view 里的 measure 值来定位。     *     * 派生类不要覆写这个方法。     * 有子 view 的派生类应该覆写 onLayout 方法，并且在这个方法里，调用它所有子 view 的 layout 方法。     *     * @param l Left position, relative to parent     * @param t Top position, relative to parent     * @param r Right position, relative to parent     * @param b Bottom position, relative to parent     */    @SuppressWarnings(&#123;&quot;unchecked&quot;&#125;)    public void layout(int l, int t, int r, int b) &#123;        if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) &#123;            onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);            mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;        &#125;        int oldL = mLeft;        int oldT = mTop;        int oldB = mBottom;        int oldR = mRight;        boolean changed = isLayoutModeOptical(mParent) ?                setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);        if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;            onLayout(changed, l, t, r, b);            if (shouldDrawRoundScrollbar()) &#123;                if(mRoundScrollbarRenderer == null) &#123;                    mRoundScrollbarRenderer = new RoundScrollbarRenderer(this);                &#125;            &#125; else &#123;                mRoundScrollbarRenderer = null;            &#125;            mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;            ListenerInfo li = mListenerInfo;            if (li != null &amp;&amp; li.mOnLayoutChangeListeners != null) &#123;                ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =                        (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();                int numListeners = listenersCopy.size();                for (int i = 0; i &lt; numListeners; ++i) &#123;                    listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB);                &#125;            &#125;        &#125;        final boolean wasLayoutValid = isLayoutValid();        mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;        mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;        if (!wasLayoutValid &amp;&amp; isFocused()) &#123;            mPrivateFlags &amp;= ~PFLAG_WANTS_FOCUS;            if (canTakeFocus()) &#123;                // We have a robust focus, so parents should no longer be wanting focus.                clearParentsWantFocus();            &#125; else if (getViewRootImpl() == null || !getViewRootImpl().isInLayout()) &#123;                // This is a weird case. Most-likely the user, rather than ViewRootImpl, called                // layout. In this case, there&#39;s no guarantee that parent layouts will be evaluated                // and thus the safest action is to clear focus here.                clearFocusInternal(null, /* propagate */ true, /* refocus */ false);                clearParentsWantFocus();            &#125; else if (!hasParentWantsFocus()) &#123;                // original requestFocus was likely on this view directly, so just clear focus                clearFocusInternal(null, /* propagate */ true, /* refocus */ false);            &#125;            // otherwise, we let parents handle re-assigning focus during their layout passes.        &#125; else if ((mPrivateFlags &amp; PFLAG_WANTS_FOCUS) != 0) &#123;            mPrivateFlags &amp;= ~PFLAG_WANTS_FOCUS;            View focused = findFocus();            if (focused != null) &#123;                // Try to restore focus as close as possible to our starting focus.                if (!restoreDefaultFocus() &amp;&amp; !hasParentWantsFocus()) &#123;                    // Give up and clear focus once we&#39;ve reached the top-most parent which wants                    // focus.                    focused.clearFocusInternal(null, /* propagate */ true, /* refocus */ false);                &#125;            &#125;        &#125;        if ((mPrivateFlags3 &amp; PFLAG3_NOTIFY_AUTOFILL_ENTER_ON_LAYOUT) != 0) &#123;            mPrivateFlags3 &amp;= ~PFLAG3_NOTIFY_AUTOFILL_ENTER_ON_LAYOUT;            notifyEnterOrExitForAutoFillIfNeeded(true);        &#125;    &#125;</code></pre><p>可以看到在<code>layout</code>过程中调用了<code>onLayout()</code> 方法，派生类此时可以覆写<code>onLayout()</code>方法，来获取<code>view</code>的位置。</p><pre><code class="java">    /**     * Called from layout when this view should     * assign a size and position to each of its children.     *     * Derived classes with children should override     * this method and call layout on each of     * their children.     * @param changed This is a new size or position for this view     * @param left Left position, relative to parent     * @param top Top position, relative to parent     * @param right Right position, relative to parent     * @param bottom Bottom position, relative to parent     */    protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123;    &#125;</code></pre><p>让我们举个栗子来看看<code>LinearLayout</code>的<code>onLayout()</code>：</p><pre><code class="java">    @Override    protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;        if (mOrientation == VERTICAL) &#123;            layoutVertical(l, t, r, b);        &#125; else &#123;            layoutHorizontal(l, t, r, b);        &#125;    &#125;    /**     * 如果该 LinearLayout 的 orientation 被设置成 VERTICAL 的话，调用该方法来确定它的 position     *     * @param left     * @param top     * @param right     * @param bottom     */    void layoutVertical(int left, int top, int right, int bottom) &#123;        final int paddingLeft = mPaddingLeft;        int childTop;        int childLeft;        // Where right end of child should go        final int width = right - left;        int childRight = width - mPaddingRight;        // Space available for child        int childSpace = width - paddingLeft - mPaddingRight;        final int count = getVirtualChildCount();        final int majorGravity = mGravity &amp; Gravity.VERTICAL_GRAVITY_MASK;        final int minorGravity = mGravity &amp; Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK;        switch (majorGravity) &#123;           case Gravity.BOTTOM:               // mTotalLength contains the padding already               childTop = mPaddingTop + bottom - top - mTotalLength;               break;               // mTotalLength contains the padding already           case Gravity.CENTER_VERTICAL:               childTop = mPaddingTop + (bottom - top - mTotalLength) / 2;               break;           case Gravity.TOP:           default:               childTop = mPaddingTop;               break;        &#125;        for (int i = 0; i &lt; count; i++) &#123;            final View child = getVirtualChildAt(i);            if (child == null) &#123;                childTop += measureNullChild(i);            &#125; else if (child.getVisibility() != GONE) &#123;                final int childWidth = child.getMeasuredWidth();                final int childHeight = child.getMeasuredHeight();                final LinearLayout.LayoutParams lp =                        (LinearLayout.LayoutParams) child.getLayoutParams();                int gravity = lp.gravity;                if (gravity &lt; 0) &#123;                    gravity = minorGravity;                &#125;                final int layoutDirection = getLayoutDirection();                final int absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection);                switch (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123;                    case Gravity.CENTER_HORIZONTAL:                        childLeft = paddingLeft + ((childSpace - childWidth) / 2)                                + lp.leftMargin - lp.rightMargin;                        break;                    case Gravity.RIGHT:                        childLeft = childRight - childWidth - lp.rightMargin;                        break;                    case Gravity.LEFT:                    default:                        childLeft = paddingLeft + lp.leftMargin;                        break;                &#125;                if (hasDividerBeforeChildAt(i)) &#123;                    childTop += mDividerHeight;                &#125;                childTop += lp.topMargin;                setChildFrame(child, childLeft, childTop + getLocationOffset(child),                        childWidth, childHeight);                childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child);                i += getChildrenSkipCount(child, i);            &#125;        &#125;    &#125;    /**     * 如果该 LinearLayout 的 orientation 被设置成 HORIZONTAL 的话，调用该方法来确定它的 position     *     * @param left     * @param top     * @param right     * @param bottom     */    void layoutHorizontal(int left, int top, int right, int bottom) &#123;        final boolean isLayoutRtl = isLayoutRtl();        final int paddingTop = mPaddingTop;        int childTop;        int childLeft;        // Where bottom of child should go        final int height = bottom - top;        int childBottom = height - mPaddingBottom;        // Space available for child        int childSpace = height - paddingTop - mPaddingBottom;        final int count = getVirtualChildCount();        final int majorGravity = mGravity &amp; Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK;        final int minorGravity = mGravity &amp; Gravity.VERTICAL_GRAVITY_MASK;        final boolean baselineAligned = mBaselineAligned;        final int[] maxAscent = mMaxAscent;        final int[] maxDescent = mMaxDescent;        final int layoutDirection = getLayoutDirection();        switch (Gravity.getAbsoluteGravity(majorGravity, layoutDirection)) &#123;            case Gravity.RIGHT:                // mTotalLength contains the padding already                childLeft = mPaddingLeft + right - left - mTotalLength;                break;            case Gravity.CENTER_HORIZONTAL:                // mTotalLength contains the padding already                childLeft = mPaddingLeft + (right - left - mTotalLength) / 2;                break;            case Gravity.LEFT:            default:                childLeft = mPaddingLeft;                break;        &#125;        int start = 0;        int dir = 1;        //In case of RTL, start drawing from the last child.        if (isLayoutRtl) &#123;            start = count - 1;            dir = -1;        &#125;        for (int i = 0; i &lt; count; i++) &#123;            final int childIndex = start + dir * i;            final View child = getVirtualChildAt(childIndex);            if (child == null) &#123;                childLeft += measureNullChild(childIndex);            &#125; else if (child.getVisibility() != GONE) &#123;                final int childWidth = child.getMeasuredWidth();                final int childHeight = child.getMeasuredHeight();                int childBaseline = -1;                final LinearLayout.LayoutParams lp =                        (LinearLayout.LayoutParams) child.getLayoutParams();                if (baselineAligned &amp;&amp; lp.height != LayoutParams.MATCH_PARENT) &#123;                    childBaseline = child.getBaseline();                &#125;                int gravity = lp.gravity;                if (gravity &lt; 0) &#123;                    gravity = minorGravity;                &#125;                switch (gravity &amp; Gravity.VERTICAL_GRAVITY_MASK) &#123;                    case Gravity.TOP:                        childTop = paddingTop + lp.topMargin;                        if (childBaseline != -1) &#123;                            childTop += maxAscent[INDEX_TOP] - childBaseline;                        &#125;                        break;                    case Gravity.CENTER_VERTICAL:                        // Removed support for baseline alignment when layout_gravity or                        // gravity == center_vertical. See bug #1038483.                        // Keep the code around if we need to re-enable this feature                        // if (childBaseline != -1) &#123;                        //     // Align baselines vertically only if the child is smaller than us                        //     if (childSpace - childHeight &gt; 0) &#123;                        //         childTop = paddingTop + (childSpace / 2) - childBaseline;                        //     &#125; else &#123;                        //         childTop = paddingTop + (childSpace - childHeight) / 2;                        //     &#125;                        // &#125; else &#123;                        childTop = paddingTop + ((childSpace - childHeight) / 2)                                + lp.topMargin - lp.bottomMargin;                        break;                    case Gravity.BOTTOM:                        childTop = childBottom - childHeight - lp.bottomMargin;                        if (childBaseline != -1) &#123;                            int descent = child.getMeasuredHeight() - childBaseline;                            childTop -= (maxDescent[INDEX_BOTTOM] - descent);                        &#125;                        break;                    default:                        childTop = paddingTop;                        break;                &#125;                if (hasDividerBeforeChildAt(childIndex)) &#123;                    childLeft += mDividerWidth;                &#125;                childLeft += lp.leftMargin;                setChildFrame(child, childLeft + getLocationOffset(child), childTop,                        childWidth, childHeight);                childLeft += childWidth + lp.rightMargin +                        getNextLocationOffset(child);                i += getChildrenSkipCount(child, childIndex);            &#125;        &#125;    &#125;</code></pre><p>可以看出，<code>VERTICAL</code>方向的<code>LinearLayout</code>和<code>HORIZONTAL</code>方向的<code>LinearLayout</code>，在定位过程中，区别并不大。唯一不太相同的地方，就是<code>HORIZONTAL</code>的<code>LinearLayout</code>需要判断是否为<code>RTL(Right-to-Left)</code>布局。</p><h2 id="Draw过程分析"><a href="#Draw过程分析" class="headerlink" title="Draw过程分析"></a><code>Draw</code>过程分析</h2><p><code>Draw</code>过程最重要的三个方法：</p><ul><li><code>View.dispatchDraw(Canvas)</code>:<br>该方法发起对子视图的绘制。<code>View</code>中默认是空实现，<code>ViewGroup</code>覆写了<code>dispatchDraw()</code>来对其子视图进行绘制。该方法我们不用去管，自定义的<code>ViewGroup</code>不应该对<code>dispatchDraw()</code>进行复写。</li><li><code>View.draw(Canvas)</code>:<br>由于<code>ViewGroup</code>并没有覆写此方法，因此，所有的视图最终都是调用<code>View</code>的<code>draw</code>方法进行绘制的。在自定义的视图中，也不应该覆写该方法，而是覆写<code>onDraw(Canvas)</code>方法进行绘制，如果自定义的视图确实要覆写该方法，那么请先调用<code>super.draw(canvas)</code>完成系统的绘制，然后再进行自定义的绘制。</li><li><code>View.onDraw(Canvas)</code>:<br><code>View.onDraw(Canvas)</code>默认是空实现，自定义绘制过程需要覆写的方法，用来绘制自身的内容。</li></ul><p>来看看源码吧：</p><p>先来看<code>ViewGroup.dispatchDraw(Canvas)</code>方法。该方法由系统调用，我们不需要主动调用：</p><pre><code class="java">    @Override    protected void dispatchDraw(Canvas canvas) &#123;        boolean usingRenderNodeProperties = canvas.isRecordingFor(mRenderNode);        final int childrenCount = mChildrenCount;        final View[] children = mChildren;        int flags = mGroupFlags;        if ((flags &amp; FLAG_RUN_ANIMATION) != 0 &amp;&amp; canAnimate()) &#123;            final boolean buildCache = !isHardwareAccelerated();            for (int i = 0; i &lt; childrenCount; i++) &#123;                final View child = children[i];                if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE) &#123;                    final LayoutParams params = child.getLayoutParams();                    attachLayoutAnimationParameters(child, params, i, childrenCount);                    bindLayoutAnimation(child);                &#125;            &#125;            final LayoutAnimationController controller = mLayoutAnimationController;            if (controller.willOverlap()) &#123;                mGroupFlags |= FLAG_OPTIMIZE_INVALIDATE;            &#125;            controller.start();            mGroupFlags &amp;= ~FLAG_RUN_ANIMATION;            mGroupFlags &amp;= ~FLAG_ANIMATION_DONE;            if (mAnimationListener != null) &#123;                mAnimationListener.onAnimationStart(controller.getAnimation());            &#125;        &#125;        int clipSaveCount = 0;        final boolean clipToPadding = (flags &amp; CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK;        if (clipToPadding) &#123;            clipSaveCount = canvas.save(Canvas.CLIP_SAVE_FLAG);            canvas.clipRect(mScrollX + mPaddingLeft, mScrollY + mPaddingTop,                    mScrollX + mRight - mLeft - mPaddingRight,                    mScrollY + mBottom - mTop - mPaddingBottom);        &#125;        // We will draw our child&#39;s animation, let&#39;s reset the flag        mPrivateFlags &amp;= ~PFLAG_DRAW_ANIMATION;        mGroupFlags &amp;= ~FLAG_INVALIDATE_REQUIRED;        boolean more = false;        final long drawingTime = getDrawingTime();        if (usingRenderNodeProperties) canvas.insertReorderBarrier();        final int transientCount = mTransientIndices == null ? 0 : mTransientIndices.size();        int transientIndex = transientCount != 0 ? 0 : -1;        // Only use the preordered list if not HW accelerated, since the HW pipeline will do the        // draw reordering internally        final ArrayList&lt;View&gt; preorderedList = usingRenderNodeProperties                ? null : buildOrderedChildList();        final boolean customOrder = preorderedList == null                &amp;&amp; isChildrenDrawingOrderEnabled();        // 开始绘制 child        for (int i = 0; i &lt; childrenCount; i++) &#123;            while (transientIndex &gt;= 0 &amp;&amp; mTransientIndices.get(transientIndex) == i) &#123;                final View transientChild = mTransientViews.get(transientIndex);                if ((transientChild.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE ||                        transientChild.getAnimation() != null) &#123;                    more |= drawChild(canvas, transientChild, drawingTime);                &#125;                transientIndex++;                if (transientIndex &gt;= transientCount) &#123;                    transientIndex = -1;                &#125;            &#125;            final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);            final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);            if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) &#123;                more |= drawChild(canvas, child, drawingTime);            &#125;        &#125;        while (transientIndex &gt;= 0) &#123;            // there may be additional transient views after the normal views            final View transientChild = mTransientViews.get(transientIndex);            if ((transientChild.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE ||                    transientChild.getAnimation() != null) &#123;                more |= drawChild(canvas, transientChild, drawingTime);            &#125;            transientIndex++;            if (transientIndex &gt;= transientCount) &#123;                break;            &#125;        &#125;        if (preorderedList != null) preorderedList.clear();        // Draw any disappearing views that have animations        if (mDisappearingChildren != null) &#123;            final ArrayList&lt;View&gt; disappearingChildren = mDisappearingChildren;            final int disappearingCount = disappearingChildren.size() - 1;            // Go backwards -- we may delete as animations finish            for (int i = disappearingCount; i &gt;= 0; i--) &#123;                final View child = disappearingChildren.get(i);                more |= drawChild(canvas, child, drawingTime);            &#125;        &#125;        if (usingRenderNodeProperties) canvas.insertInorderBarrier();        if (debugDraw()) &#123;            onDebugDraw(canvas);        &#125;        if (clipToPadding) &#123;            canvas.restoreToCount(clipSaveCount);        &#125;        // mGroupFlags might have been updated by drawChild()        flags = mGroupFlags;        if ((flags &amp; FLAG_INVALIDATE_REQUIRED) == FLAG_INVALIDATE_REQUIRED) &#123;            invalidate(true);        &#125;        if ((flags &amp; FLAG_ANIMATION_DONE) == 0 &amp;&amp; (flags &amp; FLAG_NOTIFY_ANIMATION_LISTENER) == 0 &amp;&amp;                mLayoutAnimationController.isDone() &amp;&amp; !more) &#123;            // We want to erase the drawing cache and notify the listener after the            // next frame is drawn because one extra invalidate() is caused by            // drawChild() after the animation is over            mGroupFlags |= FLAG_NOTIFY_ANIMATION_LISTENER;            final Runnable end = new Runnable() &#123;               @Override               public void run() &#123;                   notifyAnimationListener();               &#125;            &#125;;            post(end);        &#125;    &#125;</code></pre><p>可以看到，<code>dispatchDraw(Canvas)</code>方法主要有处理动画相关的事务、绘制child、绘制消失的child。</p><p>在绘制child时，调用的<code>drawChild()</code>如下：</p><pre><code class="java">    /**     * 绘制该 ViewGroup 其中一个 child。该方法的主要职责是将 canvas 置为合适的状态（包括 clipping、translating等），     * 让 child 的初始滚动位置置为 0,0，并应用动画效果。     *     * @param canvas The canvas on which to draw the child     * @param child Who to draw     * @param drawingTime The time at which draw is occurring     * @return True if an invalidate() was issued     */    protected boolean drawChild(Canvas canvas, View child, long drawingTime) &#123;        return child.draw(canvas, this, drawingTime);    &#125;</code></pre><p>接着就是<code>View.draw(Canvas)</code>部分：</p><pre><code class="java">    /**     * 使用给定的 canvas 手动渲染这个 view（和它的子 view 们）。     * 该 view 必须已经完成了 layout 过程，才能调用该方法。     * 当实现自定义 view 时，覆写onDraw(Canvas)方法，而不是覆写draw(Canvas)方法。如果真的要覆写，那先调用一个super.draw(canvas)     *     * @param canvas The Canvas to which the View is rendered.     */    @CallSuper    public void draw(Canvas canvas) &#123;        final int privateFlags = mPrivateFlags;        mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;        /*         * 遍历绘制需要按照下面的步骤来：         *         *      1. 绘制背景         *      2. 如果需要绘制边缘渐隐，则需要保存 canvas 的图层         *      3. 绘制 view 的内容         *      4. 绘制 child         *      5. 如果需要，绘制边缘渐隐并恢复图层         *      6. 绘制其他装饰（比如 scrollbar）         */        // 第1步，绘制背景        int saveCount;        drawBackground(canvas);        // 如果可能的话，跳过第2步和第5步。        final int viewFlags = mViewFlags;        boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0;        boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0;        if (!verticalEdges &amp;&amp; !horizontalEdges) &#123;            // 第3步，绘制内容            onDraw(canvas);            // 第4步，绘制子child            dispatchDraw(canvas);            drawAutofilledHighlight(canvas);            // Overlay 也是内容的一部分，绘制在前景的下层            if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) &#123;                mOverlay.getOverlayView().dispatchDraw(canvas);            &#125;            // 第6步，绘制其他装饰（前景色啊 scrollbar 啊）            onDrawForeground(canvas);            // 第7步，绘制默认的焦点高亮            drawDefaultFocusHighlight(canvas);            if (debugDraw()) &#123;                debugDrawFocus(canvas);            &#125;            // 完事儿走人            return;        &#125;        /*         * 这儿实现了一个完整的流程，这个流程并不常见，因为它会对速度有一定的影响。         */        boolean drawTop = false;        boolean drawBottom = false;        boolean drawLeft = false;        boolean drawRight = false;        float topFadeStrength = 0.0f;        float bottomFadeStrength = 0.0f;        float leftFadeStrength = 0.0f;        float rightFadeStrength = 0.0f;        // 第2步，保存 canvas 的图层        int paddingLeft = mPaddingLeft;        final boolean offsetRequired = isPaddingOffsetRequired();        if (offsetRequired) &#123;            paddingLeft += getLeftPaddingOffset();        &#125;        int left = mScrollX + paddingLeft;        int right = left + mRight - mLeft - mPaddingRight - paddingLeft;        int top = mScrollY + getFadeTop(offsetRequired);        int bottom = top + getFadeHeight(offsetRequired);        if (offsetRequired) &#123;            right += getRightPaddingOffset();            bottom += getBottomPaddingOffset();        &#125;        final ScrollabilityCache scrollabilityCache = mScrollCache;        final float fadeHeight = scrollabilityCache.fadingEdgeLength;        int length = (int) fadeHeight;        // clip the fade length if top and bottom fades overlap        // overlapping fades produce odd-looking artifacts        if (verticalEdges &amp;&amp; (top + length &gt; bottom - length)) &#123;            length = (bottom - top) / 2;        &#125;        // also clip horizontal fades if necessary        if (horizontalEdges &amp;&amp; (left + length &gt; right - length)) &#123;            length = (right - left) / 2;        &#125;        if (verticalEdges) &#123;            topFadeStrength = Math.max(0.0f, Math.min(1.0f, getTopFadingEdgeStrength()));            drawTop = topFadeStrength * fadeHeight &gt; 1.0f;            bottomFadeStrength = Math.max(0.0f, Math.min(1.0f, getBottomFadingEdgeStrength()));            drawBottom = bottomFadeStrength * fadeHeight &gt; 1.0f;        &#125;        if (horizontalEdges) &#123;            leftFadeStrength = Math.max(0.0f, Math.min(1.0f, getLeftFadingEdgeStrength()));            drawLeft = leftFadeStrength * fadeHeight &gt; 1.0f;            rightFadeStrength = Math.max(0.0f, Math.min(1.0f, getRightFadingEdgeStrength()));            drawRight = rightFadeStrength * fadeHeight &gt; 1.0f;        &#125;        saveCount = canvas.getSaveCount();        int topSaveCount = -1;        int bottomSaveCount = -1;        int leftSaveCount = -1;        int rightSaveCount = -1;        int solidColor = getSolidColor();        if (solidColor == 0) &#123;            if (drawTop) &#123;                topSaveCount = canvas.saveUnclippedLayer(left, top, right, top + length);            &#125;            if (drawBottom) &#123;                bottomSaveCount = canvas.saveUnclippedLayer(left, bottom - length, right, bottom);            &#125;            if (drawLeft) &#123;                leftSaveCount = canvas.saveUnclippedLayer(left, top, left + length, bottom);            &#125;            if (drawRight) &#123;                rightSaveCount = canvas.saveUnclippedLayer(right - length, top, right, bottom);            &#125;        &#125; else &#123;            scrollabilityCache.setFadeColor(solidColor);        &#125;        // 第3步，绘制内容         onDraw(canvas);        // 第4步，绘制child        dispatchDraw(canvas);        // 第5步，绘制渐隐边缘并恢复图层        final Paint p = scrollabilityCache.paint;        final Matrix matrix = scrollabilityCache.matrix;        final Shader fade = scrollabilityCache.shader;        // 还得按照保存的顺序反向恢复        if (drawRight) &#123;            matrix.setScale(1, fadeHeight * rightFadeStrength);            matrix.postRotate(90);            matrix.postTranslate(right, top);            fade.setLocalMatrix(matrix);            p.setShader(fade);            if (solidColor == 0) &#123;                canvas.restoreUnclippedLayer(rightSaveCount, p);            &#125; else &#123;                canvas.drawRect(right - length, top, right, bottom, p);            &#125;        &#125;        if (drawLeft) &#123;            matrix.setScale(1, fadeHeight * leftFadeStrength);            matrix.postRotate(-90);            matrix.postTranslate(left, top);            fade.setLocalMatrix(matrix);            p.setShader(fade);            if (solidColor == 0) &#123;                canvas.restoreUnclippedLayer(leftSaveCount, p);            &#125; else &#123;                canvas.drawRect(left, top, left + length, bottom, p);            &#125;        &#125;        if (drawBottom) &#123;            matrix.setScale(1, fadeHeight * bottomFadeStrength);            matrix.postRotate(180);            matrix.postTranslate(left, bottom);            fade.setLocalMatrix(matrix);            p.setShader(fade);            if (solidColor == 0) &#123;                canvas.restoreUnclippedLayer(bottomSaveCount, p);            &#125; else &#123;                canvas.drawRect(left, bottom - length, right, bottom, p);            &#125;        &#125;        if (drawTop) &#123;            matrix.setScale(1, fadeHeight * topFadeStrength);            matrix.postTranslate(left, top);            fade.setLocalMatrix(matrix);            p.setShader(fade);            if (solidColor == 0) &#123;                canvas.restoreUnclippedLayer(topSaveCount, p);            &#125; else &#123;                canvas.drawRect(left, top, right, top + length, p);            &#125;        &#125;        canvas.restoreToCount(saveCount);        drawAutofilledHighlight(canvas);        // Overlay 也是内容的一部分，绘制在前景的下层        if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) &#123;            mOverlay.getOverlayView().dispatchDraw(canvas);        &#125;        // 第6步，绘制其他装饰（前景色啊 scrollbar 啊）        onDrawForeground(canvas);        if (debugDraw()) &#123;            debugDrawFocus(canvas);        &#125;    &#125;</code></pre><p>由代码可以看出，第2步和第5步是可以省略不做的，并且可以极大地提高性能。所以通常情况下，不要设置FadingEdge。</p><p>::: tip</p><p>FadingEdge是个啥？</p><p>就是<strong>边缘渐隐</strong>，通常长这个样子：</p><p><img width="20%" src="/img/5.png"></img></p><p>根据<a href="https://developer.android.com/reference/android/R.attr.html#fadingEdge">官方文档</a>来看，android:fadingEdge已经被弃用了。如果想实现这种效果，要这样设置：</p><pre><code class="xml">android:requiresFadingEdge=&quot;horizontal&quot;android:fadingEdgeLength=&quot;40dp&quot;android:ellipsize=&quot;none&quot;</code></pre><p>同时，尽量将<code>layout_width</code>设置为<code>match_parent</code>或者<code>100dp</code>之类的。<br>:::</p><p>同样地，我们还是拿<code>LinearLayout</code>来举例，看看它的<code>onDraw(Canvas)</code>是如何实现的：</p><pre><code class="java">    @Override    protected void onDraw(Canvas canvas) &#123;        if (mDivider == null) &#123;            return;        &#125;        if (mOrientation == VERTICAL) &#123;            drawDividersVertical(canvas);        &#125; else &#123;            drawDividersHorizontal(canvas);        &#125;    &#125;    void drawDividersVertical(Canvas canvas) &#123;        final int count = getVirtualChildCount();        for (int i = 0; i &lt; count; i++) &#123;            final View child = getVirtualChildAt(i);            if (child != null &amp;&amp; child.getVisibility() != GONE) &#123;                if (hasDividerBeforeChildAt(i)) &#123;                    final LayoutParams lp = (LayoutParams) child.getLayoutParams();                    final int top = child.getTop() - lp.topMargin - mDividerHeight;                    drawHorizontalDivider(canvas, top);                &#125;            &#125;        &#125;        if (hasDividerBeforeChildAt(count)) &#123;            final View child = getLastNonGoneChild();            int bottom = 0;            if (child == null) &#123;                bottom = getHeight() - getPaddingBottom() - mDividerHeight;            &#125; else &#123;                final LayoutParams lp = (LayoutParams) child.getLayoutParams();                bottom = child.getBottom() + lp.bottomMargin;            &#125;            drawHorizontalDivider(canvas, bottom);        &#125;    &#125;    void drawDividersHorizontal(Canvas canvas) &#123;        final int count = getVirtualChildCount();        final boolean isLayoutRtl = isLayoutRtl();        for (int i = 0; i &lt; count; i++) &#123;            final View child = getVirtualChildAt(i);            if (child != null &amp;&amp; child.getVisibility() != GONE) &#123;                if (hasDividerBeforeChildAt(i)) &#123;                    final LayoutParams lp = (LayoutParams) child.getLayoutParams();                    final int position;                    if (isLayoutRtl) &#123;                        position = child.getRight() + lp.rightMargin;                    &#125; else &#123;                        position = child.getLeft() - lp.leftMargin - mDividerWidth;                    &#125;                    drawVerticalDivider(canvas, position);                &#125;            &#125;        &#125;        if (hasDividerBeforeChildAt(count)) &#123;            final View child = getLastNonGoneChild();            int position;            if (child == null) &#123;                if (isLayoutRtl) &#123;                    position = getPaddingLeft();                &#125; else &#123;                    position = getWidth() - getPaddingRight() - mDividerWidth;                &#125;            &#125; else &#123;                final LayoutParams lp = (LayoutParams) child.getLayoutParams();                if (isLayoutRtl) &#123;                    position = child.getLeft() - lp.leftMargin - mDividerWidth;                &#125; else &#123;                    position = child.getRight() + lp.rightMargin;                &#125;            &#125;            drawVerticalDivider(canvas, position);        &#125;    &#125;</code></pre><p>可以看到，在<code>LinearLayout</code>的<code>onDraw(Canvas)</code>方法中，只是多绘制了一个<code>divider</code>，如果没有<code>divider</code>的话，那就不再处理。</p><h2 id="其他的重要方法"><a href="#其他的重要方法" class="headerlink" title="其他的重要方法"></a>其他的重要方法</h2><ul><li><code>invalidate()</code>方法：</li></ul><p>该方法请求重绘<code>View</code>树，即<code>draw</code>过程，假如视图发生大小没有变化就不会调用<code>layout</code>过程，并且只绘制那些『需要重绘的』<br>视图，即谁请求<code>invalidate()</code>方法，就绘制谁(<code>View</code>的话，只绘制该<code>View</code>；<code>ViewGroup</code>，则绘制整个<code>ViewGroup</code>)。</p><p>一般引起<code>invalidate()</code>操作的函数如下：</p><ol><li><p>直接调用<code>invalidate()</code>方法，请求重新<code>draw()</code>，但只会绘制调用者本身。</p></li><li><p><code>setSelection()</code>方法 ：请求重新<code>draw()</code>，但只会绘制调用者本身。</p></li><li><p><code>setVisibility()</code>方法 ： 当<code>View</code>可视状态在<code>INVISIBLE</code>转换<code>VISIBLE</code>时，会间接调用<code>invalidate()</code>方法，<br>继而绘制该View。</p></li><li><p><code>setEnabled()</code>方法 ： 请求重新<code>draw()</code>，但不会重新绘制任何视图包括该调用者本身。</p></li></ol><ul><li><code>requestLayout()</code>方法：</li></ul><p>看字面意思『请求布局』。调用该方法会导致调用<code>measure</code>过程和<code>layout</code>过程，但只是对<code>View</code>树重新布局，不会调用<code>draw</code>过程，也就是不会重新绘制。</p><p>看一眼它的源码吧：</p><pre><code class="java">    /**     * 当某些东西发生了改变并刷新了 View 布局时，调用该方法。     * 该方法会对 View 树进行一次 layout 流程。     * 该方法不应该在 view 树正在进行 layout 流程（可由 isInLayout()方法判断）时被调用。     * 如果调用该方法时正在进行 layout 流程，这次的请求会被放在当前 layout 流程结束之后（也就是再跑一次），或者是     * 绘制完当前帧之后。     *     * 子类覆写该方法时，要调用 super.requestLayout() 以保证能正确处理一些 request-during-layout 的错误。     */    @CallSuper    public void requestLayout() &#123;        if (mMeasureCache != null) mMeasureCache.clear();        if (mAttachInfo != null &amp;&amp; mAttachInfo.mViewRequestingLayout == null) &#123;            // Only trigger request-during-layout logic if this is the view requesting it,            // not the views in its parent hierarchy            ViewRootImpl viewRoot = getViewRootImpl();            if (viewRoot != null &amp;&amp; viewRoot.isInLayout()) &#123;                if (!viewRoot.requestLayoutDuringLayout(this)) &#123;                    return;                &#125;            &#125;            mAttachInfo.mViewRequestingLayout = this;        &#125;        mPrivateFlags |= PFLAG_FORCE_LAYOUT;        mPrivateFlags |= PFLAG_INVALIDATED;        if (mParent != null &amp;&amp; !mParent.isLayoutRequested()) &#123;            mParent.requestLayout();        &#125;        if (mAttachInfo != null &amp;&amp; mAttachInfo.mViewRequestingLayout == this) &#123;            mAttachInfo.mViewRequestingLayout = null;        &#125;    &#125;</code></pre><p>可以看到，<code>requestLayout()</code>方法会不断向上传，向父<code>view</code>请求布局，最后会交给<code>DecorView</code>，也即根<code>view</code>，最终会被<code>ViewRootImpl</code>接收并得到处理。关于<code>ViewRootImpl</code>，会单开一篇文章再来讲，里面会涉及到<code>Activity</code>、<code>Window</code>、<code>WindowManager</code>等内容。</p>]]></content>
      
      
      <categories>
          
          <category> Development </category>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Android Framework </tag>
            
            <tag> View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jetpack 由浅入深</title>
      <link href="/2023-01-31//"/>
      <url>/2023-01-31//</url>
      
        <content type="html"><![CDATA[<p>本文会把 Jetpack 中所有的组件，以单篇文章的形式来一一讲解。</p><p>索引：</p><ul><li><a href="">LiveModel</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023-01-31//"/>
      <url>/2023-01-31//</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>其他扩展面试题</title>
      <link href="/2021-01-09//"/>
      <url>/2021-01-09//</url>
      
        <content type="html"><![CDATA[<h2 id="其他扩展面试题"><a href="#其他扩展面试题" class="headerlink" title="其他扩展面试题"></a>其他扩展面试题</h2><span id="more"></span><h3 id="一、Kotlin-（⭐⭐）"><a href="#一、Kotlin-（⭐⭐）" class="headerlink" title="一、Kotlin （⭐⭐）"></a>一、Kotlin （⭐⭐）</h3><h4 id="1、Kotlin-特性，和-Java-相比有什么不同的地方"><a href="#1、Kotlin-特性，和-Java-相比有什么不同的地方" class="headerlink" title="1、Kotlin 特性，和 Java 相比有什么不同的地方?"></a>1、Kotlin 特性，和 Java 相比有什么不同的地方?</h4><ul><li>能直接与Java相互调用，能与Java工程共存</li><li>大大减少样板代码</li><li>可以将Kotlin代码编译为无需虚拟机就可运行的原生二进制文件</li><li>支持协程</li><li>支持高阶函数</li><li>语言层面解决空指针问题</li><li>对字符串格式化的处理（$变量名）</li><li>更像Python的语法</li><li>对λ表达式支持更好</li></ul><p><a href="https://mp.weixin.qq.com/s/FqXLNz5p9M-5vcMUkxJyFQ">https://mp.weixin.qq.com/s/FqXLNz5p9M-5vcMUkxJyFQ</a></p><h4 id="2、Kotlin为什么能和Java混编"><a href="#2、Kotlin为什么能和Java混编" class="headerlink" title="2、Kotlin为什么能和Java混编?"></a>2、Kotlin为什么能和Java混编?</h4><h4 id="3、什么是协程？"><a href="#3、什么是协程？" class="headerlink" title="3、什么是协程？"></a>3、什么是协程？</h4><h3 id="二、大前端-（⭐⭐）"><a href="#二、大前端-（⭐⭐）" class="headerlink" title="二、大前端 （⭐⭐）"></a>二、大前端 （⭐⭐）</h3><h4 id="1、Hybrid通信原理是什么，有做研究吗？"><a href="#1、Hybrid通信原理是什么，有做研究吗？" class="headerlink" title="1、Hybrid通信原理是什么，有做研究吗？"></a>1、Hybrid通信原理是什么，有做研究吗？</h4><h4 id="2、JS的交互理解吗？平时工作用的多吗，项目中是怎么与Web交互的？"><a href="#2、JS的交互理解吗？平时工作用的多吗，项目中是怎么与Web交互的？" class="headerlink" title="2、JS的交互理解吗？平时工作用的多吗，项目中是怎么与Web交互的？"></a>2、JS的交互理解吗？平时工作用的多吗，项目中是怎么与Web交互的？</h4><h5 id="Android通过WebView调用JS代码："><a href="#Android通过WebView调用JS代码：" class="headerlink" title="Android通过WebView调用JS代码："></a>Android通过WebView调用JS代码：</h5><p>1、通过WebView的loadUrl()：</p><ul><li><p>设置与Js交互的权限：</p><p>webSettings.setJavaScriptEnabled(true)</p></li><li><p>设置允许JS弹窗：</p><p>webSettings.setJavaScriptCanOpenWindowsAutomatically(true)</p></li><li><p>载入JS代码：</p><p>mWebView.loadUrl(“file:///android_asset/javascript.html”)</p></li><li><p>webview只是载体，内容的渲染需要使用webviewChromClient类去实现，通过设置WebChromeClient对象处理JavaScript的对话框。</p></li></ul><p>特别注意：</p><p>JS代码调用一定要在 onPageFinished（） 回调之后才能调用，否则不会调用。</p><p>2、通过WebView的evaluateJavascript()：</p><ul><li>该方法比第一种方法效率更高、使用更简洁，因为该方法的执行不会使页面刷新，而第一种方法（loadUrl ）的执行则会。</li><li>Android 4.4 后才可使用。</li></ul><p>只需要将第一种方法的loadUrl()换成evaluateJavascript()即可，通过onReceiveValue()回调接收返回值。</p><p>建议：两种方法混合使用，即Android 4.4以下使用方法1，Android 4.4以上方法2。</p><h5 id="JS通过WebView调用-Android-代码："><a href="#JS通过WebView调用-Android-代码：" class="headerlink" title="JS通过WebView调用 Android 代码："></a>JS通过WebView调用 Android 代码：</h5><p>1、通过 WebView的addJavascriptInterface（）进行对象映射：</p><p>-定义一个与JS对象映射关系的Android类：AndroidtoJs：</p><ul><li>定义JS需要调用的方法，被JS调用的方法必须加入@JavascriptInterface注解。</li><li>通过addJavascriptInterface()将Java对象映射到JS对象。</li></ul><p>优点：使用简单，仅将Android对象和JS对象映射即可。</p><p>缺点：addJavascriptInterface 接口引起远程代码执行漏洞，漏洞产生原因是：</p><p>当JS拿到Android这个对象后，就可以调用这个Android对象中所有的方法，包括系统类（java.lang.Runtime 类），从而进行任意代码执行。</p><p>2、通过 WebViewClient 的方法shouldOverrideUrlLoading ()回调拦截 url：</p><ul><li><p>Android通过 WebViewClient 的回调方法shouldOverrideUrlLoading ()拦截 url。</p></li><li><p>解析该 url 的协议。</p></li><li><p>如果检测到是预先约定好的协议，就调用相应方法。</p><p>根据协议的参数，判断是否是所需要的url。<br>一般根据scheme（协议格式） &amp; authority（协议名）判断（前两个参数）。</p></li></ul><p>优点：不存在方式1的漏洞；</p><p>缺点：JS获取Android方法的返回值复杂,如果JS想要得到Android方法的返回值，只能通过 WebView 的 loadUrl （）去执行 JS 方法把返回值传递回去。</p><p>3、通过 WebChromeClient 的onJsAlert()、onJsConfirm()、onJsPrompt（）方法回调拦截JS对话框alert()、confirm()、prompt（） 消息：</p><p>原理：</p><p>Android通过 WebChromeClient 的onJsAlert()、onJsConfirm()、onJsPrompt（）方法回调分别拦截JS对话框<br>（警告框、确认框、输入框），得到他们的消息内容，然后解析即可。</p><p>常用的拦截是：拦截 JS的输入框（即prompt（）方法），因为只有prompt（）可以返回任意类型的值，操作最全面方便、更加灵活；而alert（）对话框没有返回值；confirm（）对话框只能返回两种状态（确定 / 取消）两个值。</p><p><img src="https://upload-images.jianshu.io/upload_images/944365-613b57c93dff2eb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p><a href="https://blog.csdn.net/carson_ho/article/details/64904691">Android：你要的WebView与 JS 交互方式 都在这里了</a></p><h4 id="3、react-native有多少了解？讲一下原理。"><a href="#3、react-native有多少了解？讲一下原理。" class="headerlink" title="3、react native有多少了解？讲一下原理。"></a>3、react native有多少了解？讲一下原理。</h4><h4 id="4、weex了解吗？如何自己实现类似技术？"><a href="#4、weex了解吗？如何自己实现类似技术？" class="headerlink" title="4、weex了解吗？如何自己实现类似技术？"></a>4、weex了解吗？如何自己实现类似技术？</h4><h4 id="5、flutter了解吗？内部是如何实现跨平台的？如何实现多Native页面接入？如何实现对现有工程的flutter迁移？"><a href="#5、flutter了解吗？内部是如何实现跨平台的？如何实现多Native页面接入？如何实现对现有工程的flutter迁移？" class="headerlink" title="5、flutter了解吗？内部是如何实现跨平台的？如何实现多Native页面接入？如何实现对现有工程的flutter迁移？"></a>5、flutter了解吗？内部是如何实现跨平台的？如何实现多Native页面接入？如何实现对现有工程的flutter迁移？</h4><h4 id="6、Dart语言有研究过吗？"><a href="#6、Dart语言有研究过吗？" class="headerlink" title="6、Dart语言有研究过吗？"></a>6、Dart语言有研究过吗？</h4><h4 id="7、快应用了解吗？跟其她方式相比有什么优缺点？"><a href="#7、快应用了解吗？跟其她方式相比有什么优缺点？" class="headerlink" title="7、快应用了解吗？跟其她方式相比有什么优缺点？"></a>7、快应用了解吗？跟其她方式相比有什么优缺点？</h4><h4 id="8、说说你用过的混合开发技术有哪些？各有什么优缺点？"><a href="#8、说说你用过的混合开发技术有哪些？各有什么优缺点？" class="headerlink" title="8、说说你用过的混合开发技术有哪些？各有什么优缺点？"></a>8、说说你用过的混合开发技术有哪些？各有什么优缺点？</h4><h3 id="三、脚本语言-（⭐⭐）"><a href="#三、脚本语言-（⭐⭐）" class="headerlink" title="三、脚本语言 （⭐⭐）"></a>三、脚本语言 （⭐⭐）</h3><h4 id="1、脚本语言会吗"><a href="#1、脚本语言会吗" class="headerlink" title="1、脚本语言会吗?"></a>1、脚本语言会吗?</h4><h4 id="2、Python会吗？"><a href="#2、Python会吗？" class="headerlink" title="2、Python会吗？"></a>2、Python会吗？</h4><p><a href="https://jsonchao.github.io/2018/07/26/%20Python%E5%85%A5%E9%97%A8%E7%AF%87/">Python基础</a></p><p><a href="https://jsonchao.github.io/2018/03/18/%E5%88%9D%E8%AF%86%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/">人工智能了解</a></p><h4 id="3、Gradle了解多少？groovy语法会吗？"><a href="#3、Gradle了解多少？groovy语法会吗？" class="headerlink" title="3、Gradle了解多少？groovy语法会吗？"></a>3、Gradle了解多少？groovy语法会吗？</h4>]]></content>
      
      
      <categories>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kotlin </tag>
            
            <tag> coroutine </tag>
            
            <tag> 协程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 中线程的状态及转换</title>
      <link href="/2020-12-07/java-thread/"/>
      <url>/2020-12-07/java-thread/</url>
      
        <content type="html"><![CDATA[<p>线程是操作系统中能够进行运算调度的最小单位了。它被包含在进程中，是进程在运行过程中，真正的『打工人』。每一个进程有且至少有一个线程存在，默认的线程我们可以把它叫作『主线程』。</p><p>在 Java 中，进行线程的切换是一件比较浪费资料的事情，这意味着代码的执行需要从用户态切换到内核态，然后再从内核态切换回用户态。但这也不是说我们不能用线程，合理的使用可以提高程序执行的吞吐率。</p><p>既然上面提到了『线程切换』，那我们就来聊聊，线程的几种状态。</p><span id="more"></span><h2 id="线程的六种状态"><a href="#线程的六种状态" class="headerlink" title="线程的六种状态"></a>线程的六种状态</h2><p>根据<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.State.html">官方文档</a>来看，Java 中线程有六种状态，分别是 <code>NEW</code>、<code>RUNNABLE</code>、<code>BLOCKED</code>、<code>WAITING</code>、<code>TIMED_WAITING</code> 和 <code>TERMINATED</code>。</p><h3 id="NEW"><a href="#NEW" class="headerlink" title="NEW"></a><strong>NEW</strong></h3><p>刚创建线程对象时，线程就处在这个状态。该状态只能向下一个状态 <code>RUNNABLE</code> 发生转换，一旦发生转换，则无法再回到 <code>NEW</code> 状态。</p><p>比如下方代码：</p><pre><code class="java">Runnable runnable = new Runnable() &#123;    @Override    public void run() &#123; &#125;&#125;;Thread thread = new Thread(runnable);System.out.println(&quot;t1 state: &quot; + thread.getState());</code></pre><p>则会看到输出：</p><pre><code>t1 state: NEW</code></pre><h3 id="RUNNABLE"><a href="#RUNNABLE" class="headerlink" title="RUNNABLE"></a><strong>RUNNABLE</strong></h3><p>当应用程序调用了线程对象的 <code>start()</code> 方法之后，该线程就会进入 <code>RUNNABLE</code> 状态。此时，该线程会被置于可运行的线程池中，等待被线程调度选中，获取 CPU 的使用权。一旦线程获取到 CPU 的使用权，则开始真正执行程序代码。我们还可以将这个状态细分为 <code>READY</code> 和 <code>RUNNING</code> 两种状态，用于区分线程是否抢占到 CPU，已经开始运行代码了。</p><pre><code class="java">Runnable runnable = new Runnable() &#123;    @Override    public void run() &#123; &#125;&#125;;Thread thread = new Thread(runnable);thread.start();System.out.println(&quot;t1 state: &quot; + thread.getState());</code></pre><p>则会输出：</p><pre><code>t1 state: RUNNABLE</code></pre><h3 id="BLOCKED"><a href="#BLOCKED" class="headerlink" title="BLOCKED"></a><strong>BLOCKED</strong></h3><p>在这种状态下，线程一般是在等待 monitor 的锁。一般我们管这种状态叫『阻塞状态』。进入阻塞状态是因为某种原因下，线程放弃了 CPU 的使用权，线程暂停执行代码，进入阻塞状态。</p><p>用下面的例子来说明：</p><pre><code class="java">public class Main &#123;    public static void main(String[] args) throws InterruptedException &#123;        Thread t1 = new Thread(new DemoThreadB());        Thread t2 = new Thread(new DemoThreadB());        t1.start();        t2.start();        Thread.sleep(1000);        System.out.println(&quot;t2 state: &quot; + t2.getState());        System.exit(0);    &#125;    static class DemoThreadB implements Runnable &#123;        @Override        public void run() &#123;            process();        &#125;        public static synchronized void process() &#123;            while(true) &#123;                // 模拟重量级的过程处理，t1 如果正在运行该代码块，则 t2 就会进入 BLOCKED 状态            &#125;        &#125;    &#125;&#125;</code></pre><p>这个例子中创建了 t1 和 t2 两个线程。t1 在调用 <code>start()</code> 方法后进入 <code>process()</code> 方法。因为这里使用了 <code>while(true)</code> 来保证线程不会轻易狗带，所以 t2 就甭想抢占到 CPU 并执行 <code>process()</code> 方法。但 t2 也调用了 <code>start()</code> 方法进入了 <code>RUNNABLE</code> 状态，又由于比 t1 晚了一步，所以只能进入 <code>BLOCKED</code> 状态，等待 t1 释放锁。</p><p>该例子会输出：</p><pre><code>t2 state: BLOCKED</code></pre><h3 id="WAITING"><a href="#WAITING" class="headerlink" title="WAITING"></a><strong>WAITING</strong></h3><p>在这种状态下，线程就是在<strong>无限期</strong>等待其他线程完成某个操作。比如说，某个线程在一个对象上调用了 <code>Object.wait()</code>，就是在等待另一个线程对该对象调用 <code>Object.notifiy()</code> 或者 <code>Object.nofityAll()</code>。有可能引起线程进入 <code>WATING</code> 状态的方法有下面几种：<br>    - <code>Object.wait()</code> 无超时的等待<br>    - <code>Thread.join()</code> 无超时的等待<br>    - <code>LockSupport.park()</code></p><p>我们使用下面的例子来模拟这个状态：</p><pre><code class="java">public class Main &#123;    static Thread t1;    public static void main(String[] args) throws InterruptedException &#123;        Thread t2 = new Thread(new DemoThreadB());        t1 = new Thread(new DemoThreadA(t2));        t1.start();    &#125;    static class DemoThreadA implements Runnable &#123;        Thread t2;        DemoThreadA(Thread thread) &#123;            this.t2 = thread;        &#125;        @Override        public void run() &#123;            this.t2.start();            try &#123;                this.t2.join();                System.out.println(&quot;t1 state: &quot; + t1.getState());            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    static class DemoThreadB implements Runnable &#123;        @Override        public void run() &#123;            try &#123;                Thread.sleep(1000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(&quot;t1 state: &quot; + t1.getState());        &#125;    &#125;&#125;</code></pre><p>上面的例子中，创建了两个线程 t1 和 t2，并且在 t1 的 <code>run()</code> 方法中启动了 t2，并且调用了 t2 的 <code>join()</code> 方法。此时，t1 就进入了 <code>WAITING</code> 状态，当 t2 的 <code>run()</code> 方法执行完毕后，t1 就会从 <code>WAIT</code> 状态回到 <code>RUNNABLE</code> 状态。</p><p>所以上述代码的执行结果如下：</p><pre><code>t1 state: WAITINGt1 state: RUNNABLE</code></pre><h3 id="TIMED-WAITING"><a href="#TIMED-WAITING" class="headerlink" title="TIMED_WAITING"></a><strong>TIMED_WAITING</strong></h3><p>顾名思义，这种状态也是 <code>WAITNG</code> 状态，只不过这种状态是<strong>有等待时限</strong>的。有可能引起线程进入 <code>TIMED_WAITING</code> 状态的方法有下面几种：<br>    - <code>Thread.sleep(long millis)</code> 不必介绍<br>    - <code>Object.wait(long timeout)</code> 带有时限的 <code>Object.wait()</code><br>    - <code>Thread.join(long millis)</code> 带有时限的 <code>Thread.join()</code><br>    - <code>LockSupport.parkNanos(Object blocker, long nanos)</code><br>    - <code>LockSupport.parkUntil(Object blocker, long deadline)</code></p><p>同样地，我们使用一个例子来演示这个状态：</p><pre><code class="java">public class Main &#123;    public static void main(String[] args) throws InterruptedException &#123;        Thread t1 = new Thread(new DemoThreadC());        t1.start();        Thread.sleep(1000);        System.out.println(&quot;t1 state: &quot; + t1.getState());    &#125;    static class DemoThreadC implements Runnable &#123;        @Override        public void run() &#123;            try &#123;                Thread.sleep(3000);                // Thread.join(3000);                // LockSupport.parkNanos(this, 3000000000);                // LockSupport.parkUntil(this, 3000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;</code></pre><p>主线程 sleep 1 秒就结束了，而子线程 t1 则由于『业务量巨大』导致 sleep 3 秒后才能退出，在 1 秒之后观察 t1 的状态，则输出如下：</p><pre><code>t1 state: TIMED_WAITING</code></pre><h3 id="TERMINATED"><a href="#TERMINATED" class="headerlink" title="TERMINATED"></a><strong>TERMINATED</strong></h3><p>线程的 <code>run()</code> 方法执行完毕，或者因为异常导致退出了 <code>run()</code> 方法，则该线程的生命周期就结束了，进入 <code>TERMINATED</code> 状态。进入 <code>TERMINATED</code> 状态的线程不可再次重生。</p><p>这个例子就简单多了：</p><pre><code class="java">Runnable runnable = new Runnable() &#123;    @Override    public void run() &#123; &#125;&#125;;Thread t1 = new Thread(runnable);t1.start();Thread.sleep(1000);System.out.println(&quot;t1 state: &quot; + t1.getState());</code></pre><p>线程瞬间运行完毕（因为 run() 方法为空），1秒后观察 t1 的状态，就会有如下输出：</p><pre><code>t1 state: TERMINATED</code></pre><p>下面用一张图来展示这六种状态之间的关系：</p><p><img src="https://s3.ax1x.com/2020/12/07/DxHtAO.png" alt="线程的六种状态转换"></p><p>按时间顺序来解释一下：</p><ul><li><code>NEW</code> 状态下的线程，在调用 <code>start()</code> 方法之后，进入 <code>RUNNABLE</code> 状态。此时可以细分为 <code>READY</code> 和 <code>RUNNING</code> 两种状态，<code>READY</code> 状态下还未抢占到 CPU，代码无法执行；抢占到 CPU，则进入 <code>RUNNING</code> 状态，开始执行代码；</li><li>如果在 <code>RUNNABLE</code> 状态下调用了 <code>Object.wait()</code> 或者 <code>Thread.join()</code> 或者 <code>LockSupport.park()</code>，则进入 <code>WAIT</code> 状态；</li><li>如果在 <code>RUNNABLE</code> 状态下调用了 <code>Thread.sleep(long millis)</code> 或者 <code>Object.wait(long timeout)</code> 或者 <code>Thread.join(long millis)</code> 或者 <code>LockSupport.parkNanos(Object locker, long nanos)</code> 或者 <code>LockSupport.parkUntil(Object blocker, long deadline)</code>，则进入 <code>TIMED_WAITING</code> 状态；</li><li>如果在 <code>RUNNABLE</code> 状态下还需要等待 monitor 锁进入同步代码块或者重入同步代码块，则进入 <code>BLOCKED</code> 状态；</li><li>在 <code>WAITING</code> 或者 <code>TIMED_WAITING</code> 状态下，如果其他线程调用了 <code>Object.notify()</code> 或者 <code>Object.nofityAll()</code> 方法，则进入 <code>RUNNABLE</code> 状态，</li><li>在 <code>BLOCKED</code> 状态下，一旦获取 monitor 锁，则回到 <code>RUNNABLE</code> 状态；</li><li>在 <code>WAITING</code> 或者 <code>TIMED_WAITING</code> 或者 <code>BLOCKED</code> 状态下，线程代码执行结束，或因为异常提前结束，都会进入 <code>TERMINATED</code> 状态。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Thread </tag>
            
            <tag> Thread-Safe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发者必须掌握的设计模式</title>
      <link href="/2020-09-09/design-pattern-must/"/>
      <url>/2020-09-09/design-pattern-must/</url>
      
        <content type="html"><![CDATA[<p>注意：本笔记为设计模式核心学习笔记，为笔者快速复习和回顾设计模式时使用，更详细的教程请查看更专业的设计模式教程。</p><span id="more"></span><h2 id="一、设计模式六大原则"><a href="#一、设计模式六大原则" class="headerlink" title="一、设计模式六大原则"></a>一、设计模式六大原则</h2><p>设计模式有六大原则，如下所示：</p><ul><li>单一职责原则</li><li>开放封闭原则</li><li>里氏替换原则</li><li>依赖倒置</li><li>迪米特原则</li><li>接口隔离原则</li></ul><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>一个类应该仅有一个引起它变化的原因，即不要让一个类承担过多的职责，以此降低耦合性。</p><h3 id="开放封闭原则"><a href="#开放封闭原则" class="headerlink" title="开放封闭原则"></a>开放封闭原则</h3><p>类、函数、模块应该是可以扩展的，但是不可以修改，即对扩展开放，修改封闭。</p><h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><p>所有引用基类的地方都能透明地替换为子类对象，即可以在定义时尽量使用基类对象，等到运行时再确定其子类类型，用子类对象来替换父类对象。</p><h3 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h3><p>高层、底层模块、模块间和细节都应该依赖于抽象，即通过接口或抽象类产生依赖关系。</p><h3 id="迪米特原则"><a href="#迪米特原则" class="headerlink" title="迪米特原则"></a>迪米特原则</h3><p>一个软件实体应该尽可能少地与其它实体发生相互作用，即最少知识原则。</p><p>如果一个对象需要调用其它对象的某个方法，可以通过第三者来调用，这个第三者的作用就如Android中的事件总线EventBus一样。</p><h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><p>一个类对另一个类的依赖应该建立在最小的接口上。</p><h2 id="二、设计模式分类"><a href="#二、设计模式分类" class="headerlink" title="二、设计模式分类"></a>二、设计模式分类</h2><p>GoF提出的设计模式有23种，按照目的准则分类，有三大类：</p><ul><li>创建性设计模式5种：单例、工厂方法、抽象工厂、建造者、原型。</li><li>结构型设计模式7种：适配器、装饰、代理、外观、桥接、组合、享元。</li><li>行为型设计模式11种：策略、模板方法、观察者、迭代器、责任链、命令、备忘录、状态、访问者、中介者、解释器。</li></ul><h2 id="三、Android开发常用设计模式"><a href="#三、Android开发常用设计模式" class="headerlink" title="三、Android开发常用设计模式"></a>三、Android开发常用设计模式</h2><h3 id="1、创建型设计模式"><a href="#1、创建型设计模式" class="headerlink" title="1、创建型设计模式"></a>1、创建型设计模式</h3><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>保证一个类仅有一个实例，提供一个访问它的全局访问点。</p><p>单例模式共有5种写法：</p><h5 id="1、饿汉模式"><a href="#1、饿汉模式" class="headerlink" title="1、饿汉模式"></a>1、饿汉模式</h5><pre><code class="java">public class Singleton &#123;    private static Singleton instance = new Singleton;    private Singleton () &#123;            &#125;    public static Singleton getInstance() &#123;        return instance;    &#125;&#125;</code></pre><ul><li>在类加载的时候就完成实例化，如果从始至终未使用这个实例，则会造成内存的浪费。</li></ul><h5 id="2、懒汉模式（线程安全）"><a href="#2、懒汉模式（线程安全）" class="headerlink" title="2、懒汉模式（线程安全）"></a>2、懒汉模式（线程安全）</h5><pre><code class="java">public class Singletion &#123;    private static Singleton instance;    private Singleton () &#123;    &#125;    public static synchronized Singleton getInstance() &#123;        if (instance == null) &#123;            instance = new Singleton();        &#125;        return instance;    &#125;&#125;</code></pre><ul><li>为了处理并发，每次调用getInstance方法时都需要进行同步，会有不必要的同步开销。</li></ul><h5 id="3、双重检查模式（DCL）"><a href="#3、双重检查模式（DCL）" class="headerlink" title="3、双重检查模式（DCL）"></a>3、双重检查模式（DCL）</h5><pre><code class="java">public class Singleton &#123;    private static volatile Singleton instance;    private Singleton &#123;    &#125;    public static Singleton getInstance() &#123;        if (instance == null) &#123;            synchronized (Singleton.class) &#123;                if (instance == null) &#123;                    instance = new Singleton();                &#125;            &#125;        &#125;        return instance;    &#125;&#125;</code></pre><ul><li>第一次判空，省去了不必要的同步。第二次是在Singleton等于空时才创建实例。</li><li>使用volatile保证了实例的可见性。</li><li>DCL在一定程度上解决了资源的消耗和多余的同步、线程安全等问题，但是在某些情况下会失效。</li></ul><p>假设线程A执行到instance = new Singleton()语句，看起来只有一行代码，但实际上它并不是原子操作，这句代码最终会被编译成多条汇编指令，它大致做了3件事：</p><p>1）给instance的实例分配内存。</p><p>2）调用Singleton()构造函数，初始化成员字段。</p><p>3）将instance对象指向分配的内存空间（此时instance就不是null了）。</p><p>但是，由于Java编译器允许处理器乱序执行，以及JDK1.5之前JMM中的Cache、寄存器到主内存回写顺序的规定，上面的2和3的顺序是无法保证的，也就是说，执行顺序可能是1-2-3也可能是1-3-2。如果是后者，并且在3执行完毕、2未执行之前，被切换到线程B上，这时候instance因为已经在线程A内执行过了3，instance已经是非空了，所以，线程B直接取走instance，再使用时就会出错，这就是DCL失效问题，而且这种难以跟踪难以重现的错误可能会隐藏很久。</p><p>在JDK1.5之后，SUN官方已经注意到这种问题，调整了JVM，具体化了volatile关键字，因此，如果JDK1.5或之后的版本，只需要将instance的定义改成private volatile static Singleton instance = null就可以保证instance对象每次都是从主内存中读取，就可以使用DCL的写法来完成单例模式。当然，volatile或多或少也会影响到性能，但考虑到程序的正确性，这点牺牲也是值得的。</p><p>DCL优点：资源利用率高，第一次执行getInstance时单例对象才会被实例化，效率高。</p><p>缺点：第一次加载稍慢，也由于JMM的原因导致偶尔会失败。在高并发环境下也有一定的缺陷，虽然发生概率很小。DCL模式是使用最多的单例实现方式，它能够在需要时才实例化对象，并且能在绝大多数场景下保证对象的唯一性，除非你的代码在并发场景比较复杂或低于JDK1.6版本下使用，否则，这种方式一般能够满足要求。</p><h5 id="4、静态内部类单例模式"><a href="#4、静态内部类单例模式" class="headerlink" title="4、静态内部类单例模式"></a>4、静态内部类单例模式</h5><pre><code class="java">public class Singleton() &#123;    private Singleton() &#123;    &#125;    public static Singleton getInstance() &#123;        return SingletonHolder.sInstance;    &#125;    private static class SingletonHolder &#123;        private static final Singleton sInstance = new Singleton();    &#125;&#125;</code></pre><ul><li>第一次调用getInstance方法时虚拟机才加载SingletonHolder并初始化sInstance，这样保证了线程安全和实例的唯一性。</li></ul><h5 id="5、枚举单例"><a href="#5、枚举单例" class="headerlink" title="5、枚举单例"></a>5、枚举单例</h5><pre><code class="java">public enum Singleton &#123;    INSTANCE;    public void doSomeThing() &#123;    &#125;&#125;</code></pre><ul><li>默认枚举实例的创建是线程安全的，并且在任何情况下都是单例。</li><li>简单、可读性不高。</li></ul><p>注意：上面的几种单例模式创建的单例对象被反序列化时会重新创建实例，可以重写readReslove方法返回当前的单例对象。</p><h4 id="简单工厂模式（补充）"><a href="#简单工厂模式（补充）" class="headerlink" title="简单工厂模式（补充）"></a>简单工厂模式（补充）</h4><p>也称为静态工厂方法模式，由一个工厂对象决定创建出哪一种产品类的实例。</p><p>简单工厂模式中有如下角色：</p><ul><li>工厂类：核心，负责创建所有实例的内部逻辑，由外界直接调用。</li><li>抽象产品类：要创建所有对象的抽象父类，负责描述所有实例所共有的公共接口。</li><li>具体产品类：要创建的产品。</li></ul><h5 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h5><p>1、抽象产品类</p><pre><code class="java">public abstract class Computer &#123;    public abstarct void start();&#125;</code></pre><p>2、具体产品类</p><pre><code class="java">public class LenovaComputer extends Computer &#123;    @Override    public void start() &#123;        ...    &#125;&#125;public class HpComputer extends Computer &#123;    @Override    public void start() &#123;        ...    &#125;&#125;public class AsusComputer extends Computer &#123;    @Override    public void start() &#123;        ...    &#125;&#125;</code></pre><p>3、工厂类</p><pre><code class="java">public class ComputerFactory &#123;    public static Computer createComputer(String type) &#123;        Computer mComputer = null;        switch (type) &#123;            case &quot;lenovo&quot;:                mComputer = new LenovoComputer();                break;            case &quot;hp&quot;:                mComputer = new HpComputer();                break;            case &quot;asus&quot;:                mComputer = new AsusComputer();                break;        &#125;        return mComputer;    &#125;&#125;</code></pre><ul><li>它需要知道所有工厂类型，因此只适合工厂类负责创建的对象比较少的情况。</li><li>避免直接实例化类，降低耦合性。</li><li>增加新产品需要修改工厂，违背开放封闭原则。</li></ul><h4 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h4><p>定义一个用于创建对象的接口，使类的实例化延迟到子类。</p><p>工厂方法有以下角色：</p><ul><li>抽象产品类。</li><li>具体产品类。</li><li>抽象工厂类：返回一个泛型的产品对象。</li><li>具体工厂类：返回具体的产品对象。</li></ul><h5 id="简单示例-1"><a href="#简单示例-1" class="headerlink" title="简单示例"></a>简单示例</h5><p>抽象产品类和具体产品类同简单工厂一样。</p><p>3、抽象工厂类</p><pre><code class="java">public abstract class ComputerFactory &#123;    public abstract &lt;T extends Computer&gt; T createComputer(Class&lt;T&gt; clz);&#125;</code></pre><p>4、具体工厂类</p><pre><code class="java">public class GDComputerFactory extends ComputerFactory &#123;    @Override    public &lt;T extends Computer&gt; T createComputer(Class&lt;T&gt; clz) &#123;        Computer computer = null;        String classname = clz.getName();        try &#123;            computer = (Computer) Class.forName(classname).newInstance();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        return (T) computer;    &#125;&#125;</code></pre><ul><li>相比简单工厂，如果我们需要新增产品类，无需修改工厂类，直接创建产品即可。</li></ul><h4 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h4><p>将一个复杂对象的构建和它的表示分离，使得同样的构建过程可以创建不同的表示。</p><p>建造者有以下角色：</p><ul><li>导演类：负责安排已有模块的安装顺序，最后通知建造者开始建造。</li><li>建造者：抽象Builder类，用于规范产品的组建。</li><li>具体建造者：实现抽象Builder类的所有方法，并返回建造好的对象。</li><li>产品类。</li></ul><h5 id="简单示例-2"><a href="#简单示例-2" class="headerlink" title="简单示例"></a>简单示例</h5><p>1、产品类</p><pre><code class="java">public class Computer &#123;    private String mCpu;    private Stiring mMainboard;    private String mRam;    public void setmCpu(String mCpu) &#123;        this.mCpu = mCpu;    &#125;    public void setmMainboard(String mMainboard) &#123;        this.mMainboard = mMainboard;    &#125;    public void setmRam(String mRam) &#123;        this.mRam = mRam;    &#125;&#125;</code></pre><p>2、抽象建造者</p><pre><code class="java">public abstract class Builder &#123;    public abstract void buildCpu(String cpu);    public abstract void buildMainboard(String mainboard);    public abstract void buildRam(String ram);    public abstract Computer create();&#125;</code></pre><p>3、具体建造者</p><pre><code class="java">public class MoonComputerBuilder extends Builder &#123;    private Computer mComputer = new Computer();        @Override    public void buildCpu(String cpu) &#123;        mComputer.setmCpu(cpu);    &#125;        @Override    public void buildMainboard(String mainboard) &#123;        mComputer.setmMainboard(mainboard);    &#125;        @Override    public void buildRam(String ram) &#123;        mComputer.setmRam(ram);    &#125;        @Override    public Computer create() &#123;        return mComputer;    &#125;&#125;</code></pre><p>4、导演类</p><pre><code class="java">public class Director &#123;    Builder mBuilder = null;    public Director (Builder builder) &#123;        this.mBuilder = builder;    &#125;        public Computer createComputer(String cpu, String mainboard, String ram) &#123;        this.mBuilder.buildCpu(cpu);        this.mBuilder.buildMainboard(mainboard);        this.mBuilder.buildRam(ram);        return mBuilder.create();    &#125;&#125;</code></pre><ul><li>屏蔽产品内部组成细节。</li><li>具体建造者类之间相互独立，容易扩展。</li><li>会产生多余的建造者对象和导演类。</li></ul><h3 id="2、结构型设计模式"><a href="#2、结构型设计模式" class="headerlink" title="2、结构型设计模式"></a>2、结构型设计模式</h3><h4 id="1、代理模式"><a href="#1、代理模式" class="headerlink" title="1、代理模式"></a>1、代理模式</h4><p>为其它对象提供一种代理以控制这个对象的访问。</p><p>代理模式中有以下角色：</p><ul><li>抽象主题类：声明真实主题和代理的共同接口方法。</li><li>真实主题类。</li><li>代理类：持有对真实主题类的引用。</li><li>客户端类。</li></ul><h5 id="静态代理示例代码"><a href="#静态代理示例代码" class="headerlink" title="静态代理示例代码"></a>静态代理示例代码</h5><p>1、抽象主题类</p><pre><code class="java">public interface IShop &#123;    void buy();&#125;</code></pre><p>2、真实主题类</p><pre><code class="java">public class JsonChao implements IShop &#123;    @Override     public void buy() &#123;        ...    &#125;&#125;</code></pre><p>3、代理类</p><pre><code class="java">public class Purchasing implements IShop &#123;    private IShop mShop;    public Purchasing(IShop shop) &#123;        this.mShop = shop;    &#125;        @Override     public void buy() &#123;        mShop.buy();    &#125;&#125;</code></pre><p>4、客户端类</p><pre><code class="java">public class Clent &#123;        public static void main(String[] args) &#123;        IShop jsonChao = new JsonChao();        IShop purchasing = new Purchasing(jsonChao);        purchasing.buy();    &#125;&#125;</code></pre><h5 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h5><p>在代码运行时通过反射来动态地生成代理类的对象，并确定到底来代理谁。</p><h5 id="动态代理示例代码"><a href="#动态代理示例代码" class="headerlink" title="动态代理示例代码"></a>动态代理示例代码</h5><p>改写静态代理的代理类和客户端类，如下所示：</p><p>1、动态代理类</p><pre><code class="java">public class DynamicPurchasing implements InvocationHandler &#123;    private Object obj;    public DynamicPurchasing(Object obj) &#123;        this.obj = obj;    &#125;        @Overrdie    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;        return method.invoke(obj, args);    &#125;&#125;</code></pre><p>2、客户端类</p><pre><code class="java">public class Clent &#123;        public static void main(String[] args) &#123;        IShop jsonChao = new JsonChao();        DynamicPurchasing mDynamicPurchasing = new DynamicPurchasing(jsonChao);        ClassLoader cl = jsonChao.getClass.getClassLoader();        IShop purchasing = Proxy.newProxyInstance(cl, new Class[]&#123;IShop.class&#125;, mDynamicPurchasing);        purchasing.buy();    &#125;&#125;</code></pre><ul><li>真实主题类发生变化时，由于它实现了公用的接口，因此代理类不需要修改。</li></ul><h4 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h4><p>动态地给一个对象添加一些额外的职责。</p><p>装饰模式有以下角色：</p><ul><li>抽象组件：接口/抽象类，被装饰的最原始的对象。</li><li>具体组件：被装饰的具体对象。</li><li>抽象装饰者：扩展抽象组件的功能。</li><li>具体装饰者：装饰者具体实现类。</li></ul><h5 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h5><p>1、抽象组件</p><pre><code class="java">public abstract class Swordsman &#123;    public abstract void attackMagic();&#125;</code></pre><p>2、具体组件</p><pre><code class="java">public class YangGuo extends Swordsman &#123;    @Override    public void attackMagic() &#123;        ...    &#125;&#125;</code></pre><p>3、抽象装饰者</p><p>抽象装饰者必须持有抽象组件的引用，以便扩展功能。</p><pre><code class="java">public abstract class Master extends Swordsman &#123;    private Swordsman swordsman;    public Master(Swordsman swordsman) &#123;        this.swordman = swordman;    &#125;        @Override    public void attackMagic() &#123;        swordsman.attackMagic();    &#125;&#125;</code></pre><p>4、具体装饰者</p><pre><code class="java">public class HongQiGong extends Master &#123;    public HongQiGong(Swordsman swordsman) &#123;        this.swordsman = swordsman;    &#125;        public void teachAttackMagic() &#123;        ...    &#125;        @Override    public void attackMagic() &#123;        super.attackMagic();        teackAttackMagic();    &#125;&#125;</code></pre><p>5、使用</p><pre><code class="java">YangGuo mYangGuo = new YangGuo();HongQiGong mHongQiGong = new HongQiGong(mYangGuo);mHongQiGong.attackMagic();</code></pre><ul><li>使用组合，动态地扩展对象的功能，在运行时能够使用不同的装饰器实现不同的行为。</li><li>比继承更易出错，旨在必要时使用。</li></ul><h4 id="外观模式（门面模式）"><a href="#外观模式（门面模式）" class="headerlink" title="外观模式（门面模式）"></a>外观模式（门面模式）</h4><p>一个子系统的内部和外部通信必须通过一个统一的对象进行。即提供一个高层的接口，方便子系统更易于使用。</p><p>外观模式有以下角色：</p><ul><li>外观类：将客户端的请求代理给适当的子系统对象。</li><li>子系统类：可以有一个或多个子系统，用于处理外观类指派的任务。注意子系统不含外观类的引用。</li></ul><h5 id="简单示例-3"><a href="#简单示例-3" class="headerlink" title="简单示例"></a>简单示例</h5><p>1、子系统类（这个有三个子系统）</p><pre><code class="java">public class ZhaoShi &#123;    public void TaiJiQuan() &#123;        ...    &#125;        public void QiShanQuan() &#123;        ...    &#125;        public void ShengHuo() &#123;        ...    &#125;&#125;public class NeiGong &#123;    public void JiuYang() &#123;        ...    &#125;        public void QianKun() &#123;        ...    &#125;&#125;public class JingMai &#123;    public void JingMai() &#123;        ...    &#125;&#125;</code></pre><p>2、外观类</p><pre><code class="java">public class ZhangWuJi &#123;    private ZhaoShi zhaoShi;    private JingMai jingMai;    pirvate Neigong neiGong;        public ZhangWuJi() &#123;        zhaoShi = new ZhaoShi();        jingMai = new JingMai();        neiGong = new NeiGong();    &#125;        public void qianKun() &#123;        jingMai.JingMai();        neiGong.QianKun();    &#125;        public void qiShang() &#123;        jingMai.JingMai();        neiGong.JiuYang();        zhaoShi.QiShangQuan();    &#125;&#125;</code></pre><p>3、使用</p><pre><code class="java">ZhangWuJi zhangWuJi = new ZhangWuJi();zhangWuJi.QianKun();zhangWuJi.QiShang();</code></pre><ul><li>将对子系统的依赖转换为对外观类的依赖。</li><li>对外部隐藏子系统的具体实现。</li><li>这种外观特性增强了安全性。</li></ul><h4 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h4><p>使用共享对象有效支持大量细粒度（性质相似）的对象。</p><p>额外的两个概念：</p><ul><li>1、内部状态：共享信息，不可改变。</li><li>2、外部状态：依赖标记，可以改变。</li></ul><p>享元模式有以下角色：</p><ul><li>抽象享元角色：定义对象内部和外部状态的接口。</li><li>具体享元角色：实现抽象享元角色的任务。</li><li>享元工厂：管理对象池及创建享元对象。</li></ul><h5 id="简单示例-4"><a href="#简单示例-4" class="headerlink" title="简单示例"></a>简单示例</h5><p>1、抽象享元角色</p><pre><code class="java">public interface IGoods &#123;    public void showGoodsPrice(String name);&#125;</code></pre><p>2、具体享元角色</p><pre><code class="java">public class Goods implements IGoods &#123;    private String name;    private String price;        Goods (String name) &#123;        this.name = name;    &#125;        @Override    public void showGoodsPrice(String name) &#123;        ...    &#125;&#125;</code></pre><p>3、享元工厂</p><pre><code class="java">public class GoodsFactory &#123;    private static Map&lt;String, Goods&gt; pool = new HashMap&lt;String, Goods&gt;();    public static Goods getGoods(String name) &#123;        if (pool.containsKey(name)) &#123;            return pool.get(name);        &#125; else &#123;            Goods goods = new Goods(name);            pool.put(name, goods);            return goods;        &#125;    &#125;&#125;</code></pre><p>4、使用</p><pre><code class="java">Goods goods1 = GoodsFactory.getGoods(&quot;Android进阶之光&quot;);goods1.showGoodsPrice(&quot;普通版&quot;);Goods goods2 = GoodsFactory.getGoods(&quot;Android进阶之光&quot;);goods1.showGoodsPrice(&quot;普通版&quot;);Goods goods3 = GoodsFactory.getGoods(&quot;Android进阶之光&quot;);goods1.showGoodsPrice(&quot;签名版&quot;);</code></pre><p>goods1为新创建的对象，后面的都是从对象池中取出的缓存对象。</p><h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><p>将一个接口转换为另一个需要的接口。</p><p>适配器有以下角色：</p><ul><li>要转换的接口。</li><li>要转换的接口的实现类。</li><li>转换后的接口。</li><li>转换后的接口的实现类。</li><li>适配器类。</li></ul><h5 id="简单示例-5"><a href="#简单示例-5" class="headerlink" title="简单示例"></a>简单示例</h5><p>1、要转换的接口（火鸡）</p><pre><code class="java">public interface Turkey &#123;    public void gobble();    public void fly();&#125;</code></pre><p>2、要转换的接口的实现类</p><pre><code class="java">public class WildTurkey implements Turkey &#123;    @Override    public void gobble() &#123;        ...    &#125;        @Override    public void fly() &#123;        ...    &#125;&#125;</code></pre><p>3、转换后的接口（鸭子）</p><pre><code class="java">public interface Duck &#123;    public void quack();    public void fly();&#125;</code></pre><p>4、转换后的接口的实现类。</p><pre><code class="java">public class MallardDuck implements Duck &#123;    @Override    public void quack() &#123;        ...    &#125;        @Overrdie    public void fly() &#123;        ...    &#125;&#125;</code></pre><p>5、适配器类</p><pre><code class="java">public class TurkeyAdapter implements Duck &#123;    Turkey turkey;        public TurkeyAdapter(Turkey turkey) &#123;        this.turkey = turkey;    &#125;        @Override    public void quack() &#123;        turkey.gobble();    &#125;        @Override    public void fly() &#123;        // 火鸡没有鸭子飞的远，因此多飞几次，达到适配鸭子fly的作用        for(int i;i &lt; 5;i++) &#123;            turkey.fly();        &#125;    &#125;&#125;</code></pre><p>6、使用</p><pre><code class="java">WildTurkey wildTurkey = new WildTurkey();TurkeyAdapter turkeyAdapter = new TurkeyAdapter(wildTurkey);turkeyAdapter.quack();turkeyAdapter.fly();</code></pre><ul><li>注重适度使用即可。</li></ul><h3 id="3、行为型设计模式"><a href="#3、行为型设计模式" class="headerlink" title="3、行为型设计模式"></a>3、行为型设计模式</h3><h4 id="1、策略模式"><a href="#1、策略模式" class="headerlink" title="1、策略模式"></a>1、策略模式</h4><p>定义一系列的算法，将每一个算法都封装起来，并且可相互替换。这使得算法可以独立于调用者而单独变化。</p><p>策略模式有以下角色：</p><ul><li>上下文角色：用来操作策略使用的上下文环境。屏蔽了高层模块对策略和算法的直接访问。</li><li>抽象策略角色。</li><li>具体策略角色。</li></ul><h5 id="简单示例-6"><a href="#简单示例-6" class="headerlink" title="简单示例"></a>简单示例</h5><p>1、抽象策略角色</p><pre><code class="java">public interface FightingStrategy &#123;    public void fighting();&#125;</code></pre><p>2、具体策略角色</p><pre><code class="java">public class WeakRivalStrategy implements FightingStrategy &#123;        @Override    public void fighting() &#123;        ...    &#125;&#125;public class CommonRivalStrategy implements FightingStrategy &#123;        @Override    public void fighting() &#123;        ...    &#125;&#125;public class StrongRivalStrategy implements FightingStrategy &#123;        @Override    public void fighting() &#123;        ...    &#125;&#125;</code></pre><p>3、上下文角色</p><pre><code class="java">public class Context &#123;    private FightingStrategy mFightingStrategy;        public void Context(FightingStrategy fightingStrategy) &#123;        this.mFightingStrategy = fightingStrategy;    &#125;        public void fighting() &#123;        mFightingStrategy.fighting();    &#125;&#125;</code></pre><p>4、使用</p><pre><code class="java">Context context;context = new Context(new WeakRivalStrategy());context.fighting();context = new Context(new CommonRivalStategy());context.fighting();context = new Context(new StrongRivalStategy());context.fighting();</code></pre><ul><li>隐藏具体策略中算法的实现细节。</li><li>避免使用多重条件语句。</li><li>易于扩展</li><li>每一个策略都是一个类，复用性小。</li><li>上层模块必须知道有哪些策略类，与迪米特原则相违背。</li></ul><h4 id="2、模板方法模式"><a href="#2、模板方法模式" class="headerlink" title="2、模板方法模式"></a>2、模板方法模式</h4><p>定义了一套算法框架，将某些步骤交给子类去实现。使得子类不需改变框架结构即可重写算法中的某些步骤。</p><p>模板方法模式有以下角色：</p><ul><li>抽象类：定义了一套算法框架。</li><li>具体实现类。</li></ul><h5 id="简单示例-7"><a href="#简单示例-7" class="headerlink" title="简单示例"></a>简单示例</h5><p>1、抽象类</p><pre><code class="java">public abstract class AbstractSwordsman &#123;    public final void fighting() &#123;        neigong();                // 这个是具体方法        jingmai();                if (hasWeapons()) &#123;            weapons();        &#125;                moves();                hook();    &#125;        protected void hook() &#123; &#125;;    protected void abstract neigong();    protected void abstract weapons();    protected void abstract moves();    public void jingmai() &#123;        ...    &#125;        protected boolean hasWeapons() &#123;        return ture;    &#125;&#125;</code></pre><p>2、具体实现类</p><pre><code class="java">public class ZhangWuJi extends AbstractSwordsman &#123;        @Override    public void neigong() &#123;        ...    &#125;        @Override     public void weapons() &#123;        // 没有武器，不做处理    &#125;        @Override     public void moves() &#123;        ...    &#125;        @Override    public boolean hasWeapons() &#123;        return false;    &#125;&#125;public class ZhangSanFeng extends AbstractSwordsman &#123;        @Override    public void neigong() &#123;        ...    &#125;        @Override     public void weapons() &#123;        ...    &#125;        @Override     public void moves() &#123;        ...    &#125;        @Override    public void hook() &#123;        // 额外处理        ...    &#125;&#125;</code></pre><p>3、使用</p><pre><code class="java">ZhangWuJi zhangWuJi = new ZhangWuJi();zhangWuJi.fighting();ZhangSanFeng zhangSanFeng = new ZhangSanFeng();zhangSanFeng.fighting();</code></pre><ul><li>可以使用hook方法实现子类对父类的反向控制。</li><li>可以把核心或固定的逻辑搬移到基类，其它细节交给子类实现。</li><li>每个不同的实现都需要定义一个子类，复用性小。</li></ul><h4 id="3、观察者模式（发布-订阅模式）"><a href="#3、观察者模式（发布-订阅模式）" class="headerlink" title="3、观察者模式（发布 - 订阅模式）"></a>3、观察者模式（发布 - 订阅模式）</h4><p>定义对象间的一种1对多的依赖关系，每当这个对象的状态改变时，其它的对象都会接收到通知并被自动更新。</p><p>观察者模式有以下角色：</p><ul><li>抽象被观察者：将所有已注册的观察者对象保存在一个集合中。</li><li>具体被观察者：当内部状态发生变化时，将会通知所有已注册的观察者。</li><li>抽象观察者：定义了一个更新接口，当被观察者状态改变时更新自己。</li><li>具体被观察者：实现抽象观察者的更新接口。</li></ul><h5 id="简单示例-8"><a href="#简单示例-8" class="headerlink" title="简单示例"></a>简单示例</h5><p>1、抽象观察者</p><pre><code class="java">public interface observer &#123;        public void update(String message);&#125;</code></pre><p>2、具体观察者</p><pre><code class="java">public class WeXinUser implements observer &#123;    private String name;        public WeXinUser(String name) &#123;        this.name = name;    &#125;        @Override    public void update(String message) &#123;        ...    &#125;&#125;</code></pre><p>3、抽象被观察者</p><pre><code class="java">public interface observable &#123;        public void addWeXinUser(WeXinUser weXinUser);        public void removeWeXinUser(WeXinUser weXinUser);        public void notify(String message);&#125;</code></pre><p>4、具体被观察者</p><pre><code class="java">public class Subscription implements observable &#123;    private List&lt;WeXinUser&gt; mUserList = new ArrayList();    @Override    public void addWeXinUser(WeXinUser weXinUser) &#123;        mUserList.add(weXinUser);    &#125;    @Override    public void removeWeXinUser(WeXinUser weXinUser) &#123;        mUserList.remove(weXinUser);    &#125;    @Override    public void notify(String message) &#123;        for(WeXinUser weXinUser : mUserList) &#123;            weXinUser.update(message);        &#125;    &#125;&#125;</code></pre><p>5、使用</p><pre><code class="java">Subscription subscription = new Subscription();WeXinUser hongYang = new WeXinUser(&quot;HongYang&quot;);WeXinUser rengYuGang = new WeXinUser(&quot;RengYuGang&quot;);WeXinUser liuWangShu = new WeXinUser(&quot;LiuWangShu&quot;);subscription.addWeiXinUser(hongYang);subscription.addWeiXinUser(rengYuGang);subscription.addWeiXinUser(liuWangShu);subscription.notify(&quot;New article coming&quot;);</code></pre><ul><li>实现了观察者和被观察者之间的抽象耦合，容易扩展。</li><li>有利于建立一套触发机制。</li><li>一个被观察者卡顿，会影响整体的执行效率。采用异步机制可解决此类问题。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MVC-MVP-MVVM 进化之路</title>
      <link href="/2020-08-17/mvc-mvp-mvvm/"/>
      <url>/2020-08-17/mvc-mvp-mvvm/</url>
      
        <content type="html"><![CDATA[<p>众所周知，日常开发中，比较受欢迎的设计模式，除了单例、工厂、装饰器等之外，被大家讨论最多的，就是 MVC、MVP 和 MVVM 了。</p><p>这三种设计模式各有千秋，耦合度都比较低，并且易于测试与维护。我们今天就来讨论一下这三种设计模式在开发中的应用。</p><span id="more"></span><blockquote><p>这篇文章中关于设计模式的讨论，都以 Android 平台做为示例环境，以 Kotlin 做为示例语言。</p></blockquote><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>MVC（Model-View-Controller），它有三个部分：<strong>模型（Model）</strong>、<strong>视图（View）</strong>和<strong>控制器（Controller）</strong>。</p><ul><li><p>Model<br>这部分功能比较明显，就是我们的应用需要显示的数据，它是一个类，其中承载了业务模型和数据模型；同时，它又提供数据的操作，并且直观地展示了数据的变化，当然，这种变化要遵循一定的业务逻辑。</p></li><li><p>View<br>View 代表了 UI 组件，如 XML、HTML 等，在 MVC 模式中，View 负责展现 Controller 交过来的数据，它会监听 Model 的状态变化，并展示数据更新后的 Model。Model 和 View 的交互是基于观察者模式。在 Android 中，各种 XML 布局，就是我们的 View 层。</p></li><li><p>Controller<br>Controller 负责处理各种请求。它会通过 Model 处理用户数据，并将处理结果交给 View 去展示，它通常扮演着 View 和 Model 之间的调度者的角色。显而易见地，在 Android 中，Activity 或 Fragment 担当了这个角色。</p></li></ul><p>其实 Activity 并非标准的 Controller，它一方面用来控制了布局，另一方面还要在 Activity 中写业务代码，造成了 Activity 既像 View 又像 Controller。</p><p>因此，<strong>这种开发方式不太适合 Android 开发</strong>。</p><p>MVC 的结构如下图所示：</p><p><img src="http://blog.cigis-cloud.com/design-pattern-1597991354.png" alt="MVC 结构"></p><p>我们用代码来展示一下 Android 中如何使用 MVC 模式，我们的例子是用户填写用户名密码，点击登录按钮之后，请求 UserInfo，并最终展示在界面上。</p><p>首先是 Model：</p><pre><code class="kotlin">class UserInfo &#123;    var uid: Int = 0     var name: String? = null    var phone: String? = null    var password: String? = null&#125;</code></pre><p>接下来是我们的 View 层，也就是 XML 布局：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;&gt;    &lt;LinearLayout        android:id=&quot;@+id/llPhone&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;        android:orientation=&quot;horizontal&quot;        android:layout_margin=&quot;16dp&quot;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;        app:layout_constraintStart_toStartOf=&quot;parent&quot;        app:layout_constraintTop_toTopOf=&quot;parent&quot;&gt;        &lt;TextView            android:layout_width=&quot;0dp&quot;            android:layout_height=&quot;wrap_content&quot;            android:layout_weight=&quot;1&quot;            android:text=&quot;PHONE&quot; /&gt;        &lt;EditText            android:id=&quot;@+id/etPhone&quot;            android:layout_width=&quot;0dp&quot;            android:layout_height=&quot;wrap_content&quot;            android:layout_weight=&quot;4&quot;            android:layout_marginStart=&quot;8dp&quot;            android:inputType=&quot;phone&quot;            android:hint=&quot;Input phone number&quot;             /&gt;    &lt;/LinearLayout&gt;    &lt;LinearLayout        android:id=&quot;@+id/llPassword&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_margin=&quot;16dp&quot;        android:orientation=&quot;horizontal&quot;        app:layout_constraintTop_toBottomOf=&quot;@+id/llPhone&quot;        tools:layout_editor_absoluteX=&quot;16dp&quot;&gt;        &lt;TextView            android:layout_width=&quot;0dp&quot;            android:layout_height=&quot;wrap_content&quot;            android:layout_weight=&quot;1&quot;            android:text=&quot;PASSWORD&quot; /&gt;        &lt;EditText            android:id=&quot;@+id/etPassword&quot;            android:layout_width=&quot;0dp&quot;            android:layout_height=&quot;wrap_content&quot;            android:layout_marginStart=&quot;8dp&quot;            android:layout_weight=&quot;4&quot;            android:hint=&quot;Input password&quot;            android:inputType=&quot;textVisiblePassword&quot; /&gt;    &lt;/LinearLayout&gt;    &lt;Button        android:id=&quot;@+id/btnLogin&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_margin=&quot;16dp&quot;        app:layout_constraintTop_toBottomOf=&quot;@+id/llPassword&quot;        tools:layout_editor_absoluteX=&quot;16dp&quot;        android:text=&quot;LOGIN&quot;/&gt;        &lt;TextView        android:id=&quot;@+id/tvUserInfo&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;        app:layout_constraintTop_toBottomOf=&quot;@id/btnLogin&quot;        android:layout_marginTop=&quot;16dp&quot; /&gt;    &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</code></pre><p>接着就是 Controller 层，也就是我们的 Activity：</p><pre><code class="kotlin">package me.codingrabbit.jetpacklearnimport androidx.appcompat.app.AppCompatActivityimport android.os.Bundleimport com.google.android.material.snackbar.Snackbarimport kotlinx.android.synthetic.main.activity_login.*import java.io.BufferedInputStreamimport java.io.InputStreamimport java.net.HttpURLConnectionimport java.net.URLimport javax.net.ssl.HttpsURLConnectionclass LoginActivity : AppCompatActivity(), Callback &#123;    override fun onCreate(savedInstanceState: Bundle?) &#123;        super.onCreate(savedInstanceState)        setContentView(R.layout.activity_login)        btnLogin.setOnClickListener &#123;            val userInfo = UserInfo()            userInfo.phone = etPhone.editableText.toString()            userInfo.password = etPassword.editableText.toString()            requestUserInfo(userInfo, this@LoginActivity)        &#125;    &#125;    override fun onSuccess(userInfo: UserInfo) &#123;        super.onSuccess(userInfo)        Snackbar.make(tvUserInfo, &quot;UserInfo: uid=$&#123;userInfo.uid&#125;, &quot; +                &quot;name=$&#123;userInfo.name&#125;, &quot; +                &quot;phone=$&#123;userInfo.phone&#125;&quot;, Snackbar.LENGTH_SHORT)    &#125;    override fun onError(msg: String) &#123;        super.onError(msg)        Snackbar.make(tvUserInfo, &quot;Error: $&#123;msg&#125;&quot;, Snackbar.LENGTH_SHORT)    &#125;    private fun requestUserInfo(userInfo: UserInfo, callback: Callback) &#123;        // 请求数据，省略        callback.onSuccess(userInfo)    &#125;&#125;</code></pre><p>可以看到，Activity 如上面所说，也的确是同时扮演了 View 和 Controller 的角色。</p><p>上面的流程可以用下图总结：</p><p><img src="http://blog.cigis-cloud.com/design-pattern-1597984167.png"></p><p>盘点一下 MVC 模式的优缺点：</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>Model 与 View 耦合度较低，方便进行单独的单元测试；</li><li>结构简单；</li><li>代码量少。</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>Model 与 View 并没有完全解耦，后期业务复杂度较高时，维护起来稍显复杂；</li><li>Controller 与 Android API 耦合度很高，测试起来比较麻烦；</li><li>Controller 与 View 耦合度很高，如果我们修改了 View，那么回头来还要修改 Controller，这也意味着，Controller 将会变得越来越臃肿和难以维护；</li><li>MVC 模型不适合小型 APP 的开发。</li></ol><h2 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h2><p>MVP（Model-View-Presenter）是 MVC 模式的演化版本，它也有三个部分：<strong>模型（Model）</strong>、<strong>视图（View）</strong>和<strong>展示（Presenter）</strong>。</p><ul><li><p>Model</p><p>与 MVC 中的 Model 不太相同。这里的 Model 指存取数据，也就是<strong>用来从指定的数据源中获取数据</strong>，不要将其理解成 MVC 中的 Model。在MVC 中 Model 是<strong>数据模型</strong>，而在MVP中，我们用Bean来表示数据模型。</p></li><li><p>View</p><p>与 MVC 中的 View 相同，一般指 XML 布局。</p></li><li><p>Presenter</p><p>这就是 MVC 与 MVP 不同的一个部分了。它负责连接 Model 和 View，让 Model 和 View <strong>彻底解耦</strong>。Model 和 View 不会直接发生关系，它们需要通过 Presenter 来进行交互。在实际的开发中，我们可以用接口来定义一些规范，然后让我们的 Model 和 View 实现它们，并借助 Presenter 进行交互即可。</p></li></ul><p>它的结构如下图所示：</p><p><img src="http://blog.cigis-cloud.com/design-pattern-1597991166.png" alt="MVP 结构"></p><p>接下来我们使用 MVP 模式改进一下上面的例子。</p><p>我们先看一下，使用 MVP 模式之后，项目下包的结构：</p><p><img src="http://blog.cigis-cloud.com/design-pattern-1597972649.png" alt="MVP 包结构"></p><p>可以看到，我抽出了一个单独的包<code>base</code>，用来做一些通用型的功能，所有的 View 都应该继承自这个父类。</p><p>那么，随着 View 和 Presenter 越来越多，维护的难度系数也会越来越高，这时我们需要引入新的一层 —— Contract。</p><p>这一层的意义在于，可以将某一个业务相关的指定的 View 和 Presenter 放在一个接口中，更加集中，每一个业务所需要的 View 和 Presenter 可以一目了然地展现在我们面前。上面的例子就可以修改成：</p><p><img src="http://blog.cigis-cloud.com/design-pattern-1597973055.png"></p><p>LoginContract 代码如下：</p><pre><code class="kotlin">interface LoginContract &#123;    interface IView : BaseView &#123;        fun onSuccess(userInfo: UserInfo?)        fun onError(msg: String?)    &#125;    interface IPresenter : BasePresenter &#123;        fun requestUserInfo()    &#125;&#125;</code></pre><p>而 View 和 Presenter 类实现的接口，同样地要转变为实现该 Contract 中的对应接口：</p><pre><code class="kotlin">interface LoginView : LoginContract.IView &#123;    override fun onSuccess(userInfo: UserInfo?) &#123;    &#125;    override fun onError(msg: String?) &#123;    &#125;&#125;class LoginPresenter(val view: LoginContract.IView) : LoginContract.IPresenter &#123;    override fun requestUserInfo() &#123;    &#125;&#125;</code></pre><p>从上面我们可以看出，我们需要在 Presenter 初始化的时候传入 View，Presenter 通过 Model 获取数据，并在拿到数据的时候，通过 View 的方法通知给 View 层。</p><p>这时，我们的 Activity 可以从之前的 Controller 的角色中解放出来，成为下面的样子：</p><pre><code class="kotlin">class LoginActivity : AppCompatActivity(), LoginView &#123;    var presenter: LoginContract.IPresenter = LoginPresenter(this)    override fun onCreate(savedInstanceState: Bundle?) &#123;        super.onCreate(savedInstanceState)        setContentView(R.layout.activity_login)        btnLogin.setOnClickListener &#123;            presenter.requestUserInfo(etPhone.editableText.toString(),                    etPassword.editableText.toString())        &#125;    &#125;    override fun onSuccess(userInfo: UserInfo?) &#123;        Snackbar.make(tvUserInfo, &quot;UserInfo: uid=$&#123;userInfo?.uid&#125;, &quot; +                &quot;name=$&#123;userInfo?.name&#125;, &quot; +                &quot;phone=$&#123;userInfo?.phone&#125;&quot;, Snackbar.LENGTH_SHORT)    &#125;    override fun onError(msg: String?) &#123;        Snackbar.make(tvUserInfo, &quot;Error: $&#123;msg&#125;&quot;, Snackbar.LENGTH_SHORT)    &#125;&#125;</code></pre><p>实际在 View 中也要维护一个 Presenter 的实例。 当需要请求数据的时候会使用该实例的方法来请求数据，所以，在开发的时候，我们需要根据请求数据的情况，在 Presenter 中定义接口方法。也就是说，MVP 的原理就是 <strong>View 通过 Presenter 获取数据，获取到数据之后再回调View的方法来展示数据</strong>。</p><p>同样地，我们盘点一下 MVP 的优缺点。</p><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ol><li>降低耦合度，实现了 Model 和 View 真正的完全分离，可以修改 View 而不影响 Model；</li><li>模块职责划分明显，层次清晰；</li><li>隐藏数据；</li><li>Presenter 可以复用，一个 Presenter 可以用于多个 View，而不需要更改 Presenter 的逻辑；</li><li>利于测试驱动开发，以前的 Android 开发是难以进行单元测试的；</li><li>View 可以进行组件化，在 MVP 当中，View 不依赖 Model。</li></ol><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ol><li>Presenter 中除了应用逻辑以外，还有大量的 View → Model，Model → View 的手动同步逻辑，造成 Presenter 比较笨重，维护起来会比较困难；</li><li>由于对视图的渲染放在了 Presenter 中，所以视图和 Presenter 的交互会过于频繁；</li><li>如果 Presenter 过多地渲染了视图，往往会使得它与特定的视图的联系过于紧密，一旦视图需要变更，那么 Presenter 也需要变更了。</li></ol><h2 id="MVC-与-MVP-的对比"><a href="#MVC-与-MVP-的对比" class="headerlink" title="MVC 与 MVP 的对比"></a>MVC 与 MVP 的对比</h2><ol><li>MVC 中是允许 Model 和 View 进行交互的，而 MVP 中，Model 与 View 之间的交互由 Presenter 完成；</li><li>MVP 模式就是将 P 定义成一个接口，然后在每个触发的事件中调用接口的方法来处理，也就是将逻辑放进了 P 中，需要执行某些操作的时候调用 P 的方法就行了。</li></ol><h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>MVVM（Model-View-ViewModel）模式本质上也是 MVC 的改进版，它会将 View 的状态以及行为进行<strong>抽象化</strong>，从而让我们把业务与视图分开。</p><ul><li><p>Model<br>负责从各种数据源中获取数据；</p></li><li><p>View<br>在 Android 中对应于 Activity 和 Fragment，用于展示给用户和处理用户交互，会驱动 ViewModel 从 Model 中获取数据；</p></li><li><p>ViewModel<br>用于将 Model 和 View 进行关联，我们可以在 View 中通过 ViewModel 从 Model 中获取数据；当获取到了数据之后，会通过自动绑定，比如 DataBinding，来将结果自动刷新到界面上。</p></li></ul><p>乍看之下，MVVM 模式与 MVP 模式很相似，因为它们都很好地完成了对 View 层状态和行为的抽象化。在 MVP 中，Presenter 抽象了一个独立于特定 UI 的 View，而在 MVVM 模式中，它简化了 UI 事件驱动的编程方式。</p><p>如果 MVP 模式意味着 Presenter 直接告诉 View 要显示的内容，则在 MVVM 中，ViewModel 公开 View <strong>可以绑定的事件流</strong>（Stream of Events）。由此一来，ViewModel <strong>不再需要像 Presenter 一样持有对 View 的引用</strong>。这也意味着 MVP 中所需要的那些接口，都可以扔掉了。</p><p>View 还会通知 ViewModel 有关不同的操作。因此，MVVM 模式支持 View 和 ViewModel 之间的<strong>双向数据绑定</strong>，并且 View 和 ViewModel 之间存在多对一关系。View 引用了 ViewModel，但是 ViewModel 没有有关 View 的信息。数据的使用者应该了解生产者，但是生产者——也就是ViewModel——不知道，也不在乎谁使用数据。</p><p>它的模型如下图所示：</p><p><img src="http://blog.cigis-cloud.com/design-pattern-1597991055.png" alt="MVVM 结构"></p><p>使用 Google 官方的 Android Architecture Components ，可以很轻松地将 MVVM 模式应用到我们的代码中。下面，我们就使用它来展示一下 MVVM 的实际的应用。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>扒掉 synchronized 的底裤</title>
      <link href="/2020-07-26/synchronized/"/>
      <url>/2020-07-26/synchronized/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/29866981">zhihu</a></p>]]></content>
      
      
      <categories>
          
          <category> Development </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> synchronized </tag>
            
            <tag> 线程安全 </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter 的 Isolate 与事件循环机制</title>
      <link href="/2020-07-23/flutter-isolate-and-event-loop/"/>
      <url>/2020-07-23/flutter-isolate-and-event-loop/</url>
      
        <content type="html"><![CDATA[<p>在 Dart 中，没有『多线程』的概念，在绝大多数的开发中，只会用到 UI 线程，也就是 Android 中所谓的『主线程』。</p><p>但是 Dart 给我们提供了异步编程的方式，来让我们『同步』地编写『异步』的代码。也即<code>await/async</code>关键字。在运行一些代码时，UI 线程还会继续渲染 Widget Tree，不会卡死。</p><p>那么单线程的 Dart 是如何实现这种看起来像『多线程』的机制的呢？这里我们要先介绍一个概念：Isolate。</p><span id="more"></span><h2 id="Isolate"><a href="#Isolate" class="headerlink" title="Isolate"></a>Isolate</h2><p>每一个 Isolate 都有自己的内存空间，以及一个单独的线程来运行 event loop。</p><p>绝大多数情况下，一个 Flutter 应用只需要一个 Isolate 就可以了，但如果你有庞大的计算需求，大到有可能会阻碍到 UI 线程掉帧，那你就得创建一个新的 Isolate 来进行这些计算。</p><p>创建新的 Isolate 包括但不限于以下方式：</p><ul><li><code>Isolate.spawn()</code></li><li><code>compute()</code></li></ul><p>创建完成的新 Isolate 有它自己独立的内存空间，即便是它的创建者也无法访问这部分空间。这也是『隔离』的意义所在。</p><p>实际上，要让多个 Isolate 合作，也是可以的，这需要用到它的 SendPort 和 ReceivePort。举例代码如下：</p><pre><code class="dart">ReceivePort receivePort = ReceivePort();// 创建新的 Isolateawait Isolate.spawn(complexCompute, receivePort.sendPort);SendPort sendPort = await receivePort.first;// 流的第一个元素被收到后监听会关闭，所以需要新打开一个ReceivePort以接收传入的消息ReceivePort response = ReceivePort();int toBeComputed = 1;// 以数组的形式将参数和发送方传入，方便进行数据回传sendPort.send([toBeComputed, response.sendPort]);int result = await response.first;setState(() &#123;    ...&#125;);</code></pre><p><code>complexCompute()</code>方法必须是个顶级方法或者静态方法：</p><pre><code class="dart">void complexCompute(SendPort sendPort) async &#123;  ReceivePort port = ReceivePort();  sendPort.send(port.sendPort);  await for (var param in port) &#123;    int toBeComputed = param[0];    SendPort replyTo = param[1];    toBeComputed++;    replyTo.send(toBeComputed);  &#125;&#125;</code></pre><p>当然，上面的计算也可以直接用 <code>compute()</code> 来解决：</p><pre><code class="dart">int result = await compute(anotherComplexCompute, 1);setState(( &#123;    ...&#125;));</code></pre><p>同样地，<code>anotherComplexCompute()</code> 也必须是顶级方法：</p><pre><code class="dart">int anotherComplexCompute(int value) &#123;    return value + 1;&#125;</code></pre><h2 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h2><p>上面讲完了 Isolate 机制，下面就该讲讲异步代码是如何被运行起来的。</p><p>Event Loop（事件循环）与 Android 中的 Looper 类似。</p>]]></content>
      
      
      <categories>
          
          <category> Development </category>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 布局优化</title>
      <link href="/2020-07-16/layout-optimization/"/>
      <url>/2020-07-16/layout-optimization/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/leipDao/p/8981687.html">https://www.cnblogs.com/leipDao/p/8981687.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>团队管理面试</title>
      <link href="/2020-06-16/manager-job-interview/"/>
      <url>/2020-06-16/manager-job-interview/</url>
      
        <content type="html"><![CDATA[<p>这里准备了一些管理职位相关的面试题。</p><span id="more"></span><h3 id="1-之前的公司的团队有多少技术、产品人员、测试人员比例是多少？"><a href="#1-之前的公司的团队有多少技术、产品人员、测试人员比例是多少？" class="headerlink" title="1. 之前的公司的团队有多少技术、产品人员、测试人员比例是多少？"></a>1. 之前的公司的团队有多少技术、产品人员、测试人员比例是多少？</h3><p>之前的团队里有 10 名 Android 开发人员，产品人员有 4 人，但产品是一个单独的部门。测试人员有 4 人。我管理的是 Android 的开发人员，同时进行的项目最多有 4 个。</p><h3 id="2-你如何应对未过试用期的技术人员离职？"><a href="#2-你如何应对未过试用期的技术人员离职？" class="headerlink" title="2. 你如何应对未过试用期的技术人员离职？"></a>2. 你如何应对未过试用期的技术人员离职？</h3><p>如果他的手里有需求比较紧急的代码，我会把他的代码首先进行 Review，查看进度，然后指派给对应的人手，同时立刻通知人资部门进行招聘。</p><h3 id="3-你在项目当中碰到的最大困难是什么，如何解决？"><a href="#3-你在项目当中碰到的最大困难是什么，如何解决？" class="headerlink" title="3. 你在项目当中碰到的最大困难是什么，如何解决？"></a>3. 你在项目当中碰到的最大困难是什么，如何解决？</h3><p>项目中有很多之前同事留下大量代码，写得毫无章法，已经遗留很久，而且没有注释，在代码重构时遇到了很大的困难。</p><p>重构时定制的方案是组件化，拆为了四层，分别是常规业务组件层（登录界面、市场界面、我的界面、下载界面等）、核心管理层（组件生命周期、路由服务等）、基础业务层（分享、推送、下载等）、基础功能层（日志、网络、工具类等）</p><p>最后的解决办法是先将这些遗留代码全部包装起来，移动到最底层 - 特殊层，先让项目可以继续运行，然后安排所有人阅读这部分代码，每个人对其进行分类，是属于哪一层，然后移动到哪一层。同时对代码力所能及地加入注释，在保证无 BUG 的情况下，合并部分代码。</p><h3 id="4-团队中技术人员技术参差不齐，你如何保证团队开发产品的质量？"><a href="#4-团队中技术人员技术参差不齐，你如何保证团队开发产品的质量？" class="headerlink" title="4. 团队中技术人员技术参差不齐，你如何保证团队开发产品的质量？"></a>4. 团队中技术人员技术参差不齐，你如何保证团队开发产品的质量？</h3><p>先通过一段时间的 Code Review 发现团队人员的编码水平及有效代码数量，对开发人员能力做到心中有数。然后与水平较低的团队人员进行单独的沟通，指出代码中的错误，并提供一些思路和习惯上的帮助；同时安排单元测试，对每一个完成的小模块进行测试，让所有的代码都必须在通过测试的情况下交付至测试部门。</p><h3 id="5-现在团队只有你一个人，但是公司要求在-2-个月之内上线一个新功能，你有什么工作思路？"><a href="#5-现在团队只有你一个人，但是公司要求在-2-个月之内上线一个新功能，你有什么工作思路？" class="headerlink" title="5. 现在团队只有你一个人，但是公司要求在 2 个月之内上线一个新功能，你有什么工作思路？"></a>5. 现在团队只有你一个人，但是公司要求在 2 个月之内上线一个新功能，你有什么工作思路？</h3><p>通过熟人或者招聘平台，快速招聘团队人员，看功能的体量选择招聘的人数；另外可以使用外包服务，支付少量金钱的情况下，快速完成工作。如果该功能有大量的后期维护需求，再继续招聘团队人员，进行代码交接和后期维护。</p><h3 id="6-在之前的开发中使用到那些新技术，对这种技术有什么看法？"><a href="#6-在之前的开发中使用到那些新技术，对这种技术有什么看法？" class="headerlink" title="6. 在之前的开发中使用到那些新技术，对这种技术有什么看法？"></a>6. 在之前的开发中使用到那些新技术，对这种技术有什么看法？</h3><p>在 Kotlin 刚应用于 Android 时使用过 Kotlin，它极大地提高了开发效率，在非空检查上有比较强的能力，能够让开发人员在提高效率的同时，让代码的稳健性更好；在后期 Kotlin 推出协程时也将协程应用到了开发中，使代码编写起来更像是『同步』的。</p><h3 id="7-觉得自身有哪些优点和不足，有哪些需要提升的地方？"><a href="#7-觉得自身有哪些优点和不足，有哪些需要提升的地方？" class="headerlink" title="7. 觉得自身有哪些优点和不足，有哪些需要提升的地方？"></a>7. 觉得自身有哪些优点和不足，有哪些需要提升的地方？</h3><p>通过候选人的回答来确定候选人的品行，是否诚实、谦逊为人等品行。</p><h3 id="8-对新人怎么培训和管理，有没有什么方法？"><a href="#8-对新人怎么培训和管理，有没有什么方法？" class="headerlink" title="8. 对新人怎么培训和管理，有没有什么方法？"></a>8. 对新人怎么培训和管理，有没有什么方法？</h3><p>通过候选人的回答，考察其有没有真正的带队经验，团队建设的能力。</p><h3 id="9-在技术架构，技术选型的时候，主要考虑哪方面的因素，有哪些注意事项？"><a href="#9-在技术架构，技术选型的时候，主要考虑哪方面的因素，有哪些注意事项？" class="headerlink" title="9. 在技术架构，技术选型的时候，主要考虑哪方面的因素，有哪些注意事项？"></a>9. 在技术架构，技术选型的时候，主要考虑哪方面的因素，有哪些注意事项？</h3><p>考查技术架构能力，比如能否根据业务不同选择不同的技术解决方案，有没有考虑并发、分库分表等方面。</p><h3 id="10-对未来的职业规划？"><a href="#10-对未来的职业规划？" class="headerlink" title="10. 对未来的职业规划？"></a>10. 对未来的职业规划？</h3><p>考察候选人对自己的未来有没有清晰的计划和目标，如果一个技术经理、CTO对自己未来没有清晰的认识的话，单纯是为了挣钱而工作的话，建议慎重考虑。</p>]]></content>
      
      
      <categories>
          
          <category> 职场 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>The Manager&#39;s Path</title>
      <link href="/2020-06-04/the-managers-path/"/>
      <url>/2020-06-04/the-managers-path/</url>
      
        <content type="html"><![CDATA[<p>《The Manager’s Path》全本，正在翻译中。</p><span id="more"></span><h3 id="英文版目录："><a href="#英文版目录：" class="headerlink" title="英文版目录："></a>英文版目录：</h3><ul><li><a href="/the-managers-path/the-managers-path-intro/">Introduction</a></li><li><a href="/the-managers-path-chapter-1/">Chapter 1. Management 101</a></li><li><a href="/the-managers-path-chapter-2/">Chapter 2. Mentoring</a></li><li><a href="/the-managers-path-chapter-3/">Chapter 3. Tech Lead</a></li><li><a href="/the-managers-path-chapter-4/">Chapter 4. Managing People</a></li><li><a href="/the-managers-path-chapter-5/">Chapter 5. Managing a Team</a></li><li><a href="/the-managers-path-chapter-6/">Chapter 6. Managing Multiple Teams</a></li><li><a href="/the-managers-path-chapter-7/">Chapter 7. Managing Managers</a></li><li><a href="/the-managers-path-chapter-8/">Chapter 8. The Big Leagues</a></li><li><a href="/the-managers-path-chapter-9/">Chapter 9. Bootstrapping Culture</a></li><li><a href="/the-managers-path-chapter-10/">Chapter 10. Conclusion</a></li></ul><h3 id="中文版目录："><a href="#中文版目录：" class="headerlink" title="中文版目录："></a>中文版目录：</h3><ul><li><a href="/the-managers-path-intro-zh/">序言</a></li><li><a href="/the-managers-path-chapter-1-zh/">第一章：管理 101</a></li><li><a href="/the-managers-path-chapter-2-zh/">第二章：导师</a></li><li><a href="/the-managers-path-chapter-3-zh/">第三章：技术领导</a></li><li><a href="/the-managers-path-chapter-4-zh/">第四章：人员管理</a></li><li><a href="/the-managers-path-chapter-5-zh/">第五章：团队管理</a></li><li><a href="/the-managers-path-chapter-6-zh/">第六章：多团队管理</a></li><li><a href="/the-managers-path-chapter-7-zh/">第七章：管理管理人员</a></li><li><a href="/the-managers-path-chapter-8-zh/">第八章：大联盟</a></li><li><a href="/the-managers-path-chapter-9-zh/">第九章：引导文化</a></li><li><a href="/the-managers-path-chapter-10-zh/">第十章：总结</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Book </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 书籍 </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Activity 启动流程分析</title>
      <link href="/2020-05-27/activity-start-process/"/>
      <url>/2020-05-27/activity-start-process/</url>
      
        <content type="html"><![CDATA[<p>很多人对 Activity 启动过程不甚了解，我们来捋一下它的启动流程。</p><span id="more"></span><p>启动 Activity 无非是下面几种场景：</p><ol><li>从应用中启动自身 Activity</li><li>从应用中启动其他应用中的 Activity</li><li>从桌面点击应用图标启动 Activity</li></ol><p>理论上来说，桌面是一个<strong>单独进程</strong>，点击应用图标打开新的 Activity 属于上述第2种情况。<br>所以，上面的3种情况，可以归结为两类：</p><ol><li>启动自身进程内的 Activity</li><li>启动其他进程内的 Activity</li></ol><p>我们来看看 Android 系统是如何实现的。了解启动过程，需要理解 ActvitiyTaskManagerService 和 ActivityThread 的功能，以及 Binder 通讯机制，我们在下面会慢慢讲到。</p><blockquote><p>注：本文源代码基于 Android API 29</p></blockquote><h2 id="源进程中的流程"><a href="#源进程中的流程" class="headerlink" title="源进程中的流程"></a>源进程中的流程</h2><p>启动自身进程的的 Activity 就是在代码中调用<code>startActivity()</code>或<code>startActivityForResult()</code>来启动目标 Activity。我们来看看<code>startActivity()</code>和<code>startActivityForResult()</code>都做了什么。</p><pre><code class="java">@Overridepublic void startActivity(Intent intent, @Nullable Bundle options) &#123;    if (options != null) &#123;        startActivityForResult(intent, -1, options);    &#125; else &#123;        // Note we want to go through this call for compatibility with        // applications that may have overridden the method.        startActivityForResult(intent, -1);    &#125;&#125;</code></pre><p>可以看到，它调用了<code>startActivityForResult()</code>方法，只不过传入了<code>requestCode</code>为<code>-1</code>，表示『我不要结果』。</p><pre><code class="java">public void startActivityForResult(@RequiresPermission Intent intent, int requestCode,            @Nullable Bundle options) &#123;    if (mParent == null) &#123;        options = transferSpringboardActivityOptions(options);        Instrumentation.ActivityResult ar =            mInstrumentation.execStartActivity(                this, mMainThread.getApplicationThread(), mToken, this,                intent, requestCode, options);        if (ar != null) &#123;            mMainThread.sendActivityResult(                mToken, mEmbeddedID, requestCode, ar.getResultCode(),                ar.getResultData());        &#125;        if (requestCode &gt;= 0) &#123;            // If this start is requesting a result, we can avoid making            // the activity visible until the result is received.  Setting            // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the            // activity hidden during this time, to avoid flickering.            // This can only be done when a result is requested because            // that guarantees we will get information back when the            // activity is finished, no matter what happens to it.            mStartedActivity = true;        &#125;        cancelInputsAndStartExitTransition(options);        // TODO Consider clearing/flushing other event sources and events for child windows.    &#125; else &#123;        if (options != null) &#123;            mParent.startActivityFromChild(this, intent, requestCode, options);        &#125; else &#123;            // Note we want to go through this method for compatibility with            // existing applications that may have overridden it.            mParent.startActivityFromChild(this, intent, requestCode);        &#125;    &#125;&#125;</code></pre><p><code>startActivityForResult()</code>方法会先判断<code>mParent</code>的值是否为空，这个<code>mParent</code>也是一个 Activity 类型的变量，在<code>Activity.attach()</code>时被赋值，第一次启动 Activity 时必然为空。接下来就将任务转交给了<code>Instrumentation.execStartActivity()</code>方法。</p><p>mInstrumentation 也是在<code>Activity.attach()</code>中被初始化，由 ActivityThread 传入。我们来看看它的<code>execStartActivity()</code>方法：</p><pre><code class="java">public ActivityResult execStartActivity(        Context who, IBinder contextThread, IBinder token, Activity target,        Intent intent, int requestCode, Bundle options) &#123;    ...    try &#123;        ...        int result = ActivityTaskManager.getService()            .startActivity(whoThread, who.getBasePackageName(), intent,                    intent.resolveTypeIfNeeded(who.getContentResolver()),                    token, target != null ? target.mEmbeddedID : null,                    requestCode, 0, null, options);        checkStartActivityResult(result, intent);    &#125; catch (RemoteException e) &#123;        throw new RuntimeException(&quot;Failure from system&quot;, e);    &#125;    return null;&#125;</code></pre><p>在这里，Instumentation 将任务通过 Binder 通信的方式交给了 ActivityTaskManagerService（下称ATMS）。盲猜这里是要先判断要启动的 Activity 是否已经有了相应任务栈，如果没有，就要创建新的任务栈，我们通过代码来看看它是否是这么做的。</p><h2 id="ActivityTaskManagerService-中的流程"><a href="#ActivityTaskManagerService-中的流程" class="headerlink" title="ActivityTaskManagerService 中的流程"></a>ActivityTaskManagerService 中的流程</h2><pre><code class="java">// com.android.server.wm.ActivityTaskManagerService.java@Overridepublic final int startActivity(IApplicationThread caller, String callingPackage,        Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,        int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) &#123;    return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,            resultWho, requestCode, startFlags, profilerInfo, bOptions,            UserHandle.getCallingUserId());&#125;@Overridepublic int startActivityAsUser(IApplicationThread caller, String callingPackage,        Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,        int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) &#123;    return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,            resultWho, requestCode, startFlags, profilerInfo, bOptions, userId,            true /*validateIncomingUser*/);&#125;int startActivityAsUser(IApplicationThread caller, String callingPackage,        Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,        int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId,        boolean validateIncomingUser) &#123;    enforceNotIsolatedCaller(&quot;startActivityAsUser&quot;);    userId = getActivityStartController().checkTargetUser(userId, validateIncomingUser,            Binder.getCallingPid(), Binder.getCallingUid(), &quot;startActivityAsUser&quot;);    // TODO: Switch to user app stacks here.    return getActivityStartController().obtainStarter(intent, &quot;startActivityAsUser&quot;)            .setCaller(caller)            .setCallingPackage(callingPackage)            .setResolvedType(resolvedType)            .setResultTo(resultTo)            .setResultWho(resultWho)            .setRequestCode(requestCode)            .setStartFlags(startFlags)            .setProfilerInfo(profilerInfo)            .setActivityOptions(bOptions)            .setMayWait(userId)            .execute();&#125;ActivityStartController getActivityStartController() &#123;    return mActivityStartController;&#125;</code></pre><p>ActivityStartController 是一个控制器，用来代理的 Activity 启动。它的主要目的是把 Activity 的启动请求进行整理，并交给 ActivityStarter 类。它的<code>obtainStarter()</code>方法就是获取一个 ActivityStarter 的实例。可见 ActivityStarter 使用的是 Builder 模式，最终的执行在它的<code>execute()</code>方法中：</p><pre><code class="java">int execute() &#123;    try &#123;        if (mRequest.mayWait) &#123;            return startActivityMayWait(mRequest.caller, mRequest.callingUid,                    mRequest.callingPackage, mRequest.realCallingPid, mRequest.realCallingUid,                    mRequest.intent, mRequest.resolvedType,                    mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo,                    mRequest.resultWho, mRequest.requestCode, mRequest.startFlags,                    mRequest.profilerInfo, mRequest.waitResult, mRequest.globalConfig,                    mRequest.activityOptions, mRequest.ignoreTargetSecurity, mRequest.userId,                    mRequest.inTask, mRequest.reason,                    mRequest.allowPendingRemoteAnimationRegistryLookup,                    mRequest.originatingPendingIntent, mRequest.allowBackgroundActivityStart);        &#125; else &#123;            return startActivity(mRequest.caller, mRequest.intent, mRequest.ephemeralIntent,                    mRequest.resolvedType, mRequest.activityInfo, mRequest.resolveInfo,                    mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo,                    mRequest.resultWho, mRequest.requestCode, mRequest.callingPid,                    mRequest.callingUid, mRequest.callingPackage, mRequest.realCallingPid,                    mRequest.realCallingUid, mRequest.startFlags, mRequest.activityOptions,                    mRequest.ignoreTargetSecurity, mRequest.componentSpecified,                    mRequest.outActivity, mRequest.inTask, mRequest.reason,                    mRequest.allowPendingRemoteAnimationRegistryLookup,                    mRequest.originatingPendingIntent, mRequest.allowBackgroundActivityStart);        &#125;    &#125; finally &#123;        onExecutionComplete();    &#125;&#125;</code></pre><p>在 ActivityStarter 中有个内部类 Request，用来存储一次启动请求，包括传递的 Intent、请求者的身份、启动模式的 FLAG、requestCode 等等。这里单独讲一下<code>Request.mayWait</code>变量，这个变量表示是否要等待启动结果。当调用<code>Request.setMayWait()</code>方法时，这个值就会被置为<code>true</code>。在这个例子里面，我们在上面的代码里看到，它的值为<code>true</code>，所以会继续调用<code>startActivityMayWait()</code>方法：</p><pre><code class="java">// com.android.server.wm.ActivityStarter.javaprivate int startActivityMayWait(IApplicationThread caller, int callingUid,        String callingPackage, int requestRealCallingPid, int requestRealCallingUid,        Intent intent, String resolvedType, IVoiceInteractionSession voiceSession,        IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode,        int startFlags, ProfilerInfo profilerInfo, WaitResult outResult,        Configuration globalConfig, SafeActivityOptions options, boolean ignoreTargetSecurity,        int userId, TaskRecord inTask, String reason,        boolean allowPendingRemoteAnimationRegistryLookup,        PendingIntentRecord originatingPendingIntent, boolean allowBackgroundActivityStart) &#123;    // 一系列判断 + 初始化    ...    ActivityInfo aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, profilerInfo);    ...    synchronized (mService.mGlobalLock) &#123;        ...        int res = startActivity(caller, intent, ephemeralIntent, resolvedType, aInfo, rInfo,                voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid,                callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options,                ignoreTargetSecurity, componentSpecified, outRecord, inTask, reason,                allowPendingRemoteAnimationRegistryLookup, originatingPendingIntent,                allowBackgroundActivityStart);        ...        return res;    &#125;&#125;</code></pre><p><code>mSupervisor</code>是 ActivityStackSupervisor 类，从命名上看，是管理 Activity 栈的一个类，但其实这个类在不久的版本里，可能会被废除掉，把它的功能都移动到 ActivityLifeCycle、AMS 中。这里我们不用太在意，继续向下看<code>ActivityStarter.startActivity()</code>方法：</p><pre><code class="java">private int startActivity(IApplicationThread caller, Intent intent, Intent ephemeralIntent,        String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,        IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid,        String callingPackage, int realCallingPid, int realCallingUid, int startFlags,        SafeActivityOptions options,        boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity,        TaskRecord inTask, boolean allowPendingRemoteAnimationRegistryLookup,        PendingIntentRecord originatingPendingIntent, boolean allowBackgroundActivityStart) &#123;    ...    // 各种判断与初始化    ....    ActivityRecord r = new ActivityRecord(mService, callerApp, callingPid, callingUid,            callingPackage, intent, resolvedType, aInfo, mService.getGlobalConfiguration(),            resultRecord, resultWho, requestCode, componentSpecified, voiceSession != null,            mSupervisor, checkedOptions, sourceRecord);    if (outActivity != null) &#123;        outActivity[0] = r;    &#125;    ...    final int res = startActivity(r, sourceRecord, voiceSession, voiceInteractor, startFlags,            true /* doResume */, checkedOptions, inTask, outActivity, restrictedBgActivity);    mSupervisor.getActivityMetricsLogger().notifyActivityLaunched(res, outActivity[0]);    return res;&#125;private int startActivity(final ActivityRecord r, ActivityRecord sourceRecord,            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,            int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask,            ActivityRecord[] outActivity, boolean restrictedBgActivity) &#123;    int result = START_CANCELED;    final ActivityStack startedActivityStack;    try &#123;        mService.mWindowManager.deferSurfaceLayout();        result = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor,                startFlags, doResume, options, inTask, outActivity, restrictedBgActivity);    &#125; finally &#123;        ...    &#125;    return result;&#125;private int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord,        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,        int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask,        ActivityRecord[] outActivity, boolean restrictedBgActivity) &#123;    ...    // 各种判断与初始化    reusedActivity = setTargetStackAndMoveToFrontIfNeeded(reusedActivity);    ...    mTargetStack.startActivityLocked(mStartActivity, topFocused, newTask, mKeepCurTransition,            mOptions);    ...    return START_SUCCESS;&#125;</code></pre><p>上面最后的代码中，<code>mTargetStack</code>是 ActivityStack 类型的变量，是在<code>setTargetStackAndMoveToFrontIfNeeded()</code>方法中被赋值的。我们继续来看看<code>ActivityStack.startActivityLocked()</code>：</p><pre><code class="java">void startActivityLocked(ActivityRecord r, ActivityRecord focusedTopActivity,        boolean newTask, boolean keepCurTransition, ActivityOptions options) &#123;    TaskRecord rTask = r.getTaskRecord();    final int taskId = rTask.taskId;    final boolean allowMoveToFront = options == null || !options.getAvoidMoveToFront();    // mLaunchTaskBehind tasks get placed at the back of the task stack.    if (!r.mLaunchTaskBehind &amp;&amp; allowMoveToFront            &amp;&amp; (taskForIdLocked(taskId) == null || newTask)) &#123;        // Last activity in task had been removed or ActivityManagerService is reusing task.        // Insert or replace.        // Might not even be in.        insertTaskAtTop(rTask, r);    &#125;    TaskRecord task = null;    if (!newTask) &#123;        // 如果不是新的任务栈，那就找到它所属的任务栈        boolean startIt = true;        for (int taskNdx = mTaskHistory.size() - 1; taskNdx &gt;= 0; --taskNdx) &#123;            task = mTaskHistory.get(taskNdx);            if (task.getTopActivity() == null) &#123;                // All activities in task are finishing.                continue;            &#125;            if (task == rTask) &#123;                // 找到了对应的 TaskRecord，如果当前任务栈还未对用户可见，那就只添加，不启动                if (!startIt) &#123;                    if (DEBUG_ADD_REMOVE) Slog.i(TAG, &quot;Adding activity &quot; + r + &quot; to task &quot;                            + task, new RuntimeException(&quot;here&quot;).fillInStackTrace());                    r.createAppWindowToken();                    ActivityOptions.abort(options);                    return;                &#125;                break;            &#125; else if (task.numFullscreen &gt; 0) &#123;                startIt = false;            &#125;        &#125;    &#125;    // 在栈顶放目标 Activity，下一个与用户交互的 Activity 就是它    // 如果不把目标 Activity 放到最前，就不要给实际的当前最前的 Activity 发送 onUserLeaving 消息    final TaskRecord activityTask = r.getTaskRecord();    if (task == activityTask &amp;&amp; mTaskHistory.indexOf(task) != (mTaskHistory.size() - 1)) &#123;        mStackSupervisor.mUserLeaving = false;        if (DEBUG_USER_LEAVING) Slog.v(TAG_USER_LEAVING,                &quot;startActivity() behind front, mUserLeaving=false&quot;);    &#125;    task = activityTask;    // Slot the activity into the history stack and proceed    if (DEBUG_ADD_REMOVE) Slog.i(TAG, &quot;Adding activity &quot; + r + &quot; to stack to task &quot; + task,            new RuntimeException(&quot;here&quot;).fillInStackTrace());    // TODO: Need to investigate if it is okay for the controller to already be created by the    // time we get to this point. I think it is, but need to double check.    // Use test in b/34179495 to trace the call path.    if (r.mAppWindowToken == null) &#123;        r.createAppWindowToken();    &#125;    // 将 Activity 移到 task 最前    task.setFrontOfTask();    // 如果 allowMoveToFront 为 false，则不需要切换动画，因为 Activity 不可见    if ((!isHomeOrRecentsStack() || numActivities() &gt; 0) &amp;&amp; allowMoveToFront) &#123;        final DisplayContent dc = getDisplay().mDisplayContent;        if (DEBUG_TRANSITION) Slog.v(TAG_TRANSITION,                &quot;Prepare open transition: starting &quot; + r);        if ((r.intent.getFlags() &amp; Intent.FLAG_ACTIVITY_NO_ANIMATION) != 0) &#123;            dc.prepareAppTransition(TRANSIT_NONE, keepCurTransition);            mStackSupervisor.mNoAnimActivities.add(r);        &#125; else &#123;            int transit = TRANSIT_ACTIVITY_OPEN;            if (newTask) &#123;                if (r.mLaunchTaskBehind) &#123;                    transit = TRANSIT_TASK_OPEN_BEHIND;                &#125; else if (getDisplay().isSingleTaskInstance()) &#123;                    transit = TRANSIT_SHOW_SINGLE_TASK_DISPLAY;                &#125; else &#123;                    // If a new task is being launched, then mark the existing top activity as                    // supporting picture-in-picture while pausing only if the starting activity                    // would not be considered an overlay on top of the current activity                    // (eg. not fullscreen, or the assistant)                    if (canEnterPipOnTaskSwitch(focusedTopActivity,                            null /* toFrontTask */, r, options)) &#123;                        focusedTopActivity.supportsEnterPipOnTaskSwitch = true;                    &#125;                    transit = TRANSIT_TASK_OPEN;                &#125;            &#125;            dc.prepareAppTransition(transit, keepCurTransition);            mStackSupervisor.mNoAnimActivities.remove(r);        &#125;        boolean doShow = true;        if (newTask) &#123;            // Even though this activity is starting fresh, we still need            // to reset it to make sure we apply affinities to move any            // existing activities from other tasks in to it.            // If the caller has requested that the target task be            // reset, then do so.            if ((r.intent.getFlags() &amp; Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != 0) &#123;                resetTaskIfNeededLocked(r, r);                doShow = topRunningNonDelayedActivityLocked(null) == r;            &#125;        &#125; else if (options != null &amp;&amp; options.getAnimationType()                == ActivityOptions.ANIM_SCENE_TRANSITION) &#123;            doShow = false;        &#125;        if (r.mLaunchTaskBehind) &#123;            // Don&#39;t do a starting window for mLaunchTaskBehind. More importantly make sure we            // tell WindowManager that r is visible even though it is at the back of the stack.            r.setVisibility(true);            // 这里继续深入            ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS);        &#125; else if (SHOW_APP_STARTING_PREVIEW &amp;&amp; doShow) &#123;            // Figure out if we are transitioning from another activity that is            // &quot;has the same starting icon&quot; as the next one.  This allows the            // window manager to keep the previous window it had previously            // created, if it still had one.            TaskRecord prevTask = r.getTaskRecord();            ActivityRecord prev = prevTask.topRunningActivityWithStartingWindowLocked();            if (prev != null) &#123;                // We don&#39;t want to reuse the previous starting preview if:                // (1) The current activity is in a different task.                if (prev.getTaskRecord() != prevTask) &#123;                    prev = null;                &#125;                // (2) The current activity is already displayed.                else if (prev.nowVisible) &#123;                    prev = null;                &#125;            &#125;            r.showStartingWindow(prev, newTask, isTaskSwitch(r, focusedTopActivity));        &#125;    &#125; else &#123;        // If this is the first activity, don&#39;t do any fancy animations,        // because there is nothing for it to animate on top of.        ActivityOptions.abort(options);    &#125;&#125;</code></pre><p>这里的代码我没有精简，这段代码展示了对于 TaskRecord 及内部 Activity 顺序的处理。Activity 到现在还未进行创建，我们继续向下走，看<code>ensureActivitiesVisibleLocked()</code>方法：</p><pre><code class="java">final void ensureActivitiesVisibleLocked(ActivityRecord starting, int configChanges,        boolean preserveWindows, boolean notifyClients) &#123;    ...    try &#123;        for (int taskNdx = mTaskHistory.size() - 1; taskNdx &gt;= 0; --taskNdx) &#123;            final TaskRecord task = mTaskHistory.get(taskNdx);            final ArrayList&lt;ActivityRecord&gt; activities = task.mActivities;            for (int activityNdx = activities.size() - 1; activityNdx &gt;= 0; --activityNdx) &#123;                ...                if (reallyVisible) &#123;                    ...                    if (!r.attachedToProcess()) &#123;                        if (makeVisibleAndRestartIfNeeded(starting, configChanges, isTop,                                resumeNextActivity, r)) &#123;                            if (activityNdx &gt;= activities.size()) &#123;                                // Record may be removed if its process needs to restart.                                activityNdx = activities.size() - 1;                            &#125; else &#123;                                resumeNextActivity = false;                            &#125;                        &#125;                    &#125; else if (r.visible) &#123;                        ...                    &#125; else &#123;                        ...                    &#125;                    // Aggregate current change flags.                    configChanges |= r.configChangeFlags;                &#125;                ...            &#125;            ...        &#125;        ...    &#125; finally &#123;        ...    &#125;&#125;private boolean makeVisibleAndRestartIfNeeded(ActivityRecord starting, int configChanges,        boolean isTop, boolean andResume, ActivityRecord r) &#123;    if (isTop || !r.visible) &#123;        ...        if (r != starting) &#123;            // We should not resume activities that being launched behind because these            // activities are actually behind other fullscreen activities, but still required            // to be visible (such as performing Recents animation).            mStackSupervisor.startSpecificActivityLocked(r, andResume &amp;&amp; !r.mLaunchTaskBehind,                    true /* checkConfig */);            return true;        &#125;    &#125;    return false;&#125;</code></pre><p>这里又出现了一个<code>mStackSupervisor</code>的变量，它是 ActivityStackSupervisor 类型，上面我们介绍过，我们看它的<code>startSpecificActivityLocked()</code>方法：</p><pre><code class="java">// com.android.server.wm.ActivityStackSupervisor.javavoid startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig) &#123;    // Activity 所属的应用是否正在运行？    final WindowProcessController wpc =            mService.getProcessController(r.processName, r.info.applicationInfo.uid);    boolean knownToBeDead = false;    if (wpc != null &amp;&amp; wpc.hasThread()) &#123; // 判断它的 ActivityThread 是否为 null        // 如果已经在运行，则开始创建 Activity 实例        try &#123;            realStartActivityLocked(r, wpc, andResume, checkConfig);            return;        &#125; catch (RemoteException e) &#123;            Slog.w(TAG, &quot;Exception when starting activity &quot;                    + r.intent.getComponent().flattenToShortString(), e);        &#125;        // If a dead object exception was thrown -- fall through to        // restart the application.        knownToBeDead = true;    &#125;    // Suppress transition until the new activity becomes ready, otherwise the keyguard can    // appear for a short amount of time before the new process with the new activity had the    // ability to set its showWhenLocked flags.    if (getKeyguardController().isKeyguardLocked()) &#123;        r.notifyUnknownVisibilityLaunched();    &#125;    final boolean isTop = andResume &amp;&amp; r.isTopRunningActivity();    mService.startProcessAsync(r, knownToBeDead, isTop, isTop ? &quot;top-activity&quot; : &quot;activity&quot;);&#125;</code></pre><p>好，接下来是重头戏，<code>realStartActivityLocked()</code>：</p><pre><code class="java"> boolean realStartActivityLocked(ActivityRecord r, WindowProcessController proc,            boolean andResume, boolean checkConfig) throws RemoteException &#123;    ...    // 一系列检查    ...    try &#123;        ...        try &#123;            ...            // 检查是否要输出 Transaction too large 的日志，面熟吗？            logIfTransactionTooLarge(r.intent, r.icicle);            // 创建启动 Activity 的事务            final ClientTransaction clientTransaction = ClientTransaction.obtain(                    proc.getThread(), r.appToken);            final DisplayContent dc = r.getDisplay().mDisplayContent;            clientTransaction.addCallback(LaunchActivityItem.obtain(new Intent(r.intent),                    System.identityHashCode(r), r.info,                    // TODO: Have this take the merged configuration instead of separate global                    // and override configs.                    mergedConfiguration.getGlobalConfiguration(),                    mergedConfiguration.getOverrideConfiguration(), r.compat,                    r.launchedFromPackage, task.voiceInteractor, proc.getReportedProcState(),                    r.icicle, r.persistentState, results, newIntents,                    dc.isNextTransitionForward(), proc.createProfilerInfoIfNeeded(),                            r.assistToken));            // 设置最终的生命周期状态            final ActivityLifecycleItem lifecycleItem;            // 创建下一个生命周期事务            if (andResume) &#123;                lifecycleItem = ResumeActivityItem.obtain(dc.isNextTransitionForward());            &#125; else &#123;                lifecycleItem = PauseActivityItem.obtain();            &#125;            clientTransaction.setLifecycleStateRequest(lifecycleItem);            // 安排上了。            mService.getLifecycleManager().scheduleTransaction(clientTransaction);            ...        &#125; catch (RemoteException e) &#123;            ...        &#125;    &#125; finally &#123;        ...    &#125;    ...    return true;&#125;</code></pre><p>从 Android 26 之后，引入了事务机制，并将 Activity 的生命周期管理都交给一个名为 ClientLifecycleManager 的工具类来进行辅助管理。ClientTransaction 指定要执行的任务类型（如 LaunchActivityItem）及所在进程，ClientLifecycleManager 负责传递消息。</p><p>上面代码中，mService 是 ATMS 的实例，在构造 ActivityStackSupervisor 实例时由外部传入。<code>ActivityTaskManagerService.getLifecycleManager()</code>返回的即是 ATMS 中 ClientLifecycleManager 的实例，我们来看看<code>ClientLifecycleManager.scheduleTransaction()</code>都做了些什么：</p><pre><code class="java">void scheduleTransaction(ClientTransaction transaction) throws RemoteException &#123;    final IApplicationThread client = transaction.getClient();    transaction.schedule();    if (!(client instanceof Binder)) &#123;        // If client is not an instance of Binder - it&#39;s a remote call and at this point it is        // safe to recycle the object. All objects used for local calls will be recycled after        // the transaction is executed on client in ActivityThread.        transaction.recycle();    &#125;&#125;</code></pre><p>哦？又交还给 ClientTransaction 自己去 schedule 了：</p><pre><code class="java">public void schedule() throws RemoteException &#123;    mClient.scheduleTransaction(this);&#125;</code></pre><p><code>mClient</code> 自然就是 ApplicationThread 的实例，通过 Binder 方式远程调用了它的<code>scheduleTransaction()</code>方法。</p><p>至此，Activity 启动的请求就交还给了目标进程的 ApplicationThread。</p><h2 id="ActivityThread-中的流程"><a href="#ActivityThread-中的流程" class="headerlink" title="ActivityThread 中的流程"></a>ActivityThread 中的流程</h2><p>接下来的部分就比较好理解了，我们继续看看<code>ApplicationThread.scheduleTransaction()</code>：</p><pre><code class="java">// android.app.ActivityThread.ApplicationThread.javaprivate class ApplicationThread extends IApplicationThread.Stub &#123;    public void scheduleTransaction(ClientTransaction transaction) throws RemoteException &#123;        ActivityThread.this.scheduleTransaction(transaction);    &#125;&#125;// android.app.ActivityThread.javapublic final class ActivityThread extends ClientTransactionHandler &#123;    void scheduleTransaction(ClientTransaction transaction) &#123;        transaction.preExecute(this);        sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction);    &#125;&#125;</code></pre><p>H 是 ActivityThread 中的一个内部类，它继承自 Handler。这里调用了<code>sendMessage()</code>方法，企图向这个 Handler 发送消息：</p><pre><code class="java">void sendMessage(int what, Object obj) &#123;    sendMessage(what, obj, 0, 0, false);&#125;private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) &#123;    Message msg = Message.obtain();    msg.what = what;    msg.obj = obj;    msg.arg1 = arg1;    msg.arg2 = arg2;    if (async) &#123;        msg.setAsynchronous(true);    &#125;    mH.sendMessage(msg);&#125;</code></pre><p><code>mH</code>自然就是 H 的实例。我们来看看它是如何处理<code>EXECUTE_TRANSACTION</code>消息的：</p><pre><code class="java">case EXECUTE_TRANSACTION:    final ClientTransaction transaction = (ClientTransaction) msg.obj;    mTransactionExecutor.execute(transaction);    if (isSystem()) &#123;        // Client transactions inside system process are recycled on the client side        // instead of ClientLifecycleManager to avoid being cleared before this        // message is handled.        transaction.recycle();    &#125;    // TODO(lifecycler): Recycle locally scheduled transactions.    break;</code></pre><p>又蹦出个东西叫 TransactionExecutor，它的功能是让事务能够按照正确的顺序执行。</p><pre><code class="java">// android.app.servertransaction.TransactionExecutor.javapublic void execute(ClientTransaction transaction) &#123;    ...    executeCallbacks(transaction);    // 如果指定的最终的生命周期状态，那就再继续执行事务直到指定状态    executeLifecycleState(transaction);    ...&#125;public void executeCallbacks(ClientTransaction transaction) &#123;    final List&lt;ClientTransactionItem&gt; callbacks = transaction.getCallbacks();    ...    final IBinder token = transaction.getActivityToken();    ...    final int size = callbacks.size();    for (int i = 0; i &lt; size; ++i) &#123;        final ClientTransactionItem item = callbacks.get(i);        ...        item.execute(mTransactionHandler, token, mPendingActions);        item.postExecute(mTransactionHandler, token, mPendingActions);        if (r == null) &#123;            // Launch activity request will create an activity record.            r = mTransactionHandler.getActivityClient(token);        &#125;        if (postExecutionState != UNDEFINED &amp;&amp; r != null) &#123;            // Skip the very last transition and perform it by explicit state request instead.            final boolean shouldExcludeLastTransition =                    i == lastCallbackRequestingState &amp;&amp; finalState == postExecutionState;            cycleToPath(r, postExecutionState, shouldExcludeLastTransition, transaction);        &#125;    &#125;&#125;</code></pre><p>这里看到了，是拿到事务的 callback，并进行回调。调用它的<code>execute()</code>方法来真正执行操作。</p><p>那么这个 callback 是什么时候设置的呢？向上翻翻代码，在 ClientTransaction 创建时，有这样的一句代码：</p><pre><code class="java">clientTransaction.addCallback(LaunchActivityItem.obtain(new Intent(r.intent),        System.identityHashCode(r), r.info,        // TODO: Have this take the merged configuration instead of separate global        // and override configs.        mergedConfiguration.getGlobalConfiguration(),        mergedConfiguration.getOverrideConfiguration(), r.compat,        r.launchedFromPackage, task.voiceInteractor, proc.getReportedProcState(),        r.icicle, r.persistentState, results, newIntents,        dc.isNextTransitionForward(), proc.createProfilerInfoIfNeeded(),                r.assistToken));</code></pre><p>也就是说，在『启动 Activity』这个事务中，callback 是 LaunchActivityItem 的实例。我们来看看这个类：</p><pre><code class="java">public class LaunchActivityItem extends ClientTransactionItem &#123;    private Intent mIntent;    ...    private ActivityInfo mInfo;    ...    private Bundle mState;    private PersistableBundle mPersistentState;    private List&lt;ResultInfo&gt; mPendingResults;    ...    @Override    public void execute(ClientTransactionHandler client, IBinder token,            PendingTransactionActions pendingActions) &#123;        ...        ActivityClientRecord r = new ActivityClientRecord(token, mIntent, mIdent, mInfo,                mOverrideConfig, mCompatInfo, mReferrer, mVoiceInteractor, mState, mPersistentState,                mPendingResults, mPendingNewIntents, mIsForward,                mProfilerInfo, client, mAssistToken);        client.handleLaunchActivity(r, pendingActions, null /* customIntent */);        ...    &#125;    @Override    public void postExecute(ClientTransactionHandler client, IBinder token,            PendingTransactionActions pendingActions) &#123;        client.countLaunchingActivities(-1);    &#125;&#125;</code></pre><p>在<code>execute()</code>方法中，首先构造了一个 ActivityClientRecord 类型的变量<code>r</code>，然后将它交给了 ClientTransactionHandler。这个类是啥呢？它是 ActivityThread 的父类。这个<code>client</code>也即<code>TransactionExecutor.mTransactionHandler</code>，而<code>mTransactionHander</code>是在 TransactionExecutor 构造时传入的，我们看一眼：</p><pre><code class="java">public final class ActivityThread extends ClientTransactionHandler &#123;    ...    private final TransactionExecutor mTransactionExecutor = new TransactionExecutor(this);    ...&#125;</code></pre><p>转来转去，又回到了 ActivityThread 中。</p><pre><code class="java">@Overridepublic Activity handleLaunchActivity(ActivityClientRecord r,        PendingTransactionActions pendingActions, Intent customIntent) &#123;    ...    // 初始化 WindowManagerGlobal    // 这个类用来与 WindowManagerService 进行通讯    WindowManagerGlobal.initialize();    ...    final Activity a = performLaunchActivity(r, customIntent);    ...    return a;&#125;/**  Core implementation of activity launch. */private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;    ActivityInfo aInfo = r.activityInfo;    if (r.packageInfo == null) &#123;        r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,                Context.CONTEXT_INCLUDE_CODE);    &#125;    ComponentName component = r.intent.getComponent();    if (component == null) &#123;        component = r.intent.resolveActivity(            mInitialApplication.getPackageManager());        r.intent.setComponent(component);    &#125;    if (r.activityInfo.targetActivity != null) &#123;        component = new ComponentName(r.activityInfo.packageName,                r.activityInfo.targetActivity);    &#125;    ContextImpl appContext = createBaseContextForActivity(r);    // 创建 Activity 实例    Activity activity = null;    try &#123;        ClassLoader cl = appContext.getClassLoader();        activity = mInstrumentation.newActivity(                cl, component.getClassName(), r.intent);        StrictMode.incrementExpectedActivityCount(activity.getClass());        r.intent.setExtrasClassLoader(cl);        r.intent.prepareToEnterProcess();        if (r.state != null) &#123;            r.state.setClassLoader(cl);        &#125;    &#125; catch (Exception e) &#123;        if (!mInstrumentation.onException(activity, e)) &#123;            throw new RuntimeException(                &quot;Unable to instantiate activity &quot; + component                + &quot;: &quot; + e.toString(), e);        &#125;    &#125;    try &#123;        // 如果应用未启动，则要创建应用的 Application        // 如果创建过了，则直接返回已创建的实例        Application app = r.packageInfo.makeApplication(false, mInstrumentation);        if (localLOGV) Slog.v(TAG, &quot;Performing launch of &quot; + r);        if (localLOGV) Slog.v(                TAG, r + &quot;: app=&quot; + app                + &quot;, appName=&quot; + app.getPackageName()                + &quot;, pkg=&quot; + r.packageInfo.getPackageName()                + &quot;, comp=&quot; + r.intent.getComponent().toShortString()                + &quot;, dir=&quot; + r.packageInfo.getAppDir());        if (activity != null) &#123;            CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());            Configuration config = new Configuration(mCompatConfiguration);            if (r.overrideConfig != null) &#123;                config.updateFrom(r.overrideConfig);            &#125;            if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Launching activity &quot;                    + r.activityInfo.name + &quot; with config &quot; + config);            Window window = null;            if (r.mPendingRemoveWindow != null &amp;&amp; r.mPreserveWindow) &#123;                window = r.mPendingRemoveWindow;                r.mPendingRemoveWindow = null;                r.mPendingRemoveWindowManager = null;            &#125;            appContext.setOuterContext(activity);            // 调用 Activity.attach() 方法，对 Activity 进行初始化，比如创建 PhoneWindow，绑定 ActivityThread 等            activity.attach(appContext, this, getInstrumentation(), r.token,                    r.ident, app, r.intent, r.activityInfo, title, r.parent,                    r.embeddedID, r.lastNonConfigurationInstances, config,                    r.referrer, r.voiceInteractor, window, r.configCallback,                    r.assistToken);            if (customIntent != null) &#123;                activity.mIntent = customIntent;            &#125;            r.lastNonConfigurationInstances = null;            checkAndBlockForNetworkAccess();            activity.mStartedActivity = false;            int theme = r.activityInfo.getThemeResource();            if (theme != 0) &#123;                activity.setTheme(theme);            &#125;            activity.mCalled = false;            // 调用 Activity 生命周期方法，完成创建            if (r.isPersistable()) &#123;                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);            &#125; else &#123;                mInstrumentation.callActivityOnCreate(activity, r.state);            &#125;            if (!activity.mCalled) &#123;                throw new SuperNotCalledException(                    &quot;Activity &quot; + r.intent.getComponent().toShortString() +                    &quot; did not call through to super.onCreate()&quot;);            &#125;            r.activity = activity;        &#125;        r.setState(ON_CREATE);        // updatePendingActivityConfiguration() reads from mActivities to update        // ActivityClientRecord which runs in a different thread. Protect modifications to        // mActivities to avoid race.        synchronized (mResourcesManager) &#123;            mActivities.put(r.token, r);        &#125;    &#125; catch (SuperNotCalledException e) &#123;        throw e;    &#125; catch (Exception e) &#123;        if (!mInstrumentation.onException(activity, e)) &#123;            throw new RuntimeException(                &quot;Unable to start activity &quot; + component                + &quot;: &quot; + e.toString(), e);        &#125;    &#125;    return activity;&#125;</code></pre><p>上面的代码分为三大步：</p><ol><li>利用 Instrumentation 反射创建 Activity 的实例；</li><li>调用<code>Activity.attach()</code>对 Activity 进行 Context 绑定、创建 PhoneWindow 实例等；</li><li>调用<code>Instrumentation.callActivityOnCreate()</code>从而调用到 Activity 的<code>onCreate()</code>生命周期方法。</li></ol><p>那么，Activity 的<code>onCreate()</code>被调用完成后，还会继续调用<code>onStart()</code>和<code>onResume()</code>呢，它们是在哪里被调用的呢？</p><p>还记得上面有这样一段吗？</p><pre><code class="java">// 如果指定的最终的生命周期状态，那就再继续执行事务直到指定状态executeLifecycleState(transaction);</code></pre><p>这里就执行了创建 ClientTransactionItem 请求时，顺带创建的 ActivityLifecycleItem 请求。在这个例子里，<code>transaction</code>是 ResumeActivityItem 的实例。</p><p>经过与上面相同的步骤，最终会来到 ActivityThread 的<code>handleResumeActivity()</code>方法中：</p><pre><code class="java">public void handleResumeActivity(IBinder token, boolean finalStateRequest, boolean isForward,        String reason) &#123;    ...    final ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason);    ...    final Activity a = r.activity;    ...    // If the window hasn&#39;t yet been added to the window manager,    // and this guy didn&#39;t finish itself or start another activity,    // then go ahead and add the window.    boolean willBeVisible = !a.mStartedActivity;    if (!willBeVisible) &#123;        try &#123;            willBeVisible = ActivityTaskManager.getService().willActivityBeVisible(                    a.getActivityToken());        &#125; catch (RemoteException e) &#123;            throw e.rethrowFromSystemServer();        &#125;    &#125;    if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;        r.window = r.activity.getWindow();        View decor = r.window.getDecorView();        decor.setVisibility(View.INVISIBLE);        ViewManager wm = a.getWindowManager();        WindowManager.LayoutParams l = r.window.getAttributes();        a.mDecor = decor;        l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;        l.softInputMode |= forwardBit;        if (r.mPreserveWindow) &#123;            a.mWindowAdded = true;            r.mPreserveWindow = false;            // Normally the ViewRoot sets up callbacks with the Activity            // in addView-&gt;ViewRootImpl#setView. If we are instead reusing            // the decor view we have to notify the view root that the            // callbacks may have changed.            ViewRootImpl impl = decor.getViewRootImpl();            if (impl != null) &#123;                impl.notifyChildRebuilt();            &#125;        &#125;        if (a.mVisibleFromClient) &#123;            if (!a.mWindowAdded) &#123;                a.mWindowAdded = true;                wm.addView(decor, l);            &#125; else &#123;                // The activity will get a callback for this &#123;@link LayoutParams&#125; change                // earlier. However, at that time the decor will not be set (this is set                // in this method), so no action will be taken. This call ensures the                // callback occurs with the decor set.                a.onWindowAttributesChanged(l);            &#125;        &#125;        // If the window has already been added, but during resume        // we started another activity, then don&#39;t yet make the        // window visible.    &#125; else if (!willBeVisible) &#123;        if (localLOGV) Slog.v(TAG, &quot;Launch &quot; + r + &quot; mStartedActivity set&quot;);        r.hideForNow = true;    &#125;    // Get rid of anything left hanging around.    cleanUpPendingRemoveWindows(r, false /* force */);    // The window is now visible if it has been added, we are not    // simply finishing, and we are not starting another activity.    if (!r.activity.mFinished &amp;&amp; willBeVisible &amp;&amp; r.activity.mDecor != null &amp;&amp; !r.hideForNow) &#123;        if (r.newConfig != null) &#123;            performConfigurationChangedForActivity(r, r.newConfig);            if (DEBUG_CONFIGURATION) &#123;                Slog.v(TAG, &quot;Resuming activity &quot; + r.activityInfo.name + &quot; with newConfig &quot;                        + r.activity.mCurrentConfig);            &#125;            r.newConfig = null;        &#125;        if (localLOGV) Slog.v(TAG, &quot;Resuming &quot; + r + &quot; with isForward=&quot; + isForward);        WindowManager.LayoutParams l = r.window.getAttributes();        if ((l.softInputMode                &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)                != forwardBit) &#123;            l.softInputMode = (l.softInputMode                    &amp; (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION))                    | forwardBit;            if (r.activity.mVisibleFromClient) &#123;                ViewManager wm = a.getWindowManager();                View decor = r.window.getDecorView();                wm.updateViewLayout(decor, l);            &#125;        &#125;        r.activity.mVisibleFromServer = true;        mNumVisibleActivities++;        if (r.activity.mVisibleFromClient) &#123;            // 让 Activity 可见的重要方法            r.activity.makeVisible();        &#125;    &#125;&#125;</code></pre><p>这个方法也是比较重要的一个方法，它会调用<code>performResumeActivity()</code>方法，然后初始化一些 Window 相关的数据，并最终通过调用 <code>Activity.makeVisible()</code>方法让 Activity 可见。</p><pre><code class="java">public ActivityClientRecord performResumeActivity(IBinder token, boolean finalStateRequest,        String reason) &#123;    final ActivityClientRecord r = mActivities.get(token);    ...    try &#123;        ...        r.activity.performResume(r.startsNotResumed, reason);    &#125; catch (Exception e) &#123;        ...    &#125;&#125;</code></pre><p>Activity 的<code>performResume()</code>如下：</p><pre><code class="java">final void performResume(boolean followedByPause, String reason) &#123;    ...    performRestart(true /* start */, reason); //     ...    // mResumed is set by the instrumentation    mInstrumentation.callActivityOnResume(this);    ...    onPostResume();    ...    dispatchActivityPostResumed();&#125;final void performRestart(boolean start, String reason) &#123;    ...    if (mStopped) &#123;        ...        mInstrumentation.callActivityOnRestart(this);        ...        if (start) &#123;            performStart(reason);        &#125;    &#125;&#125;final void performStart(String reason) &#123;    ...    mInstrumentation.callActivityOnStart(this);    ...    dispatchActivityPostStarted();&#125;</code></pre><p>Activity 生命周期流程得到了佐证，会由<code>onCreate()</code>→<code>onRestart()</code>→<code>onStart()</code>→<code>onResume()</code></p><p>真的是很长的一个流程。我们简单总结一下：</p><ol><li>源进程调用<code>startActivity()</code>，最终会调用到<code>Instrumentation.execStartActivity()</code>方法；</li><li>通过 Binder 调用 ActivityTaskManagerService 的<code>startActivity()</code>方法；</li><li>ATMS 会使用 ActivityStack 类和 ActivityStackSupervisor 类来处理 Task 与 Activity 的入栈操作；</li><li>接着在<code>ActivityStackSupervisor.realStartActivityLocked()</code>方法中，使用提交事务的方法，创建一个启动 Activity 的事务，并提交给 ClientLifecycleManager；</li><li>ClientLifecycleManager 会通过 Binder 调用 ActivityThread 的<code>scheduleTransaction()</code>方法，该方法会向 ActivityThread 中的 Handler 发送一个消息；</li><li>Handler 接收消息后，利用 TransactionExecutor 按顺序执行事务；</li><li>在这个『启动 Activity』的事务回调中，又调用了 ActivityThread 的<code>handleLaunchActivity()</code>方法，进而又调用了<code>performLaunchActivity()</code>方法；</li><li>在这个方法中，利用反射创建了 Activity 的实例，如果需要的话，还利用反射创建了 Application 的实例，并调用<code>Activity.attach()</code>方法，创建 PhoneWindow、绑定 Context；</li><li>最后调用了<code>Instrumentation.callActivityOnCreate()</code>方法，执行了 Activity 的<code>onCreate()</code>生命周期方法；</li><li>接着 TransactionExecutor 又开始执行生命周期事务，最后依次调用到<code>onStart()</code>、<code>onResume()</code>。</li></ol><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>本文代码分析基于 Android 10.0，在 10.0 中，出现了 ATMS，AMS 中原来的<code>startActivity()</code>全部由 ATMS 来执行。</p><p>可以从下面链接中观察两者的不同：<br><a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java;l=3521;bpv=0;bpt=1">10.0.0_r30 中的 ActivityManagerService</a><br><a href="https://cs.android.com/android/platform/superproject/+/android-9.0.0_r34:frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java;l=5088;bpv=0;bpt=1">9.0.0_r34 中的 ActivityManagerService</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Activity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 GC</title>
      <link href="/2020-05-21/gc/"/>
      <url>/2020-05-21/gc/</url>
      
        <content type="html"><![CDATA[<p>GC（Garbage Collect）是 Java 虚拟机最著名的一个机制——<strong>内存回收</strong>。</p><p>我们按着下面的流程来讲述 GC：</p><blockquote><ol><li>什么是 GC</li><li>GC 常用算法</li><li>垃圾收集器是什么</li><li><code>finalize()</code>方法详解</li><li>总结</li></ol></blockquote><span id="more"></span><h2 id="一、什么是-GC"><a href="#一、什么是-GC" class="headerlink" title="一、什么是 GC"></a>一、什么是 GC</h2><p>在我们的开发工作中，几乎所有人都遇到过内存溢出的情况。因为程序运行时，内存空间是有限的，那么如何及时的把不再使用的对象清除将内存释放出来，这就是 GC 要做的事。</p><p>理解 GC 机制就从：『GC 的区域在哪里』，『GC 的对象是什么』，『GC 的时机是什么』，『GC 做了哪些事』几方面来分析。</p><h3 id="1、需要GC的内存区域"><a href="#1、需要GC的内存区域" class="headerlink" title="1、需要GC的内存区域"></a>1、需要GC的内存区域</h3><p>我们先来从一个较高的维度来看 JVM 与系统调用之间的关系：</p><div class="center-img"><p><img src="/img/gc-1588648765.png"></p></div><p>由上图可见，JVM 中，虚拟机栈、本地方法栈和程序计数器因为是<strong>线程私有</strong>（也即线程隔离），都是随线程而生随线程而灭，栈帧随着方法的进入和退出做入栈和出栈操作，实现了<strong>自动的内存清理</strong>。因此，我们的内存垃圾回收主要集中于 java <strong>堆和方法区</strong>中，在程序运行期间，这部分内存的分配和使用都是动态的。</p><p>并且，JVM 运行时的数据区大致可以分为5个部分：</p><ol><li><p><strong>方法区</strong></p><p>这个区域<strong>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</strong>。JVM 运行时，Class Loader 将会提取 class 文件里面的类信息，并将其存放在方法区中。例如类的名称、类的类型（枚举、类、接口）、字段、方法等等。</p></li><li><p><strong>堆（ Heap）</strong></p><p>熟悉 c/c++ 编程的同学们应该相当熟悉 Heap 了，而对于 Java 而言，对大多数应用来说，堆是 Java 虚拟机所管理的内存中最大的一块。Java 堆是被<strong>所有线程共享</strong>的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是<strong>存放对象实例</strong>，几乎所有的对象实例都在这里分配内存。<strong>每个应用都唯一对应一个 JVM 实例</strong>，而<strong>每一个 JVM 实例唯一对应一个堆</strong>。堆由 JVM 的自动内存管理机制所管理，也即本文的主角 —— GC（Garbage Collection）。</p></li><li><p><strong>虚拟机栈（VM Stack）</strong></p><p>操作系统内核<strong>为某个进程或者线程建立的存储区域</strong>，是线程私有的，<strong>它的生命周期与线程相同</strong>。虚拟机栈描述的是 <strong>Java 方法执行的内存模型</strong>：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。<strong>每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程</strong>。</p></li><li><p><strong>本地方法栈</strong></p><p>用来调用其余语言的本地方法，为虚拟器使用到的 native 方法服务，例如 C/C++ 写的本地代码，这些方法在本地方法栈中执行，而不会在 Java 栈中执行。</p></li><li><p><strong>程序计数器</strong></p><p><strong>线程私有</strong>。有时也叫『PC 寄存器（PC Register）』，是一块较小的内存空间，它可以看作是当前线程所执行的字节码的<strong>行号指示器</strong>，用于存放下一条指令的地址，每一个线程都有一个程序计数器。</p><blockquote><p><strong>小知识</strong><br>JVM 中，只有程序计数器部分不会出现 OOM。</p></blockquote></li></ol><p>在 JVM 中绝大部分对象都是英年早逝的，在编码时大部分堆中的内存都是短暂临时分配的，所以无论是效率还是开销方面，随着分配的对象增多，GC 的时间与开销将会越来越大。所以，JVM 的内存被分为了三个主要部分：<strong>新生代，老年代和永久代</strong>。</p><div class="center-img"><p><img src="/img/gc-1588651828.png"></p></div><ul><li><p><strong>新生代</strong></p><p>所有新产生的对象一律都在新生代中， Eden 区保存最新的对象，有两个 Survivor Space —— S0 和 S1，三个区域的比例大致为 Eden:S0:S1 = 8:1:1。<strong>当 Eden 区满时，触发 Minor GC</strong>。Minor GC 是一种 Stop the World 事件，在回收时会暂停当前线程正在做的所有事情。</p></li><li><p><strong>老年代</strong></p><p>老年代用来存储存活时间较长的对象，老年代区域的 GC 是 Major GC，老年代中的内存不够时，就会触发一次。这也是一个 Stop the World事件，但是看名字就知道，这个回收过程会相当慢，由于这<strong>包括了对新生代和老年代所有对象的回收</strong>，也叫 Full GC。</p></li><li><p><strong>永久代</strong>（JDK1.7及之前）</p><p>永久代位于方法区，主要存放元数据，例如 Class、 Method 的元信息，与 GC 要回收的对象其实关系并不是很大，我们可以几乎忽略其对 GC 的影响。除了 JavaHotSpot 这种较新的虚拟机技术，会回收无用的常量和的类，以免大量运用反射这类频繁自己设置 ClassLoader 的操作时方法区溢出。</p></li></ul><h3 id="2、GC-的对象以及判断方法"><a href="#2、GC-的对象以及判断方法" class="headerlink" title="2、GC 的对象以及判断方法"></a>2、GC 的对象以及判断方法</h3><p>需要进行 GC 的对象就是已经没有存活的对象，判断一个对象是否存活常用的有这几种办法：<strong>引用计数</strong>、<strong>可达性分析</strong>、<strong>两次标记</strong>和**finalize()**。</p><h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>引用计数算法是在JVM中被摒弃的一种对象存活判定算法，不过它也有一些知名的应用场景（如Python、FlashPlayer），因此在这里也简单介绍一下。</p><p>用引用计数器判断对象是否存活的过程是这样的：<strong>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器加1；当引用失效时，计数器减1；任何时刻计数器为0的对象就是不可能再被使用的</strong>。此方法简单，但<strong>无法解决对象相互循环引用的问题</strong>。</p><p>比如下面的代码：</p><pre><code class="java">public class ReferenceCountingGC &#123;    public Object instance = null;    private static final int _1MB = 1024 * 1024;    /** * 这个成员属性的唯一意义就是占点内存，以便在能在GC日志中看清楚是否有回收过 */    private byte[] bigSize = new byte[2 * _1MB];    public static void testGC() &#123;        ReferenceCountingGC objA = new ReferenceCountingGC();        ReferenceCountingGC objB = new ReferenceCountingGC();        objA.instance = objB;        objB.instance = objA;        objA = null;        objB = null;        // 假设在这行发生GC，objA和objB是否能被回收？        System.gc();    &#125;&#125;</code></pre><p>在上面这段代码中，对象<code>objA</code>和对象<code>objB</code>都有字段<code>instance</code>，赋值令<code>objA.instance = objB;</code>、<code>objB.instance = objA;</code>，除此之外，这两个对象再无引用。如果 JVM 采用引用计数算法来管理内存，<strong>这两个对象不可能再被访问</strong>，但是他们<strong>互相引用着对方</strong>，导致它们<strong>引用计数不为0</strong>，所以引用计数器无法通知 GC 收集器回收它们。</p><p>而事实上执行这段代码，<code>objA</code>和<code>objB</code>是可以被回收的，下面一节将介绍 JVM 实际使用的存活判定算法。</p><h4 id="可达性分析（Reachability-Analysis）"><a href="#可达性分析（Reachability-Analysis）" class="headerlink" title="可达性分析（Reachability Analysis）"></a>可达性分析（Reachability Analysis）</h4><p>在主流商用程序语言的实现中，都是通过可达性分析（tracing GC）来判定对象是否存活的。此算法的基本思路是：<strong>通过一系列的称为『GC Roots』的对象作为起点，从这些节点向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到 GC Roots 没有任何引用链相连（用图论的话来说，就是GC Roots 到这个对象不可达）时，则证明此对象是不可用的</strong>。用下图来加以说明：</p><p><img src="/img/48.png"></p><p>上图中，对象object 5、object 6、object 7虽然互有关联，但是它们到GC Roots是不可达的，所以它们将会被判定为是可回收的对象。</p><p>可以看到，GC Roots 在对象图之外，是特别定义的『<strong>起点</strong>』，不可能被对象图内的对象所引用。</p><p>准确地说，<strong>GC Roots 其实不是一组对象，而通常是一组特别管理的指向引用类型对象的指针</strong>，这些指针是 tracing GC 的 trace 的起点。它们不是对象图里的对象，对象也不可能引用到这些『外部』的指针，这也是 tracing GC 算法不会出现循环引用问题的基本保证。因此也容易得出，<strong>只有引用类型的变量才被认为是 Roots ，值类型的变量永远不被认为是 Roots</strong>。只有深刻理解引用类型和值类型的内存分配和管理的不同，才能知道为什么 root 只能是引用类型。</p><p>在Java语言中，可以做为 GC Roots 的对象包括：</p><ul><li>虚拟机栈中引用的对象。</li><li>方法区中类静态属性实体引用的对象。</li><li>方法区中常量引用的对象。</li><li>本地方法栈中JNI引用的对象。</li></ul><p>可以概括得出，可作为 GC Roots 的节点主要在<strong>全局性的引用</strong>与<strong>执行上下文</strong>中。要明确的是，tracing gc 必须以当前存活的对象集为Roots，因此必须选取确定存活的引用类型对象。GC 管理的区域是 Java 堆，<strong>虚拟机栈</strong>、<strong>方法区</strong>和<strong>本地方法栈</strong>不被 GC 所管理，因此选用这些区域内引用的对象作为 GC Roots ，是不会被 GC 所回收的。其中虚拟机栈和本地方法栈都是线程私有的内存区域，只要线程没有终止，就能确保它们中引用的对象的存活。而方法区中类静态属性引用的对象是显然存活的。常量引用的对象在当前可能存活，因此，也可能是 GC roots 的一部分。</p><p>在 JDK1.2之后，Java将引用分为强引用、软引用、弱引用、虚引用4种，这4种引用强度依次减弱。</p><h4 id="两次标记与-finalize-方法"><a href="#两次标记与-finalize-方法" class="headerlink" title="两次标记与 finalize()方法"></a>两次标记与 <code>finalize()</code>方法</h4><p>即使在可达性分析算法中不可达的对象，也不是一定会死亡的，它们暂时都处于『缓刑』阶段，要真正宣告一个对象『死亡』，至少要经历两次标记过程：</p><ol><li><p>如果对象在进行可达性分析后发现没有与 GC Roots相连接的引用链，那它将会被<strong>第一次标记</strong>并且进行一次筛选，筛选的条件是<strong>此对象是否有必要执行finalize</strong>()方法。当对象没有覆写<code>finalize()</code>方法，或者<code>finalize()</code>方法已经被虚拟机调用过，虚拟机将这两种情况都视为『没有必要执行』。</p></li><li><p>如果这个对象被判定为有必要执行<code>finalize()</code>方法，那么此对象将会放置在一个叫做 F-Queue 的队列中，并在稍后由一个虚拟机自动建立的、低优先级的 Finalizer 线程去执行它。这里所谓的『执行』是指虚拟机会触发此方法，但并不承诺会等待它运行结束，原因是：如果一个对象在<code>finalize()</code>方法中执行缓慢，或者发生了死循环（更极端的情况），将很可能导致 F-Queue 队列中的其它对象永久处于等待，甚至导致整个内存回收系统崩溃。</p><p> <code>finalize()</code>方法是对象逃脱死亡命运的最后一次机会，稍后 GC 将对 F-Queue 队列中的对象进行<strong>第二次小规模的标记</strong>。如果对象想在<code>finalize()</code>方法中成功拯救自己，只要<strong>重新与引用链上的任何一个对象建立关联即可</strong>，例如把<strong>自己（this关键字）赋值给某个类变量或者对象的成员变量</strong>，这样在第二次标记时它将被移出『即将回收』的集合；如果对象这时候还没有逃脱，基本上它就真的被回收了。</p></li></ol><p>值得注意的是，如果代码中有两段一模一样的代码段，执行结果却是一次逃脱成功，一次失败。这是因为任何一个对象的<code>finalize()</code>方法都只会被系统调用一次，如果对象面临下一次回收，它的<code>finalize()</code>方法不会再被执行，因此第二次逃脱行动失败。</p><p>需要说明的是，使用<code>finalize()</code>方法来『拯救』对象是不值得提倡的，因为它不是 C/C++ 中的析构函数，而是 Java 刚诞生时为了使 C/C++ 程序员更容易接受它所做的一个妥协。它的<strong>运行代价高昂，不确定性大，无法保证各个对象的调用顺序</strong>。<code>finalize()</code>能做的工作，使用 <code>try-catch-finally</code> 或者其它方法都更适合、及时，所以兔子建议大家可以忘掉此方法的存在。</p><h3 id="3、什么时候触发GC"><a href="#3、什么时候触发GC" class="headerlink" title="3、什么时候触发GC"></a>3、什么时候触发GC</h3><ul><li>程序调用<code>System.gc()</code>时可以触发</li><li>系统自身来决定 GC 触发的时机（根据 Eden 区和 From Space 区的内存大小来决定。当内存大小不足时，则会启动 GC 线程并停止应用线程）。</li></ul><p>上文提到了 Minor GC 和 Full GC，这两种 GC 触发的条件也不太相同：</p><ul><li><strong>Minor GC 触发</strong>：当 Eden 区满时触发</li><li><strong>Full GC 触发</strong>：<ul><li>调用<code>System.gc()</code>时，系统建议执行 Full GC，但是不必然执行</li><li>老年代空间不足</li><li>方法区空间不足</li><li>通过 Minor GC 后进入老年代的平均大小大于老年代的可用内存</li><li>由 Eden 区、S0 区向 S1 区复制时，对象大小大于 S1 可用内存，则把该对象转存到老年代，且该对象大小大于老年代的可用内存</li></ul></li></ul><h3 id="4、GC做了什么事"><a href="#4、GC做了什么事" class="headerlink" title="4、GC做了什么事"></a>4、GC做了什么事</h3><p>主要做了清理对象，整理内存的工作。Java堆分为<strong>新生代</strong>和<strong>老年代</strong>，采用了不同的回收方式。（回收方式即回收算法详见后文）</p><h2 id="二、GC常用算法"><a href="#二、GC常用算法" class="headerlink" title="二、GC常用算法"></a>二、GC常用算法</h2><p>GC常用算法有：<strong>标记-清除算法</strong>，<strong>标记-压缩算法</strong>，<strong>复制算法</strong>，<strong>分代收集算法</strong>。</p><p>::: tip<br>目前主流的JVM（HotSpot）采用的是分代收集算法。<br>::: </p><h3 id="1-标记-清除算法"><a href="#1-标记-清除算法" class="headerlink" title="1. 标记-清除算法"></a>1. 标记-清除算法</h3><p>为每个对象存储一个标记位，记录对象的状态（活着或是死亡）。分为两个阶段，一个是标记阶段，这个阶段内，为每个对象更新标记位，检查对象是否死亡；第二个阶段是清除阶段，该阶段对死亡的对象进行清除，执行 GC 操作。如图所示：</p><p><img src="/img/34.jpeg"></p><ul><li><span style="color: green">优点</span>：标记—清除算法中<strong>每个活着的对象的引用只需要找到一个即可</strong>，找到一个就可以判断它为活的。此外，更重要的是，这个算法并不移动对象的位置。</li><li><span style="color: red">缺点</span>：效率比较低（递归与全堆对象遍历）。每个活着的对象都要在标记阶段遍历一遍；所有对象都要在清除阶段扫描一遍，因此算法复杂度较高。没有移动对象，导致可能<strong>出现很多碎片空间无法利用</strong>的情况。</li></ul><h3 id="2-标记-压缩（整理）算法"><a href="#2-标记-压缩（整理）算法" class="headerlink" title="2. 标记-压缩（整理）算法"></a>2. 标记-压缩（整理）算法</h3><p><strong>标记-压缩</strong>是 <strong>标记-清除</strong>的一个改进版。同样，在标记阶段，该算法也将所有对象标记为存活和死亡两种状态；不同的是，在第二个阶段，该算法并没有直接对死亡的对象进行清理，而是将所有存活的对象整理一下，放到另一处空间，然后把剩下的所有对象全部清除。这样就达到了标记-整理的目的。如图所示：</p><p><img src="/img/35.jpeg"></p><p>左边是标记阶段，右边是整理之后的状态。可以看到，该算法不会产生大量碎片内存空间。</p><ul><li><span style="color: green">优点</span>：该算法不会像标记-清除算法那样产生大量的碎片空间。</li><li><span style="color: red">缺点</span>：如果存活的对象过多，整理阶段将会执行较多复制操作，导致算法效率降低。</li></ul><h3 id="3-复制算法"><a href="#3-复制算法" class="headerlink" title="3. 复制算法"></a>3. 复制算法</h3><p>该算法将内存平均分成两部分，然后每次只使用其中的一部分，当这部分内存满的时候，将内存中所有存活的对象复制到另一个内存中，然后将之前的内存清空，只使用这部分内存，循环下去。如图所示：</p><p><img src="/img/36.jpeg"></p><p>这个算法与标记-压缩（整理）算法的区别在于，该算法不是在同一个区域复制，而是将所有存活的对象复制到另一个区域内。</p><ul><li><span style="color: green">优点</span>：实现简单；不产生内存碎片</li><li><span style="color: red">缺点</span>：每次运行，总有一半内存是空的，导致可使用的内存空间只有原来的一半。</li></ul><h3 id="4-分代收集算法"><a href="#4-分代收集算法" class="headerlink" title="4. 分代收集算法"></a>4. 分代收集算法</h3><p>现在的虚拟机 GC 大多采用这种方式，它根据对象的生存周期，将堆分为新生代（Young Generation）和老年代（Tenured Generation）。在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这时就采用<strong>复制算法</strong>。老年代里的对象存活率较高，没有额外的空间进行分配担保，所以可以使用<strong>标记-整理</strong>或者<strong>标记-清除</strong>。</p><p>新生代又分为 Eden 区、From Survivor 0（S0）区、To Survivor 1（S1）区。</p><p>老年代不分区。</p><p>如下图所示：</p><div class="center-img"><p><img src="/img/37.png"></p></div><p>当系统创建一个对象的时候，总是在 Eden 区操作，当这个区满了，那么就会触发一次 Young GC，也就是年轻代的垃圾回收。一般来说这时候不是所有的对象都没用了，所以就会把还能用的对象复制到 S0 区。 </p><blockquote><p>Minor GC 与 Young GC 并不相同。Minor GC 只负责 Eden 区，而 Young GC 负责 Eden + S0 + S1 三个区</p></blockquote><div class="center-img"><p><img src="/img/38.png"></p></div><p>这样整个 Eden 区就被清理干净了，可以继续创建新的对象，当 Eden 区再次被用完，就再触发一次 Young GC。然后呢，注意，这个时候跟刚才稍稍有点区别。这次触发 Young GC 后，会将 Eden 区还在被使用的对象与 S0 区还在被使用的对象复制到 S1 区。</p><div class="center-img"><p><img src="/img/39.png"></p></div><p>再下一次 Young GC 的时候，则是将 Eden 区还在被使用的对象与 S1 区中还在被使用的对象复制到 S0 区。</p><div class="center-img"><p><img src="/img/40.png"></p></div><p>经过若干次 Young GC 后，有些对象在 S0 与 S1 之间来回游荡，每复制一次，年龄就 +1，这时候 S0 区与 S1 区亮出了底线（临界值，由<code>-XX:MaxTenuringThreshold</code>来设，HotSpot虚拟机默认为 15），这些家伙要是到现在还没挂掉，恭喜你们，你们已经长大了，去（复制到）老年代吧。 </p><div class="center-img"><p><img src="/img/41.png"></p></div><p>老年代经过这么几次折腾，也就扛不住了（空间被用完），好，那就来次集体大扫除（Full GC），也就是全量回收。如果 Full GC 使用太频繁的话，无疑会对系统性能产生很大的影响。所以要合理设置年轻代与老年代的大小，尽量减少 Full GC 的操作。</p><h2 id="三、垃圾收集器"><a href="#三、垃圾收集器" class="headerlink" title="三、垃圾收集器"></a>三、垃圾收集器</h2><p>如果说收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现。</p><p>Java虚拟机规范中对垃圾收集器应该如何实现并没有任何规定，因此不同的厂商、版本的虚拟机所提供的垃圾收集器都可能会有很大差别，并且一般都会提供参数供用户根据自己的应用特点和要求<strong>组合出各个年代所使用的收集器</strong>。接下来讨论的收集器基于 JDK1.7 Update 14 之后的 HotSpot 虚拟机（在此版本中正式提供了商用的 G1 收集器，之前 G1 仍处于实验状态），该虚拟机包含的所有收集器如下图所示：</p><div class="center-img"><p><img src="/img/42.png"></p></div><p>上图展示了7种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用。收集器所处的区域，则表示它是属于新生代收集器还是老年代收集器。Hotspot 实现了如此多的收集器，正是因为目前并无完美的收集器出现，只是选择对具体应用最适合的收集器。</p><p>先解释一些下面会用到的概念：</p><ul><li>并行和并发<ul><li>并行（Parallel）：指<strong>多条垃圾收集线程并行工作</strong>，但此时<strong>用户线程仍然处于等待状态</strong>。</li><li>并发（Concurrent）：指<strong>用户线程与垃圾收集线程同时执行</strong>（但不一定是并行的，可能会交替执行），用户程序在继续运行。而垃圾收集程序运行在另一个CPU上。</li></ul></li><li>吞吐量（Throughput）吞吐量就是 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值，即<code>吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）</code>。假设虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</li></ul><p>下面逐个介绍上面的7种收集器。</p><h3 id="新生代收集器"><a href="#新生代收集器" class="headerlink" title="新生代收集器"></a>新生代收集器</h3><h4 id="1-Serial-收集器"><a href="#1-Serial-收集器" class="headerlink" title="1. Serial 收集器"></a>1. Serial 收集器</h4><p><strong>Serial（串行）收集器</strong>是最基本、发展历史最悠久的收集器，它是采用<strong>复制算法</strong>的新生代收集器，曾经（JDK 1.3.1之前）是虚拟机新生代收集的唯一选择。它是一个单线程收集器，只会使用一个 CPU 或一条收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集时，必须暂停其他所有的工作线程，直至 Serial 收集器收集结束为止（也即 Stop the World）。这项工作是由虚拟机在后台自动发起和自动完成的，在用户不可见的情况下把用户正常工作的线程全部停掉，这对很多应用来说是难以接受的。</p><p>下图展示了 Serial 收集器（老年代采用 Serial Old 收集器）的运行过程：</p><div class="center-img"><p><img src="/img/43.jpeg"></p></div><p>为了消除或减少工作线程因内存回收而导致的停顿，HotSpot 虚拟机开发团队在 JDK 1.3 之后的 Java 发展历程中研发出了各种其他的优秀收集器，这些将在稍后介绍。但是这些收集器的诞生并不意味着 Serial 收集器已经『老而无用』，实际上到现在为止，它<strong>依然是 HotSpot 虚拟机运行在 Client 模式下的默认的新生代收集器。</strong> 它也有着优于其他收集器的地方：<strong>简单而高效（与其他收集器的单线程相比），对于限定单个 CPU 的环境来说，Serial 收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得更高的单线程收集效率。</strong></p><p>在用户的桌面应用场景中，分配给虚拟机管理的内存一般不会很大，收集几十兆甚至一两百兆的新生代（仅仅是新生代使用的内存，桌面应用基本不会再大了），停顿时间完全可以控制在几十毫秒最多一百毫秒以内，只要不频繁发生，这点停顿时间可以接受。所以，Serial 收集器对于运行在 Client 模式下的虚拟机来说是一个很好的选择。</p><h4 id="2-ParNew-收集器"><a href="#2-ParNew-收集器" class="headerlink" title="2. ParNew 收集器"></a>2. ParNew 收集器</h4><p>ParNew收集器就是Serial收集器的多线程版本。除了使用多线程进行垃圾收集外，其余行为包括 Serial 收集器可用的所有控制参数、收集算法（复制算法）、Stop The World、对象分配规则、回收策略等与 Serial 收集器完全相同，两者共用了相当多的代码。</p><p>ParNew收集器的工作过程如下图（老年代采用Serial Old收集器）：</p><div class="center-img"><p><img src="/img/44.jpeg"></p></div><p>ParNew 收集器除了使用多线程收集外，其他与 Serial 收集器相比并无太多创新之处，但它却是许多运行在 Server 模式下的虚拟机中首选的新生代收集器，其中有一个与性能无关的重要原因是，<strong>除了 Serial 收集器外，目前只有它能和 CMS 收集器（Concurrent Mark Sweep）配合工作</strong>，CMS 收集器是 JDK 1.5 推出的一个具有划时代意义的收集器，具体内容将在稍后进行介绍。</p><p>ParNew 收集器在单CPU的环境中绝对不会有比 Serial 收集器有更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个 CPU 的环境中都不能百分之百地保证可以超越 Serial 收集器。在多 CPU 环境下，随着 CPU 的数量增加，它对于 GC 时系统资源的有效利用是很有好处的。它默认开启的收集线程数与 CPU 的数量相同，在 CPU 非常多的情况下可使用<code>-XX:ParallerGCThreads</code>参数设置。</p><h4 id="3-Parallel-Scavenge-收集器"><a href="#3-Parallel-Scavenge-收集器" class="headerlink" title="3. Parallel Scavenge 收集器"></a>3. Parallel Scavenge 收集器</h4><p>Parallel Scavenge 收集器也是一个并行的多线程新生代收集器，它也使用复制算法。Parallel Scavenge 收集器的特点是它的关注点与其他收集器不同，CMS 等收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而 Parallel Scavenge 收集器的目标是<strong>达到一个可控制的吞吐量（Throughput）</strong>。</p><p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在<strong>后台运算而不需要太多交互的任务</strong>。</p><p>Parallel Scavenge 收集器除了会显而易见地提供可以精确控制吞吐量的参数，还提供了一个参数<code>-XX:+UseAdaptiveSizePolicy</code>，这是一个开关参数，打开参数后，就不需要手工指定新生代的大小（<code>-Xmn</code>）、Eden 和 Survivor 区的比例（<code>-XX:SurvivorRatio</code>）、晋升老年代对象年龄（<code>-XX:PretenureSizeThreshold</code>）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种方式称为GC自适应的调节策略（GC Ergonomics）。自适应调节策略也是 Parallel Scavenge 收集器与 ParNew 收集器的一个重要区别。</p><p>另外值得注意的一点是，Parallel Scavenge 收集器无法与 CMS 收集器配合使用，所以在 JDK 1.6 推出 Parallel Old 之前，<strong>如果新生代选择 Parallel Scavenge 收集器，老年代只有 Serial Old 收集器能与之配合使用</strong>。</p><p>Parallel Scavenge 收集器的工作过程如下图：</p><div class="center-img"><p><img src="/img/45.jpeg"></p></div><h3 id="老年代收集器"><a href="#老年代收集器" class="headerlink" title="老年代收集器"></a>老年代收集器</h3><h4 id="1-Serial-Old-收集器"><a href="#1-Serial-Old-收集器" class="headerlink" title="1. Serial Old 收集器"></a>1. Serial Old 收集器</h4><p>Serial Old 是 Serial 收集器的老年代版本，它同样是一个<strong>单线程</strong>收集器，使用『标记-整理』算法。</p><p>此收集器的主要意义也是在于给 Client 模式下的虚拟机使用。如果在 Serve r模式下，它还有两大用途：</p><ul><li>在 JDK1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。</li><li>作为 CM 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。</li></ul><p>它的工作流程与Serial收集器完全相同。</p><h4 id="2-Parallel-Old-收集器"><a href="#2-Parallel-Old-收集器" class="headerlink" title="2. Parallel Old 收集器"></a>2. Parallel Old 收集器</h4><p>Parallel Old 收集器是 Parallel Scavenge 收集器的老年代版本，使用多线程和『标记-整理』算法。前面已经提到过，这个收集器是在JDK 1.6 中才开始提供的，在此之前，如果新生代选择了 Parallel Scavenge 收集器，老年代除了 Serial Old 以外别无选择，所以在Parallel Old 诞生以后，『吞吐量优先』收集器终于有了比较名副其实的应用组合，在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑Parallel Scavenge 加 Parallel Old 收集器。Parallel Old 收集器的工作流程与 Parallel Scavenge 完全相同。</p><h4 id="3-CMS收集器"><a href="#3-CMS收集器" class="headerlink" title="3. CMS收集器"></a>3. CMS收集器</h4><p>CMS（Concurrent Mark Sweep）收集器是一种以<strong>获取最短回收停顿时间</strong>为目标的收集器，它非常符合那些集中在互联网站或者 B/S 系统的服务端上的 Java 应用，这些应用都非常重视服务的响应速度。从名字上就可以看出它是基于『标记-清除』算法实现的。</p><p>CMS收集器工作的整个流程分为以下4个步骤：</p><ul><li><strong>初始标记（CMS initial mark）</strong>：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要 Stop The World。</li><li><strong>并发标记（CMS concurrent mark）</strong>：进行 GC Roots Tracing 的过程，在整个过程中耗时最长。</li><li><strong>重新标记（CMS remark）</strong>：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。此阶段也需要 Stop The World。</li><li><strong>并发清除（CMS concurrent sweep）</strong></li></ul><p>由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。通过下图可以比较清楚地看到 CMS 46收集器的运作步骤中并发和需要停顿的时间：</p><div class="center-img"><p><img src="/img/46.jpeg"></p></div><p><span style="color: green">优点</span>：CMS 是一款优秀的收集器，它的主要优点在名字上已经体现出来了：<strong>并发收集、低停顿，</strong>因此CMS收集器也被称为<strong>并发低停顿收集器（Concurrent Low Pause Collector）</strong>。</p><p><span style="color: red">缺点</span>：</p><ul><li><strong>对CPU资源非常敏感</strong>。其实，面向并发设计的程序都对 CPU 资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但会因为占用了一部分线程（或者说 CPU 资源）而导致应用程序变慢，总吞吐量会降低。CMS 默认启动的回收线程数是<code>(CPU数量+3)/ 4</code>，也就是当 CPU 在4个以上时，并发回收时垃圾收集线程不少于 25% 的CPU资源，并且随着 CPU 数量的增加而下降。但是当 CPU 不足4个时（比如2个），CMS 对用户程序的影响就可能变得很大，如果本来 CPU 负载就比较大，还要分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然降低了50%，其实也让人无法接受。</li><li><strong>无法处理浮动垃圾（Floating Garbage）</strong>。可能出现『Concurrent Mode Failure』失败而导致另一次 Full GC 的产生。 <strong>由于CMS 并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生。</strong> 这一部分垃圾出现在标记过程之后，CMS 无法再当次收集中处理掉它们，只好留待下一次 GC 时再清理掉。这一部分垃圾就被称为『<strong>浮动垃圾</strong>』。也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此 CMS 收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。</li><li><strong>标记-清除算法导致的空间碎片</strong>。CMS是一款基于『标记-清除』算法实现的收集器，这意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象。</li></ul><h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>G1（Garbage-First）收集器是当今收集器技术发展最前沿的成果之一，它是一款<strong>面向服务端应用的垃圾收集器</strong>，HotSpot开发团队赋予它的使命是（在比较长期的）未来可以替换掉 JDK 1.5 中发布的 CMS 收集器。与其他 GC 收集器相比，G1 具备如下特点：</p><ul><li><strong>并行与并发</strong> G1 能充分利用多 CPU、多核环境下的硬件优势，使用多个 CPU 来缩短『Stop The World』停顿时间，部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，<strong>G1 收集器仍然可以通过并发的方式让 Java 程序继续执行</strong>。</li><li><strong>分代收集</strong> 与其他收集器一样，分代概念在 G1 中依然得以保留。虽然 <strong>G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但它能够采用不同方式去处理新创建的对象和已存活一段时间、熬过多次 GC 的旧对象</strong>来获取更好的收集效果。</li><li><strong>空间整合</strong> G1 从整体来看是基于『标记-整理』算法实现的收集器，从局部（两个 Region 之间）上来看是基于『复制』算法实现的。这意味着 G1 运行期间<strong>不会产生内存空间碎片</strong>，收集后能提供规整的可用内存。此特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC。</li><li><strong>可预测的停顿</strong> 这是 G1 相对 CMS 的一大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了降低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒，这几乎已经是实时 Java（RTSJ）的垃圾收集器的特征了。</li></ul><h4 id="横跨整个堆内存"><a href="#横跨整个堆内存" class="headerlink" title="横跨整个堆内存"></a>横跨整个堆内存</h4><p>在 G1 之前的其他收集器进行收集的范围都是整个新生代或者老生代，而 G1 不再是这样。G1在使用时，Java 堆的内存布局与其他收集器有很大区别，<strong>它将整个 Java 堆划分为多个大小相等的独立区域（Region）</strong>，虽然还保留新生代和老年代的概念，但<strong>新生代和老年代不再是物理隔离的了，而都是一部分 Region（不需要连续）的集合</strong>。</p><h4 id="建立可预测的时间模型"><a href="#建立可预测的时间模型" class="headerlink" title="建立可预测的时间模型"></a>建立可预测的时间模型</h4><p>G1 收集器之所以能建立可预测的停顿时间模型，是因为它可以<strong>有计划地避免在整个 Java 堆中进行全区域的垃圾收集</strong>。G1 跟踪各个 Region 里面的垃圾堆积的<strong>价值大小</strong>（回收所获得的空间大小以及回收所需时间的经验值），<strong>在后台维护一个优先列表</strong>，每次根据允许的收集时间，优先回收价值最大的 Region（这也就是 Garbage-First 名称的来由）。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限的时间内可以获取尽可能高的收集效率。</p><h4 id="避免全堆扫描-——-Remembered-Set"><a href="#避免全堆扫描-——-Remembered-Set" class="headerlink" title="避免全堆扫描 —— Remembered Set"></a>避免全堆扫描 —— Remembered Set</h4><p>G1 把 Java 堆分为多个 Region，就是『化整为零』。但是 Region 不可能是孤立的，一个对象分配在某个 Region 中，可以与整个 Java 堆任意的对象发生引用关系。在做可达性分析确定对象是否存活的时候，需要扫描整个 Java 堆才能保证准确性，这显然是对 GC 效率的极大伤害。</p><p>为了避免全堆扫描的发生，虚拟机<strong>为 G1 中每个 Region 维护了一个与之对应的 Remembered Set</strong>。虚拟机发现程序在对 Reference 类型的数据进行写操作时，会产生一个 Write Barrier 暂时中断写操作，检查 Reference 引用的对象是否处于不同的 Region 之中（在分代的例子中就是检查是否老年代中的对象引用了新生代中的对象），如果是，便通过 CardTable 把相关引用信息记录到被引用对象所属的 Region 的 Remembered Set 之中。当进行内存回收时，在 GC 根节点的枚举范围中加入 Remembered Set 即可保证不对全堆扫描也不会有遗漏。</p><p>如果不计算维护Remembered Set的操作，G1收集器的运作大致可划分为以下几个步骤：</p><ul><li><strong>初始标记（Initial Marking）</strong> 仅仅只是标记一下 GC Roots 能直接关联到的对象，并且修改 NTMS（Nest Top Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可以的 Region 中创建对象，此阶段需要停顿线程，但耗时很短。</li><li><strong>并发标记（Concurrent Marking）</strong> 从 GC Root 开始对堆中对象进行可达性分析，找到存活对象，此阶段耗时较长，但可与用户程序并发执行。</li><li><strong>最终标记（Final Marking）</strong> 为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中，这阶段需要停顿线程，但是可并行执行。</li><li><strong>筛选回收（Live Data Counting and Evacuation）</strong> 首先对各个 Region 的回收价值和成本进行排序，根据用户所期望的 GC 停顿是时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li></ul><p>通过下图可以比较清楚地看到G1收集器的运作步骤中并发和需要停顿的阶段（Safepoint处）：</p><div class="center-img"><p><img src="/img/47.jpeg"></p></div><p>用一张表看7种收集器的对比：</p><table><thead><tr><th>收集器</th><th>串行、并行or并发</th><th>新生代/老年代</th><th>算法</th><th>目标</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>Serial</strong></td><td>串行</td><td>新生代</td><td>复制算法</td><td>响应速度优先</td><td>单 CPU 环境下的 Client 模式</td></tr><tr><td><strong>Serial Old</strong></td><td>串行</td><td>老年代</td><td>标记-整理</td><td>响应速度优先</td><td>单 CPU 环境下的 Client 模式、CMS 的后备预案</td></tr><tr><td><strong>ParNew</strong></td><td>并行</td><td>新生代</td><td>复制算法</td><td>响应速度优先</td><td>多 CPU 环境时在 Server 模式下与 CMS 配合</td></tr><tr><td><strong>Parallel Scavenge</strong></td><td>并行</td><td>新生代</td><td>复制算法</td><td>吞吐量优先</td><td>在后台运算而不需要太多交互的任务</td></tr><tr><td><strong>Parallel Old</strong></td><td>并行</td><td>老年代</td><td>标记-整理</td><td>吞吐量优先</td><td>在后台运算而不需要太多交互的任务</td></tr><tr><td><strong>CMS</strong></td><td>并发</td><td>老年代</td><td>标记-清除</td><td>响应速度优先</td><td>集中在互联网站或 B/S 系统服务端上的 Java 应用</td></tr><tr><td><strong>G1</strong></td><td>并发</td><td>both</td><td>标记-整理+复制算法</td><td>响应速度优先</td><td>面向服务端应用，将来替换 CMS</td></tr></tbody></table><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>根据 GC 的工作原理，我们可以通过一些技巧和方式，让 GC 运行更加有效率，更加符合应用程序的要求。一些关于程序设计的几点建议： </p><ol><li><p>最基本的建议就是尽早释放无用对象的引用。大多数程序员在使用临时变量的时候，都是让引用变量在退出活动域（scope）后，自动设置为 <code>null</code>。我们在使用这种方式时候，必须特别注意一些复杂的对象图，例如数组，队列，树，图等，这些对象之间有相互引用关系较为复杂。对于这类对象，GC 回收它们一般效率较低。如果程序允许，尽早将不用的引用对象赋为 <code>null</code>，这样可以加速 GC 的工作。 </p></li><li><p>尽量少用<code>finalize()</code>函数。<code>finalize()</code>函数是 Java 提供给程序员一个释放对象或资源的机会。但是，它会加大 GC 的工作量，因此尽量少采用<code>finalize()</code>方式回收资源。 </p></li><li><p>如果需要使用经常使用的图片，可以使用软引用类型（Soft Reference）。它可以尽可能将图片保存在内存中，供程序调用，而不引起 OutOfMemoryError. </p></li><li><p>注意集合数据类型，包括数组，树，图，链表等数据结构，这些数据结构对 GC 来说，回收更为复杂。另外，注意一些全局的变量，以及一些静态变量。这些变量往往容易引起悬挂对象（dangling reference），造成内存浪费。 </p></li><li><p>当程序有一定的等待时间，程序员可以手动执行<code>System.gc()</code>，通知 GC 运行，但是 Java 语言规范并不保证 GC 一定会执行。使用增量式 GC 可以缩短 Java 程序的暂停时间。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
            <tag> GC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin 协程</title>
      <link href="/2020-05-13/kotlin-coroutine/"/>
      <url>/2020-05-13/kotlin-coroutine/</url>
      
        <content type="html"><![CDATA[<p>Kotlin 语言发展至今，也有9个年头了。当初发明之后一直不愠不火，直到近年 Google 宣布将支持使用 Kotlin 语言支持 Android 开发之后，Kotlin 才算是真正火起来。</p><p>在 Android 开发中，Kotlin 语言与 Java 语言可以无缝衔接，其实背后还是 Android 虚拟机的功劳，它会将 Kotlin 文件转换为 class 文件，然后加载到虚拟机中运行。在本文写作时，Kotlin 版本已经到了 <a href="https://github.com/JetBrains/kotlin/releases/tag/v1.3.72">1.3.72</a>，<a href="https://blog.jetbrains.com/kotlin/2020/03/kotlin-1-4-m1-released/">1.4.0</a> 正处于 preview 阶段。关于 Kotlin 语言的学习，我会单开一篇文章来讲，这篇文章我们来讲讲 Kotlin 中一个非常重要的特性——协程（Coroutine）。</p><span id="more"></span><h2 id="协程的概念"><a href="#协程的概念" class="headerlink" title="协程的概念"></a>协程的概念</h2><p>协程的概念由来已久，当初邓超代言广告的时候。。。喂喂喂，此协程非彼携程啊！</p><p>好，重新来。</p><p>协程的概念由来已久，它又被称为『<strong>微线程</strong>』、『<strong>纤程</strong>』。从名字上可以看出，它是一种非常轻量级的概念。它很早就被提出来了，进程下有线程，那线程下是不是也得分一分？好，就叫协程吧。虽然概念的提出很早，但也只是近几年才得到广泛应用。</p><p><img src="/img/coroutine-1589349773.png"></p><div style="text-align:center"><p><em>进程下有多个线程</em></p></div><p><img src="/img/coroutine-1589349908.png"></p><div style="text-align:center"><p><em>线程下有多个协程</em></p></div><p>我们可以给它下一个定义：<strong>协程是能够在单个线程下，还能够并发运行的一种机制</strong>。它最重要的特点是，它<strong>不会被操作系统内核所管理</strong>，而<strong>完全由用户程序来控制</strong>，也就是在<strong>用户态</strong>执行，而非内核态。这样带来的好处是<strong>可以省去传统多线程机制中线程切换时的性能损耗</strong>，大幅度提高并发性能。</p><p>在 Python 中很早就引入了协程的使用，我们可以简单看一下一个很简单的<strong>生产者-消费者的例子</strong>：</p><pre><code class="python"># 消费者def consume():    while True:        number = yield  # 在这停顿        print(&#39;Start Consuming&#39;, number)consumer = consume()# 初始化协程，并在 yield 处停止next(consumer)# 生产者for num in range(0, 100):    print(&#39;Start Producing&#39;, num)    consumer.send(num)</code></pre><p>上面的代码创建了一个协程<code>consumer</code>，然后在主线程中生产数据，并交给协程去消费。<code>yield</code>是 Python 的语法，指的是程序执行到这儿的时候，会停顿，等待主线线使用<code>send()</code>发送消息时，才会接收消息并继续执行。</p><p>上面的代码运行如下：</p><pre><code>Start Producing 0Start Consuming 0Start Producing 1Start Consuming 1Start Producing 2Start Consuming 2Start Producing 3Start Consuming 3......Start Producing 97Start Consuming 97Start Producing 98Start Consuming 98Start Producing 99Start Consuming 99</code></pre><p>各位同学们看出来了没有，实际上这是一种『障眼法』，两段代码完全是在程序的控制下交替执行，虽然我们使用线程 + 同步机制也可以做到这一点，但是在线程切换的资源消耗以及性能上，就比这种做法要差上那么『一 nai nai』。</p><blockquote><p>在 Python 3.5+ 上，使用<code>async/await</code>来替代了<code>yield/send()</code>。</p></blockquote><p>还有其他的语言也使用了协程的概念，比如 Lua、Go、C# 等等。</p><h2 id="协程与线程的比较"><a href="#协程与线程的比较" class="headerlink" title="协程与线程的比较"></a>协程与线程的比较</h2><p>上面我们提到了，协程是比线程还要低一级的并发机制，那么它们两个有什么相同点和不同之处呢？理论上来说，这两种概念不太应该用来比较，但是我们还是列举一下，也方便我们理解协程的优缺点。</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程拥有独立的栈、局部变量、可以共享进程的内存。在使用共享数据时，为了避免造成数据错误，需要控制线程的状态。但这种控制是由内核来做的，所以程序会不断地在用户态和内核态之间切换，这种切换的消耗和代价是比较大的。</p><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>协程也拥有自己的栈、局部变量，可以共享线程内的内存。在一个线程上可以同时跑多个协程，同一时间只有一个协程被执行，本质上是在单线程上模拟多线程并发。协程的运行和暂停，全部是由开发者自己决定的，不需要切换至内核态，大大减少了消耗，提高了性能。</p><p>协程默认是非阻塞式的（也可以阻塞），一个协程在<strong>进入阻塞后不会阻塞当前线程</strong>，当前线程会去执行其他协程任务。</p><h2 id="Kotlin-中的协程"><a href="#Kotlin-中的协程" class="headerlink" title="Kotlin 中的协程"></a>Kotlin 中的协程</h2><p>Kotlin 的协程的中心思想是：<strong>暂停计算</strong>。简单来说，就是一个方法在执行到某处的时候，可以暂停，然后在到达某一个时间节点时，继续运行。把这种概念应用到编程中，就是可以<strong>直接编写无阻塞的代码</strong>，能达到与阻塞代码相同的效果。官网给出了一个例子：</p><pre><code class="kotlin">fun postItem(item: Item) &#123;    launch &#123;        val token = preparePost()        val post = submitPost(token, item)        processPost(post)    &#125;&#125;suspend fun preparePost(): Token &#123;    // 执行请求，暂停协程    return suspendCoroutine &#123; /* ... */ &#125; &#125;</code></pre><p>这块代码并不会阻塞主线程，<code>preparePost()</code>被称为『<strong>可中止方法</strong>』。与上面讲过的中心思想一致：方法被执行 → 暂停执行 → 在某个时间节点继续执行。</p><p>使用 Kotlin 的协程有下面几个优点：</p><ol><li>方法本身不变，唯一的变化是加上了<code>suspend</code>关键字；</li><li>写代码时直接采用同步写法，看起来就是『由上至下』的执行方式，不用任何特殊的语法、特殊的处理。我们只需要使用<code>launch</code>关键字来启动协程并执行可中止方法即可；</li><li>Kotlin 中其他的 API 等照常使用，你可以随便使用循环、异常处理之类的，不需要再学习什么新的 API；</li><li>平台无关性。无论你的代码是运行在 JVM 上，Javascipt 平台或者是其他平台，代码是一样一样的，让编译器来帮你做这些适配的工作。</li></ol><h2 id="Android-中的-Kotlin-协程"><a href="#Android-中的-Kotlin-协程" class="headerlink" title="Android 中的 Kotlin 协程"></a>Android 中的 Kotlin 协程</h2><p>要在 Android 中使用 Kotlin 协程，要分为两步：</p><ol><li>将 Kotlin 集成到项目中。</li></ol><p>首先在项目的 build.gradle 文件中，修改成如下代码：</p><pre><code class="gradle">buildscript &#123;    ext.kotlin_version = &#39;1.3.72&#39;  // kotlin 的版本    repositories &#123;        google()        jcenter()            &#125;    dependencies &#123;        classpath &#39;com.android.tools.build:gradle:3.6.3&#39;  // 要使用 kotlin，gradle 版本必须在 3.0.0 以上        classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot;          // NOTE: Do not place your application dependencies here; they belong        // in the individual module build.gradle files    &#125;&#125;...</code></pre><p>然后在模块的 build.gradle 文件中，修改代码：</p><pre><code class="gradle">apply plugin: &#39;com.android.application&#39;apply plugin: &#39;kotlin-android&#39;apply plugin: &#39;kotlin-android-extensions&#39;android &#123;    ...    kotlinOptions &#123;        jvmTarget = &quot;1.8&quot;    &#125;&#125;dependencies &#123;    ...    implementation &quot;org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version&quot;    ...&#125;</code></pre><p>同步 gradle，Kotlin 就集成完毕了。</p><ol start="2"><li>加入协程的依赖</li></ol><p>在模块的 buidl.gradle 文件中，做出如下修改：</p><pre><code class="gradle">dependencies &#123;    ...    implementation &quot;org.jetbrains.kotlin:kotlin-stdlib:1.3.72&quot;    implementation &quot;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.6&quot;&#125;</code></pre><p>就完成了协程的集成工作。</p><p>然后我们使用协程来写一个简单的倒计时的小例子，我们设计一个 textView 和一个 button，当点击 button 时，textView 就会显示 10 秒钟的倒计时，精确到毫秒。</p><pre><code class="kotlin">button.setOnClickListener &#123;    GlobalScope.launch(Dispatchers.Main) &#123;        println(Looper.myLooper() == Looper.getMainLooper())        for (i in 1000 downTo 0) &#123;            textView.text = formatTime(i)            delay(1)        &#125;    &#125;&#125;</code></pre><p>可以看出，与上面简单介绍的 suspend、launch 关键字不同，这里又多了一些新的东西。</p><ul><li>GlobalScope</li></ul><p>GlobalScope 用来启动顶级的协程，生命周期与 Application 一致。当然，还有其他的 Scope，我们回头慢慢介绍。</p><ul><li>Dispatchers</li></ul><p>用来指定协程运行在哪个线程里。毕竟网络请求还是要在子线程中，更新 UI 还是要在主线程哇。后面会讲一个简单的网络请求的例子。</p><p>Dispatcher 有几种类型，如下表所示：</p><table><thead><tr><th>常量</th><th>作用</th></tr></thead><tbody><tr><td>Default</td><td></td></tr><tr><td>Main</td><td>让协程运行在主线程</td></tr><tr><td></td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kotlin </tag>
            
            <tag> coroutine </tag>
            
            <tag> 协程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConcurrentHashMap</title>
      <link href="/2020-05-12/concurrent-hashmap/"/>
      <url>/2020-05-12/concurrent-hashmap/</url>
      
        <content type="html"><![CDATA[<p><img src="/img/covers/cover-java-2020-05-12.png" alt="cover"><br>ConcurrentHashMap 底层是基于<strong>数组 + 链表</strong>组成的，不过在 jdk1.7 和 1.8 中具体实现稍有不同。</p><span id="more"></span><h2 id="JDK-1-7"><a href="#JDK-1-7" class="headerlink" title="JDK 1.7"></a>JDK 1.7</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>在 JDK1.7 中是这样的：</p><p><img src="/img/concurrent-hashmap-1589261515.png"></p><p>如图所示，是由 Segment 数组、HashEntry 组成，和 HashMap 一样，仍然是<strong>数组加链表</strong>。</p><p>Segment 是 ConcurrentHashMap 的一个内部类，主要的组成如下：</p><pre><code class="java">static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable &#123;        private static final long serialVersionUID = 2249069246763182397L;        // 和 HashMap 中的 HashEntry 作用一样，真正存放数据的地方       transient volatile HashEntry&lt;K,V&gt;[] table;        transient int count;    // 用于 fail-fast，快速失败    transient int modCount;    // 大小    transient int threshold;    // 负载因子    final float loadFactor;&#125;</code></pre><p>HashEntry 跟 HashMap 中的 Entry 基本相同，但是不同点是，他**使用<code>volatile</code>去修饰了他的数据<code>value</code>还有下一个节点<code>next</code>**。</p><blockquote><p><strong><code>volatile</code>的功能</strong></p><p>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。（实现可见性）</p><p>禁止进行指令重排序。（实现有序性）</p><p>注意：<code>volatile</code>只能保证对<strong>单次读/写的原子性</strong>。i++ 这种操作不能保证原子性。</p></blockquote><p>原理上来说，ConcurrentHashMap 采用了分段锁技术，其中<strong>Segment 继承于 ReentrantLock</strong>。</p><p>它不会像 HashTable 那样不管是<code>put()</code>还是<code>get()</code>操作都需要做同步处理，理论上 ConcurrentHashMap 支持 CurrencyLevel (值为 Segment 数组数量）的线程并发。</p><p>每当一个线程占用锁访问一个 Segment 时，不会影响到其他的 Segment。</p><p>就是说如果 Segment 当前大小是16他的并发度就是16，可以同时允许16个线程操作16个 Segment 而且还是线程安全的。</p><h3 id="put"><a href="#put" class="headerlink" title="put()"></a><code>put()</code></h3><p>我们看一下 ConcurrentHashMap 的<code>put()</code>方法：</p><pre><code class="java">// jdk1.7 ConcurrentHashMap.javapublic V put(K key, V value) &#123;    Segment&lt;K,V&gt; s;    if (value == null)        throw new NullPointerException(); //这就是为啥他不可以put null值的原因    int hash = hash(key);    int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;    // if 中拿到的 s 不是 volatile 的，将会在 ensureSegment 中重新进行检查    if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject(segments, (j &lt;&lt; SSHIFT) + SBASE)) == null)        s = ensureSegment(j);    return s.put(key, hash, value, false);&#125;</code></pre><p>他先定位到当前 key 属于哪个 Segment，然后再对该 Segment 进行<code>put()</code>操作。</p><p>然后我们看看 Segment 的<code>put()</code>源代码，你就知道他是怎么做到线程安全的了，关键句子我注释了。</p><pre><code class="java">final V put(K key, int hash, V value, boolean onlyIfAbsent) &#123;    // 将当前 Segment 中的 table 通过 key 的 hashcode 定位到 HashEntry    // 因为 Segment 继承自 ReentrantLock，所以此处直接调用了父类的 tryLock() 方法，持有当前锁    HashEntry&lt;K,V&gt; node = tryLock() ? null : scanAndLockForPut(key, hash, value);    V oldValue;    try &#123;        HashEntry&lt;K,V&gt;[] tab = table;        // 计算 index        int index = (tab.length - 1) &amp; hash;        HashEntry&lt;K,V&gt; first = entryAt(tab, index);        for (HashEntry&lt;K,V&gt; e = first;;) &#123;            // 如果拿到的当前 index 的值不为空，表示该 index 上有数据，需要进行覆盖            if (e != null) &#123;                K k;                // 遍历该 HashEntry，                // 如果不为空则判断传入的 key 和当前遍历的 key 是否相等，相等则覆盖旧的 value。                if ((k = e.key) == key ||                    (e.hash == hash &amp;&amp; key.equals(k))) &#123;                    oldValue = e.value;                    if (!onlyIfAbsent) &#123;                        e.value = value;                        ++modCount;                    &#125;                    break;                &#125;                e = e.next;            &#125;            else &#123;                // 不为空则需要新建一个 HashEntry 并加入到 Segment 中，同时会先判断是否需要扩容                if (node != null)                    node.setNext(first);                else                    node = new HashEntry&lt;K,V&gt;(hash, key, value, first);                int c = count + 1;                // 判断是否需要扩容                if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)                    rehash(node);                else                    setEntryAt(tab, index, node);                ++modCount;                count = c;                oldValue = null;                break;            &#125;        &#125;    &#125; finally &#123;        //释放锁        unlock();    &#125;    return oldValue;&#125;private HashEntry&lt;K,V&gt; scanAndLockForPut(K key, int hash, V value) &#123;    HashEntry&lt;K,V&gt; first = entryForHash(this, hash);    HashEntry&lt;K,V&gt; e = first;    HashEntry&lt;K,V&gt; node = null;    int retries = -1;    while (!tryLock()) &#123;  // 自旋获取锁        HashEntry&lt;K,V&gt; f;        if (retries &lt; 0) &#123;            if (e == null) &#123;                if (node == null) // 尝试创建新的 HashEntry                    node = new HashEntry&lt;K,V&gt;(hash, key, value, null);                retries = 0;            &#125;            else if (key.equals(e.key))                retries = 0;            else                e = e.next;        &#125;        else if (++retries &gt; MAX_SCAN_RETRIES) &#123;             // 直接使用阻塞锁的方式，暴力而有效            lock();            break;        &#125;        else if ((retries &amp; 1) == 0 &amp;&amp;                    (f = entryForHash(this, hash)) != first) &#123;            e = first = f; // re-traverse if entry changed            retries = -1;        &#125;    &#125;    return node;&#125;</code></pre><p>首先第一步的时候会尝试<strong>获取锁</strong>，如果获取失败肯定就有其他线程存在竞争，则利用<code>scanAndLockForPut()</code><strong>自旋获取锁</strong>。如果重试的次数达到了<code>MAX_SCAN_RETRIES</code>（CPU数量大于1时，值为64，否则为1）则改为阻塞锁获取，保证能获取成功。</p><blockquote><p>自旋就是执行一段无意义的循环。</p></blockquote><h3 id="get"><a href="#get" class="headerlink" title="get()"></a><code>get()</code></h3><p><code>get()</code>逻辑比较简单，定位 Segment → 定位 HashEntry → 定位链表节点：</p><pre><code class="java">    public V get(Object key) &#123;        Segment&lt;K,V&gt; s; // manually integrate access methods to reduce overhead        HashEntry&lt;K,V&gt;[] tab;        int h = hash(key.hashCode());        long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;        // 定位 Segment        if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;&amp;            (tab = s.table) != null) &#123;            // 定位 HashEntry            for (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile                     (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE);                 e != null; e = e.next) &#123;                K k;                // 定位链表上的节点                if ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))                    return e.value;            &#125;        &#125;        return null;    &#125;</code></pre><p>由于 HashEntry 中的<code>value</code>属性是用<code>volatile</code>关键词修饰的，保证了内存可见性，所以每次获取时都是最新值。所以 ConcurrentHashMap 的<code>get()</code>方法是非常高效的，因为整个过程都不需要加锁。</p><p>但是，虽然 JDK1.7 中可以支持每个 Segment 并发访问，但是还是存在一些问题：<strong>我们去查询的时候，还得遍历链表</strong>，会导致效率很低，这个跟 JDK1.7 的 HashMap 是存在的一样问题，所以他在 JDK1.8 完全优化了。</p><h3 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h3><p>然后讲讲在 JDK1.7 中的扩容机制。</p><p>我们向上翻一下，在<code>put()</code>方法中，当判断需要扩容时，调用的是<code>rehash()</code>方法，我们来看看它是如何做的：</p><pre><code class="java">private void rehash(HashEntry&lt;K,V&gt; node) &#123;    HashEntry&lt;K,V&gt;[] oldTable = table;    int oldCapacity = oldTable.length;    int newCapacity = oldCapacity &lt;&lt; 1; // 与 HashMap 相同，采用2次幂扩容    threshold = (int)(newCapacity * loadFactor);    HashEntry&lt;K,V&gt;[] newTable = (HashEntry&lt;K,V&gt;[]) new HashEntry[newCapacity];    int sizeMask = newCapacity - 1;    for (int i = 0; i &lt; oldCapacity ; i++) &#123;        HashEntry&lt;K,V&gt; e = oldTable[i];        if (e != null) &#123;            HashEntry&lt;K,V&gt; next = e.next;            int idx = e.hash &amp; sizeMask;            if (next == null)   // 链表中只有一个节点                newTable[idx] = e;            else &#123; // 将原来的顺序原封不动地移到新的 table 中                HashEntry&lt;K,V&gt; lastRun = e;                int lastIdx = idx;                for (HashEntry&lt;K,V&gt; last = next; last != null; last = last.next) &#123;                    int k = last.hash &amp; sizeMask;                    if (k != lastIdx) &#123;                        lastIdx = k;                        lastRun = last;                    &#125;                &#125;                newTable[lastIdx] = lastRun;                               for (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;                    V v = p.value;                    int h = p.hash;                    int k = h &amp; sizeMask;                    HashEntry&lt;K,V&gt; n = newTable[k];                    newTable[k] = new HashEntry&lt;K,V&gt;(h, p.key, v, n);                &#125;            &#125;        &#125;    &#125;    int nodeIndex = node.hash &amp; sizeMask; // 将新的节点加入    node.setNext(newTable[nodeIndex]);    newTable[nodeIndex] = node;    table = newTable;&#125;</code></pre><p>可以看出，与 HashMap 扩容机制类似，采取了<strong>2次幂的方式</strong>来决定新数组的大小。但是，Segment 没有扩容机制，在初始化时，就指定好了 Segment 数组的大小，也既该 ConcurrentHashMap 的并发数。</p><h3 id="size"><a href="#size" class="headerlink" title="size()"></a><code>size()</code></h3><p>既然要考虑线程安全，在获取 ConcurrentHashMap 的大小时，也要特殊处理一下。这里采用的是<strong>多次对比机制</strong>，我们来看看它的代码：</p><pre><code class="java">public int size() &#123;    final Segment&lt;K,V&gt;[] segments = this.segments;    int size;    boolean overflow; // true if size overflows 32 bits    long sum;         // sum of modCounts    long last = 0L;   // previous sum    int retries = -1; // first iteration isn&#39;t retry    try &#123;        for (;;) &#123;            if (retries++ == RETRIES_BEFORE_LOCK) &#123;  // 重试次数达到2                for (int j = 0; j &lt; segments.length; ++j)                    ensureSegment(j).lock(); // 强制让所有 Segment 获得阻塞锁            &#125;            sum = 0L;            size = 0;            overflow = false;            for (int j = 0; j &lt; segments.length; ++j) &#123;                Segment&lt;K,V&gt; seg = segmentAt(segments, j);                if (seg != null) &#123;                    sum += seg.modCount;                    int c = seg.count;                    if (c &lt; 0 || (size += c) &lt; 0)                        overflow = true;                &#125;            &#125;            // 如果此次获取的大小与上次一致，则认为这就是当前大小            if (sum == last)                break;            last = sum;        &#125;    &#125; finally &#123;        if (retries &gt; RETRIES_BEFORE_LOCK) &#123;            for (int j = 0; j &lt; segments.length; ++j)                segmentAt(segments, j).unlock();  // 比对完成后让所有 Segment 解锁        &#125;    &#125;    return overflow ? Integer.MAX_VALUE : size;&#125;</code></pre><p>可以看到，至少要进行两次遍历，如果<strong>相邻的两次遍历计算出的 key-value 的数量是相等</strong>的，那就认为这个数量是当前的正确数量。如果一直对比不上，这说明数据在不断地更改，此时要让<strong>所有 Segment 获取阻塞锁</strong>，然后再进行对比，对比成功后，解锁，返回数量。</p><h2 id="JDK-1-8"><a href="#JDK-1-8" class="headerlink" title="JDK 1.8"></a>JDK 1.8</h2><h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><p>在 JDK1.8 中，ConcurrentHashMap 抛弃了原有的 Segment 分段锁，而采用了 CAS + synchronized 来保证并发安全性。</p><p>虽然它的源码中还是会包含 Segment 类，但是也只用在 Serializable 的<strong>序列化和反序列化</strong>中，而且多亏了 Serializable 的<code>serialVersionUID</code>特性，只要版本号保持一致，Segment 可以在 JDK1.7 和 JDK1.8 甚至 JDKX.X 之间自由转换，JVM 会认为是同一个类。</p><p>跟 HashMap 的1.7 → 1.8很像，ConcurrentHashMap 也把之前 JDK1.7 中的 HashEntry 改成了 Node，但是作用不变，把<code>value</code>和<code>next</code>采用了<code>volatile</code>去修饰，保证了可见性，并且也引入了<strong>红黑树</strong>，在链表大于一定值的时候会转换（默认是8）。</p><p>它的数据结构如下图所示：</p><p><img src="/img/concurrent-hashmap-1589262515.png"></p><p>对于每一个链表，ConcurrentHashMap 将其称之 <strong>『桶』（bin）</strong>。</p><h3 id="put-1"><a href="#put-1" class="headerlink" title="put()"></a><code>put()</code></h3><p>先看一下它的 put 方法：</p><pre><code class="java">public V put(K key, V value) &#123;    return putVal(key, value, false);&#125;final V putVal(K key, V value, boolean onlyIfAbsent) &#123;    if (key == null || value == null) throw new NullPointerException();    // 计算 hashCode    int hash = spread(key.hashCode());    int binCount = 0;    for (Node&lt;K,V&gt;[] tab = table;;) &#123;  // 死循环确保可以插入数据        Node&lt;K,V&gt; f;         int n, i, fh;        // 如果 Node 数组为 null，则需要初始化，只有在第一次进行 put 时才会进行这个操作        if (tab == null || (n = tab.length) == 0)            tab = initTable();        else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123; // 利用 (n - 1) &amp; hash 计算 index，得出要插入的 Node 数组的 index            // 如果节点为空，则利用 CAS 机制写入数据            if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null))) // 向空桶中插入数据                break;  // 向空的桶中添加数据时，不需要加锁        &#125;        // 要扩容了        else if ((fh = f.hash) == MOVED)            tab = helpTransfer(tab, f);        else &#123;            // 尝试使用 synchronized 写入数据            V oldVal = null;            synchronized (f) &#123;                if (tabAt(tab, i) == f) &#123;                    if (fh &gt;= 0) &#123;                        binCount = 1;                        for (Node&lt;K,V&gt; e = f;; ++binCount) &#123;                            K ek;                            if (e.hash == hash &amp;&amp;                                ((ek = e.key) == key ||                                    (ek != null &amp;&amp; key.equals(ek)))) &#123;                                oldVal = e.val;                                if (!onlyIfAbsent)                                    e.val = value;                                break;                            &#125;                            Node&lt;K,V&gt; pred = e;                            if ((e = e.next) == null) &#123;                                pred.next = new Node&lt;K,V&gt;(hash, key,                                                            value, null);                                break;                            &#125;                        &#125;                    &#125;                    // 已经被转换为红黑树节点了，需要用 putTreeVal 来进行插入                    else if (f instanceof TreeBin) &#123;                        Node&lt;K,V&gt; p;                        binCount = 2;                        if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,                                                        value)) != null) &#123;                            oldVal = p.val;                            if (!onlyIfAbsent)                                p.val = value;                        &#125;                    &#125;                    else if (f instanceof ReservationNode)                        throw new IllegalStateException(&quot;Recursive update&quot;);                &#125;            &#125;            if (binCount != 0) &#123;                // 桶中节点的数量大于 TREEIFY_THRESHOLD，值为8，转换红黑树                if (binCount &gt;= TREEIFY_THRESHOLD)                    treeifyBin(tab, i);                if (oldVal != null)                    return oldVal;                break;            &#125;        &#125;    &#125;    addCount(1L, binCount);    return null;&#125;</code></pre><p>ConcurrentHashMap 在进行<code>put()</code>操作的还是比较复杂的，大致可以分为以下步骤：</p><ol><li>如果是第一次插入数据，则需要调用<code>initTable()</code>初始化 Node 数组；</li><li>利用<code>(n - 1) &amp; hash</code>得出要插入的数组 index；</li><li>如果数组的 index 位置为 null，则直接利用 CAS 机制插入，不需要加锁；</li><li>如果数组的 index 位置不为 null，则要使用 synchronized 方式插入到桶（链表）中；</li><li>如果插入完成后，桶的节点数量大于等于8了，就要转换为红黑树（红黑桶🛢）；</li><li>如果节点的 hash 值为 -1，则需要扩容。</li></ol><blockquote><p><strong>CAS（Compare And Swap）</strong></p><p>CAS 是乐观锁的一种实现方式，是一种轻量级锁，JUC 中很多工具类的实现就是基于 CAS 的。<br>CAS 的中心思想是线程<strong>在读取数据时不进行加锁</strong>，在准备写回数据时，<strong>比较原值是否修改</strong>，若未被其他线程修改则写回，若已被修改，则&gt; 重新执行读取流程。<br>这是一种<strong>乐观策略</strong>，认为并发操作并不总会发生。</p><p>但是经典的 ABA 问题，它就无法判断了。就是数据从 A 变为 B 又变成 A，看似没修改过，但实际上是修改过的。<br>想要解决 ABA 问题，要么使用版本号，要么使用时间戳标识，都可以。</p></blockquote><h3 id="get-1"><a href="#get-1" class="headerlink" title="get()"></a><code>get()</code></h3><p>再来看它的<code>get()</code>：</p><pre><code class="java">public V get(Object key) &#123;    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;    int h = spread(key.hashCode());    // 根据计算出来的 hashcode 寻址，如果就在链表上那么直接返回值。    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;        (e = tabAt(tab, (n - 1) &amp; h)) != null) &#123;        // 如果是红黑树那就按照树的方式获取值。        if ((eh = e.hash) == h) &#123;            if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))                return e.val;        &#125;        // 都不满足那就按照链表的方式遍历获取值。        else if (eh &lt; 0)            return (p = e.find(h, key)) != null ? p.val : null;        while ((e = e.next) != null) &#123;            if (e.hash == h &amp;&amp;                ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))))                return e.val;        &#125;    &#125;    return null;&#125;</code></pre><p>比较简单，也不需要加锁，因为节点的值都是 volatile 的。</p><h3 id="扩容机制-1"><a href="#扩容机制-1" class="headerlink" title="扩容机制"></a>扩容机制</h3><p>我们直接来看它的代码：</p><pre><code class="java">private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#123;    int n = tab.length, stride;    if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)        stride = MIN_TRANSFER_STRIDE; // subdivide range    if (nextTab == null) &#123;            // initiating        try &#123;            @SuppressWarnings(&quot;unchecked&quot;)            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];            nextTab = nt;        &#125; catch (Throwable ex) &#123;      // try to cope with OOME            sizeCtl = Integer.MAX_VALUE;            return;        &#125;        nextTable = nextTab;        transferIndex = n;    &#125;    int nextn = nextTab.length;    ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab);    boolean advance = true;    boolean finishing = false; // to ensure sweep before committing nextTab    for (int i = 0, bound = 0;;) &#123;        Node&lt;K,V&gt; f; int fh;        while (advance) &#123;            int nextIndex, nextBound;            if (--i &gt;= bound || finishing)                advance = false;            else if ((nextIndex = transferIndex) &lt;= 0) &#123;                i = -1;                advance = false;            &#125;            else if (U.compareAndSwapInt                        (this, TRANSFERINDEX, nextIndex,                        nextBound = (nextIndex &gt; stride ?                                    nextIndex - stride : 0))) &#123;                bound = nextBound;                i = nextIndex - 1;                advance = false;            &#125;        &#125;        if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) &#123;            int sc;            if (finishing) &#123;                nextTable = null;                table = nextTab;                sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1);                return;            &#125;            if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) &#123;                if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)                    return;                finishing = advance = true;                i = n; // recheck before commit            &#125;        &#125;        else if ((f = tabAt(tab, i)) == null)            advance = casTabAt(tab, i, null, fwd);        else if ((fh = f.hash) == MOVED)            advance = true; // already processed        else &#123;            synchronized (f) &#123;                if (tabAt(tab, i) == f) &#123;                    Node&lt;K,V&gt; ln, hn;                    if (fh &gt;= 0) &#123;                        int runBit = fh &amp; n;                        Node&lt;K,V&gt; lastRun = f;                        for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) &#123;                            int b = p.hash &amp; n;                            if (b != runBit) &#123;                                runBit = b;                                lastRun = p;                            &#125;                        &#125;                        if (runBit == 0) &#123;                            ln = lastRun;                            hn = null;                        &#125;                        else &#123;                            hn = lastRun;                            ln = null;                        &#125;                        for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;                            int ph = p.hash; K pk = p.key; V pv = p.val;                            if ((ph &amp; n) == 0)                                ln = new Node&lt;K,V&gt;(ph, pk, pv, ln);                            else                                hn = new Node&lt;K,V&gt;(ph, pk, pv, hn);                        &#125;                        setTabAt(nextTab, i, ln);                        setTabAt(nextTab, i + n, hn);                        setTabAt(tab, i, fwd);                        advance = true;                    &#125;                    else if (f instanceof TreeBin) &#123;                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;                        TreeNode&lt;K,V&gt; lo = null, loTail = null;                        TreeNode&lt;K,V&gt; hi = null, hiTail = null;                        int lc = 0, hc = 0;                        for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) &#123;                            int h = e.hash;                            TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;                                (h, e.key, e.val, null, null);                            if ((h &amp; n) == 0) &#123;                                if ((p.prev = loTail) == null)                                    lo = p;                                else                                    loTail.next = p;                                loTail = p;                                ++lc;                            &#125;                            else &#123;                                if ((p.prev = hiTail) == null)                                    hi = p;                                else                                    hiTail.next = p;                                hiTail = p;                                ++hc;                            &#125;                        &#125;                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :                            (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t;                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :                            (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t;                        setTabAt(nextTab, i, ln);                        setTabAt(nextTab, i + n, hn);                        setTabAt(tab, i, fwd);                        advance = true;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><p>ConcurrentHashMap 的 JDK1.8 与 JDK1.7 版本的并发实现相比，最大的区别在于 JDK1.8 的<strong>锁的粒度更细</strong>。</p><p>理想情况下 table 数组元素的大小就是其支持并发的最大个数，在 JDK1.7 里面最大并发个数就是 Segment 的个数，默认值是16，可以通过构造函数改变一经创建不可更改，这个值就是并发的粒度，每一个 Segment 下面管理一个 table 数组，加锁的时候其实锁住的是整个 Segment，这样设计的好处在于数组的扩容是不会影响其他的 Segment，简化了并发设计，不足之处在于并发的粒度稍粗，所以在 JDK1.8 里面，去掉了分段锁，将锁的级别控制在了更细粒度的 table 元素级别，也就是说只需要<strong>锁住这个链表的 head 节点，并不会影响其他的 table 元素的读写</strong>，好处在于<strong>并发的粒度更细，影响更小</strong>，从而并发效率更好，但不足之处在于并发扩容的时候，由于操作的 table 都是同一个，不像 JDK1.7 中分段控制，所以这里<strong>需要等扩容完之后，所有的读写操作才能进行</strong>，所以扩容的效率就成为了整个并发的一个瓶颈点。好在 Doug lea 大神对扩容做了优化，本来在一个线程扩容的时候，如果影响了其他线程的数据，那么其他的线程的读写操作都<strong>应该阻塞</strong>，但是他们闲着也是闲着，不如来一起参与扩容任务，这样人多力量大，办完事你们该干啥干啥，别浪费时间，于是在 JDK1.8 的源码里面就引入了一个 ForwardingNode 类，在一个线程发起扩容的时候，就会改变 <code>sizeCtl</code> 这个值，其含义如下：</p><blockquote><p><strong>sizeCtl</strong> ：默认为0，用来控制table的初始化和扩容操作，具体应用在后续会体现出来。<br>值为 -1 时代表 table 正在初始化<br>值为 -(1 + n) 时，表示正在有 n 个线程正在扩容<br>如果 table 未初始化，值表示 table 需要初始化的大小<br>如果 table 初始化完成，表示 table 的容量，值是 <code>table 的大小 x 负载因子</code></p></blockquote><p>扩容时候会判断这个值，如果超过阈值就要扩容，首先根据运算得到需要遍历的次数i，然后利用<code>tabAt()</code>方法获得<code>i</code>位置的元素<code>f</code>，初始化一个ForwardingNode 实例<code>fwd</code>，如果<code>f == null</code>，则在table中的<code>i</code>位置放入<code>fwd</code>，否则采用头插法的方式把当前旧 table 数组的指定任务范围的数据给迁移到新的数组中，然后 给旧 table 原位置赋值<code>fwd</code>。直到遍历过所有的节点以后就完成了复制工作，把 table 指向 nextTable，并更新<code>sizeCtl</code>为新数组大小的0.75倍 ，扩容完成。在此期间如果其他线程的有读写操作都会判断<code>head</code>节点是否为 ForwardingNode 节点 ，如果是就帮助扩容。</p><p>我们来看看 ForwadingNode 的代码：</p><pre><code class="java">static final int MOVED     = -1; // hash for forwarding nodes/** * A node inserted at head of bins during transfer operations. */static final class ForwardingNode&lt;K,V&gt; extends Node&lt;K,V&gt; &#123;    final Node&lt;K,V&gt;[] nextTable;    ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;        super(MOVED, null, null, null);        this.nextTable = tab;    &#125;    Node&lt;K,V&gt; find(int h, Object k) &#123;        // 使用循环，避免多次碰到 ForwardingNode 导致递归过深        outer: for (Node&lt;K,V&gt;[] tab = nextTable;;) &#123;            Node&lt;K,V&gt; e; int n;            if (k == null || tab == null || (n = tab.length) == 0 ||                (e = tabAt(tab, (n - 1) &amp; h)) == null)                return null;            for (;;) &#123;                int eh; K ek;                if ((eh = e.hash) == h &amp;&amp;                    ((ek = e.key) == k || (ek != null &amp;&amp; k.equals(ek))))  // 第一个节点就是要找的节点，直接返回                    return e;                if (eh &lt; 0) &#123;                    if (e instanceof ForwardingNode) &#123;                        tab = ((ForwardingNode&lt;K,V&gt;)e).nextTable;                        continue outer;                    &#125;                    else                        return e.find(h, k);  // 特殊节点，调用其find方法进行查找                &#125;                if ((e = e.next) == null)  // 普通节点直接循环遍历链表                    return null;            &#125;        &#125;    &#125;&#125;</code></pre><p>ForwardingNode 是一种临时节点，在<strong>扩容进行中</strong>才会出现，hash 值固定为 -1，并且它不存储实际的数据数据。如果旧数组的一个 hash 桶中全部的节点都迁移到新数组中，旧数组就在这个 hash 桶中放置一个 ForwardingNode。读操作或者迭代读时碰到 ForwardingNode 时，将操作转发到扩容后的新的 table 数组上去执行，写操作碰见它时，则尝试帮助扩容。</p><h3 id="size-1"><a href="#size-1" class="headerlink" title="size()"></a><code>size()</code></h3><p>与 jdk1.7 中的计数方式不同，jdk1.8 中的 ConcurrentHashMap 引入了一个 CounterCell 类，用于记录每一个桶中的节点数量，在<code>put()</code>值时，最后调用的<code>addCount()</code>中，就会对这个值做出修改，所以在<code>size()</code>时，直接使用循环方式累加所有的 CounterCell 的值即可得出当前的 key-value 的数量。</p><pre><code class="java">public int size() &#123;    long n = sumCount();    return ((n &lt; 0L) ? 0 :            (n &gt; (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE :            (int)n);&#125;static final class CounterCell &#123;    volatile long value;    CounterCell(long x) &#123; value = x; &#125;&#125;final long sumCount() &#123;    CounterCell[] as = counterCells; CounterCell a;    long sum = baseCount;    if (as != null) &#123;        for (int i = 0; i &lt; as.length; ++i) &#123;            if ((a = as[i]) != null)                sum += a.value;        &#125;    &#125;    return sum;&#125;</code></pre><blockquote><p>红黑树（Red Black Tree） 是一种自平衡二叉查找树。它是一种特化的平衡二叉树，都是在进行插入和删除操作时通过特定操作保持二叉查找&gt; 树的平衡，从而获得较高的查找性能。它的查找时间复杂度是O(log n)。</p><p>红黑树是每个节点都带有颜色属性的二叉查找树，颜色或红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的&gt; 额外要求:</p><ol><li>节点是红色或黑色</li><li>根节点是黑色 </li><li>所有叶子都是黑色。（叶子是NUIL节点）</li><li>每个红色节点的两个子节点都是黑色。（从每个叶子到根的所有路径上不能有两个连续的红色节点）</li><li>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点</li></ol></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于 Service</title>
      <link href="/2020-05-10/service/"/>
      <url>/2020-05-10/service/</url>
      
        <content type="html"><![CDATA[<p>在 Android 系统中，四大组件中，Service 的重要性也是不言而喻的，它可以长时间在后台生存，执行一些复杂的或者耗时的工作。即便用户切换到了其他应用，Service 仍将在后台继续运行。此外，组件可通过绑定到 Service 与之进行交互，甚至是执行进程间通信 (IPC)。</p><span id="more"></span><h2 id="Service-的分类"><a href="#Service-的分类" class="headerlink" title="Service 的分类"></a>Service 的分类</h2><p>我们一般将 Service 分为三大类：后台 Service 、绑定 Service 和前台 Service 。其中，后台 Service 和绑定 Service 是『不可见 Service』，前台 Service 是『可见 Service』。</p><h3 id="后台-Service"><a href="#后台-Service" class="headerlink" title="后台 Service"></a>后台 Service</h3><p>后台 Service （Background Service）一般是用来执行一些用户不会直接注意到的操作，比如解压数据包，比如进行网络请求。</p><p>需要注意的是，API 26（Android 8.0）之后，如果应用本身没有在前台运行，系统会对后台<strong>可执行的操作增加一些限制</strong>。这些限制有两个方面：</p><ol><li><p><strong>后台 Service 限制</strong>。这些限制不适用于前台 Service，因为前台 Service 更容易引起用户注意。</p><p>在后台运行的 Service 会消耗资源，这有可能会造成不良的用户体验，所以 Android 对应用状态进行了区分：<strong>前台应用</strong>和<strong>后台应用</strong>。满足下面任意条件，即可视为前台应用：</p><ul><li>具有可见的 Activity</li><li>具有前台 Service</li><li>另一个前台应用已关联到该应用，比如说输入法在应用中弹出，应用正在与屏幕识别和读取功能交互等等。</li></ul><p>如果上面的条件<strong>都不满足</strong>，应用就会被视为<strong>后台应用</strong>。</p><p>当应用处于前台时，可以随意创建和运行前台、后台 Service。当进入后台时，会有几分钟的时间，应用仍然可以创建和使用 Service，这个时间一过，应用就会被视为处于<strong>空闲</strong>状态，这时，系统将<strong>停止应用的后台 Service</strong>。</p><p>但是，大多数情况下，可以使用 JobScheduler 来完成 Service 能完成的操作。对于 JobScheduler 的解析，在<br><a href="/jobscheduler-and-workmanager/" target="_blank">这篇文章里</a>。</p></li><li><p><strong>广播限制</strong>。除了一些特殊的例外情况，应用<strong>无法使用 AndroidManifest 注册隐式广播</strong>。但是仍然可以在运行时注册广播，并且可以使用 AndroidManifest 注册<strong>专门针对它们的显式广播</strong>。具体的限制如下：</p><ul><li>应用<strong>不能在 AndroidManifest 中为隐式广播注册广播接收器</strong>。例如<code>ACTION_PACKAGE_REPLACED</code>广播。显式广播不受影响。</li><li>应用可以使用<code>Context.registerReceiver()</code>为任意广播（不管是显式还是隐式）注册接收器。</li><li>需要<strong>签名权限的广播不受此限制所限</strong>，因为这些广播只会发送到使用相同证书签名的应用，而不是发送到设备上的所有应用。</li></ul><p>同样地，之前使用隐式广播的应用也可以使用 <strong>JobScheduler + 动态注册广播接收器</strong>来实现类似的功能。</p></li></ol><h3 id="绑定-Service"><a href="#绑定-Service" class="headerlink" title="绑定 Service"></a>绑定 Service</h3><p>当系统组件与 Service 进行绑定时， Service 就处于『<strong>绑定状态</strong>』。绑定 Service 会以 C/S 模式提供接口，以便组件与 Service 进行交互、发送请求、接收结果，甚至是跨进程通信（IPC）来执行这些操作。绑定 Service 只会<strong>在与某个系统组件绑定时才会运行</strong>。多个组件可同时绑定到该 Service ，全部取消绑定后，该 Service 才会被销毁。</p><p>但是，绑定 Service 并不是说不能以正常的方式来运行，一个 Service ，它既可以是启动 Service （以无限期运行），也同时支持绑定，看你要覆写哪种方法了：<code>onStartCommand()</code>是让组件来启动 Service 后会回调的方法，而<code>onBind()</code>是以绑定方式启动 Service 后回调的方法。但无论是哪种 Service ，都可以使用 Intent 来启动它。</p><h3 id="前台-Service"><a href="#前台-Service" class="headerlink" title="前台 Service"></a>前台 Service</h3><p>前台 Service （Foreground Service）可以被用户看到。通常前台 Service <strong>必须在通知栏显示一个通知</strong>，比如各种音乐 APP：</p><p><img src="/img/service-1588775376.jpeg"></p><p>即使用户停止与 App 的交互， Service 也依然会继续运行。</p><h2 id="为什么要使用-Service"><a href="#为什么要使用-Service" class="headerlink" title="为什么要使用 Service"></a>为什么要使用 Service</h2><p>如上所述，使用 Service 有诸多限制，而且还分什么前台后台绑定，<strong>用子线程它不香吗？</strong></p><p>这里要看使用场景。</p><p>Service 是一种即便用户不与它交互，也能一直运行在后台的组件，它默认是运行在主线程上的。因此，Service 适合<strong>执行短期的、不阻塞的、不与用户交互的任务</strong>。如果你必须要在主线程之外执行一些操作，比如密集性的网络通信、比如进行大量数据的初始化和解析，那你最好还是选择在 Service 中新建一个线程来做这件事。</p><h2 id="Service-的食用指南"><a href="#Service-的食用指南" class="headerlink" title="Service 的食用指南"></a>Service 的食用指南</h2><h3 id="覆写方法"><a href="#覆写方法" class="headerlink" title="覆写方法"></a>覆写方法</h3><p>使用 Service 的时候，我们必须要自定义一个继承 Service 的类，并覆写下面几种重要的方法：</p><ul><li><p><code>onStartCommand(Intent intent, int flags, int startId)</code>：</p><p>当另一个组件（如 Activity）请求启动 Service 时，一般会通过调用<code>startService()</code>来启动，此时，系统会执行<code>onStartCommand()</code>方法（具体如何调用的，查看<a href="#%E6%99%AE%E9%80%9A%20-Service-%20%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B">这一章节</a>），如果此时有 Intent 传入，则可以进行一些初始化的工作。通常情况下，这个方法被调用的时候， Service 已经启动了。如果是要覆写该方法的话，那你得使用<code>stopSelf()</code>或 <code>stopService()</code>来停止 Service 。如果只想提供一个绑定 Service ，则无需覆写此方法。</p><blockquote><p>你可能会注意到，在覆写时，还有个<code>onStart()</code>方法，如果查看源码的话，在<code>onStartCommand()</code>中直接调用了<code>onStart()</code>。该方法在 Android 4.0.3之后就被废弃了，现在都采用直接覆写<code>onStartCommand()</code>方法了。</p></blockquote></li></ul><p>  它的第一个参数是一个 Intent，是启动 Service 时组件传递过来的 Intent，可以用于初始化。<strong>这个 Intent 有可能为 null</strong>，哪怕你明明传递了非 null 的 Intent。具体原因在下面会讲到。</p><p>  它的第二个参数是一个 int 值，是启动 Service 时系统给的额外参数，一般情况下是0，也有可能是<code>START_FLAT_REDELIVERY</code>（Intent 之前传递过）和<code>START_FLAG_RETRY</code>（之前的 Intent 没有正确传递过来，重试传递）的<strong>或值</strong>。</p><p>  它的第三个参数也是一个 int 值，叫<code>startId</code>，它用来唯一标识一次启动请求，会在<code>stopSelfResult(int)</code>这个方法中用到这个值，用以终止当前 Service。它和<code>stopService()</code>是有区别的，<code>stopService()</code>方法一旦被调用，就直接一刀砍死 Service，毫不留情；但<code>stopSelfResult()</code>会检查<code>startId</code>，如果在调用<code>stopSelfResult()</code>的时候又来了个启动的请求，此时<code>startId</code>发生了变化，它就会大喊一声『刀下留人~~~~』，Service 就不会死掉了。</p><p>  它的返回值也是一个 int 值，有下面几种选择：</p><ul><li><code>START_STICKY</code>：被系统清理后，会保留 Service 的启动状态，但不保留 Intent，系统重启 Service 后会重新调用<code>onStartCommand()</code>方法，但如果这期间没有收到任何 Intent，那传入的 Intent 就是 null，需要小心处理。</li><li><code>START_STICKY_COMPATIBILITY</code>：<code>START_STICKY</code> 的兼容版本，但是不能保证<code>onStartCommand()</code>会被调用。</li><li><code>START_NOT_STICKY</code>：被系统清理后，不保留 Service 状态。</li><li><code>START_REDELIVER_INTENT</code>：被系统清理后，会保留 Service 状态，同时会保留 Intent，系统重启 Service 后会重新调用<code>onStartCommand()</code>方法，此时会传入之前保留的 Intent。</li></ul><p>  默认情况下，<code>onStartCommand()</code>会返回<code>START_STICKY_COMPATIBILITY</code>或者<code>START_STICKY</code>。</p><ul><li><p><code>onBind(Intent intent)</code>：</p><p>当以绑定方式启动 Service 时，系统会调用这个方法（具体如何调用的，查看<a href="##service-%E7%9A%84%E5%88%86%E7%B1%BB">这一章节</a>），如果此时有 Intent 传入，则可以进行一些初始化的工作。如果要实现与 Client 端通信，那么这个方法必须要返回一个 IBinder 的接口；如果该 Service 不希望与 Client 端通信，可以直接返回 null。</p></li><li><p><code>onCreate()</code>：</p><p>这一看就是生命周期回调方法。这个方法会在<code>onStartCommand()</code>和<code>onBind()</code>之前被调用。如果 Service 已经在运行了，而再次尝试启动 Service 的话，这个方法<strong>不会再被调用</strong>。</p></li><li><p><code>onDestroy()</code>：</p><p>生命周期回调方法，在 Service 被销毁之前调用。可以在这里面做一些回收线程、注销 BroadcastReceiver 之类的工作。</p><p>值得注意的是，Service 在<strong>一般情况下不会被销毁</strong>，如果这个 Service 是前台 Service ，那它<strong>几乎永远不会终止</strong>（运行在某些国产OS上除外，说砍就砍没得商量🔪）；如果 Service 被绑定到前台 Activity 上，它也<strong>不太可能会终止</strong>；如果系统在<strong>低内存且必须回收资源以保证前台 Activity 与用户的交互</strong>的情况下终止了 Service ，那么在这种情况缓解时会<strong>立即重启 Service</strong> ——当然，要看<code>onStartCommand()</code>中你返回了个啥。</p></li></ul><h3 id="声明-Service"><a href="#声明-Service" class="headerlink" title="声明 Service"></a>声明 Service</h3><p>如果想要该 Service 可用，必须在 AndroidManifest 中注册这个 Service ，如下：</p><pre><code class="xml">&lt;manifest ...&gt;  &lt;application ...&gt;    &lt;service android:name=&quot;.CustomService&quot; /&gt;  &lt;/application&gt;&lt;/manifest&gt;</code></pre><p>在<code>&lt;service&gt;</code>标签中，还有很多其他的属性可以设置，我们来介绍几个比较重要的。</p><ul><li><code>android:name</code>：这是唯一必需的属性，用于<strong>指定 Service 的类名</strong>。在维护代码的过程中，尽量保持这个类名不变，以避免一些用<strong>显式 Intent 启动 Service</strong> 的代码碰钉子。</li></ul><blockquote><p><strong>显式 Intent</strong></p><p>隐式 Intent 指的是<strong>不指定特定处理者</strong>的 Intent，谁都可以接收和处理；而<strong>显式 Intent 指定了接收者</strong>，除了指定的接收者外，任何应用都无法接收和使用这个 Intent，使得应用更加安全。<br>从 Android 5.0 开始，如果使用隐式 Intent 调用<code>bindService()</code>，就会抛出异常：<br>java.lang.IllegalArgumentException: Service Intent must be explicit</p></blockquote><ul><li><p><code>android:enabled</code>：表示系统是否可以实例化该 Service 。默认为<code>true</code>，表示可以。如果设置了<code>false</code>，可以通过调用<code>PackageManager.setComponentEnabledSetting()</code>方法动态开启。</p></li><li><p><code>android:exported</code>：表示<strong>其他的应用能否调用该 Service 或者与之交互</strong>。该属性的默认值取决于该 Service 是否包含 Intent Filter。如果没有任何 Filter 则表示 Service 只能通过指定确切的类名来调用，也意味着该 Service 是『应用内部专享』，因为其他的应用不知道它的类名（正常情况下）。在这种情况下，默认值是<code>false</code>；反之如果有任意一个 Filter 则表明 Service 可以供外部使用，这时默认值是<code>true</code>。</p><p>另外，要限制这个 Service 的暴露，将该字段设置为 false 并不是唯一的方式。还可以使用权限控制<code>android:permission</code>来限制哪些外部应用可以与 Service 交互。下面会讲到。</p></li><li><p><code>android:permission</code>：组件启动 Service 或绑定到 Service 所必需的权限的名称。如果<code>startService()</code>、<code>bindService()</code>或<code>stopService()</code>的调用者<strong>尚未获得此权限</strong>，那该方法将<strong>不起作用</strong>，且系统不会将 Intent 对象传送给 Service ，也即无法完成交互。<strong>如果未设置该属性，则系统将会将其设置为<code>&lt;application&gt;</code>标签中<code>permission</code>属性所设置的权限</strong>（注意：不是<code>&lt;uses-permisson&gt;</code>标签）。如果两个属性都没设置，则 Service 不受权限保护。</p></li><li><p><code>android:process</code>：将运行 Service 的进程名称。正常情况下，应用的所有组件都会在为<strong>应用创建的默认进程</strong>中运行。该名称与<strong>应用包名相同</strong>。<code>&lt;application&gt;</code> 元素的<code>process</code>属性可为所有组件设置默认进程名称。不过，组件可以使用自己的<code>process</code>属性替换默认值，从而将应用散布到多个进程中。</p><p>如果为此属性分配的名称<strong>以冒号<code>:</code>开头</strong>，则系统会<strong>在需要时创建应用专用的新进程</strong>，并且 Service 会<strong>在该进程中运行</strong>。如果进程名称<strong>以小写字符开头</strong>，则 Service 将在<strong>使用该名称的全局进程中运行，前提是它拥有相应的权限</strong>。如此一来，不同应用中的组件便可共享进程，从而减少资源使用。</p></li></ul><h3 id="启动-Service"><a href="#启动-Service" class="headerlink" title="启动 Service"></a>启动 Service</h3><p>启动 Service 有两种方法，上面讲过了，<code>startService()</code>和<code>bindService()</code>方法。我们还是分开来讲。</p><h4 id="通过startService-启动的-Service"><a href="#通过startService-启动的-Service" class="headerlink" title="通过startService()启动的 Service"></a>通过<code>startService()</code>启动的 Service</h4><pre><code class="java">Intent intent = new Intent(this, CustomService.class);startService(intent);</code></pre><p>这种方式启动 Service ，系统将会调用<code>onStartCommand()</code>方法。这种 Service 在启动之后，<strong>其生命周期将独立于它的启动者</strong>。例如一个 Activity 通过这种方式启动了 Service ，哪怕 Activity 不可见了、甚至被销毁了， Service 也会继续运行。因此，我们应该在 Service 完成工作后，调用它的<code>stopSelf()</code>来停止运行，或者由其他的组件调用<code>stopService()</code>来停止该 Service 。</p><p>在调用该方法时，可以传递一个 Intent 对象给 Service ， Service 会在<code>onStartCommand()</code>中接收到这个 Intent。多次通过这种方式启动，会多次调用到<code>onStartCommand()</code>方法。<strong>这通常被用来向 Service 传递数据</strong>。</p><p>此处必须再强调一次， Service 启动后，<strong>是工作在主线程上的</strong>。如果交给 Service 去做一些密集性的、耗时的、阻塞的任务，可能会影响 Activity 的性能。如果要使用 Service 做这些事，你可以在 Service 中新建线程来做这些事。</p><h4 id="通过bindService-启动的-Service"><a href="#通过bindService-启动的-Service" class="headerlink" title="通过bindService()启动的 Service"></a>通过<code>bindService()</code>启动的 Service</h4><pre><code class="java">ServiceConnection conn = new ServiceConnection() &#123;    @Override    public void onServiceConnected(ComponentName className,                  IBinder service) &#123;        LocalBinder binder = (LocalBinder) service;        mService = binder.getService();        mBound = true;    &#125;    @Override    public void onServiceDisconnected(ComponentName arg0) &#123;        mBound = false;    &#125;&#125;Intent intent = new Intent(this, CustomService.class);bindService(intent, conn, Context.BIND_AUTO_CREATE);</code></pre><p>组件可以通过上述方式与 Service 进行长期绑定。这种 Service 在一般情况下，不允许组件通过调用<code>startService()</code>方法来启动它。它通常只在<strong>为其他应用组件提供服务时</strong>处于活动状态，并不会无限期地在后台运行。</p><p>这种启动方式多用在与 Activity 或者其他组件的交互，以及通过进程间通信（IPC）与其他应用产生交互。</p><p>一旦绑定，Service 就会启动，如果当前没有任何组件与 Service 是绑定状态，那 Service <strong>就会被系统销毁</strong>，所以，对于这种 Service ，我们**不必调用<code>stopSelf()</code>或者<code>stopService()</code>**。</p><p>上面我们也说过，同一个 Service 可以<strong>同时被多个组件绑定</strong>。</p><p>在以这种方式绑定 Service 时，系统会调用<code>onBind()</code>方法，我们需要<strong>自己实现<code>onBind()</code>回调方法，返回一个 IBinder 对象，供 Client 来与 Service 进行交互</strong>。多次绑定同一个 Service ，并不会重复调用<code>onBind()</code>方法，系统会在第一次绑定时生成 IBinder 对象，并对其进行缓存，在之后的绑定中，直接返回这个对象给 Client。</p><p>ServiceConnection 会监控与 Service 的连接状态，如上面代码所示，它有两个需要覆写的方法：<code>onServiceConnected()</code>和<code>onServiceDisconnected()</code>。前者会传递一个 IBinder 对象进来，Client 这时需要<strong>强转成自己需要的 Binder 对象</strong>，并可以调用该对象的方法，完成与 Service 的通信。后者则是<strong>与 Service 主动解绑或丢失链接</strong>时的回调。</p><h4 id="启动前台-Service"><a href="#启动前台-Service" class="headerlink" title="启动前台 Service"></a>启动前台 Service</h4><p>上面的两种 Service 都是『后台 Service 』，换言之，它们不会被用户可见。如果要启动用户可见的『前台 Service 』，需要调用<code>startForegroundService()</code>方法。</p><pre><code class="java">Intent intent = new Intent(this, CustomService.class);startForegroundService(intent);</code></pre><p>使用这种方法启动 Service ，就意味着 Service 在启动之后，就会<strong>立刻调用它的<code>startForeground(int, Notification)</code>方法</strong>，用于在通知栏中创建通知。</p><pre><code class="java">final int ONGOING_NOTIFICATION_ID = 1;  // 该值不可为0Intent notificationIntent = new Intent(this, MainActivity.class);PendingIntent pendingIntent =        PendingIntent.getActivity(this, 0, notificationIntent, 0);Notification notification =          new Notification.Builder(this, CHANNEL_DEFAULT_IMPORTANCE)    .setContentTitle(getText(R.string.notification_title))    .setContentText(getText(R.string.notification_message))    .setSmallIcon(R.drawable.icon)    .setContentIntent(pendingIntent)    .setTicker(getText(R.string.ticker_text))    .build();startForeground(ONGOING_NOTIFICATION_ID, notification);</code></pre><p>使用前台 Service 可以变相实现『保活』，因为系统几乎不会考虑将它停止，哪怕内存空间不足。但是这并不代表我们可以滥用前台 Service ，因为每一个 Service 都会消耗系统资源。</p><p>如果要移除前台 Service，需要手动调用<code>stopForeground(bool)</code>，参数表示是否要同时移除通知栏的通知。<strong>这个方法不会终止 Service</strong>。如果使用了<code>stopServie()</code>来终止 Service，那么通知栏中的通知也会随之被移除。</p><h3 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h3><p>IntentService 是 Service 的子类，它包含一个 HandlerThread，这意味着它<strong>并不是在主线程上工作</strong>的，可以将一些具有顺序性的、不需要同时处理的任务交给 IntentService 来处理。</p><p>要使用这个类，我们只需要实现它的<code>onHandleIntent()</code>方法，该方法会接收每个启动请求中的 Intent，并交给 HandlerThread 去处理。</p><p>值得注意的是，使用 IntentService 时，如果你需要重写<code>onStartCommand()</code>方法，在处理完自己的工作后，<strong>必须要调用<code>return super.onStartCommand()</code>方法来返回</strong>，以保证在<code>onHandleIntent()</code>中能正确接收到 Intent。</p><p>IntentService 在处理完所有请求后会停止 Service ，所以，<strong>不必调用<code>stopSelf()</code>方法</strong>。</p><blockquote><p>IntentService 在 API 30 中被废弃了。</p></blockquote><h2 id="Service-的生命周期"><a href="#Service-的生命周期" class="headerlink" title="Service 的生命周期"></a>Service 的生命周期</h2><p>盗个官网的图，美滋儿滋儿：</p><div class="center-img"><p><img src="/img/service-1588840496.png"></p><p><em>左边是使用startService()调用的生命周期，右边是bindService()</em></p></div><p>可见，Service 的生命周期很简单，与 Activity 相比简直是小巫见格格巫。下面的代码，就可以监控 Service 的所有生命周期：</p><pre><code class="java">public class CustomService extends Service &#123;    int startMode;       // indicates how to behave if the service is killed    IBinder binder;      // interface for clients that bind    boolean allowRebind; // indicates whether onRebind should be used    @Override    public void onCreate() &#123;        // Service 创建时回调    &#125;    @Override    public int onStartCommand(Intent intent, int flags, int startId) &#123;        // 服务已启动，每一次使用 startService() 启动服务时回调        return mStartMode;    &#125;    @Override    public IBinder onBind(Intent intent) &#123;        // 一个 Client 正在尝试调用 bindService() 绑定该服务        return mBinder;    &#125;    @Override    public boolean onUnbind(Intent intent) &#123;        // 一个 Client 正在尝试调用 unbindService() 与该服务解绑        return mAllowRebind;    &#125;    @Override    public void onRebind(Intent intent) &#123;        // 一个 Client 在解绑后又尝试重新绑定    &#125;    @Override    public void onDestroy() &#123;        // Service 销毁之前回调    &#125;&#125;</code></pre><p>看出来了吗？与 Activity 不一样的地方是，每一个生命周期方法，<strong>都不需要调用超类的生命周期方法</strong>。</p><h2 id="Service详解"><a href="#Service详解" class="headerlink" title="Service详解"></a>Service详解</h2><p>好，来到这篇文章最核心最复杂的部分了。我们先提出几个问题，然后带着问题去理解这部分。</p><blockquote><p>Service 是如何启动的？</p><p>传递给 Service 的 Intent 是如何交到 Service 手中的？</p><p>IntentService 是如何实现的？</p></blockquote><p>我们来逐个解释。</p><h3 id="普通-Service-的启动过程"><a href="#普通-Service-的启动过程" class="headerlink" title="普通 Service 的启动过程"></a>普通 Service 的启动过程</h3><p>我们都知道，启动 Service 最常用的方法是<code>Context.startService()</code>，我们就从这儿入手，看看 Service 的启动过程是怎样的：</p><pre><code class="java">// android.content.Context.javapublic abstract ComponentName startService(Intent service);</code></pre><p>Service 继承自 ContextWrapper，所以</p><p>Context 是一个抽象类，它的主要实现在 ContextImpl 类里：</p><pre><code class="java">// android.app.ContextImpl.java@Overridepublic ComponentName startService(Intent service) &#123;    warnIfCallingFromSystemProcess(); // 检查当前进程的 uid 是否与 Process.SYSTEM_UID 相等    return startServiceCommon(service, false, mUser);&#125;private ComponentName startServiceCommon(Intent service, boolean requireForeground,            UserHandle user) &#123;        try &#123;            validateServiceIntent(service);            service.prepareToLeaveProcess(this);            ComponentName cn = ActivityManager.getService().startService(                mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(                            getContentResolver()), requireForeground,                            getOpPackageName(), user.getIdentifier());            ...            return cn;        &#125; catch (RemoteException e) &#123;            throw e.rethrowFromSystemServer();        &#125;    &#125;</code></pre><p>由上面的代码可以看出，Context 将启动 Service 的任务转交给了 ActivityManager。同时交给 ActivityManager 的，还有当前 App 的主线程。这里可以解释为什么 Service 启动时会默认在主线程执行任务。</p><p>有人要杠了：这不明明是 Service 嘛，为啥交给 ActivityManager 来启动？先别杠，我们继续往下深入：</p><pre><code class="java">// android.app.ActivityManager.javapublic static IActivityManager getService() &#123;    return IActivityManagerSingleton.get();&#125;</code></pre><p>这里使用单例模式返回了 IActivityManager 的 Binder 对象，也即真正的<code>startService()</code>工作是在 ActivityManagerService 中完成的。</p><pre><code class="java">// com.android.server.ActivityManagerServicepublic class ActivityManagerService extends IActivityManager.Stub        implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback &#123;    ...    ActiveServices mServices;    ...    @Override    public ComponentName startService(IApplicationThread caller, Intent service,            String resolvedType, boolean requireForeground, String callingPackage, int userId)            throws TransactionTooLargeException &#123;        ...        // 使用 synchronized 来保证创建 Service 时的线程安全        synchronized(this) &#123;            final int callingPid = Binder.getCallingPid();            final int callingUid = Binder.getCallingUid();            final long origId = Binder.clearCallingIdentity();            ComponentName res;            try &#123;                res = mServices.startServiceLocked(caller, service,                        resolvedType, callingPid, callingUid,                        requireForeground, callingPackage, userId);            &#125; finally &#123;                Binder.restoreCallingIdentity(origId);            &#125;            return res;        &#125;    &#125;    ...&#125;</code></pre><p>继续看<code>ActiveServices.startServiceLocked()</code>方法：</p><pre><code class="java">// com.android.server.am.ActiveServices.javaComponentName startServiceLocked(IApplicationThread caller, Intent service, String resolvedType,        int callingPid, int callingUid, boolean fgRequired, String callingPackage, final int userId)        throws TransactionTooLargeException &#123;    return startServiceLocked(caller, service, resolvedType, callingPid, callingUid, fgRequired,            callingPackage, userId, false);&#125;ComponentName startServiceLocked(IApplicationThread caller, Intent service, String resolvedType,        int callingPid, int callingUid, boolean fgRequired, String callingPackage,        final int userId, boolean allowBackgroundActivityStarts)        throws TransactionTooLargeException &#123;    ...    // 各种启动前的检查、如 App 是否存在、AndroidManifest 中是否注册、权限是否合理    ...    // 将 Intent 包装进了 ServiceRecord 的新实例中    r.pendingStarts.add(new ServiceRecord.StartItem(r, false, r.makeNextStartId(),              service, neededGrants, callingUid));    if (fgRequired) &#123;        // 前台服务启动成功        ServiceState stracker = r.getTracker();        if (stracker != null) &#123;            stracker.setForeground(true, mAm.mProcessStats.getMemFactorLocked(),                    r.lastActivity);        &#125;        mAm.mAppOpsService.startOperation(AppOpsManager.getToken(mAm.mAppOpsService),                AppOpsManager.OP_START_FOREGROUND, r.appInfo.uid, r.packageName, true);    &#125;    ...    ComponentName cmp = startServiceInnerLocked(smap, service, r, callerFg, addToStarting);    return cmp;&#125;ComponentName startServiceInnerLocked(ServiceMap smap, Intent service, ServiceRecord r,        boolean callerFg, boolean addToStarting) throws TransactionTooLargeException &#123;    ...    // 记录一次运行，方便系统计算电量与运行时间的关系    synchronized (r.stats.getBatteryStats()) &#123;        r.stats.startRunningLocked();    &#125;    String error = bringUpServiceLocked(r, service.getFlags(), callerFg, false, false);    ...    return r.name;&#125;private String bringUpServiceLocked(ServiceRecord r, int intentFlags, boolean execInFg,        boolean whileRestarting, boolean permissionsReviewRequired)        throws TransactionTooLargeException &#123;    ...    // 还是各种检查    // Service 正在被启动，此时它不能被 force stop    try &#123;        AppGlobals.getPackageManager().setPackageStoppedState(                r.packageName, false, r.userId);    &#125; catch (RemoteException e) &#123;    &#125; catch (IllegalArgumentException e) &#123;        Slog.w(TAG, &quot;Failed trying to unstop package &quot;                + r.packageName + &quot;: &quot; + e);    &#125;    ...    ProcessRecord app;    if (!isolated) &#123;        app = mAm.getProcessRecordLocked(procName, r.appInfo.uid, false);        if (app != null &amp;&amp; app.thread != null) &#123;            try &#123;                app.addPackage(r.appInfo.packageName, r.appInfo.longVersionCode, mAm.mProcessStats);                // 这里开始启动服务                realStartServiceLocked(r, app, execInFg);                return null;            &#125; catch (TransactionTooLargeException e) &#123;                throw e;            &#125; catch (RemoteException e) &#123;                Slog.w(TAG, &quot;Exception when starting service &quot; + r.shortInstanceName, e);            &#125;            // If a dead object exception was thrown -- fall through to            // restart the application.        &#125;    &#125; else &#123;        ...    &#125;    ...    return null;&#125;private final void realStartServiceLocked(ServiceRecord r,            ProcessRecord app, boolean execInFg) throws RemoteException &#123;    ...    // 好熟悉的一句话，在 AMS 中，也是使用了 ActivityThread 中的 scheduleXXX 来实现的创建 Activity 的功能    app.thread.scheduleCreateService(r, r.serviceInfo,            mAm.compatibilityInfoForPackage(r.serviceInfo.applicationInfo),            app.getReportedProcState());    ...    // 这里开始向 Service 发送 Intent，也即调用 onStartCommand() 方法    sendServiceArgsLocked(r, execInFg, true);    ...&#125;private final void sendServiceArgsLocked(ServiceRecord r, boolean execInFg,            boolean oomAdjusted) throws TransactionTooLargeException &#123;    ...    r.app.thread.scheduleServiceArgs(r, slice);    ...&#125;</code></pre><p>可以看到，与 AMS 创建 Activity 的过程很相似，都是通过 ActivityThread 来完成最后的创建工作，之前所有的检查工作，都是为了保证安全性，同时记录一些 Service 的启动信息，以便进行后期管理。</p><p><code>scheduleCreateService()</code>和<code>scheduleCreateArgs()</code>分别向 ActivityThread 中的 Handler 发送了<code>CREATE_SERVICE</code>和<code>SERVICE_ARGS</code>事件，并分别调用到<code>handleCreateService()</code>和<code>handleServiceArgs((ServiceArgsData)msg.obj)</code>方法：</p><pre><code class="java">// android.app.ActivityThread.javaprivate void handleCreateService(CreateServiceData data) &#123;    ...    LoadedApk packageInfo = getPackageInfoNoCheck(            data.info.applicationInfo, data.compatInfo);    Service service = null;    try &#123;        // 利用反射创建 Service 的实例        java.lang.ClassLoader cl = packageInfo.getClassLoader();        service = packageInfo.getAppFactory()                .instantiateService(cl, data.info.name, data.intent);    &#125; catch (Exception e) &#123;        if (!mInstrumentation.onException(service, e)) &#123;            throw new RuntimeException(                &quot;Unable to instantiate service &quot; + data.info.name                + &quot;: &quot; + e.toString(), e);        &#125;    &#125;    try &#123;        if (localLOGV) Slog.v(TAG, &quot;Creating service &quot; + data.info.name);        ContextImpl context = ContextImpl.createAppContext(this, packageInfo);        context.setOuterContext(service);        Application app = packageInfo.makeApplication(false, mInstrumentation);        service.attach(context, this, data.info.name, data.token, app,                ActivityManager.getService());        // 调用了 Service 的 onCreate 生命周期方法        service.onCreate();        mServices.put(data.token, service);        try &#123;            ActivityManager.getService().serviceDoneExecuting(                    data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0);        &#125; catch (RemoteException e) &#123;            throw e.rethrowFromSystemServer();        &#125;    &#125; catch (Exception e) &#123;        if (!mInstrumentation.onException(service, e)) &#123;            throw new RuntimeException(                &quot;Unable to create service &quot; + data.info.name                + &quot;: &quot; + e.toString(), e);        &#125;    &#125;&#125;private void handleServiceArgs(ServiceArgsData data) &#123;    Service s = mServices.get(data.token);    if (s != null) &#123;        try &#123;            if (data.args != null) &#123;                data.args.setExtrasClassLoader(s.getClassLoader());                data.args.prepareToEnterProcess();            &#125;            int res;            if (!data.taskRemoved) &#123;                // 调用了 onStartCommand 生命周期方法                res = s.onStartCommand(data.args, data.flags, data.startId);            &#125; else &#123;                s.onTaskRemoved(data.args);                res = Service.START_TASK_REMOVED_COMPLETE;            &#125;            QueuedWork.waitToFinish();            try &#123;                ActivityManager.getService().serviceDoneExecuting(                        data.token, SERVICE_DONE_EXECUTING_START, data.startId, res);            &#125; catch (RemoteException e) &#123;                throw e.rethrowFromSystemServer();            &#125;        &#125; catch (Exception e) &#123;            if (!mInstrumentation.onException(s, e)) &#123;                throw new RuntimeException(                        &quot;Unable to start service &quot; + s                        + &quot; with &quot; + data.args + &quot;: &quot; + e.toString(), e);            &#125;        &#125;    &#125;&#125;</code></pre><p>至此，Service 完成了创建和 Intent 的传递。我们用一张时序图，来展示整个过程：</p><p><img src="/img/service-1588840496.png"></p><h3 id="绑定-Service-的启动过程"><a href="#绑定-Service-的启动过程" class="headerlink" title="绑定 Service 的启动过程"></a>绑定 Service 的启动过程</h3><p>还是从入口方法<code>Context.bindService()</code>开始看：</p><pre><code class="java">// android.app.ContextImpl.java@Overridepublic boolean bindService(Intent service, ServiceConnection conn, int flags) &#123;    warnIfCallingFromSystemProcess(); // 检查当前进程的 uid 是不是 Process.SYSTEM_UID    return bindServiceCommon(service, conn, flags, null, mMainThread.getHandler(), null, getUser());&#125;private boolean bindServiceCommon(Intent service, ServiceConnection conn, int flags,        String instanceName, Handler handler, Executor executor, UserHandle user) &#123;    ...    int res = ActivityManager.getService().bindIsolatedService(        mMainThread.getApplicationThread(), getActivityToken(), service,        service.resolveTypeIfNeeded(getContentResolver()),        sd, flags, instanceName, getOpPackageName(), user.getIdentifier());    ...&#125;</code></pre><p>与上面相同，还是来到了 ActivityManagerService 中，省略部分代码：</p><pre><code class="java">// com.android.server.ActivityManagerServicepublic class ActivityManagerService extends IActivityManager.Stub        implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback &#123;    ...    ActiveServices mServices;    ...    public int bindIsolatedService(IApplicationThread caller, IBinder token, Intent service,        String resolvedType, IServiceConnection connection, int flags, String instanceName,        String callingPackage, int userId) throws TransactionTooLargeException &#123;        ...        synchronized(this) &#123;            return mServices.bindServiceLocked(caller, token, service,                resolvedType, connection, flags, instanceName, callingPackage, userId);        &#125;    &#125;    ...&#125;</code></pre><p>这里与普通 Service 不同的是，它没有返回 ComponentName，而是返回了一个 int 值。</p><pre><code class="java">// com.android.server.am.ActiveServices.javaint bindServiceLocked(IApplicationThread caller, IBinder token, Intent service,        String resolvedType, final IServiceConnection connection, int flags,        String instanceName, String callingPackage, final int userId)        throws TransactionTooLargeException &#123;    ...    // 各种检查    ...    // 这里有个很重要的操作。    // 如果在应用的任何组件运行之前，需要让用户检查是否可以给予权限，这时会先计划一个绑定服务，但是并不启用它，    // 然后启动 review Activity，并给它一个 callback，用户交互完成后，再完成服务的绑定工作    if (mAm.getPackageManagerInternalLocked().isPermissionsReviewRequired(            s.packageName, s.userId)) &#123;        permissionsReviewRequired = true;        final ServiceRecord serviceRecord = s;        final Intent serviceIntent = service;        RemoteCallback callback = new RemoteCallback(                new RemoteCallback.OnResultListener() &#123;            @Override            public void onResult(Bundle result) &#123;                synchronized(mAm) &#123;                    final long identity = Binder.clearCallingIdentity();                    try &#123;                        if (!mPendingServices.contains(serviceRecord)) &#123;                            return;                        &#125;                        // If there is still a pending record, then the service                        // binding request is still valid, so hook them up. We                        // proceed only if the caller cleared the review requirement                        // otherwise we unbind because the user didn&#39;t approve.                        if (!mAm.getPackageManagerInternalLocked()                                .isPermissionsReviewRequired(                                        serviceRecord.packageName,                                        serviceRecord.userId)) &#123;                            try &#123;                                // 用户通过了权限验证，则创建 Service 实例                                bringUpServiceLocked(serviceRecord,                                        serviceIntent.getFlags(),                                        callerFg, false, false);                            &#125; catch (RemoteException e) &#123;                                /* ignore - local call */                            &#125;                        &#125; else &#123;                            unbindServiceLocked(connection);                        &#125;                    &#125; finally &#123;                        Binder.restoreCallingIdentity(identity);                    &#125;                &#125;            &#125;        &#125;);        final Intent intent = new Intent(Intent.ACTION_REVIEW_PERMISSIONS);        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK                | Intent.FLAG_ACTIVITY_MULTIPLE_TASK                | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);        intent.putExtra(Intent.EXTRA_PACKAGE_NAME, s.packageName);        intent.putExtra(Intent.EXTRA_REMOTE_CALLBACK, callback);        mAm.mHandler.post(new Runnable() &#123;            @Override            public void run() &#123;                mAm.mContext.startActivityAsUser(intent, new UserHandle(userId));            &#125;        &#125;);    &#125;    final long origId = Binder.clearCallingIdentity();    try &#123;        ...        // 如果这时 Service 还没有被创建，则创建 Service 实例        if ((flags&amp;Context.BIND_AUTO_CREATE) != 0) &#123;            s.lastActivity = SystemClock.uptimeMillis();            if (bringUpServiceLocked(s, service.getFlags(), callerFg, false,                    permissionsReviewRequired) != null) &#123;                return 0;            &#125;        &#125;        ...        if (s.app != null &amp;&amp; b.intent.received) &#123;            // Service 已经在运行了，就可以直接进行 connect            // 此处的 connected 是 IServiceConnection.aidl 中定义的，这个方法由 LoadedApk 来实现，具体查看『关于 Context』一文，此处略过            // 最后会调用到 ServiceConnection.onServiceConnected() 方法，完成了绑定工作            try &#123;                c.conn.connected(s.name, b.intent.binder, false);            &#125; catch (Exception e) &#123;                Slog.w(TAG, &quot;Failure sending service &quot; + s.shortInstanceName                        + &quot; to connection &quot; + c.conn.asBinder()                        + &quot; (in &quot; + c.binding.client.processName + &quot;)&quot;, e);            &#125;            // 如果是重新绑定            if (b.intent.apps.size() == 1 &amp;&amp; b.intent.doRebind) &#123;                requestServiceBindingLocked(s, b.intent, callerFg, true);            &#125;        // 如果是第一次绑定        &#125; else if (!b.intent.requested) &#123;            requestServiceBindingLocked(s, b.intent, callerFg, false);        &#125;        getServiceMapLocked(s.userId).ensureNotStartingBackgroundLocked(s);    &#125; finally &#123;        Binder.restoreCallingIdentity(origId);    &#125;    return 1;&#125;private final boolean requestServiceBindingLocked(ServiceRecord r, IntentBindRecord i,        boolean execInFg, boolean rebind) throws TransactionTooLargeException &#123;    ...    r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind,            r.app.getReportedProcState());    ...&#125;</code></pre><p>继续交给 ActivityThread 去做这件事，经过发送<code>BIND_SERVICE</code>的消息后，来到了<code>ActivityThread.handleBindService()</code>方法：</p><pre><code class="java">// android.app.ActivityThreadprivate void handleBindService(BindServiceData data) &#123;    Service s = mServices.get(data.token);    if (s != null) &#123;        try &#123;            data.intent.setExtrasClassLoader(s.getClassLoader());            data.intent.prepareToEnterProcess();            try &#123;                if (!data.rebind) &#123;                    // 调用 Servcie 对象的 onBind 生命周期方法                    IBinder binder = s.onBind(data.intent);                    ActivityManager.getService().publishService(                            data.token, data.intent, binder);                &#125; else &#123;                    // 调用 Servcie 对象的 onRebind 生命周期方法                    s.onRebind(data.intent);                    ActivityManager.getService().serviceDoneExecuting(                            data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0);                &#125;            &#125; catch (RemoteException ex) &#123;                throw ex.rethrowFromSystemServer();            &#125;        &#125; catch (Exception e) &#123;            if (!mInstrumentation.onException(s, e)) &#123;                throw new RuntimeException(                        &quot;Unable to bind to service &quot; + s                        + &quot; with &quot; + data.intent + &quot;: &quot; + e.toString(), e);            &#125;        &#125;    &#125;&#125;</code></pre><p>又回到了 ActivityManagerService 中。这里我们看到了两个方法<code>publishService()</code>和<code>serviceDoneExecuting()</code>。追踪下去，发现<code>publishService()</code>方法最终还是调用了 LoadedApk.connected() 方法；而<code>serviceDoneExecuting()</code>方法并没有，因为这个方法是在 rebind 的情况下才会调用，刚才在 ActiveServices.bindServiceLocked 已经针对 rebind 情况调用过一次 LoadedApk.connected() 了。</p><p>至此，绑定 Service 的启动完成。</p><p>同样地，我们使用一张时序图来展示一下这个过程：</p><p><img src="/img/service-1588840496.png"></p><h3 id="IntentService-原理解析"><a href="#IntentService-原理解析" class="headerlink" title="IntentService 原理解析"></a>IntentService 原理解析</h3><p>IntentService 的特点就不再赘述了，我们直接看它关键的代码，然后再解释它的原理：</p><pre><code class="java">public abstract class IntentService extends Service &#123;    // 有自己的 Looper    private volatile Looper mServiceLooper;    // 有自定义的 Handler    private volatile ServiceHandler mServiceHandler;    private String mName;    private boolean mRedelivery;    // 将 Handler 绑定到初始化的线程中    private final class ServiceHandler extends Handler &#123;        public ServiceHandler(Looper looper) &#123;            super(looper);        &#125;        @Override        public void handleMessage(Message msg) &#123;            onHandleIntent((Intent)msg.obj);            stopSelf(msg.arg1);        &#125;    &#125;    // 传入 name 以供内部的 HandlerThread 使用，方便进行调试    public IntentService(String name) &#123;        super();        mName = name;    &#125;    // 设置 intent 是否会被重新传递    //    // 如果设置为 true，onStartCommand() 会返回 Serivce.START_REDELIVER_INTENT，这种情况下，    // 如果 onHandleIntent() 还没有执行完返回，进程就死掉了，这时进程会被重启然后重新传递刚才的 intent。    // 如果之前发送了多个 intent （其他的在等待），只有最近发送的一个能保证被送达（其他的不一定了）。    //     // 如果设置为 false onStartCommand() 会返回 Serivce.START_NOT_STICKY，如果进行死掉，intent 也就随风消散了    //    public void setIntentRedelivery(boolean enabled) &#123;        mRedelivery = enabled;    &#125;    @Override    public void onCreate() &#123;        super.onCreate();        // 新建了一个局部的 HandlerThread，也即不允许外部直接管理这个线程的状态。        HandlerThread thread = new HandlerThread(&quot;IntentService[&quot; + mName + &quot;]&quot;);        thread.start();        mServiceLooper = thread.getLooper();        mServiceHandler = new ServiceHandler(mServiceLooper);    &#125;    @Override    public void onStart(@Nullable Intent intent, int startId) &#123;        Message msg = mServiceHandler.obtainMessage();        msg.arg1 = startId;        msg.obj = intent;        mServiceHandler.sendMessage(msg);    &#125;    // 不要重写这个方法    @Override    public int onStartCommand(@Nullable Intent intent, int flags, int startId) &#123;        onStart(intent, startId);        return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;    &#125;    @Override    public void onDestroy() &#123;        mServiceLooper.quit();    &#125;    // 除非你需要绑定这个服务，否则不用重写这个方法    @Override    @Nullable    public IBinder onBind(Intent intent) &#123;        return null;    &#125;    // 唯一需要重写的的方法，在这里可以处理调用者发送来的数据    @WorkerThread    protected abstract void onHandleIntent(@Nullable Intent intent);&#125;</code></pre><p>可见这个类并不是很神秘：</p><ol><li>继承了 Service 类；</li><li>重写了<code>onCreate()</code>方法，并在其中定义了一个局部的 HandlerThread，并不允许外部直接访问；</li><li>定义了一个 ServiceHandler 并与新建的 HandlerThread 绑定；</li><li>重写了<code>onStart()</code>方法，在每次启动服务调用到<code>onStartCommand()</code>的时候，调用<code>onStart()</code>，并将消息传递给 ServiceHandler；</li><li>定义了一个抽象方法<code>onHandleIntent(Intent)</code>供子类使用，用于真正处理请求。</li></ol><p>这个类虽然很常用，但是 Google 决定在 Android R（Android 11）中，将会<strong>废弃这个类</strong>，原因与最开始提到的『后台操作限制』相同，一个总是在后台运行的服务，必然会造成资源的消耗与浪费。Android 现在大力推宠的是 androidx 中的 <a href="https://developer.android.com/reference/androidx/work/WorkManager.html">WorkManager</a> 和 <a href="https://developer.android.com/reference/androidx/core/app/JobIntentService.html">JobIntentService</a>，我将会在其他的文章里讲解。</p>]]></content>
      
      
      <categories>
          
          <category> Development </category>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Android Framework </tag>
            
            <tag> Service </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JobScheduler 和 WorkManager</title>
      <link href="/2020-04-26/jobscheduler-and-workmanager/"/>
      <url>/2020-04-26/jobscheduler-and-workmanager/</url>
      
        <content type="html"><![CDATA[<p>这篇文章我们来讲讲 JobScheduler 和 WorkManager。</p><span id="more"></span><h2 id="JobScheduler"><a href="#JobScheduler" class="headerlink" title="JobScheduler"></a>JobScheduler</h2><p>JobScheduler 是 Google 在 API 21（Android 5.0）中推出的一种后台执行任务的方式。因为普通的 Service 会在后台一直运行，只有系统资源不足时才会将其回收，哪怕这个 Service 现在没有在做任何事情，这显然会对系统资源造成相当大的浪费，毕竟启动一个 Service 对开发者来说没什么成本是吧？</p><p>JobScheduler 提供的是<strong>根据某个条件来执行任务</strong>，而不是在某个时间来执行。它能确保把你的任务执行了，但是不能告诉你会在什么时候执行。<img class="sticker" src="http://img.doutula.com/production/uploads/image/2017/11/12/20171112500197_UKzaih.jpg" /></p><p>这让我想起了一句名言：</p><blockquote><p>我会还你钱的，但我没说什么时候还你。</p></blockquote><p>当然，情况没有那么严重。系统只是会<strong>智能分配</strong>目前所有的用 JobScheduler 方式提交的任务，并尝试批量执行，并且能推迟多久就推迟多久。这么说吧，你要是不给这个 Job 指定一个 deadline，那它真的可能会在很久之后才会执行。</p><p>那这玩意这么不靠谱，我们为什么还要用它呢？</p><p>因为随着 Android 版本的不断更迭，系统也逐渐变得流畅，这背后是对 App 更多的限制：限制后台进程的运行时间、限制反射可调用的接口、限制某些耗电行为、限制你可以接收到的广播。。。Android 必须也要推出一种行之有效的方案，让 App 能够在某种条件下，完成某种任务。JobScheduler 就应运而生了。</p><h3 id="JobScheduler-的使用"><a href="#JobScheduler-的使用" class="headerlink" title="JobScheduler 的使用"></a>JobScheduler 的使用</h3><p>要使用 JobScheduler，必须要先了解它的一家人：</p><ul><li>JobInfo：提交任务时要传递的参数，包含了任务概要、执行条件、deadline 等。</li><li>JobService：当系统调度到你这个任务时，要如何处理任务，你要自己去实现。</li><li>JobScheduler：用于向系统提交任务。</li></ul><p>它的使用很简单，可以分为三步：</p><h3 id="1-创建-JobService-的子类"><a href="#1-创建-JobService-的子类" class="headerlink" title="1. 创建 JobService 的子类"></a>1. 创建 JobService 的子类</h3><p>JobService 继承自 Service，也是抽象类，所以我们必须要自己写一个子类：</p><blockquote><p>注意！这是一个 Sevice，意味着它是在<strong>主线程</strong>中被回调的！所以，这里如果要访问网络进行密集、耗时的操作，还是需要另起线程来做。</p></blockquote><pre><code class="java">public class CustomJobService extends JobService &#123;    @Override    public boolean onStartJob(JobParameters params) &#123;        jobFinished(params, true);        return true;    &#125;    @Override    public boolean onStopJob(JobParameters params) &#123;        return false;    &#125;&#125;</code></pre><p>它只需要实现两个方法：<code>onStartJob(JobParameters)</code>和<code>onStopJob(JobParameters)</code>。顾名思义，就是任务开始的回调和任务停止的回调。还有一个重要的方法是<code>jobFinished(JobParameters, boolean)</code>，我们解释一下这三个方法。</p><ul><li><p><code>onStartJob()</code>：传入了 JobParameters 类型的变量，它包含了<code>jobId</code>和提交任务时创建 JobInfo 时传入的 Bundle 等数据。在任务执行完成时，需要调用<code>jobFinished()</code>来告诉系统：我的任务执行完成了。它的返回值是一个 boolean：</p><ul><li>返回<code>true</code>就是告诉系统，我还在执行任务，一会任务完成了，我会调用<code>jobFinished()</code>来告诉你的。但是，如果在任务执行期间，任务的执行环境发生了变更，比如在提交任务时指定『充电时执行』，但用户这时候把充电线拔掉了，那就会<strong>立刻结束任务</strong>，并调用<code>onStopJob()</code>；</li><li>返回<code>false</code>则告诉系统，我执行完了。系统也不会再去调用<code>onStopJob()</code>方法。</li></ul></li><li><p><code>jobFinished()</code>：只能在<code>onStartJob()</code>中调用，这个方法是被 final 修饰的，不能被覆写。它有两个参数，第一个参数是 JobParameters，第二个是 boolean 类型的参数，传入<code>true</code>是希望系统能根据创建任务时的标准<strong>再次将这个任务提上日程</strong>，传入<code>false</code>则相反。</p></li><li><p><code>onStopJob()</code>：当这个方法被调用时，表示任务要被强制中断了。这通常发生在任务执行条件不满足时。这个方法执行完毕后，系统就会释放 Wakelock。这个方法的返回值也是一个 boolean：如果返回<code>true</code>表示『教练，我想再试试🏀』，教练会在合适的时间再安排你打篮球（大误）；返回<code>false</code>表示『我不行了☠️』，教练扭头就走。但不管你返回什么，任务是肯定会被终止的。</p></li></ul><p>在<code>onStartJob()</code>被调用之前，系统会给 App 绑定一个 Wakelock，以防止系统进入休眠状态，这个 Wakelock 会在你调用<code>jobFinished()</code>或者系统调用<code>onStopJob()</code>时被释放掉。</p><h3 id="2-创建-JobInfo"><a href="#2-创建-JobInfo" class="headerlink" title="2. 创建 JobInfo"></a>2. 创建 JobInfo</h3><p>JobInfo 是一个 Parcelable，显然是用于 IPC 的。它采用了 Builder 设计模式来创建实例，使用起来也比较简单：</p><pre><code class="java">public static final int JOB_ID = 0;JobInfo jobInfo = new JobInfo.Builder(    JOB_ID,    new ComponentName(context, CustomJobService.class))        .setRequiredNetWork()        .setRequireCharging()        .build();</code></pre><p>可以看到，给这个 JobInfo 设置了要处理任务的类，设置了 jobId，设置了执行任务的条件等。</p><p>它的 Builder 中还有很多其他的方法，下面是它所有的方法：</p><p><img src="/img/job-1589006675.png"></p><h3 id="3-提交任务"><a href="#3-提交任务" class="headerlink" title="3. 提交任务"></a>3. 提交任务</h3><p>JobScheduler 是系统服务，不能直接被实例化，要通过<code>Context.getSystemService()</code>来获取。</p><pre><code class="java">JobScheduler js = (JobScheduler) context.getSystemService(Context.JOB_SCHEDULER_SERVICE);js.schedule(jobInfo);</code></pre><p>至此，一个任务就被『安排上了』。<img class="sticker" src="/img/anpai.jpg" /></p><p>JobScheduler 中最常用的是<code>schedule()</code>方法，用于提交任务。多次调用的话，如果系统中已经有相同 jobId 的任务，则会用新的直接替换掉旧任务，如果旧任务当前正在运行，那它<strong>会被终止</strong>。</p><p>它还有一个方法是<code>enqueue(JobInfo, JobWorkItem)</code>，用来给某个任务（新任务或者已存在任务皆可）插入工作内容（JobWorkItem）。如果系统中已经有相同 jobId 的任务，则会用新的直接替换旧任务，如果旧任务当前正在运行，传入的 JobWorkItem 会被<strong>插入任务的工作队列</strong>，任务<strong>并不会被终止</strong>。虽然不会终止任务，但还是<strong>强烈建议使用同一个 JobInfo</strong>来插入工作内容，这样，系统就不会分配额外的资源去更改 JobInfo，从而能更专注于执行任务。</p><h2 id="JobScheduler-实现原理"><a href="#JobScheduler-实现原理" class="headerlink" title="JobScheduler 实现原理"></a>JobScheduler 实现原理</h2><p>既然是系统服务，那必然是遵循老套路，得有个类似 JobSchedulerService 之类的东西，并且由 system_server 进程启动，我们直接扒 SystemServer 类的代码：</p><pre><code class="java">// android.server.SystemServer.javaprivate void startOtherServices() &#123;    ...    traceBeginAndSlog(&quot;StartJobScheduler&quot;);    mSystemServiceManager.startService(JobSchedulerService.class);    traceEnd();    ...&#125;</code></pre><p>✌️✌️✌️果然如此，接下来就分析一下 JobSchedulerService 的代码：</p><pre><code class="java"></code></pre><h2 id="WorkManager"><a href="#WorkManager" class="headerlink" title="WorkManager"></a>WorkManager</h2><p>WorkManager 是 Android Jetpack 中的一个组件。它提供了更为强大的功能，包括：</p><ul><li>向下兼容到 API 14</li><li>可以添加工作条件约束：比如有 Wifi 连接、正在充电等等（这很合适在后台下载 App 的更新包）</li><li>可以执行一次性的或者周期性的任务</li><li>能够监听和管理已计划的任务</li><li>将多个任务链接起来（妙啊）</li><li>保证任务一定会被执行，哪怕 App 重启甚至设备重启</li><li>遵循手机的省电模式</li></ul><p>WorkManager 适合运行那种<strong>非即时的、确定要执行</strong>的任务，比如说在某个时间段向后台发送日志、同步数据，或者定期检查 App 版本情况并下载新版本等等。</p><p>While a job is running, the system holds a wakelock on behalf of your app. For this reason, you do not need to take any action to guarantee that the device stays awake for the duration of the job.</p><p>You do not instantiate this class directly; instead, retrieve it through Context.getSystemService(Context.JOB_SCHEDULER_SERVICE).</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Jetpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 优化浅谈</title>
      <link href="/2020-04-24/android-optimization/"/>
      <url>/2020-04-24/android-optimization/</url>
      
        <content type="html"><![CDATA[<p>Android 优化是一个永恒的话题，主要可以入以下 5 个角度入手：</p><p><a href="#%E4%B8%80%20-%20%E7%A8%B3%E5%AE%9A%E6%80%A7">1. 稳定性</a><br><a href="#%E4%BA%8C%20-%20%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8">2. 内存占用</a><br><a href="#%E4%B8%89%20-%20%E6%B5%81%E7%95%85%E5%BA%A6">3. 流畅度</a><br><a href="#%E5%9B%9B%20-%20%E8%B5%84%E6%BA%90%E6%B6%88%E8%80%97">4. 资源消耗（网络流量、电量等）</a><br><a href="#%E4%BA%94%20-%20%E5%AE%89%E8%A3%85%E5%8C%85%E5%A4%A7%E5%B0%8F">5. 安装包大小</a></p><span id="more"></span><h2 id="一-稳定性"><a href="#一-稳定性" class="headerlink" title="一. 稳定性"></a>一. 稳定性</h2><p>一个好的应用，首先要求的就是稳定性。如果用户点点点，就崩溃了，那用户量的损失可不是能够轻易挽回的。</p><p>一般造成应用不稳定的原因有下面几种：</p><ol><li>ANR</li><li>Crash</li><li>死锁</li><li>Panic</li></ol><h3 id="1-ANR"><a href="#1-ANR" class="headerlink" title="1. ANR"></a>1. ANR</h3><p>ANR 即 Application Not Responding，是比较常见的现象，这种现象一般出现在应用<strong>主线程无法在规定时间内取出 Looper 中的下一个消息进行处理</strong>时，屏幕上会弹出『应用无响应，是否关闭？』的对话框，是令无数开发者头疼的问题。</p><p><img src="https://global-uploads.webflow.com/5c741219fd0819aad790e78b/5cc68a117c5efa97aed96e76_android-anr-photosnap.png" alt="FUCK ANR"></p><p>Android 对主线程下运行的组件都有要求：主线程5秒内无响应；BroadcastReceiver 10 秒内未返回；后台 Service 处理超时超过20秒；前台 Service 超过5秒；绑定服务超过200秒。无法达到上述要求，即被系统定义为 ANR。造成这种问题的原因的比较多，但常见的有以下几种：</p><ul><li>线程自身主线程出现问题，比如进行 IO 文件操作时间过长，进行了大量频繁的数据库操作，死循环等等。</li><li>调用 AMS、PMS 等长时间未响应，这种情况有可能发生在 <strong>system_server 进程正在等待某个锁，无法响应应用当前的请求</strong>。</li><li>io 操作时的 iowait 过高，比如下在用多线程下载文件，进行频繁写操作。</li><li>cpu 占用率过高，由其他应用占用了太多的 CPU 操作，本进程无法抢占到 CPU。</li><li>内存过低，系统在不断地尝试进行 GC 释放内存，可能会引起 ANR。</li></ul><p>产生 ANR 时，系统会在<code>/data/anr</code>下生成一个<code>traces.txt</code>文件，它里面记录了 ANR 产生的原因和日志，可以通过分析得出 ANR 的具体原因。</p><h3 id="2-Crash"><a href="#2-Crash" class="headerlink" title="2. Crash"></a>2. Crash</h3><p>Crash 问题也比较常见，绝大多情况是没有进行足够的 try-catch，当异常发生时，程序就会崩溃。这些问题一般需要根据系统的 logcat 去查找对应的 StackTrace，或者使用第三方 SDK 如 Bugly 等工具，来获取崩溃时的 StackTrace。</p><h3 id="3-死锁"><a href="#3-死锁" class="headerlink" title="3. 死锁"></a>3. 死锁</h3><p>造成这种现象的原因也比较简单，简单来说，就是 A 进程正在使用某个资源，此时 B 也使用这个资源，于是等待 A 释放锁，但这时 A 又要使用 B 正在使用的资源，B 此时又无法释放该资源的锁，因为它在等待 A 释放它想要的资源的锁，就出现了你等我我等你的现象，称之为死锁。</p><p>它产生的四个必要条件是：</p><ol><li><strong>互斥条件</strong>：一个资源每次只能被一个进程使用，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待；</li><li><strong>请求与保持条件</strong>：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放；</li><li><strong>不可剥夺条件</strong>：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)；</li><li><strong>循环等待条件</strong>: 若干进程间形成首尾相接循环等待资源的关系。</li></ol><p>避免死锁的基本思想是：系统对进程发出的每一个系统能够满足的资源申请进行<strong>动态检查</strong>，并根据检查结果决定是否分配资源，如果分配后系统可能发生死锁，则不予分配，否则予以分配，这是一种保证系统不进入死锁状态的动态策略。</p><h3 id="4-Panic"><a href="#4-Panic" class="headerlink" title="4. Panic"></a>4. Panic</h3><p>Panic 是内核级别的崩溃。这种崩溃在通常情况下我们无能为力。但是可以通过 kernel_log 来分析并定位问题，并在代码中尽量避免使用这个功能点或者方法。</p><h2 id="二-内存占用"><a href="#二-内存占用" class="headerlink" title="二. 内存占用"></a>二. 内存占用</h2><p>因为 Android 是移动平台，所以对每个应用来说，都是有内存限制的，如果一个应用使用的内存空间过大，则会触发 LMK（Low Memory Killer）机制，导致应用出现闪退。这种现象大部分原因来自内存泄漏。</p><h3 id="内存泄漏的原因"><a href="#内存泄漏的原因" class="headerlink" title="内存泄漏的原因"></a>内存泄漏的原因</h3><p>一般是编码问题、第三方库问题和 Android 自身问题。</p><ul><li><strong>编码问题</strong>：比如说静态变量<strong>引用了生命周期组件</strong>，导致该组件一直无法释放；或者非静态内部类一直持有外部类的引用，等等。</li><li><strong>第三方库</strong>：第三方的 SDK 我们无法保证其是否会有内存泄漏，一旦出现，只能定位，不太好解决。</li><li><strong>Android 自身问题</strong>：比如非常著名的 <strong>WebView 内存泄漏</strong>，它的<strong>内部线程会持有 Activity 的对象，导致 Activity 对象无法释放</strong>。如何解决请继续阅读。</li></ul><h3 id="内存泄漏的检测和定位"><a href="#内存泄漏的检测和定位" class="headerlink" title="内存泄漏的检测和定位"></a>内存泄漏的检测和定位</h3><p>如果有内存泄漏，最直观的感受，就是应用的内存占用噌噌噌地往上涨。我们可以通过一些工具来观测内存占用情况，从而确定是否有内存泄漏的现象。</p><ol><li><strong>Memory Monitor</strong>。由 Android Studio 提供，可以监测内存的占用情况，但无法得知内存泄漏的原因。</li><li><strong>Memory Analyzer</strong>。一个快速、功能丰富的 Java 堆分析工具。会通过内存的 Snapshot 生成 HPROF 文件，可以查看每一个对象在堆中所占的大小，从而定位造成内存泄漏的对象是哪个。</li><li><strong>LeakCanary</strong>。由 Square 公司出品，可以以 SDK 的方式集成到应用中，它会在应用运行的过程中，及时地提醒开发者哪些地方出现了内存泄漏，并提供相应的 StackTrace 帮助定位，它的具体原理可以查看<a href="/leakcanary/">这篇文章</a>。</li><li><strong>Android Lint</strong>。由 Android Studio 提供，它可以基于源代码快速分析代码中可能出现内存泄漏的地方，并加以提示，从源头遏制内存泄漏的产生。它还提供了一些其他的功能，比如 Layout 优化、提示未使用的变量等等。</li></ol><h3 id="内存泄漏的解决"><a href="#内存泄漏的解决" class="headerlink" title="内存泄漏的解决"></a>内存泄漏的解决</h3><ol><li><p>首先要注意 Activity 实例是不是被引用后无法释放。引起这种情况一般有两种原因：</p><ol><li><strong>内部类持有外部引用</strong>的情况下，导致 Activity 泄漏：<br>这种情况下，就避免使用内部类，可以使用静态类内部来解决，静态内部类不持有外部类的引用。如果必须要使用，那么不使用这个内部类时，要强制将该类的实例置为 null。</li><li><strong>Activity 的 Context 被间接引用</strong>：<br>这种情况如果可以的话，可以使用 Android 的 ApplicationContext 来替代 Activity 的 Context。</li></ol></li><li><p>然后要注意静态变量以及单例模式，<strong>静态变量它的生命周期基本与所在进程一样长</strong>，所以要小心静态变量引用其他生命周期的对象。单例模式的生命周期也与应用进程基本一致，所以与静态变量一样，要小心使用。</p></li><li><p>自定义的监听器的注销。因为监听器中一般会维护一组静态的监听者的引用队列，如果不及时注销，有可能会引起内存泄漏。</p></li><li><p>数据库 Cursor 的及时关闭。</p></li><li><p>对于 WebView 的内存泄漏，可以采取应用退出时直接调用<code>System.exit(0)</code>来解决，但是这种方案太暴力。第二种方案是使用新的进程来加载 WebView，但是这就涉及到进程间通信，实现起来比较麻烦。</p></li></ol><h2 id="三-流畅度"><a href="#三-流畅度" class="headerlink" title="三. 流畅度"></a>三. 流畅度</h2><p>一个 App 用起来是否『流畅』，最关键的考核指标就是『是否卡顿』。造成『卡顿』感觉一般原因是用户的输入无法得到及时响应，比如滑动时列表不流畅、页面跳转切换不流畅、事件响应不及时等等。Android 中有 <strong>VSYNC</strong> 机制，它每隔<strong>16ms</strong>就发出 VSYNC 信号，触发对 UI 的渲染，如果每次都渲染成功，则能达到如丝般顺滑的 60 帧效果（1秒=1000毫秒，1000 / 16 = 62.5）。如果某个操作花费时间<strong>超过 24ms</strong>，那收到 VSYNC 信号时就无法正常渲染，就会导致『丢帧』现象出现。</p><p>但这些原因基本上都可以归结为以下两类优化层面：</p><ol><li>界面绘制问题</li><li>数据处理问题</li></ol><h3 id="1-界面绘制问题"><a href="#1-界面绘制问题" class="headerlink" title="1. 界面绘制问题"></a>1. 界面绘制问题</h3><p>这种问题一般是由于 <strong>UI 布局太复杂，嵌套层级比较深，刷新机制不合理</strong>导致的。我们知道 Android 的绘制需要经过 measure、layout、draw 三个步骤，所以布局的层级越深、元素越多、耗时也就越长。</p><p>针对这种问题，一般从以下几个方面入手：</p><ul><li><p><strong>布局优化</strong>：</p><ul><li>减少 View 层级，优化 xml 布局文件；</li><li>多使用<code>&lt;inclue&gt;</code>标签重用 layout；</li><li>使用<code>&lt;merge&gt;</code>标签替换父级布局；</li><li>使用 ViewStub 延迟 View 的加载；</li><li>删除无用属性等。</li></ul><p> 更多布局优化参见<a href="/layout-optimization/">这篇文章</a></p></li><li><p><strong>渲染优化</strong>：</p><ul><li>减少 Overdraw 现象，多个重叠的 View 注意背景的多次绘制问题；</li><li>自定义 View 中，使用<code>canvas.clipRect()</code><strong>帮助系统识别可见区域</strong>，只有在这个区域内才会被绘制。</li></ul></li><li><p><strong>启动优化</strong>：</p><ul><li>优化闪屏页布局</li><li>优化启动逻辑，可以采用分步加载、延迟加载等方法提高应用启动速度</li></ul></li><li><p><strong>动画效果优化</strong>：</p><p>好的动画效果可以让用户感觉不那么『卡顿』，在合适的情况下，可以启用『硬件加速』来帮助绘制动画效果。</p></li></ul><h3 id="2-数据处理问题"><a href="#2-数据处理问题" class="headerlink" title="2. 数据处理问题"></a>2. 数据处理问题</h3><p>产生这种问题一般分为三种情况：</p><ol><li>在主线程处理数据。要尽量避免这样做，主线程尽量只用来绘制和处理 UI 层面的东西。</li><li>数据处理占用了太多 CPU。即便使用了新线程去处理数据，也可能导致主线程无法抢占到 CPU，此时可以考虑多个线程处理，或者分时、分段处理。</li><li>内存频繁 GC 引起卡顿。不要做引起频繁 GC 的操作，如使用大量临时变量等。</li></ol><h2 id="四-资源消耗"><a href="#四-资源消耗" class="headerlink" title="四. 资源消耗"></a>四. 资源消耗</h2><p>资源的消耗可以从三个角度来优化：</p><h3 id="1-网络流量优化"><a href="#1-网络流量优化" class="headerlink" title="1. 网络流量优化"></a>1. 网络流量优化</h3><p>虽然现在大家都不差流量，但是如果流量太多，还是会引起用户的反感。针对这种问题，我们一般从这两个层面来着手优化：</p><ul><li><strong>图片网络优化</strong>：图片可以进行分类，一种是高清图（原图），一种是压缩图，还有缩略图。在不同的情况下引用不同版本的图片，可以在很大程度上缓解网络流量大的问题。比如在 ListView 中，就可以使用缩略图，当进入详情页时，可以使用压缩图，当点击图片时，再使用原图。还有，可以判断当前网络，如果网络是 Wifi，那可以使用原图或压缩图，如果当前是3g/4g，则要询问用户是否要使用原图/压缩图。</li><li><strong>网络请求优化</strong>：<strong>连接复用、合并请求、压缩请求</strong>都是比较合理的手段。</li></ul><h3 id="2-电量消耗优化"><a href="#2-电量消耗优化" class="headerlink" title="2. 电量消耗优化"></a>2. 电量消耗优化</h3><p>在手机电池容量已经发展到 4000mAh 的今天，电量依旧是考量手机是否强劲的重要指标之一。对于 App 来说，耗电优化是不会停止的追求，『电池终结者』最终的下场就是被卸载。</p><p>在 Android 5.0 之后，引入了一个获取设备电量消耗的 API —— Battery Historian，可以通过图形化数据分析，直观地展示手机的电量消耗过程，帮助开发者定位电量消耗的源头。</p><p>我们能做的，除了使用 Battery Historian 之外，也要少使用长时间占用后台的 Service，减少 UI 绘制的复杂度，尽量不要有死循环以及有可能大量使用 CPU 的行为。</p><h2 id="五-安装包大小"><a href="#五-安装包大小" class="headerlink" title="五. 安装包大小"></a>五. 安装包大小</h2><p>安装包的大小直接导致用户是否会选择下载你这个应用（当前，如果你的应用是『手机必备』的，可以另谈🥴）。另一个直观的影响就是应用的安装时间，越大的包，安装时间会越长。尤其是在 Android 5.0 之后引入了 ART 模式，由于在安装时会把程序代码转换成机器语言，安装时间会变长。所以说，安装包的大小是一个非常重要的门槛，这直接关乎到用户的使用意愿。</p><p>在 Android Studio 中，使用 Apk Analyzer 可以展示 Apk 包中每一个文件的空间占用情况，如下所示：</p><p><img src="/img/android-op-1589181336.png"></p><p>可见，最主要占用空间的，是 dex 文件和资源文件（包括 res、assets 等）。通常我们会采用以下几种方式优化 Apk 的体积：</p><ol><li><strong>代码混淆</strong>：通过 proguard 来实现，它可以在打包阶段压缩代码、优化无用代码、混淆类名等等。</li><li><strong>资源优化</strong>：使用 Android Lint 扫描冗余资源，将文件最化；同时合理分配 drawable 的路径，对不合适的 drawable 进行删除；移除不必要的字符串资源等。</li><li><strong>图片优化</strong>：可以对图片进行压缩处理，或者使用 webp 等格式来替换。</li><li><strong>插件化</strong>：将功能模块分离宿主 Apk，可以大大减少 Apk 的体积。</li></ol><p><a href="https://juejin.im/post/5e69a4fd51882549003d2f0e">再看看这篇</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Activity四大启动模式解析</title>
      <link href="/2020-04-22/activity-launchmode/"/>
      <url>/2020-04-22/activity-launchmode/</url>
      
        <content type="html"><![CDATA[<p>这篇文章我们来详细解释 Activity 的四种启动模式。</p><span id="more"></span><h1 id="Activity的四种启动模式"><a href="#Activity的四种启动模式" class="headerlink" title="Activity的四种启动模式"></a>Activity的四种启动模式</h1><p>它们分别是：</p><ul><li>standard</li><li>singleTop</li><li>singleTask</li><li>singleInstance</li></ul><p>下面来分别做介绍。</p><p>这些模式可分为两大类：standard和singleTop为一类，singleTask和singleInstance为另一类。</p><p>使用standard或singleTop启动模式的 Activity 可多次进行实例化。实例可归属任何任务，并且可位于 Activity 堆栈中的任何位置。通常，它们会启动到名为 <code>startActivity()</code>的任务中（除非 Intent 对象包含 FLAG_ACTIVITY_NEW_TASK 指令，在此情况下会选择其他任务 — 请参阅 taskAffinity属性）。</p><p>相比之下，singleTask和singleInstance只能启动任务。它们始终位于 Activity 堆栈的根位置。此外，设备一次只能保留一个 Activity 实例，即一次只允许一个此类任务。</p><h2 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h2><p>顾名思义，standard英文意思就是『标准的』。</p><p>也就是说这种启动模式是默认的，我们平时在开发中使用最多的就是standard模式的。</p><p>如果一个Activity的启动模式被设置成standard，那么它可以无限制的创建。你每一次通过Intent去启动这种模式的Activity都会重新创建一个。</p><p>大家可以想象一下邮箱里的收件箱（假设我们将打开邮件的Activity的启动模式设置为Standard，当然这也是默认的模式）里有10封邮件。我们给查看邮件的Activity起名为CheckEmailActivity,我点击第一封邮件将会打开一个CheckEmailActivity，当我看完之后点击下一封邮件，另一个CheckEmailActivity又会被创建，这样如果我们将10封邮件全部看完，那在Activity任务栈中将会有10个CheckEmailActivity，而且如果我想回到收件箱页面还必须点10次返回键！想想是不是很可怕？</p><p>所以说standard模式虽然很常用，但也不是适用于任何场合。</p><p>另外说一点，standard模式在Android 5.0（Lollipop）之前和之后是有区别的。</p><h3 id="Android-Lollipop之前"><a href="#Android-Lollipop之前" class="headerlink" title="Android Lollipop之前"></a>Android Lollipop之前</h3><p>standard模式的Activity总是会被创建在启动它的Activity同一个任务栈中顶端（任务栈是一个栈结构，先进后出 First In Last Out），就算他们来自不同的应用。</p><p>想象一个场景，如果你在A应用中要分享一个本地图片，这样会打开系统的图片查看应用中的图片选择器Activity，虽然这两个Activity来自不同的应用，但Android系统仍将会把他们放在同一个任务栈中，即A应用的任务栈中。如下图：</p><p><img src="/img/16.png" alt="webp"></p><h3 id="Android-Lollipop之后"><a href="#Android-Lollipop之后" class="headerlink" title="Android Lollipop之后"></a>Android Lollipop之后</h3><p>如果将要启动的Activity和启动它的Activity来自同一个应用，那没话说，和Lollipop之前一样，新的Activity会被创建在当前任务栈中的顶端。</p><p>但是如果它们来自不同的应用，那就会创建一个新的任务栈，再把要启动的Activity放在新的任务栈中，这时这个新启动的Activity就是新创建的任务站点的根Activity。如下图所示：</p><p><img src="/img/17.png" alt="webp"></p><h2 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h2><p>顾名思义，singleTop的意思就是『在顶部只能有一个』，也即『栈顶复用』。</p><p>这种启动模式非常类似于standard，但是也有一些区别：</p><p>如果在启动这种模式的Activity的时候，当前任务栈的顶端已经存在了相同的Activity，那系统就不会再创建新的，而是回调任务栈中已经存在的该Activity的<code>onNewIntent()</code>方法。请看下面的示意图：</p><p><img src="/img/18.png" alt="webp"></p><p>也正因为singleTop启动模式的特殊性，所以在开发时，如果指定了一个Activity的启动模式是singleTop的那就应该既要重写<code>onCreated()</code>方法用于应对第一次创建的情况，也要重写<code>onNewIntent()</code>方法来应对重复创建的情况。</p><p>其实大家可以想象一下，这种启动模式的应用场景。Android既然提供了这种启动模式，说明肯定有应有场景需要这样的方式。其实最常用的场景就是搜索，比方说我们在搜索框中输入想要搜索的内容点击搜索进入SearchResultActivty查看搜索的结果（一般我们也会在搜索结果页提供搜索框，这样用户无需点击返回键回到上一个页面再在搜索框中输入搜索内容点击搜索），如果此时用户还想搜点别的东西，就可以直接在当前的搜索结果页SearchResultActivty中的搜索框输入搜索内容继续搜索。</p><p>大家想象一下，如果我们把SearchResultActivty的启动模式设置为Standard的话会是什么样的景象。比如我们连着搜了10个内容，那就会启动10个不同的SearchResultActivty，然而这些SearchResultActivty功能完全一样，完全没有必要创建这么多，而且还有一个和上一节中的邮箱一样的问题，就是用户搜索结束想回到首页，那就还得按10次返回键才能回到首页，- -！</p><p>这时，singleTop启动模式就派上用场了，我们首先把SearchResultActivty的启动模式设置为singleTop，这样用户在SearchResultActivty页面中继续搜索的时候，我们只需把用户要搜索的内容放在Intent里面然后启动SearchResultActivty，这时系统并不会重新创建新的SearchResultActivty，而是回调当前任务栈栈顶的SearchResultActivty的<code>onNewIntent()</code>方法来接收带有用户搜索内容信息的Intent，然后我们拿到用户搜索内容后调搜索接口，并根据接口返回内容重新刷新布局即可，似不似很神奇？其实我们在上一节提到的邮箱的问题，也是用这种方式来解决的，原理和搜索一样的。</p><p>还有比较常见的应用场景就是IM应用的聊天界面，消息被推送过来之后，就会以singleTop的方式来启动该Activity，并在<code>onNewIntent()</code>中处理数据就可以了。</p><blockquote><p>“standard”和“singleTop”模式只有一处不同：每次“standard”Activity 有新的 Intent 时，系统都会创建新的类实例来响应该 Intent。每个实例处理单个 Intent。同样地，您也可以创建新的“singleTop”Activity 实例来处理新的 Intent。不过，如果目标任务的 Activity 堆栈顶部已有一个 Activity 实例，则该实例会（通过调用 onNewIntent()）接收新的 Intent；此时不会创建新实例。在其他情况下（例如，如果“singleTop”Activity 的某个现有实例虽在目标任务内，但未处于堆栈顶部，或者虽然位于堆栈顶部，但不在目标任务中），系统会创建新实例并将其送入堆栈。</p></blockquote><h2 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h2><p>这种启动模式的Activity在Android系统中只允许存在一个实例。</p><p>如果系统中已经存在了该种启动模式的目标Activity，则系统并不会重新创建一个目标Activity，而是首先将持有目标Activity的整个任务栈都会被置于前台（用户可见），并且通过<code>onNewIntent()</code>方法将启动目标Activity的Intent传递给目标Activity，置于目标Activity拿到这个Intent之后要做什么操作，系统就不管了，随便你拿来干什么。</p><p>但是这里有个问题，就是目标Activity和源Activity是不是来自同一应用。</p><ul><li><p>源Activity和目标Activity来自<strong>同一个应用</strong></p><p>  这种情况还要分两种情况说：</p><ol><li><p>当前系统中还没有目标Activity的实例。这种情况最简单，直接在当前的任务栈中创建singleTask模式的Activity并置于栈顶即可。</p></li><li><p>当前系统中已经存在目标Activity的实例。这种情况比较特殊，因为系统会把任务栈中目标Activity之上的所有Activity销毁，以让目标Activity处在栈顶的位置。</p></li></ol><p>  这里还要还要再提醒大家的是，因为目标Activity已经存在，系统不会重新创建，而是通过<code>onNewIntent()</code>的方式把Intent传递过来，这点和singleTop模式有些类似。注意了，这里让我们回想一下文章开头的我所说的场景，如何让用户在支付完成页直接跳转到首页，并把不需要的Activity销毁？singleTask启动模式是不是刚好和我们的需求一致？请看下面的示意图：</p><p>  <img src="/img/19.png" alt="singleTask示例"></p></li><li><p>源Activity和目标Activity来自<strong>不同应用</strong></p><p>  这种情况也要分两种情况说：</p><ol><li>当前系统中还没有目标Activity的实例。这时系统首先会看任务管理器中是否有目标Actvity所在应用的任务栈？如果有的话，那就直接在目标Activity所在应用的任务栈的栈顶创建即可。如果任务管理器中没有目标Activity所在应用的任务栈，系统就会创建其所在应用的任务栈和目标Activity，并且把目标Activity作为新建任务栈的根Activity。如下图所示：</li></ol><p>  <img src="/img/20.png" alt="singleTask示例"></p><ol start="2"><li>当前系统中已经存在目标Activity的实例。目标Activity所在任务栈会被置于前台（即用户可见），而且也会把目标Activity之上的所有Actvity全部销毁。</li></ol></li></ul><p>上方的几种情况，可以总结为下面的流程图：</p><p><img src="/img/21.png"></p><p>singleTask比较常见的应用场景是当应用的主页面，从层级比较深的页面（如订单完成页面）直接返回主页的时候，就可以清除其他的Activity，只保留主页面Activity。</p><h2 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h2><p>这种启动模式和singleTask几乎一样，它也只允许系统中存在一个目标Activity的实例，包括上面我们所说的singleTask的一些特性singleInstance都有。唯一不同的是，持有目标Activity的任务栈中只能有目标Activity一个Actvitiy，不能再有别的Activity。</p><p>对！就是承包了这片鱼塘！<img src="/img/doge.png"></p><p>其实从这种启动模式的名字也可以看出来它表示的意思，singleInstance直译过来就是『单一实例』，什么意思呢？有两层意思，我们来分析一下：</p><ol><li>跟系统说，『我是独一无二的，不许和我一样的人存在！』，这就是说系统中存在一个目标Activity；</li><li>跟任务栈说，『我是独一无二的，不许你心里再装别的人！』，这就是说持有目标Activity的任务栈中只能有目标Activity一个Activity。</li></ol><p>所以，如果要启动singleInstance模式的Activity，那只能新创建一个任务栈用来放它。同样的，如果从这种启动模式的Activity中启动别的Activity，那不好意思，我不管你是不是和我处在同一个应用，我所在的任务栈只能拥有我一个人，您呐，另外让系统给你创建一个任务栈待着去吧。</p><p>比较常见的应用场景是用在比较频繁调用的Activity。比如系统浏览器，比如闹钟等。</p><blockquote><p>“singleTask”和“singleInstance”模式同样只有一处不同：“singleTask”Activity 允许其他 Activity 成为其任务的一部分。该 Activity 始终位于其任务的根位置，但其他 Activity（必然是“standard”和“singleTop”Activity）可以启动到该任务中。另一方面，“singleInstance”Activity 不允许其他 Activity 成为其任务的一部分。它是任务中唯一的 Activity。如果它启动另一个 Activity，则系统会将该 Activity 分配给其他任务，就如同 Intent 中包含 FLAG_ACTIVITY_NEW_TASK 一样。</p></blockquote><p>好了，至此我们介绍了Activity的4种启动模式了，也大致了解了每种启动模式的特点了。</p><p>再引用一下官网对四种启动模式的解释：</p><table>    <tr>        <th>用例</th>        <th>启动模式</th>        <th>多个实例？</th>          <th>注释</th>      </tr>    <tr>        <td rowspan="2">大多数 Activity 的正常启动</td>        <td>standard</td>        <td>是</td>        <td>默认。系统始终会在目标任务中创建新的 Activity 实例，并向其传送 Intent。</td>    </tr>    <tr>        <td>singleTop</td>        <td>视情况而定</td>        <td>如果目标任务的顶部已存在 Activity 实例，则系统会通过调用该实例的 <span style="color: #1E90FF">onNewIntent()</span> 方法向其传送 Intent，而非创建新的 Activity 实例。</td>    </tr>    <tr>        <td rowspan="2">专用启动<br/>（不建议在一般情况下使用）</td>        <td>singleTask</td>        <td>否</td>        <td>系统会在新任务的根位置创建 Activity 并向其传送 Intent。不过，如果已存在 Activity 实例，则系统会调用该实例的 <span style="color: #1E90FF">onNewIntent()</span> 方法（而非创建新的 Activity 实例），向其传送 Intent。</td>    </tr>    <tr>        <td>singleInstance</td>        <td>否</td>        <td>与<b>『singleTask』</b>相同，只是系统不会将任何其他 Activity 启动到包含实例的任务中。该 Activity 始终是其任务中的唯一 Activity。</td>    </tr></table><p>同时，官方提出：</p><blockquote><p>如上表所示，standard 是默认模式，并且适用于大多数类型的 Activity。对众多类型的 Activity 而言，SingleTop 也是常见且有用的启动模式。其他模式（singleTask 和 singleInstance）<span style="color:red">不适用于大多数应用</span>，因为它们所形成的交互模式可能让用户感到陌生，并且与大多数其他应用差别较大。</p></blockquote><blockquote><p>无论您选择哪种启动模式，在 Activity 启动期间以及使用返回按钮从其他 Activity 和任务返回该 Activity 时，请务必对其进行易用性测试。</p></blockquote><h2 id="关于taskAffinity"><a href="#关于taskAffinity" class="headerlink" title="关于taskAffinity"></a>关于taskAffinity</h2><p>在官方文档中是这样介绍<code>android:taskAffinity</code>属性的：</p><blockquote><p>与该 Activity 有着相似性的任务。从概念上讲，具有同一相似性的 Activity 归属同一任务（从用户的角度来看，则是归属同一『应用』）。任务的相似性由其根 Activity 的相似性确定。</p><p>相似性确定两点内容 — Activity 更改父项后的任务（请参阅<code>allowTaskReparenting</code>属性），以及通过<code>FLAG_ACTIVITY_NEW_TASK</code>标记启动 Activity 时，用于容纳该 Activity 的任务。</p><p>默认情况下，应用中的所有 Activity 都具有同一相似性。您可以设置该属性，以不同方式将其分组，甚至可以在同一任务内放置不同应用中定义的 Activity。如要指定 Activity 与任何任务均无相似性，请将其设置为空字符串。</p><p>如果未设置该属性，则 Activity 会继承为应用设置的相似性（请参阅 <code>&lt;application\&gt;</code> 元素的<code>taskAffinity</code>属性）。应用默认相似性的名称为 <code>&lt;manifest&gt;</code> 元素所设置的软件包名称。</p></blockquote><p><code>taskAffinity</code>，可以翻译为<strong>任务相关性</strong>。这个参数标识了一个 Activity 所需要的任务栈的名字，默认情况下，所有 Activity 所需的任务栈的名字为应用的包名，当 Activity 设置了 <code>taskAffinity</code> 属性，那么这个 Activity 在被创建时就会运行在和 <code>taskAffinity</code> 名字相同的任务栈中，如果没有，则新建 <code>taskAffinity</code> 指定的任务栈，并将 Activity 放入该栈中。另外 <code>taskAffinity</code> 属性主要和 <code>singleTask</code> 或者  <code>allowTaskReparenting</code> 属性配对使用，在其他情况下没有意义。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Activity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 中的序列化</title>
      <link href="/2020-04-20/android-serialization/"/>
      <url>/2020-04-20/android-serialization/</url>
      
        <content type="html"><![CDATA[<p>在 Android 中传递一些数据时，我们需要将数据序列化。序列化经常会用到 Serializable 和 Parcelable 这两个类，那么你有没有想过他们的区别是什么呢？这篇文章来分析一下各自的特点及优缺点，并对比一下两种结构的区别。</p><span id="more"></span><p>在讲它们之前，先提一个问题：为什么要序列化？</p><h2 id="为什么要序列化"><a href="#为什么要序列化" class="headerlink" title="为什么要序列化"></a>为什么要序列化</h2><p>Android开发的时候，我们时长遇到传递对象的需求，但是我们无法将对象的引用传给 Activity 或者 Fragment，我们需要将这些对象放到一个Intent 或者 Bundle 里面，然后再传递，这时候就用到了序列化。所谓序列化就是<strong>把 Java 对象转换为字节序列的过程</strong>，该字节序列可以被存储到一个储存媒介里或者在网络上进行传输；反序列化就是把<strong>字节序列恢复为 Java 对象的过程</strong>。但是我们要知道序列化与反序列化仅处理 Java 变量而不处理方法，仅对数据进行处理。</p><h2 id="序列化的两种方式"><a href="#序列化的两种方式" class="headerlink" title="序列化的两种方式"></a>序列化的两种方式</h2><p>Android中序列化有两种方式：Serializable 以及 Parcelable。其中 Serializable 是 Java 自带的，而 Parcelable 是 Android 专有的。</p><h3 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h3><p>Serializable 是 Java 提供的序列化技术。使用起来非常简单，只需要让某个 Class 实现 Serializable 就可以。在Serializable的文档中提出，Serializable 在序列化运行时会关联一个版本号，用<code>serialVersionUID</code>来标识，主要用来验证发送者和接收者处理的是不是同一个版本的类。如果版本不一致，则会抛出<code>InvalidClassException</code>异常。要使用这个标识，需要在类里声明如下：</p><pre><code class="java">private/public/protected static final long serialVersionUID = 42L;</code></pre><p>虽然不提供这个值也行，Java 会自己生成一个该值，但是最好还是能提供一个。因为受编译器版本不同、内核版本不同等等的影响，有可能同一个类计算出来的<code>serialVersionUID</code>值不同，就会导致序列化/反序列化失败。</p><p>当父类实现了序列化，其子类也会自动实现序列化，不需要再显式实现 Serializable 接口了。</p><blockquote><p>Seralizable 无法序列化静态变量，使用 transient 修饰的对象也无法序列化。所以，当类中有静态变量时，序列化并不会保存该变量。</p><h3 id="transient-关键字"><a href="#transient-关键字" class="headerlink" title="transient 关键字"></a>transient 关键字</h3><p>transient 关键字的作用是<strong>控制变量的序列化</strong>，在变量声明前加上该关键字，可以<strong>阻止该变量被序列化到文件中</strong>，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。</p></blockquote><p>实现 Serializable 时，还可以添加<code>writeObject()</code>和<code>readObject()</code>方法，虚拟机在序列化和反序列化时，会试图调用这两个方法，通过这两个方法，我们可以<strong>控制序列化的过程</strong>，比如可以在序列化的过程中动态改变序列化的数值。举例如下：</p><pre><code class="java">class SerializableTest implements Serializable &#123;    private static final long serialVersionUID = 1L;    private String password = &quot;pass&quot;;    public String getPassword() &#123;        return password;    &#125;    public void setPassword(String password) &#123;        this.password = password;    &#125;    private String encrypt() &#123;        ...    &#125;    private String decrypt() &#123;        ...    &#125;    private void writeObject(ObjectOutputStream out) &#123;        try &#123;            PutField putFields = out.putFields();            System.out.println(&quot;原密码:&quot; + this.password);            this.password = encrypt(); // 加密            putFields.put(&quot;password&quot;, this.password);            System.out.println(&quot;加密后的密码&quot; + this.password);            out.writeFields();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    private void readObject(ObjectInputStream in) &#123;        try &#123;            GetField readFields = in.readFields();            Object object = readFields.get(&quot;password&quot;, &quot;&quot;);            this.password = decrypt(object.toString())            System.out.println(&quot;解密后的密码:&quot; + this.password);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; catch (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><h3 id="Parcelable"><a href="#Parcelable" class="headerlink" title="Parcelable"></a>Parcelable</h3><p>Parcelable 是 Android 提供的序列化方案。它的出现是为了解决Serializable在序列化的过程中消耗资源严重的问题，但是因为本身使用需要手动处理序列化和反序列化过程，会与具体的代码绑定，使用较为繁琐，一般只获取内存数据的时候使用。</p><p>而 Parcelable 依赖于Parcel，Parcel 的意思是包装，实现原理是在内存中<strong>建立一块共享数据块</strong>，序列化和反序列化均是操作这一块的数据，如此来实现。如图所示：</p><p><img src="/img/55.png"></p><p>听起来跟 Linux 的共享内存有没有很像？对，Parcelable 可以用于 Android 的进程间通信。举个简单的例子，应用的 Activity 要与 Service 通信的话，就可以使用 Parcelable。</p><p>使用 Parcelable 要稍微麻烦一些。它需要实现以下几点：</p><ul><li>类本身要实现 Parcelable 接口</li><li>有一个非空的静态成员变量叫<code>CREATOR</code>，并且它要实现<code>Parcelable.Creator</code>接口<ul><li>覆写<code>createFromParcel(Parcel in)</code>方法</li><li>覆写<code>newArray(int size)</code>方法</li></ul></li><li>覆写<code>describeContents()</code>方法</li><li>覆写<code>writeToParcel(Parcel dest, int flags)</code>方法</li></ul><p>看起来真的好麻烦。我们还是用代码来解释一下吧：</p><pre><code class="java">public class MyParcelable implements Parcelable &#123;    // 要被序列化的数据    private int mData;    // 描述在这个 Parcelable 实例的中含有的特殊对象的类型。    // 例如，如果在对象的 output 中包含一个文件描述符，那它的返回值必须要包含 CONTENTS_FILE_DESCRIPTOR 的 bit 值    // 返回一个 bitmask 值    public int describeContents() &#123;        return 0;    &#125;    // 用二向箔把对象搞成 Parcelable    public void writeToParcel(Parcel out, int flags) &#123;        out.writeInt(mData);    &#125;    // 一个必须要实现的接口，用来从一个 Parcel 创建你自定义的 Parcelable 实例    public static final Parcelable.Creator&lt;MyParcelable&gt; CREATOR            = new Parcelable.Creator&lt;MyParcelable&gt;() &#123;        // 使用之前存储的 Parcel 来创建实例        public MyParcelable createFromParcel(Parcel in) &#123;            return new MyParcelable(in);        &#125;        // 创建一个 Parcelable 的数组，所有元素都是 null        public MyParcelable[] newArray(int size) &#123;            return new MyParcelable[size];        &#125;    &#125;;    // 从读取的数据中进行恢复    private MyParcelable(Parcel in) &#123;        mData = in.readInt();    &#125;&#125;</code></pre><h2 id="两种序列化方式的对比"><a href="#两种序列化方式的对比" class="headerlink" title="两种序列化方式的对比"></a>两种序列化方式的对比</h2><ol><li>Serializable 代码量少，Parcelable 代码量多。</li><li>在内存间传递数据的时候，Parcelable 比 Serializable 性能高、内存开销方面较小，所以推荐使用 Parcelable；而在需要保存数据到本地或者进行网络传输时，使用 Serializable。</li><li>Serializable 在序列化时使用的是<strong>反射</strong>的技术，会产生大量的临时变量，从而引起频繁的 GC。而 Parcelable 方式的实现原理是将一个完整的对象进行<strong>字节化</strong>，而<strong>字节化</strong>之后的每一部分都是 Intent 所支持的数据类型，这样也就实现传递对象的功能了。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Development </category>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 ActivityManagerService</title>
      <link href="/2020-04-18/activity-manager-service/"/>
      <url>/2020-04-18/activity-manager-service/</url>
      
        <content type="html"><![CDATA[<p>ActivityManagerService 是 Android 提供的<strong>管理 Activity 运行状态的系统进程</strong>，其实大家别被名字迷惑了，ActivityManagerService（后称AMS）其实也兼任管理其他组件运行状态。</p><span id="more"></span><h2 id="AMS概述"><a href="#AMS概述" class="headerlink" title="AMS概述"></a>AMS概述</h2><h3 id="AMS启动流程"><a href="#AMS启动流程" class="headerlink" title="AMS启动流程"></a>AMS启动流程</h3><p>根据<a href="/android-boot/"></a>这篇文章中提到的，init 进程是 Android 系统中的初始化进程，init 生成 Zygote 进程，Android 中大多数应用进程和系统进程都是通过 Zygote 进程生成的。</p><p><img src="/img/ams-1587379033.jpg"></p><p>上面的流程图展示了 AMS 的代码执行流程。我们接下来详细讲讲。</p><p>AMS这种系统级别的服务，一般都是在启动的时候触发，我们可以看一下在 system_server 进程中，是如何启动 AMS 的：</p><pre><code class="java">// com.android.server.SystemServer.java;public final class SystemServer &#123;    /**     * The main entry point from zygote.     */    public static void main(String[] args) &#123;        new SystemServer().run();    &#125;    private void run() &#123;        ...        // Start services.        ...        startBootstrapServices();        ...    &#125;    private void startBootstrapServices() &#123;        ...        // Activity manager runs the show.        traceBeginAndSlog(&quot;StartActivityManager&quot;);        // TODO: Might need to move after migration to WM.        ActivityTaskManagerService atm = mSystemServiceManager.startService(                ActivityTaskManagerService.Lifecycle.class).getService();        // 这里真正启动了 AMS        mActivityManagerService = ActivityManagerService.Lifecycle.startService(                mSystemServiceManager, atm);        mActivityManagerService.setSystemServiceManager(mSystemServiceManager);        mActivityManagerService.setInstaller(installer);        mWindowManagerGlobalLock = atm.getGlobalLock();        ...        // 为 system 进程设置 Application 实例        mActivityManagerService.setSystemProcess();    &#125;&#125;</code></pre><p>可以看到，启动 AMS 使用的是 AMS 自身的一个静态内部类的<code>startService()</code>方法，我们来看看：</p><p><a href="https://android.googlesource.com/platform/frameworks/base/+/master/services/core/java/com/android/server/am/ActivityManagerService.java">查看ActivityManagerService.java</a></p><pre><code class="java">// ActivityManagerService.javapublic static final class Lifecycle extends SystemService &#123;    private final ActivityManagerService mService;    ...df    public static ActivityManagerService startService(            SystemServiceManager ssm, ActivityTaskManagerService atm) &#123;        sAtm = atm;        return ssm.startService(ActivityManagerService.Lifecycle.class).getService();    &#125;    @Override    public void onStart() &#123;        mService.start();    &#125;    ...&#125;</code></pre><p>这里又调用了<code>SystemServiceManager.startService(Class)</code>方法，我们来看一下：</p><pre><code class="java">// com.android.server.SystemServiceManager.java/**    * Creates and starts a system service. The class must be a subclass of    * &#123;@link com.android.server.SystemService&#125;.    *    * @param serviceClass A Java class that implements the SystemService interface.    * @return The service instance, never null.    * @throws RuntimeException if the service fails to start.    */@SuppressWarnings(&quot;unchecked&quot;)public &lt;T extends SystemService&gt; T startService(Class&lt;T&gt; serviceClass) &#123;    ...    // 通过反射的方式实例化该 service    Constructor&lt;T&gt; constructor = serviceClass.getConstructor(Context.class);    service = constructor.newInstance(mContext);    ...    startService(service);    return service;&#125;public void startService(@NonNull final SystemService service) &#123;    // 注册    mServices.add(service);    ...    // 调用 Lifecycle 的 onStart() 方法    service.onStart();    ...&#125;</code></pre><p>可以看到，最后调用到了<code>ActivityManagerService.Lifecycle.onStart()</code>方法，而<code>ActivityManagerService.Lifecycle.onStart()</code>方法又调用了<code>mService.start()</code>方法，进行了一些初始化的工作：</p><pre><code class="java">private void start() &#123;    removeAllProcessGroups();    mProcessCpuThread.start();    mBatteryStatsService.publish();    mAppOpsService.publish(mContext);    Slog.d(&quot;AppOps&quot;, &quot;AppOpsService published&quot;);    LocalServices.addService(ActivityManagerInternal.class, new LocalService());    mActivityTaskManager.onActivityManagerInternalAdded();    mUgmInternal.onActivityManagerInternalAdded();    mPendingIntentController.onActivityManagerInternalAdded();    // Wait for the synchronized block started in mProcessCpuThread,    // so that any other access to mProcessCpuTracker from main thread    // will be blocked during mProcessCpuTracker initialization.    try &#123;        mProcessCpuInitLatch.await();    &#125; catch (InterruptedException e) &#123;        Slog.wtf(TAG, &quot;Interrupted wait during start&quot;, e);        Thread.currentThread().interrupt();        throw new IllegalStateException(&quot;Interrupted wait during start&quot;);    &#125;&#125;</code></pre><p>初始化完成后，就会调用<code>mActivityManagerService.setSystemProcess()</code>方法：</p><pre><code class="java">public void setSystemProcess() &#123;    ...    ServiceManager.addService(Context.ACTIVITY_SERVICE, this, /* allowIsolated= */ true,                DUMP_FLAG_PRIORITY_CRITICAL | DUMP_FLAG_PRIORITY_NORMAL | DUMP_FLAG_PROTO);    ServiceManager.addService(ProcessStats.SERVICE_NAME, mProcessStats);    ServiceManager.addService(&quot;meminfo&quot;, new MemBinder(this), /* allowIsolated= */ false,            DUMP_FLAG_PRIORITY_HIGH);    ServiceManager.addService(&quot;gfxinfo&quot;, new GraphicsBinder(this));    ServiceManager.addService(&quot;dbinfo&quot;, new DbBinder(this));    if (MONITOR_CPU_USAGE) &#123;        ServiceManager.addService(&quot;cpuinfo&quot;, new CpuBinder(this),                /* allowIsolated= */ false, DUMP_FLAG_PRIORITY_CRITICAL);    &#125;    ServiceManager.addService(&quot;permission&quot;, new PermissionController(this));    ServiceManager.addService(&quot;processinfo&quot;, new ProcessInfoService(this));    ...&#125;</code></pre><p>可以看出，通过<code>ServiceManager.addService(Context.ACTIVITY_SERVICE, this, true)</code>方法注册了当前 AMS 的实例。AMS 是一个典型的 Binder Server，ServiceManager 还注册了与 AMS 有关的其他服务（如 CPU、PermissionController等），说明后面 AMS 会与这些服务有很多交互。</p><p>刚才我们跳过了 AMS 的实例化过程，现在我们来看一下它的实例化中，具体都做了哪些工作：</p><pre><code class="java">    // Note: This method is invoked on the main thread but may need to attach various    // handlers to other threads.  So take care to be explicit about the looper.    public ActivityManagerService(Context systemContext, ActivityTaskManagerService atm) &#123;        LockGuard.installLock(this, LockGuard.INDEX_ACTIVITY);        mInjector = new Injector();        mContext = systemContext;        mFactoryTest = FactoryTest.getMode();        // 第一步        mSystemThread = ActivityThread.currentActivityThread();        mUiContext = mSystemThread.getSystemUiContext();        Slog.i(TAG, &quot;Memory class: &quot; + ActivityManager.staticGetMemoryClass());        mHandlerThread = new ServiceThread(TAG,                THREAD_PRIORITY_FOREGROUND, false /*allowIo*/);        mHandlerThread.start();        mHandler = new MainHandler(mHandlerThread.getLooper());        mUiHandler = mInjector.getUiHandler(this);        mProcStartHandlerThread = new ServiceThread(TAG + &quot;:procStart&quot;,                THREAD_PRIORITY_FOREGROUND, false /* allowIo */);        mProcStartHandlerThread.start();        mProcStartHandler = new Handler(mProcStartHandlerThread.getLooper());        mConstants = new ActivityManagerConstants(mContext, this, mHandler);        final ActiveUids activeUids = new ActiveUids(this, true /* postChangesToAtm */);        mPlatformCompat = (PlatformCompat) ServiceManager.getService(                Context.PLATFORM_COMPAT_SERVICE);        mProcessList.init(this, activeUids, mPlatformCompat);        mLowMemDetector = new LowMemDetector(this);        mOomAdjuster = new OomAdjuster(this, mProcessList, activeUids);        // 第二步        // Broadcast policy parameters        final BroadcastConstants foreConstants = new BroadcastConstants(                Settings.Global.BROADCAST_FG_CONSTANTS);        foreConstants.TIMEOUT = BROADCAST_FG_TIMEOUT;        final BroadcastConstants backConstants = new BroadcastConstants(                Settings.Global.BROADCAST_BG_CONSTANTS);        backConstants.TIMEOUT = BROADCAST_BG_TIMEOUT;        final BroadcastConstants offloadConstants = new BroadcastConstants(                Settings.Global.BROADCAST_OFFLOAD_CONSTANTS);        offloadConstants.TIMEOUT = BROADCAST_BG_TIMEOUT;        // by default, no &quot;slow&quot; policy in this queue        offloadConstants.SLOW_TIME = Integer.MAX_VALUE;        mEnableOffloadQueue = SystemProperties.getBoolean(                &quot;persist.device_config.activity_manager_native_boot.offload_queue_enabled&quot;, false);        mFgBroadcastQueue = new BroadcastQueue(this, mHandler,                &quot;foreground&quot;, foreConstants, false);        mBgBroadcastQueue = new BroadcastQueue(this, mHandler,                &quot;background&quot;, backConstants, true);        mOffloadBroadcastQueue = new BroadcastQueue(this, mHandler,                &quot;offload&quot;, offloadConstants, true);        mBroadcastQueues[0] = mFgBroadcastQueue;        mBroadcastQueues[1] = mBgBroadcastQueue;        mBroadcastQueues[2] = mOffloadBroadcastQueue;        // 第三步        mServices = new ActiveServices(this);        mProviderMap = new ProviderMap(this);        mPackageWatchdog = PackageWatchdog.getInstance(mUiContext);        mAppErrors = new AppErrors(mUiContext, this, mPackageWatchdog);        // 第四步        final File systemDir = SystemServiceManager.ensureSystemDir();        // TODO: Move creation of battery stats service outside of activity manager service.        mBatteryStatsService = new BatteryStatsService(systemContext, systemDir,                BackgroundThread.get().getHandler());        mBatteryStatsService.getActiveStatistics().readLocked();        mBatteryStatsService.scheduleWriteToDisk();        mOnBattery = DEBUG_POWER ? true                : mBatteryStatsService.getActiveStatistics().getIsOnBattery();        mBatteryStatsService.getActiveStatistics().setCallback(this);        mOomAdjProfiler.batteryPowerChanged(mOnBattery);        mProcessStats = new ProcessStatsService(this, new File(systemDir, &quot;procstats&quot;));        mAppOpsService = mInjector.getAppOpsService(new File(systemDir, &quot;appops.xml&quot;), mHandler);        mUgmInternal = LocalServices.getService(UriGrantsManagerInternal.class);        // 第五步        mUserController = new UserController(this);        mPendingIntentController = new PendingIntentController(                mHandlerThread.getLooper(), mUserController);                        if (SystemProperties.getInt(&quot;sys.use_fifo_ui&quot;, 0) != 0) &#123;            mUseFifoUiScheduling = true;        &#125;        mTrackingAssociations = &quot;1&quot;.equals(SystemProperties.get(&quot;debug.track-associations&quot;));        mIntentFirewall = new IntentFirewall(new IntentFirewallInterface(), mHandler);        mActivityTaskManager = atm;        mActivityTaskManager.initialize(mIntentFirewall, mPendingIntentController,                DisplayThread.get().getLooper());        mAtmInternal = LocalServices.getService(ActivityTaskManagerInternal.class);        // 第六步        mProcessCpuThread = new Thread(&quot;CpuTracker&quot;) &#123;            @Override            public void run() &#123;                synchronized (mProcessCpuTracker) &#123;                    mProcessCpuInitLatch.countDown();                    mProcessCpuTracker.init();                &#125;                while (true) &#123;                    try &#123;                        try &#123;                            synchronized(this) &#123;                                final long now = SystemClock.uptimeMillis();                                long nextCpuDelay = (mLastCpuTime.get()+MONITOR_CPU_MAX_TIME)-now;                                long nextWriteDelay = (mLastWriteTime+BATTERY_STATS_TIME)-now;                                //Slog.i(TAG, &quot;Cpu delay=&quot; + nextCpuDelay                                //        + &quot;, write delay=&quot; + nextWriteDelay);                                if (nextWriteDelay &lt; nextCpuDelay) &#123;                                    nextCpuDelay = nextWriteDelay;                                &#125;                                if (nextCpuDelay &gt; 0) &#123;                                    mProcessCpuMutexFree.set(true);                                    this.wait(nextCpuDelay);                                &#125;                            &#125;                        &#125; catch (InterruptedException e) &#123;                        &#125;                        updateCpuStatsNow();                    &#125; catch (Exception e) &#123;                        Slog.e(TAG, &quot;Unexpected exception collecting process stats&quot;, e);                    &#125;                &#125;            &#125;        &#125;;        mHiddenApiBlacklist = new HiddenApiSettings(mHandler, mContext);        Watchdog.getInstance().addMonitor(this);        Watchdog.getInstance().addThread(mHandler);        // bind background threads to little cores        // this is expected to fail inside of framework tests because apps can&#39;t touch cpusets directly        // make sure we&#39;ve already adjusted system_server&#39;s internal view of itself first        updateOomAdjLocked(OomAdjuster.OOM_ADJ_REASON_NONE);        try &#123;            Process.setThreadGroupAndCpuset(BackgroundThread.get().getThreadId(),                    Process.THREAD_GROUP_SYSTEM);            Process.setThreadGroupAndCpuset(                    mOomAdjuster.mAppCompact.mCompactionThread.getThreadId(),                    Process.THREAD_GROUP_SYSTEM);        &#125; catch (Exception e) &#123;            Slog.w(TAG, &quot;Setting background thread cpuset failed&quot;);        &#125;    &#125;</code></pre><p>我总共将 AMS 的实例化过程总体分为了六个步骤：</p><ol><li>构造一些 Context、Handler 和 Thread，如 uiHandler 等，用来处理 UI 相关的工作；</li><li>定义了容纳前台和后台的广播队列，这也说明了 AMS 不仅仅关注 Activity，也负责其他组件状态的管理；</li><li>管理 Service 和 Provider 的对象数组；</li><li>初始化system下面需要的一系列文件目录。例如权限文件、进程状态信息文件等等；</li><li>管理 ActivityStack，也管理 Activity 启动时用到的 Intent 和 flag；</li><li>启动一个线程专门跟进 cpu 当前状态信息，AMS 对当前 cpu 状态了如指掌，可以更加高效的安排其他工作。</li></ol><h2 id="Activity-状态管理"><a href="#Activity-状态管理" class="headerlink" title="Activity 状态管理"></a>Activity 状态管理</h2><p>先提出几个问题，我们根据问题去看下面的部分：</p><blockquote><p>Activity 是如何被创建的？</p><p>Android 是如何管理 Activity 状态的？</p><p>一个 Task 包含一个或者多个 Activity，一个 Stack 包含一个或者多个 Task，这儿引入 ActivityStack，还有ActivityStackSupervisor 负责管理所有的 Stack。那么这些对象都是如何管理的？</p></blockquote><h3 id="Activity-的创建"><a href="#Activity-的创建" class="headerlink" title="Activity 的创建"></a>Activity 的创建</h3><p>我们在<a href="/about-activity/">关于 Activity 的一切</a>这篇文章中讲过，Activity 是由 ActivityThread 创建的实例，那么 ActivityThread 是由谁创建的？AMS 又是如何介入的呢？我们来看一下。</p><p>在前文中讲过，system_server 在它的<code>main()</code>方法中创建了 SystemServer 的实例，并调用了它的<code>run()</code>方法，在这里有这么一段：</p><pre><code class="java">private void run() &#123;    ...    // Initialize the system context.    createSystemContext();    ...&#125;private void createSystemContext() &#123;    ActivityThread activityThread = ActivityThread.systemMain();    mSystemContext = activityThread.getSystemContext();    mSystemContext.setTheme(DEFAULT_SYSTEM_THEME);    final Context systemUiContext = activityThread.getSystemUiContext();    systemUiContext.setTheme(DEFAULT_SYSTEM_THEME);&#125;</code></pre><p>system_server 进程似乎是创建了 ActivityThread 的实例，我们看看<code>ActivityThread.systemMain()</code>方法做了什么：</p><pre><code class="java">final ApplicationThread mAppThread = new ApplicationThread();@UnsupportedAppUsagepublic static ActivityThread systemMain() &#123;    ...    ActivityThread thread = new ActivityThread();    thread.attach(true, 0);    return thread;&#125;private void attach(boolean system, long startSeq) &#123;    ...    // 找到了，AMS 在这里介入了    final IActivityManager mgr = ActivityManager.getService();    try &#123;        mgr.attachApplication(mAppThread, startSeq);    &#125; catch (RemoteException ex) &#123;        throw ex.rethrowFromSystemServer();    &#125;    ...&#125;</code></pre><p>ApplicationThread 是 IApplicationThread.Stub 的子类，而 IApplicationThread 是 AMS 用来与应用进程通讯的接口。</p><p>IActivityManager 是 AMS 的 Binder 接口，应用进程会通过这个接口，用 Binder 机制与 AMS 进行通讯。</p><p>所以，<code>attachApplication()</code>方法一经调用，就将应用进程与 AMS 联系了起来，AMS 就可以管理应用进程中的 Activity 状态了。</p><p>实际上我们仔细看一下 ActivityThread 的代码，我们会发现，AMS 在很多地方都介入了管理，比如下面几处：</p><pre><code class="java">private void handleReceiver(ReceiverData data) &#123;    ...    IActivityManager mgr = ActivityManager.getService();    ...    data.sendFinished(mgr);    ...&#125;private void handleCreateService(CreateServiceData data) &#123;    ...    service.attach(context, this, data.info.name, data.token, app,                    ActivityManager.getService());    ...&#125;private void handleBindService(BindServiceData data) &#123;    ...    if (!data.rebind) &#123;        IBinder binder = s.onBind(data.intent);        ActivityManager.getService().publishService(                data.token, data.intent, binder);    &#125; else &#123;        s.onRebind(data.intent);        ActivityManager.getService().serviceDoneExecuting(                data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0);    &#125;    ...&#125;</code></pre><p>可见，AMS 真的如开头所说，是个多面手，管理了许多 Android 组件的状态与数据。</p><h3 id="ActivityRecord、TaskRecord、ActivityStack"><a href="#ActivityRecord、TaskRecord、ActivityStack" class="headerlink" title="ActivityRecord、TaskRecord、ActivityStack"></a>ActivityRecord、TaskRecord、ActivityStack</h3><p>先来一张图，挑明这三者的关系：</p><p><img src="/img/ams-1587440232.png"></p><ul><li>一个 ActivityStack 中包含多个 TaskRecord</li><li>一个 TaskRecord 中包含一个或多个 ActivityRecord，</li><li>一个 ActivityRecord 就对应着一个 Activity，保存了它的所有信息；同时一个 Activity 可能会生成多个 ActivityRecord，因为由于其启动模式决定了，它有可能被多次启动，会存在多个实例</li></ul><p>那么我们从下往上分析，先来看看 ActivityRecord。</p><h4 id="ActivityRecord"><a href="#ActivityRecord" class="headerlink" title="ActivityRecord"></a>ActivityRecord</h4><blockquote><p>An entry in the history stack, representing an activity.</p></blockquote><p>如代码注释中所言，ActivityRecord 是 Activity 历史栈中的一个条目，代表了一个 Activity。我们看看它比较重要的部分代码：</p><pre><code class="java">// package com.android.server.wm.ActivityRecord.javafinal class ActivityRecord extends ConfigurationContainer &#123;    final ActivityTaskManagerService mAtmService; // owner    final IApplicationToken.Stub appToken; // window manager token    final ActivityInfo info; // all about me    ApplicationInfo appInfo; // information about activity&#39;s app    final Intent intent;    // the original intent that generated us    final ComponentName mActivityComponent;  // the intent component, or target of an alias.    final String taskAffinity; // as per ActivityInfo.taskAffinity    private TaskRecord task;        // the task this is in.    ActivityRecord resultTo; // who started this entry, so will get our reply    final int requestCode;  // code given by requester (resultTo)    int launchMode;         // the launch mode activity attribute.    final ActivityStackSupervisor mStackSupervisor;&#125;</code></pre><h3 id="Android-如何管理-Activity-状态"><a href="#Android-如何管理-Activity-状态" class="headerlink" title="Android 如何管理 Activity 状态"></a>Android 如何管理 Activity 状态</h3><p>先来一张图，我们看看 Activity 的各种生命周期方法是在何时被调用：</p><p><img src="/img/ams-1587435208.jpg"></p><p>这儿写明了回调各个流程的时机，其中包含这对 Activity 状态的处理，这一点非常重要，Android 系统处理的 Activity 很多，我们准确指示当前 Activity 的状态，可以保证 Activity 调用的正确性。</p><p>我们来仔细分析一个事件：Activity 的<code>onPause()</code>事件是如何从触摸屏幕开始触发的。因为触发<code>onPause()</code>的途径有很多种，我们选择一种 —— <strong>按下了 HOME 键</strong>。这是一个非常复杂的过程，我们得一步步来。</p><p>我们在<a href="/view-event-dispatch/">View事件传递机制</a>中提到过，触摸作为一个 InputEvent，由 InputManagerService 来进行处理。</p><p>InputManagerService 此时会收到来自 Native 层的调用：</p><pre><code class="cpp">void NativeInputManager::onPointerDownOutsideFocus(const sp&lt;IBinder&gt;&amp; touchedToken) &#123;    ATRACE_CALL();    JNIEnv* env = jniEnv();    ScopedLocalFrame localFrame(env);    jobject touchedTokenObj = javaObjectForIBinder(env, touchedToken);    env-&gt;CallVoidMethod(mServiceObj, gServiceClassInfo.onPointerDownOutsideFocus, touchedTokenObj);    checkAndClearExceptionFromCallback(env, &quot;onPointerDownOutsideFocus&quot;);&#125;</code></pre><p>调用了它的<code>onPointerDownOutsideFocus()</code>方法：</p><pre><code class="java">// Native callback. private void onPointerDownOutsideFocus(IBinder touchedToken) &#123;    /**     * Notifies window manager that a &#123;@link android.view.MotionEvent#ACTION_DOWN&#125; pointer event     * occurred on a window that did not have focus.     *     * @param touchedToken The token for the window that received the input event.     */    mWindowManagerCallbacks.onPointerDownOutsideFocus(touchedToken);&#125;</code></pre><p>此处的<code>mWindowManagerCallback</code>是 system_server 在<code>startOtherServices()</code>方法中赋值的，代码如下：</p><pre><code class="java">// com.android.server.SystemServer.javaprivate void startOtherServices() &#123;    ...    inputManager = new InputManagerService(context);    ...    wm = WindowManagerService.main(context, inputManager, !mFirstBoot, mOnlyCore,                    new PhoneWindowManager(), mActivityManagerService.mActivityTaskManager);    ...    inputManager.setWindowManagerCallbacks(wm.getInputManagerCallback());&#125;</code></pre><p>所以此处的<code>onPointerDownOutsideFocus()</code>方法将由 InputManagerCallback 来实现：</p><pre><code class="java">// com.android.server.wm.InputManagerCallback.java@Overridepublic void onPointerDownOutsideFocus(IBinder touchedToken) &#123;    // mService 也即 WindowManagerService 的实例，它的 mH 是一个自定义的 Handler 实例    mService.mH.obtainMessage(ON_POINTER_DOWN_OUTSIDE_FOCUS, touchedToken).sendToTarget();&#125;</code></pre><pre><code class="java">// com.android.server.wm.WindowManagerService.javaclass H extends Handler &#123;    @Override    public void handleMessage(Message msg) &#123;        switch(msg.what) &#123;            ...            case ON_POINTER_DOWN_OUTSIDE_FOCUS: &#123;                synchronized (mGlobalLock) &#123;                    final IBinder touchedToken = (IBinder) msg.obj;                    onPointerDownOutsideFocusLocked(touchedToken);                &#125;                break;            &#125;            ...        &#125;    &#125;&#125;private void onPointerDownOutsideFocusLocked(IBinder touchedToken) &#123;    ...    handleDisplayFocusChange(touchedWindow);&#125;private void handleDisplayFocusChange(WindowState window) &#123;    final DisplayContent displayContent = window.getDisplayContent();    ...    // For compatibility, only the topmost activity is allowed to be resumed for pre-Q    // app. Ensure the topmost activities are resumed whenever a display is moved to top.    // TODO(b/123761773): Investigate whether we can move this into    // RootActivityContainer#updateTopResumedActivityIfNeeded(). Currently, it is risky    // to do so because it seems possible to resume activities as part of a larger    // transaction and it&#39;s too early to resume based on current order when performing    // updateTopResumedActivityIfNeeded().    displayContent.mAcitvityDisplay.ensureActivitiesVisible(null /* starting */,            0 /* configChanges */, !PRESERVE_WINDOWS, true /* notifyClients */);&#125;</code></pre><p>DisplayContent.mAcitvityDisplay 是一个 ActivityDisplay 类型的变量。一个 ActivityDisplay 表示一块屏幕，一般情况下，ActivityDisplay 在 Android 系统中，都只有一个实例。下面是 ActivityDisplay 的简介，可以回头再看。</p><p>::: tip</p><p><strong>关于 ActivityDisplay</strong></p><p>ActivityDisplay 维护了一个 ActivityStack 的栈，并且有添加和移除的方法</p><pre><code class="java">/** * Exactly one of these classes per Display in the system. Capable of holding zero or more * attached &#123;@link ActivityStack&#125;s. */class ActivityDisplay &#123;    ...    /**     * All of the stacks on this display. Order matters, topmost stack is in front of all other     * stacks, bottommost behind. Accessed directly by ActivityManager package classes. Any calls     * changing the list should also call &#123;@link #onStackOrderChanged()&#125;.     */    final ArrayList&lt;ActivityStack&gt; mStacks = new ArrayList&lt;ActivityStack&gt;();    ...    void addChild(ActivityStack stack, int position) &#123;        if (position == POSITION_BOTTOM) &#123;            position = 0;        &#125; else if (position == POSITION_TOP) &#123;            position = mStacks.size();        &#125;        addStackReferenceIfNeeded(stack);        positionChildAt(stack, position);    &#125;    void removeChild(ActivityStack stack) &#123;        mStacks.remove(stack);        ...        onStackOrderChanged(stack);    &#125;    private void positionChildAt(ActivityStack stack, int position, boolean includingParents,            String updateLastFocusedStackReason) &#123;        ...        final int insertPosition = getTopInsertPosition(stack, position);        mStacks.add(insertPosition, stack);        ...        onStackOrderChanged(stack);    &#125;&#125;</code></pre><p>:::</p><p>我们来看<code>ActivityDisplay.ensureActivitiesVisible()</code>方法的代码：</p><pre><code class="java">void ensureActivitiesVisible(ActivityRecord starting, int configChanges,        boolean preserveWindows, boolean notifyClients) &#123;    for (int stackNdx = getChildCount() - 1; stackNdx &gt;= 0; --stackNdx) &#123;        final ActivityStack stack = getChildAt(stackNdx);        stack.ensureActivitiesVisibleLocked(starting, configChanges, preserveWindows,                notifyClients);    &#125;&#125;</code></pre><p>循环调用了栈内的 ActivityStack 的<code>ensureActivitiesVisibleLocked()</code>方法：</p><pre><code class="java">// com.android.server.vm.ActivityStack.java/** * Ensure visibility with an option to also update the configuration of visible activities. * @see #ensureActivitiesVisibleLocked(ActivityRecord, int, boolean) * @see RootActivityContainer#ensureActivitiesVisible(ActivityRecord, int, boolean) */// TODO: Should be re-worked based on the fact that each task as a stack in most cases.// 由这个 TODO 可以看出，日后 Android 必定会变成一个 task 中只有一个 stack，毕竟大多数情况下是这样的final void ensureActivitiesVisibleLocked(ActivityRecord starting, int configChanges,        boolean preserveWindows, boolean notifyClients) &#123;    ...        for (int taskNdx = mTaskHistory.size() - 1; taskNdx &gt;= 0; --taskNdx) &#123;            ...            final TaskRecord task = mTaskHistory.get(taskNdx);            final ArrayList&lt;ActivityRecord&gt; activities = task.mActivities;            for (int activityNdx = activities.size() - 1; activityNdx &gt;= 0; --activityNdx) &#123;                final ActivityRecord r = activities.get(activityNdx);                ...                r.makeClientVisible();                ...            &#125;&#125;</code></pre><p>来到了<code>ActivityRecord.makeClientVisible()</code>：</p><pre><code class="java">// com.android.server.wm.ActivityRecord.java/** Send visibility change message to the client and pause if needed. */void makeClientVisible() &#123;    ...    makeActiveIfNeeded(null /* activeActivity*/);    ...&#125;/** * Make activity resumed or paused if needed. * @param activeActivity an activity that is resumed or just completed pause action. *                       We won&#39;t change the state of this activity. */boolean makeActiveIfNeeded(ActivityRecord activeActivity) &#123;    if (shouldResumeActivity(activeActivity)) &#123;        return getActivityStack().resumeTopActivityUncheckedLocked(activeActivity /* prev */,                null /* options */);    &#125; else if (shouldPauseActivity(activeActivity)) &#123;        ...    &#125;    return false;&#125;</code></pre><p>又调用了 ActivityStack 的<code>resumeTopActivityUncheckedLocked()</code>方法：</p><pre><code class="java">// com.android.server.wm.ActivityStack.java/** * Ensure that the top activity in the stack is resumed. * * @param prev The previously resumed activity, for when in the process * of pausing; can be null to call from elsewhere. * @param options Activity options. * * @return Returns true if something is being resumed, or false if * nothing happened. * * NOTE: It is not safe to call this method directly as it can cause an activity in a *       non-focused stack to be resumed. *       Use &#123;@link RootActivityContainer#resumeFocusedStacksTopActivities&#125; to resume the *       right activity for the current system state. */@GuardedBy(&quot;mService&quot;)boolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) &#123;    ...    result = resumeTopActivityInnerLocked(prev, options);    ...    return result;&#125;@GuardedBy(&quot;mService&quot;)private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) &#123;    ...    pausing |= startPausingLocked(userLeaving, false, next, false);    ...&#125;</code></pre><!--上一节中我们讲过 ActivityRecord、ActivityClientRecord、Activity 的关系，那么Android系统又是如何利用这层对应关系的呢。比如启动 Activity 时需要令上一个 Activity 执行 onPause() 方法。这时会经历以下方法调用链： ```javaActivityStack.startPausingLocked() IApplicationThread.schudulePauseActivity() ActivityThread.sendMessage() ActivityThread.H.sendMessage(); ActivityThread.H.handleMessage() ActivityThread.handlePauseActivity() ActivityThread.performPauseActivity() Activity.performPause() Activity.onPause() ActivityManagerNative.getDefault().activityPaused(token) ActivityManagerService.activityPaused() ActivityStack.activityPausedLocked() ActivityStack.completePauseLocked()``` --><pre><code class="java">// com.android.server.wm.ActivityStack.javaActivityTaskManagerService mService;final boolean startPausingLocked(boolean userLeaving, boolean uiSleeping,            ActivityRecord resuming, boolean pauseImmediately) &#123;    ...    ActivityRecord prev = mResumedActivity;    ...    if (prev.attachedToProcess()) &#123;        ...        try &#123;            ...            //prev 就是当前获得焦点的 ActivityRecord，现在的目的是令该 ActivityRecord 对应的 Activity 调用 onPause() 方法            ...            mService.getLifecycleManager().scheduleTransaction(prev.app.getThread(),                    prev.appToken, PauseActivityItem.obtain(prev.finishing, userLeaving,                            prev.configChangeFlags, pauseImmediately));        &#125; catch (Exception e) &#123;            ...            mPausingActivity = null;            mLastPausedActivity = null;            mLastNoHistoryActivity = null;        &#125;    &#125; else &#123;        mPausingActivity = null;        mLastPausedActivity = null;        mLastNoHistoryActivity = null;    &#125;    ...&#125;</code></pre><p><code>mService</code>也即 ActivityTaskManagerService，它的<code>getLifecycleManager()</code>获取了一个 ClientLifecycleManager 的内部实例，然后调用它的<code>schedultTransaction()</code>方法。PauseActivityItem 是 ActivityLifecycleItem 的派生类：</p><pre><code class="java">// com.android.server.wm.ActivityStack.javavoid scheduleTransaction(@NonNull IApplicationThread client, @NonNull IBinder activityToken,        @NonNull ActivityLifecycleItem stateRequest) throws RemoteException &#123;    final ClientTransaction clientTransaction = transactionWithState(client, activityToken,            stateRequest);    scheduleTransaction(clientTransaction);&#125;void scheduleTransaction(ClientTransaction transaction) throws RemoteException &#123;    final IApplicationThread client = transaction.getClient();    transaction.schedule();    if (!(client instanceof Binder)) &#123;        // If client is not an instance of Binder - it&#39;s a remote call and at this point it is        // safe to recycle the object. All objects used for local calls will be recycled after        // the transaction is executed on client in ActivityThread.        transaction.recycle();    &#125;&#125;</code></pre><p>ClientTransaction 类是一个 Parcelable，看命名方式，就知道这又涉及到 Binder 通讯了：</p><pre><code class="java">// android.app.servertransaction.ClientTransactionpublic class ClientTransaction implements Parcelable, ObjectPoolItem &#123;    ...    private IApplicationThread mClient;    ...    // 这里的处理分为3步：    // 1. client 端调用 preExecute(ClientTransactionHandler)，将会触发一系列的准备工作，包括设置回调，生命周期管理等等    // 2. 准备传递的消息    // 3. client 端调用 TransactionExecutor.execute(ClientTransaction)，将会执行所有的回调和生命周期方法    public void schedule() throws RemoteException &#123;        mClient.scheduleTransaction(this);    &#125;&#125;</code></pre><p>也即将 pauseActivity 的工作交给了交给了应用进程的 ActivityThread：</p><pre><code class="java">@Overridepublic void scheduleTransaction(ClientTransaction transaction) throws RemoteException &#123;    ActivityThread.this.scheduleTransaction(transaction);&#125;</code></pre><p>但是 ActivityThread 并没有直接处理这个 transaction，而是又调用了<code>scheduleTransaction()</code>这个方法，这个方法来自于它的<strong>抽象父类</strong>ClientTransactionHandler：</p><pre><code class="java">/** * Defines operations that a &#123;@link android.app.servertransaction.ClientTransaction&#125; or its items * can perform on client. * @hide */public abstract class ClientTransactionHandler &#123;    // Schedule phase related logic and handlers.    /** Prepare and schedule transaction for execution. */    void scheduleTransaction(ClientTransaction transaction) &#123;        transaction.preExecute(this);        // H extends Handler， 它定义了 ActivityThread 所需要处理的所有事件的 code        // EXECUTE_TRANSACTION 就是其中之一，代表要转换 Activity 的状态了        // 而 sendMessage 方法由 ActivityThread 方法实现，最终将消息发送到 ActivityThread 的成员变量 mH 中（H类的实例）        sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction);    &#125;&#125;</code></pre><p>我们来看看这个 H 做了什么：</p><pre><code class="java">switch(msg.what) &#123;    ...    case EXECUTE_TRANSACTION:        final ClientTransaction transaction = (ClientTransaction) msg.obj;        mTransactionExecutor.execute(transaction);        if (isSystem()) &#123;            // Client transactions inside system process are recycled on the client side            // instead of ClientLifecycleManager to avoid being cleared before this            // message is handled.            transaction.recycle();        &#125;        // TODO(lifecycler): Recycle locally scheduled transactions.        break;    ...&#125;</code></pre><p>啊。。绕得还真远，又出现了一个 TransactionExecutor 类。这个类的作用是<strong>保证一个 transaction 转换过程能够按照正确的顺序执行</strong>。</p><p>经过一系列调用，最终会运行到它的这一句：</p><pre><code class="java">performLifecycleSequence(r, path, transaction);</code></pre><p>这个方法的定义如下：</p><pre><code class="java">private void performLifecycleSequence(ActivityClientRecord r, IntArray path,                                                  ClientTransaction transaction) &#123;    final int size = path.size();        for (int i = 0, state; i &lt; size; i++) &#123;               state = path.get(i);            switch (state) &#123;                  ...                case ON_PAUSE:                    mTransactionHandler.handlePauseActivity(r.token, false /* finished */,                            false /* userLeaving */, 0 /* configChanges */, mPendingActions,                            &quot;LIFECYCLER_PAUSE_ACTIVITY&quot;);                    break;                ...            &#125;                                               </code></pre><p>绕啊绕啊绕，最终还是绕回了<code>ActivityThread.handlePauseActivity()</code>方法：</p><pre><code class="java">@Overridepublic void handlePauseActivity(IBinder token, boolean finished, boolean userLeaving,        int configChanges, PendingTransactionActions pendingActions, String reason) &#123;    ActivityClientRecord r = mActivities.get(token);    if (r != null) &#123;        if (userLeaving) &#123;            performUserLeavingActivity(r);        &#125;        r.activity.mConfigChangeFlags |= configChanges;        performPauseActivity(r, finished, reason, pendingActions);        // Make sure any pending writes are now committed.        if (r.isPreHoneycomb()) &#123;            QueuedWork.waitToFinish();        &#125;        mSomeActivitiesChanged = true;    &#125;&#125;final Bundle performPauseActivity(ActivityClientRecord r, boolean finished, String reason,            PendingTransactionActions pendingActions) &#123;    ...    // 之前启动Activity时会调用 performLaunchActivity()，并在最后以 token 为 Key，ActivityClientRecord 为 value 保存 ActivityClientRecord。    // 然后到了 performPauseActivity() 中又会根据 token 取出对应 ActivityClientRecord。    // 再调用 ActivityClientRecord 中保存的 activity 的 onPause() 方法    performPauseActivityIfNeeded(r, reason);    ...&#125;private void performPauseActivityIfNeeded(ActivityClientRecord r, String reason) &#123;    ...    mInstrumentation.callActivityOnPause(r.activity);    ...&#125;public class Instrumentation &#123;    public void callActivityOnPause(Activity activity) &#123;        activity.performPause();    &#125;&#125;</code></pre><p>至此，才完成了 Activity 的 pause 过程。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Android Framework </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 面试题合集</title>
      <link href="/2020-04-02/job-interview/"/>
      <url>/2020-04-02/job-interview/</url>
      
        <content type="html"><![CDATA[<p>兔子自己总结的一些面试题。题目会慢慢变多，答案也全部是自己写的，并非网上找的答案。</p><p>还有一篇<a href="/awesome-android-job-interview/">Awesome Android Job Interview</a></p><span id="more"></span><h2 id="Java-部分"><a href="#Java-部分" class="headerlink" title="Java 部分"></a>Java 部分</h2><h3 id="String、StringBuffer、StringBuilder-区别"><a href="#String、StringBuffer、StringBuilder-区别" class="headerlink" title="String、StringBuffer、StringBuilder 区别"></a>String、StringBuffer、StringBuilder 区别</h3><p>String 的值是<strong>不可变</strong>的，对 String 的<strong>每次操作都会生成新的对象</strong>。这会导致效率低，有可能会频繁触发 GC 机制。</p><p>StringBuffer 是<strong>线程安全的，速度较慢</strong>。它使用的方法是在各种操作方法上加上了<code>synchronized</code>关键字。</p><p>StringBuilder 是<strong>线程不安全的，速度较快</strong>。</p><p>StringBuffer 用在有多个线程可能会同时修改同一个字符串时使用。</p><p>StringBuilder 用在某一个线程内部比较合适。</p><h3 id="String-为什么是不可变的？"><a href="#String-为什么是不可变的？" class="headerlink" title="String 为什么是不可变的？"></a>String 为什么是不可变的？</h3><p>我们看看 String 的部分代码就知道了：</p><pre><code class="java">public final class String    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;    /** The value is used for character storage. */    private final char value[];    ... &#125;</code></pre><p>value 一旦被初始化，它的指针指向内存中的地址就不能再改变了。虽然 value 数组本身是可变的，但是 String 类并没有提供任何方法来改变这个私有的成员变量。所以有时<code>substring()</code>看起来似乎是改变了 String 的值，但其实是一着『偷梁换柱』，已经产生了新的对象。</p><p>我们来做个实验：</p><pre><code class="java">String a = &quot;123&quot;;String a = a.substring(1);</code></pre><p>我们 debug 一下，看一下它的对象是否产生了变化。</p><p>当断点卡在第一行时，我们可以看到，a 对象是 515，如下图：</p><div class="center-img"><p><img src="/img/interview-1588327190.png"></p></div><p>当执行完<code>substring()</code>方法后：</p><div class="center-img"><p><img src="/img/interview-1588327213.png"></p></div><p>可见对象已经发生了变化，是 518 了。</p><p>这只是从代码层面解释了为什么 String 不可变。那 Java 这样设计的原因是什么？</p><ol><li><strong>安全层面</strong>。在 JDK 中，Java 的类装载机制通过传递的参数（通常是类名）加载类，这些类名在类路径下，想象一下，假设 String 是可变的，我们通过自定义类装载机制分分钟黑掉应用。如果没有了安全，Java不会走到今天。</li><li><strong>性能层面</strong>。String 不可变的设计出于性能考虑，当然背后的原理是 String Pool，当然 String Pool 不可能使 String 类不可变，不可变的 String 能更好的提高性能。</li><li><strong>线程安全</strong>。如果对象是不可变的，那绝对是线程安全的。</li></ol><h3 id="String-Pool-是什么？"><a href="#String-Pool-是什么？" class="headerlink" title="String Pool 是什么？"></a>String Pool 是什么？</h3><p>JVM为了提升性能和减少内存开销，<strong>避免字符串的重复创建</strong>，其维护了一块特殊的内存空间，即字符串池（String Pool）。字符串池由String类私有的维护。</p><p>我们知道，在Java中有两种创建字符串对象的方式：</p><ol><li>采用字面值的方式赋值</li><li>采用<code>new</code>关键字新建一个字符串对象。</li></ol><p>这两种方式在性能和内存占用方面存在着差别。</p><p>方式一：字面方式赋值。</p><p>当我们采用下面的方式赋值的时候：</p><pre><code class="java">String str = &quot;hello&quot;;String str2 = &quot;hello&quot;;</code></pre><p>JVM首先会去字符串池中查找是否存在<code>&quot;hello&quot;</code>这个对象，如果<strong>不存在</strong>，则在字符串池中<strong>创建</strong><code>&quot;hello&quot;</code>这个对象，然后将池中<code>&quot;hello&quot;</code>这个对象的引用地址返回给字符串常量<code>str</code>，这样<code>str</code>会指向池中<code>&quot;hello&quot;</code>这个字符串对象；如果<strong>存在</strong>，则<strong>不创建</strong>任何对象，直接将池中<code>&quot;hello&quot;</code>这个对象的地址返回，赋给字符串常量。</p><p>如果我现在调用<code>str == str2</code>会得到<code>true</code>。因为创建字符串<code>str2</code>时，在字符串池中已经有了<code>&quot;hello&quot;</code>这个对象，就直接把对象<code>&quot;hello&quot;</code>的引用地址返回给<code>str2</code>，这样<code>str2</code>指向了池中<code>&quot;hello&quot;</code>这个对象，也就是说<code>str</code>和<code>str2</code>指向了同一个对象，<code>str == str2</code>自然就是<code>true</code>。</p><p>方式二：用<code>new</code>关键字创建。</p><pre><code class="java">String str3 = new String(&quot;hello&quot;);String str4 = new String(&quot;hello&quot;);</code></pre><p>采用<code>new</code>关键字新建一个字符串对象时，JVM 首先在字符串池中查找有没有<code>&quot;hello&quot;</code>这个字符串对象，如果<strong>有</strong>，则<strong>不在池中再去创建</strong><code>&quot;hello&quot;</code>这个对象了，直接在<strong>堆中创建</strong>一个<code>&quot;hello&quot;</code>字符串对象，然后将堆中的这个<code>&quot;hello&quot;</code>对象的地址返回赋给引用<code>str3</code>，这样，<code>str3</code>就指向了堆中创建的这个<code>&quot;hello&quot;</code>字符串对象；如果<strong>没有</strong>，则首先在<strong>字符串池中创建一个</strong><code>&quot;hello&quot;</code>字符串对象，然后再在<strong>堆中创建一个</strong><code>&quot;hello&quot;</code>字符串对象，然后将堆中这个<code>&quot;hello&quot;</code>字符串对象的地址返回赋给<code>str3</code>引用，这样，<code>str3</code>指向了堆中创建的这个<code>&quot;hello&quot;</code>字符串对象。</p><p>然鹅，这两个是用<code>new</code>创建的对象，<code>str3</code>和<code>str4</code>指向的必然不是同一个对象，堆中创建的两个<code>&quot;hello&quot;</code>并不是同一块内存区域，所以调用<code>str3 == str4</code>的话，返回的是<code>false</code>。</p><p>诚然，使用字符串池得有个前提条件：String 对象是不可变的。因为这样可以<strong>保证多个引用可以同时指向字符串池中的同一个对象</strong>。如果字符串是可变的，那么一个引用操作改变了对象的值，对其他引用会有影响，这样显然是不合理的。</p><p><strong>优点</strong>：避免了相同内容的字符串的创建，节省了内存，省去了创建相同字符串的时间，同时提升了性能。<br><strong>缺点</strong>：牺牲了 JVM 在常量池中遍历对象所需要的时间，不过其时间成本相比而言比较低。</p><p>值得说明的是，字符串池中维护了共享的字符串对象，这些字符串<strong>不会被 GC 回收</strong>。</p><h3 id="静态代理、动态代理，区别是什么？"><a href="#静态代理、动态代理，区别是什么？" class="headerlink" title="静态代理、动态代理，区别是什么？"></a>静态代理、动态代理，区别是什么？</h3><p>静态代理通常只能代理一个类，每代理一个类，就需要多写一个类，这个类会被编译进 .class 文件中。<br>动态代理是在运行时，获取被代理类的 class 对象，通过 Java 提供的 Proxy 类来获取代理对象。它的本质是用 Class 来制造 Class。</p><h3 id="父类的静态方法能否被子类重写？"><a href="#父类的静态方法能否被子类重写？" class="headerlink" title="父类的静态方法能否被子类重写？"></a>父类的静态方法能否被子类重写？</h3><p>不能。重写指的是<strong>根据运行时对象的类型来决定调用哪个方法，而不是根据编译时的类型</strong>。对于静态方法和静态变量来说，虽然在代码中使用子类对象来进行调用，但是底层上还是使用父类来调用的，静态变量和静态方法在编译的时候就将其与类绑定在一起。既然它们在编译的时候就决定了调用的方法、变量，那就和重写没有关系了。</p><h3 id="单例模式的分类？"><a href="#单例模式的分类？" class="headerlink" title="单例模式的分类？"></a>单例模式的分类？</h3><p><strong>饿汉式</strong>：在类加载时就构建实例，立即初始化：</p><pre><code class="java">/*** 饿汉式（推荐）**/public class Test &#123;        private Test() &#123;&#125;        private static Test instance = new Test();        public Test getInstance() &#123;                return instance;        &#125;&#125;</code></pre><p><strong>优点</strong>：因为类在加载时就构建，所以是<strong>线程安全</strong>的；在类加载的同时已经创建好一个静态对象，<strong>调用时反应速度快</strong>。<br><strong>缺点</strong>：<code>getInstance()</code>可能永远不会执行到，但执行该类的其他静态方法或者加载了该类（class.forName)，那么这个实例仍然会初始化，造成资源浪费。</p><p><strong>懒汉式</strong>：在初次使用时初始化，延迟加载：</p><pre><code class="java">class Test &#123;        private Test() &#123;        &#125;        private static Test instance = null;        public static Test getInstance() &#123;                if (instance == null) &#123;                        instance = new Singleton2();                &#125;                return instance;        &#125;&#125;</code></pre><p><strong>优点</strong>：避免了饿汉式的那种在没有用到的情况下创建事例，资源利用率高，<strong>不执行<code>getInstance()</code>就不会创建实例</strong>，可以执行该类的其他静态方法。<br><strong>缺点</strong>：线程不安全。懒汉式在单个线程中没有问题，但多个线程同时访问的时候就可能同时创建多个实例，而且这多个实例不是同一个对象，虽然后面创建的实例会覆盖先创建的实例，但是还是会存在拿到不同对象的情况。解决这个问题的办法就是加锁<code>synchonized</code>，第一次加载时不够快，多线程使用不必要的同步开销大。</p><p>那么如何构建<strong>线程安全的懒汉式单例</strong>呢？</p><p>第一种思考，在<code>getInstance()</code>上加上个同步锁：</p><pre><code class="java">class Test &#123;    private Test() &#123;    &#125;    private static Test instance = null;    public synchonized static Test getInstance() &#123;        if (instance == null) &#123;                instance = new Singleton2();        &#125;        return instance;    &#125;&#125;</code></pre><p>问题可以得到解决，但是因为<code>synchronized</code>关键字是重量级锁，所以上面代码的效率会比较低。有没有改善方案？</p><p>有。在这里我们引入<strong>双检查锁机制</strong>，在线程安全的同时，又能进一步提高效率：</p><pre><code class="java">public class Test &#123;      private Test() &#123;    &#125;      volatile private static Test instance = null; // 使用 volatile 关键字保证内存可见性    public static Test getInstance() &#123;        if(instance != null)&#123; //懒汉式                return instance;        &#125; else &#123;            synchronized (Test.class) &#123;                if (instance == null)&#123; // 二次检查                    instance = new Test();                &#125;            &#125;        &#125;        return instance;    &#125;&#125;</code></pre><p>这里在声明变量时使用了<code>volatile</code>关键字来保证其线程间的可见性；在同步代码块中使用<strong>二次检查</strong>，以保证其不被重复实例化。集合其二者，这种实现方式既保证了其高效性，也保证了其线程安全性。</p><h3 id="介绍一下注解"><a href="#介绍一下注解" class="headerlink" title="介绍一下注解"></a>介绍一下注解</h3><p>注解是一种类似注释的机制，告诉类如何运行。它可以应用于包、类型、构造方法、方法、成员变量、参数上。</p><p>Java 中的注解分为两大类：<strong>标准注解</strong>和<strong>元注解</strong>。</p><p>标准注解包括：</p><ul><li><code>Override</code>：限定重写父类方法，该注解只能用于方法；</li><li><code>Deprecated</code>：表示该程序元素已过时；</li><li><code>SupressWarnings</code>：抵制编译器的警告。</li></ul><p>元注解包括：</p><ul><li><code>Rention</code>：标记在什么级别保存该注解信息，也即注解的生命周期，如 RentionPolicy.CLASS、RentionPolicy.RUNTIME 等；</li><li><code>Documented</code>：标识是否会被包含在 Javadoc 中；</li><li><code>Target</code>：标识注解的使用范围，如 ElementType.PARAMS、ElementType.FIELD 等；</li><li><code>Inherited</code>：标识该注解可以被子类继承；</li><li><code>Repeatable</code>：标识该注解可以被某个元素重复使用。</li></ul><p>我们还可以自定义注解处理器来实现自己的注解处理方式。通常是自定义一个类，继承自 AbstractProcessor，然后覆写<code>init()</code>和<code>process()</code>方法，然后在 Jar 包的 META-INF/services 文件夹中，放入一个名为<code>javax.annotation.processing.Processor</code>的文件，并在文件中写下自定义类的包名。或者使用 Google 提供的注册处理器的库<code>auto-service</code>。</p><h3 id="Collection-类有哪些子类？"><a href="#Collection-类有哪些子类？" class="headerlink" title="Collection 类有哪些子类？"></a>Collection 类有哪些子类？</h3><p>有 List 和 Set。Map 中也使用到了 Collection。</p><h3 id="List、Set、Map的区别"><a href="#List、Set、Map的区别" class="headerlink" title="List、Set、Map的区别"></a>List、Set、Map的区别</h3><p>List 和 Set 是 Collection 类的子接口。Map 是一个单独接口。</p><p>List：</p><ol><li>允许有重复的对象。</li><li>可以插入多个 null 元素。</li><li>是有序容器，保持了元素的插入顺序。</li><li>常用实现类有 ArrayList（线程不安全）、LinkedList（线程不安全） 和 Vector（线程安全）。</li></ol><p>Set：</p><ol><li>不允许有重复的对象。</li><li>只允许一个 null 元素。</li><li>是无序容器，无法保持取出时的顺序是插入时的顺序。</li><li>常用实现类有 HashSet（哈希表）、LinkedHashSet（链表和哈希表） 和 TreeSet（红黑树）。最流行的是基于 HashMap 实现的 HashSet；TreeSet 还实现了 SortedSet 接口，因此 TreeSet 是一个根据其 compare() 和 compareTo() 的定义进行排序的有序容器。</li></ol><p>Map：</p><ol><li>Map 不是 Collection 的子接口或者实现类，它是一个单独的接口。</li><li>Map 每个节点都持有两个对象，key 和 value。</li><li>Map key 值必须是唯一的，value 不是。</li><li>Map 允许 null value 但只能有一个 null key。</li><li>Map 接口最流行的几个实现类是 HashMap、LinkedHashMap、Hashtable 和 TreeMap。（HashMap、TreeMap最常用）</li></ol><p>使用场景的区别：</p><ol><li>如果你经常会使用 index 来对容器中的元素进行访问，那应该选择 List。如果你已经知道索引了的话，那么 List 的实现类比如 ArrayList 可以提供更快速的访问；如果经常添加删除元素的，那么肯定要选择 LinkedList。</li><li>如果你想容器中的元素能够按照它们插入的次序进行<strong>有序存储</strong>，那么还是 List，因为 List 是一个有序容器，它按照插入顺序进行存储。</li><li>如果你想保证插入元素的<strong>唯一性</strong>，也就是你不想有重复值的出现，那么可以选择一个 Set 的实现类，比如 HashSet、LinkedHashSet 或者 TreeSet。所有 Set 的实现类都遵循了统一约束比如唯一性，而且还提供了额外的特性比如 TreeSet 还是一个 SortedSet，所有存储于 TreeSet 中的元素可以使用 Java 里的 Comparator 或者 Comparable 进行排序。LinkedHashSet 也按照元素的插入顺序对它们进行存储。</li><li>如果你以 key-value 的形式进行数据存储那么 Map 是你正确的选择。你可以根据你的后续需要从 Hashtable、HashMap、TreeMap 中进行选择。</li></ol><p>Collection 家族的关系表如下（并不全）：</p><div class="center-img"><p><img src="/img/interview-1588741365.png"></p></div><h3 id="HashMap-的原理？"><a href="#HashMap-的原理？" class="headerlink" title="HashMap 的原理？"></a>HashMap 的原理？</h3><p>HashMap 是常见的用 key-value 存储的工具类，它的数据结构是<strong>数组+链表</strong>。每次插入新数据时，会使用一个算法去计算它应该插入的 index（<code>key.hashCode &amp; (size - 1)</code>），如果当前位置没有数据，则直接插入，如果有数据，则用链表的形式插入该位置。JDK1.7和JDK1.8有区别，在1.7中使用的是头插法，也就是新插入的数据会替换原来的数据；1.8之后使用的是尾插法，也就是新插入的数据会跟在原来数据的后面。1.7的这种插法，因为改变了数据的顺序，有可能在多个线程插入时造成死循环，而1.8的这种方法就不会造成死循环了。但并不代表它就是线程安全的。如果想要线程安全，可以使用 Hashtable 或者 ConcurrentHashMap。每个 HashMap 默认大小是16，如果超过了它的负载因子（默认是0.75）的话，就会<strong>扩容</strong>。</p><h3 id="HashMap-扩容的过程是怎样的？"><a href="#HashMap-扩容的过程是怎样的？" class="headerlink" title="HashMap 扩容的过程是怎样的？"></a>HashMap 扩容的过程是怎样的？</h3><p>数组的大小改为原来的2倍，所有的数据会重新计算 index 并重新插入。</p><h3 id="那对比一下-Hashtable-和-ConcurrentHashMap？"><a href="#那对比一下-Hashtable-和-ConcurrentHashMap？" class="headerlink" title="那对比一下 Hashtable 和 ConcurrentHashMap？"></a>那对比一下 Hashtable 和 ConcurrentHashMap？</h3><p>Hashtable 只是在<code>put/get</code>方法上加上了<code>synchronized</code>关键字，<strong>并发度比较低</strong>。而 ConcurrentHashMap 在 JDK1.7 中采用了<strong>分段锁</strong>技术，其中 Segment 继承于 ReentrantLock。 每当一个线程占用锁访问一个 Segment 时，不会影响到其他的 Segment。每一个 HashEntry 用<code>volatile</code>来修饰了它的<code>value</code>和<code>next</code>节点，以保证内存可见性。在 JDK1.8 中抛弃了 Segment 机制，使用了 CAS 和 synchronized 机制，将 HashEntry 替换为 Node，并把它的<code>value</code>和<code>next</code>也用<code>volatile</code>来修饰。</p><h3 id="什么是浅拷贝和深拷贝"><a href="#什么是浅拷贝和深拷贝" class="headerlink" title="什么是浅拷贝和深拷贝"></a>什么是浅拷贝和深拷贝</h3><p><strong>浅拷贝：</strong></p><p>对于<strong>基本数据类型</strong>的成员对象，因为基础数据类型是<strong>值传递</strong>的，所以是直接将属性值赋值给新的对象。基础类型的拷贝，其中一个对象修改该值，不会影响另外一个。而对于<strong>引用类型</strong>，比如数组或者类对象，因为引用类型是<strong>引用传递</strong>，所以浅拷贝只是<strong>把内存地址赋值给了成员变量</strong>，它们指向了同一内存空间。改变其中一个，会对另外一个也产生影响。</p><p>简单来说，就是只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存区域，修改新对象时，原对象也会被修改。</p><p>要实现浅拷贝，需要实现 Cloneable 接口，并复写<code>clone()</code>方法。</p><p>浅拷贝会带来一定的安全隐患，因为新旧对象指向的是同一个地内存地址。</p><p><strong>深拷贝：</strong></p><p>对于<strong>基本数据类型</strong>的成员对象，因为基础数据类型是<strong>值传递</strong>的，所以是直接将属性值赋值给新的对象。基础类型的拷贝，其中一个对象修改该值，不会影响另外一个（这一点和浅拷贝一样）。而对于引用类型，比如数组或者类对象，深拷贝会<strong>新建一个对象空间</strong>，然后拷贝里面的内容，所以它们<strong>指向了不同的内存空间</strong>。</p><p>简单来说，就是会创建另外一个一模一样的对象，新旧对象不共享内存，修改新对象不会更改到原对象。</p><p>深拷贝比浅拷贝的速度要慢并且开销较大。</p><p>要实现深拷贝，需要实现 Cloneable 接口，并复写<code>clone()</code>方法。</p><h3 id="介绍一下-GC"><a href="#介绍一下-GC" class="headerlink" title="介绍一下 GC"></a>介绍一下 GC</h3><p>GC 是 Java 的内存回收机制。当堆中有长时间不使用的内存块，GC 就会开始工作回收此部分内存，以供程序创建新的对象使用。</p><p>GC 分为 Minor GC 和 Major GC（Full GC），它们作用的内存区域不同：Minor GC 主要作用于新生代，一个包含 Eden 区、S0 区和 S1 区的内存区域。在进行 Minor GC 时，当前线程将会暂停。Major GC 主要作用于老年代，但是也会回收新生代的内存，这个过程会比较慢。</p><p>判定需要回收的对象的方法是使用<strong>可达性分析法</strong>。为什么不用引用计数法呢？因为引用计数法<strong>会导致循环引用的对象无法被回收</strong>。</p><p>可达性分析是指的，通过一系列被称为 GC Roots 的对象作为起点，从这些节点向下搜索，走过的路径称为<strong>引用链</strong>，如果一个对象到 GC Roots 没有任何引用链相连（不可达），则证明该对象不可用，可以进行回收。GC Roots 有个特点，不可被对象图里的对象所引用，所以不会引起循环引用的问题。</p><p>Minor GC 和 Major GC 触发的时机不相同：</p><ul><li>Minor GC 是当 Eden 区满时触发</li><li>Major GC 有以下几种：<ul><li>调用<code>System.gc()</code>方法</li><li>老年代空间不足</li><li>方法区空间不足</li><li>通过 Minor GC 后进入老年代的平均大小大于老年代的可用内存</li><li>由 Eden 区、S0 区向 S1 区复制时，对象大小大于 S1 可用内存，则把该对象转存到老年代，且该对象大小大于老年代的可用内存</li></ul></li></ul><p>GC 回收的常用算法有四种：</p><ul><li><strong>标记-清除算法</strong>：第一阶段标记不可用对象，第二阶段清除这些对象。不会改变原有数据的位置。会造成内存碎片空间。</li><li><strong>标记-整理算法</strong>：是<strong>标记-清除</strong>的改进版。不同的是，在第二阶段，会将所存活的对象整理到另一个空间，然后把剩下的对象全部清除。不会造成内存碎片，但因为有大量复制，算法效率较低。</li><li><strong>复制算法</strong>：将内存区域划分为相等大小的两部分，只使用一半空间，当需要 GC 时，将存活对象复制到另一半，并将之前的空间清除。不会产生内存碎片，但永远只能使用一半的内存。</li><li><strong>分代收集算法</strong>：主流算法。它会根据对象的生存周期，将堆空间分为新生代和老年代。<strong>新生代</strong>中，每次回收都会有大量对象死去，此时使用<strong>复制算法</strong>；而<strong>老年代</strong>存活率较高，使用<strong>标记-清除</strong>或者<strong>标记-整理</strong>。</li></ul><p>GC 的具体实现是垃圾收集器。</p><p>常用的有 Serial（复制算法，串行）、CMS（标记-清除算法，并发）、G1（标记-整理+复制算法，并发）等。</p><h3 id="强引用、软引用、弱引用、虚引用分别是什么？区别是？"><a href="#强引用、软引用、弱引用、虚引用分别是什么？区别是？" class="headerlink" title="强引用、软引用、弱引用、虚引用分别是什么？区别是？"></a>强引用、软引用、弱引用、虚引用分别是什么？区别是？</h3><p>Java 的引用从强到弱分别是强引用、软引用、弱引用和虚引用。</p><p><strong>强引用（StrongReference）：</strong></p><p>强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器<strong>绝不会回收它</strong>。即便内存空间不足，JVM 宁愿抛出 OutOfMemory，也不会随意回收具有强引用的对象来解决内存不足的问题。如果强引用对象不使用时，需要将其『弱化』从而使 GC 能回收，比如置为 null。</p><p><strong>软引用（SoftReference）：</strong></p><p>如果一个对象只具有软引用，则<strong>内存空间充足时</strong>，垃圾回收器就<strong>不会回收</strong>它；如果<strong>内存空间不足</strong>了，<strong>就会回收</strong>这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。<strong>软引用可用来实现内存敏感的高速缓存。</strong></p><p><strong>弱引用（WeakReference）：</strong></p><p>弱引用与软引用的区别在于：<strong>只具有弱引用的对象拥有更短暂的生命周期</strong>。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。</p><p><strong>虚引用（PhantomReference）：</strong></p><p>虚引用顾名思义，就是形同虚设。与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，<strong>在任何时候都可能被垃圾回收器回收</strong>。</p><p>虚引用与软引用和弱引用的一个区别在于，虚引用<strong>必须和引用队列（ReferenceQueue）联合使用</strong>。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</p><p>一张表格来展示一下四种引用：</p><table><thead><tr><th>引用类型</th><th>被垃圾回收时间</th><th>用途</th><th>生存时间</th></tr></thead><tbody><tr><td>强引用</td><td>从来不会</td><td>对象的一般状态</td><td>JVM停止运行时终止</td></tr><tr><td>软引用</td><td>当内存不足时</td><td>对象缓存</td><td>内存不足时终止</td></tr><tr><td>弱引用</td><td>正常垃圾回收时</td><td>对象缓存</td><td>垃圾回收后终止</td></tr><tr><td>虚引用</td><td>正常垃圾回收时</td><td>跟踪对象的垃圾回收</td><td>垃圾回收后终止</td></tr></tbody></table><h3 id="如何保证线程安全？"><a href="#如何保证线程安全？" class="headerlink" title="如何保证线程安全？"></a>如何保证线程安全？</h3><p>线程安全体现在三个方面：</p><ol><li><p><strong>原子性</strong>：同一时刻只能有一个线程对数据进行操作；</p><p>要保证原子性，可以使用 Java 提供的 Atomic 类，比如 AtomicInteger、AtomicLong 等。它们的原理是基于 CAS（Compare and Set），一种乐观锁。</p><p>也可以使用<code>synchronized</code>关键字。<code>synchronized</code>是一种同步锁，依赖 JVM 实现锁机制，是一种以牺牲性能为代价的方法。它可以修饰四种对象：</p><ul><li>代码块：锁住括号内的对象；</li><li>非静态方法：锁住当前实例；</li><li>静态方法：锁住的是该类的 Class 对象；</li><li>类：锁住的是该类；</li></ul></li><li><p><strong>可见性</strong>：一个线程对主内存的修改可以及时地被其他线程看到；</p><p>保存可见性，可以使用<code>volatile</code>关键字修饰变量。但它不是原子性的，比如像<code>x++</code>这种操作就无法保存其线程安全。</p></li><li><p><strong>有序性</strong>：禁止指令重排。</p><p>要保存有序性，使用<code>synchronized</code>和<code>volatile</code>和 Lock 都可以。</p></li></ol><h3 id="synchronized-和-volatile-有什么区别？"><a href="#synchronized-和-volatile-有什么区别？" class="headerlink" title="synchronized 和 volatile 有什么区别？"></a>synchronized 和 volatile 有什么区别？</h3><ol><li><code>synchronized</code> 保证内存可见性和操作原子性，<code>volatile</code> 保证内存可见性和有序性；</li><li><code>volatile</code> 不需要加锁，比 <code>synchronized</code> 更轻量级；</li><li><code>volatile</code> 不会造成线程的阻塞；<code>synchronized</code> 可能会造成线程的阻塞；</li><li><code>volatile</code> 标记的变量不会被编译器优化，而被 <code>synchronized</code> 标记的部分可以被编译器优化（如指令重排）；</li><li><code>volatile</code> 是变量修饰符，仅能用于变量，而 <code>synchronized</code> 是一个方法或块的修饰符。</li></ol><h3 id="死锁的四个必要条件？如何处理？"><a href="#死锁的四个必要条件？如何处理？" class="headerlink" title="死锁的四个必要条件？如何处理？"></a>死锁的四个必要条件？如何处理？</h3><p>死锁是指<strong>两个或两个以上的进程（线程）在运行过程中因争夺资源而造成的一种僵局</strong>（Deadly-Embrace），若无外力作用，这些进程（线程）都将无法向前推进。</p><p>它产生的四个必要条件是：</p><ol><li><strong>互斥条件</strong>：一个资源每次只能被一个进程使用，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待；</li><li><strong>请求与保持条件</strong>：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放；</li><li><strong>不可剥夺条件</strong>：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)；</li><li><strong>循环等待条件</strong>: 若干进程间形成首尾相接循环等待资源的关系。</li></ol><p>避免死锁的基本思想是：系统对进程发出的每一个系统能够满足的资源申请进行<strong>动态检查</strong>，并根据检查结果决定是否分配资源，如果分配后系统可能发生死锁，则不予分配，否则予以分配，这是一种保证系统不进入死锁状态的动态策略。</p><h3 id="介绍一下线程池"><a href="#介绍一下线程池" class="headerlink" title="介绍一下线程池"></a>介绍一下线程池</h3><p>线程池一般用来限制程序中同一时刻运行的线程数。合理利用线程池有三个好处：</p><ol><li>降低资源消耗。通过重复利用已创建的线程<strong>降低线程创建和销毁造成的消耗</strong>；</li><li>高响应速度。当任务到达时，任务可以不需要等到线程创建就能<strong>立即执行</strong>；</li><li>提高线程的可管理性。使用线程池可以进行统一的<strong>分配，调优和监控</strong>。</li></ol><p>JDK 中提供了ThreadPoolExecutor类，用来创建线程池。线程池中的线程分为两种：<strong>核心线程</strong>和<strong>非核心线程</strong>。核心线程<strong>永远不会被回收</strong>，而<strong>非核心线程在空闲达到一定时间后，就会被回收</strong>，这个时间由构造方法中的<code>keepAliveTime</code>参数来指定。</p><p>新建线程池时，可以指定核心线程数量、线程最大数量、空闲超时时长、阻塞队列类型、回收策略等。</p><p>根据初始化时核心线程数 + 非核心线程数 + 空间超时时长，衍生出了应对不同需求的线程池派生类，如：</p><ul><li>CachedThreadPool：没有核心线程，60秒空闲超时，比较<strong>适合执行很多短期异步的小程序或者负载较轻的服务器</strong>。</li><li>FixedThreadPool：全部是核心线程，非常<strong>适合执行长期任务</strong>。因为所有线程都不会回收，所以能更快地响应执行任务的请求。</li><li>SingleThreadExecutor：只有一个核心线程，<strong>适合一个任务一个任务按顺序执行的场景</strong>。</li></ul><p>向线程池提交任务有两个方法：<code>execute(Runnable)</code>和<code>submit(Callable)</code>。它们的区别是<code>execute()</code>方法执行完后，无法得知任务是否已被执行，而<code>submit()</code>方法会返回一个 Future 用来获取执行结果。</p><p>线程池的终止有两个方法：<code>shutdown()</code>和<code>shutdownNow()</code>。它们都会关闭线程池，区别是<code>shutdown()</code>让线程池不再接收新任务，但已经添加的任务不受影响；<code>shutdownNow()</code>会尝试停止所有正在执行的任务，停止处理正在等待的任务，并返回正在等待的任务的列表。</p><h3 id="抽象类和接口的异同是什么？在什么场景下使用？"><a href="#抽象类和接口的异同是什么？在什么场景下使用？" class="headerlink" title="抽象类和接口的异同是什么？在什么场景下使用？"></a>抽象类和接口的异同是什么？在什么场景下使用？</h3><p><strong>同：</strong> </p><ul><li>它们都不能被实例化。</li><li>接口的实现类和抽象类的子类只有<strong>全部实现了接口或者抽象类中的方法后</strong>才可以被实例化。</li></ul><p><strong>异：</strong> </p><ul><li>jdk1.7 及以前，接口只能定义抽象方法不能实现方法，抽象类既可以定义抽象方法，也可以实现方法；但是，在 jdk1.8 之后，接口中也可以有默认的实现方法了，用 default 关键字修饰；</li><li>类只能继承一个类，但可以实现多个接口；</li><li>接口强调的是<strong>功能</strong>，抽象类强调的是<strong>所属关系</strong>；</li><li>接口中的所有成员变量为 public static final，静态不可修改，当然<strong>必须初始化</strong>。接口中的所有方法都是 public abstract 公开抽象的，而且不能有构造方法。抽象类就比较自由了，和普通的类差不多，可以有抽象方法也可以没有，可以有正常的方法，也可以没有；</li><li>接口表示的是<strong>like a</strong>关系，抽象类表示的是<strong>is a</strong>关系。</li></ul><p>上图：</p><div class="center-img"><p><img src="/img/interview-1588743862.png"></p></div><h4 id="什么时候使用接口？"><a href="#什么时候使用接口？" class="headerlink" title="什么时候使用接口？"></a>什么时候使用接口？</h4><p>因为 Java 只能继承一个类，所以作为继承关系的补充，可以使用接口。同时，把程序模块进行固化的契约，降低耦合。把若干功能拆分出来，按照契约来进行实现和依赖，也即<strong>依赖倒置原则</strong>。定义接口有利于代码的规范，这是<strong>接口分离原则</strong>。</p><h4 id="什么时候使用抽象类？"><a href="#什么时候使用抽象类？" class="headerlink" title="什么时候使用抽象类？"></a>什么时候使用抽象类？</h4><ol><li>需要对类型进行隐藏时。我们可以构造出一个固定的一组行为的抽象描述，一个行为可以有任意个可能的具体实现方式。这个抽象的描述就是抽象类。</li><li>需要对类的行为进行拓展时。这一组任意个可能的具体实现表现为所有可能的子类，模块可以操作一个抽象类，由于模块依赖于一个固定的抽象类，那么他是不允许修改的。同时通过这个抽象类进行派生，拓展此模块的行为功能。</li></ol><h2 id="Android-部分"><a href="#Android-部分" class="headerlink" title="Android 部分"></a>Android 部分</h2><h3 id="介绍一下-Android-的四大组件"><a href="#介绍一下-Android-的四大组件" class="headerlink" title="介绍一下 Android 的四大组件"></a>介绍一下 Android 的四大组件</h3><h4 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h4><p>Activity 是用户操作的可视化界面；负责与用户进行交互并处理事件。要使用它，必须要在 AndroidManifest.xml 中进行注册。它有四种启动模式：standard、singleTop、singleTask 和 singleInstance。它的生命周期是 onCreate - onStart - onResume - onPause - onStop - onDestroy。</p><h4 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h4><p>Service 通常用于在后台处理耗时的逻辑。要使用它，也必须要在 AndroidManifest.xml 中进行注册。启动服务并不会开启一个新的线程，它还是会默认运行在主线程中。它还有一个子类是 IntentService，它包含有一个 HandlerThread，所以可以在子线程中做耗时操作，而不会阻塞主线程。</p><p>启动 Service 的方法有两种：</p><ul><li><code>startService()</code>：这种方法启动的 Service，启动之后就与启动者无关了，哪怕启动者退出了，Service 还会继续运行。</li><li><code>bindService()</code>：这种方法启动的 Service，与启动者的生命周期有关，如果启动者退出，Service 也会挂掉。</li></ul><h4 id="BroadcastReceiver"><a href="#BroadcastReceiver" class="headerlink" title="BroadcastReceiver"></a>BroadcastReceiver</h4><p>广播是一种广泛运用的在应用程序之间传输信息的机制。要使用它，可以在 AndroidManifest.xml 中进行静态注册，也可以使用<code>Context.registerReceiver()</code>方法来动态注册。</p><p>两种注册方式是有区别的：<strong>动态注册广播不是常驻型广播</strong>，也就是说广播跟随 Activity 的生命周期。<strong>静态注册是常驻型</strong>，也就是说当应用程序关闭后，如果有信息广播来，程序也会被系统调用自动运行。</p><p>广播传递数据使用的是 Intent。</p><p>Broadcast 有三种分类：普通广播、有序广播和粘性广播。</p><ul><li>普通广播：这种广播可以依次传递给各个处理器去处理；</li><li>有序广播：这种广播在处理器端的处理顺序是按照处理器的不同优先级来区分的，高优先级的处理器会优先截获这个消息，并且可以将这个消息删除</li><li><del>粘性广播</del>：粘性消息在发送后就一直存在于系统的消息容器里面，等待对应的处理器去处理，如果暂时没有处理器处理这个消息则一直在消息容器里面处于等待状态，粘性广播的Receiver如果被销毁，那么下次重建时会自动接收到消息数据。发送粘性广播需要添加权限：<code>android.permission.BROADCAST_STICKY</code> </li></ul><article class="message message-immersive is-danger">  <div class="message-body">  <i class="fas fa-lightbulb mr-2"></i>    粘性广播在 API 21 中就被移除了，因为这种广播会导致安全问题：<strong>任何人都可以访问和修改它</strong>。  </div></article><p>那么，现在发送广播可以调用以下三种方法：</p><ul><li><code>sendOrderedBroadcast()</code>: 该方法发出的广播只能被一个 receiver 接收到，它处理完成后，会向下一个 receiver 传播一个 result。它也可以直接将广播拦截，让其他的 receiver 无法接收到这个广播。receiver 可以通过调整优先级（<code>android:priority</code>属性）来优先接收该广播。如果几个 receiver 优先级相同，那它们会按照随机顺序获得广播。</li><li><code>sendBroadcast()</code>: 该方法发出的广播能够被所有 receiver 接收到。但是无法保证发出和接收的顺序是一致的。</li><li><code>LocalBroadcastManager.sendBroadcast()</code>: 该方法发出的广播只能被当前 APP 内的 receiver 接收。如果你的广播不需要跨进程，那就使用这个方法，它的效率比较高（因为不需要考虑 IPC），并且安全性也能得到保障。</li></ul><h4 id="Content-Provider"><a href="#Content-Provider" class="headerlink" title="Content Provider"></a>Content Provider</h4><p>ContentProvider 是应用程序间非常通用的共享数据的一种方式，也是Android官方推荐的方式。它通过 uri 来标识其它应用要访问的数据，通过ContentResolver 的增、删、改、查方法实现对共享数据的操作。还可以通过注册 ContentObserver 来监听数据是否发生了变化来对应的刷新页面。</p><p>它有几个主要的方法：</p><ul><li><code>query()</code>：查询指定的数据并返回 Cursor</li><li><code>insert()</code>：添加数据</li><li><code>delete()</code>：删除数据</li><li><code>update()</code>：更新数据</li></ul><p>数据访问的方法<code>insert</code>，<code>delete</code>和<code>update</code>可能被多个线程同时调用，此时必须是线程安全的。</p><h3 id="Activity-的四种启动模式"><a href="#Activity-的四种启动模式" class="headerlink" title="Activity 的四种启动模式"></a>Activity 的四种启动模式</h3><p>分为两类：standard 和 singleTop 为一类，singleTask 和 singleInstance 为一类。</p><p>standard 和 singleTop 启动的 Activity <strong>可多次实例化</strong>。它们的实例可以处于 ActivityStack 中的<strong>任何位置</strong>。相比之下，singleTask 和 singleInstance 只能实例化一次。</p><p><strong>standard</strong>：可以被无限制地创建，每次通过 Intent 去启动这个 Activity，都会创建一个新的实例，并放入 ActivityStack 的栈顶。在 Android 5.0 之前，无论要启动的 Activity 是否跟当前 Activity 属于同一个应用，<strong>都会把目标 Activity 放在当前 Activity 的栈中</strong>。而5.0之后，如果是同一个应用，则放在当前栈，如果不是同一个，则会新建一个栈，将目标 Activity 放入。</p><p><strong>singleTop</strong>：栈顶复用，也就是说，如果在 ActivityStack 的顶部已经有了该 Activity 的实例，就会调用它的<code>onNewIntent</code>方法，而不是再创建一个实例。如果在栈内有该 Activity 的实例，也会再创建一个新的实例，并放入栈顶。</p><p><strong>singleTask</strong>：如果当前系统中已经存在了该种启动模式的 Activity，则将存在该 Activity 的栈置于前台（用户可见），同时调用它的<code>onNewIntent</code>方法。</p><ul><li>如果源 Activity 的目标 Activity 属于同一个应用，目标 Activity 目前还没有实例，那就直接在栈顶创建该 Activity 的实例；如果已经有实例，那么将会清空该 Activity 实例上方的所有其他 Activity，让目标 Activity 处于栈顶位置。</li><li>如果源 Activity 和目标 Activity 不属于同一个应用，如果系统中没有目标 Activity 的实例，则会创建它的任务栈，并创建目标Activity的实例；如果已经有实例，则将存在该 Activity 的栈置于前台（用户可见），并且清空该 Activity 实例上方的所有其他 Activity，让目标 Activity 处于栈顶位置。</li></ul><p><strong>singleInstance</strong>：它几乎和 singleTask 一样，唯一不同的是，持有目标 Activity 的任务栈中只能有目标 Activity 一个 Actvitiy 实例，不能再有别的Activity 实例。</p><h3 id="Activity状态保存与恢复"><a href="#Activity状态保存与恢复" class="headerlink" title="Activity状态保存与恢复"></a>Activity状态保存与恢复</h3><p>比如 Activity A 启动了 Activity B，A 由于某种原因被杀死回收资源了，在 Activity 被杀死之前可以使用<code>Activity.onSaveInstanceState()</code>方法中获取一个 Bundle，这个 Bundle 可以在 A 又重新启动时在<code>onCreate()</code>或者<code>onRestoreInstanceState()</code>方法中使用，用来恢复数据和 UI。</p><p>有些时候，<code>onSaveInstanceState()</code>是不会被调用的，它和<code>onStop()</code>、<code>onPause()</code>等生命周期方法不能混淆。比如当用户从 B 返回 A 的时候，B 中就不会再调用<code>onSaveInstanceState()</code>，因为它的实例已经被销毁，永远不会恢复。</p><p><code>onRestoreInstanceState()</code>会在<code>onStart()</code>方法后被调用。虽然调用<code>onCreate(Bundle)</code>也能达到相同目的，但是使用这个方法的好处是，可以在一些初始化工作完成后，再来恢复数据。</p><h3 id="Activity-A-启动另一个Activity-B-会调用哪些方法？如果B是透明主题的又或则是个DialogActivity呢-？"><a href="#Activity-A-启动另一个Activity-B-会调用哪些方法？如果B是透明主题的又或则是个DialogActivity呢-？" class="headerlink" title="Activity A 启动另一个Activity B 会调用哪些方法？如果B是透明主题的又或则是个DialogActivity呢 ？"></a>Activity A 启动另一个Activity B 会调用哪些方法？如果B是透明主题的又或则是个DialogActivity呢 ？</h3><p>我们不多说，直接做个实验：</p><p>我们在 Activity A 和 B 中，远用如下格式显示生命周期：</p><pre><code class="kotlin">override fun onStart() &#123;    super.onStart()    Log.d(&quot;CodingRabbit&quot;, &quot;Activity A: onStart&quot;)&#125;</code></pre><p>然后看一下跳转时的生命周期流程：</p><pre><code>D/CodingRabbit: Activity A: onPauseD/CodingRabbit: Activity B: onCreateD/CodingRabbit: Activity B: onStartD/CodingRabbit: Activity B: onResumeD/CodingRabbit: Activity A: onStop</code></pre><p>可见并不是 Activity A 的 <code>onPause()</code> 后立即走 <code>onStop()</code>，而是等待 Activity B 的 <code>onResume()</code> 走完后才走。</p><p>接下来我们把 Activity B 换成透明的试试。</p><pre><code class="xml">&lt;style name=&quot;Theme.Custom.Transparent&quot; parent=&quot;Theme.AppCompat.NoActionBar&quot;&gt;    &lt;item name=&quot;android:background&quot;&gt;#33000000&lt;/item&gt;     &lt;item name=&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt;    &lt;item name=&quot;android:windowBackground&quot;&gt;@android:color/transparent&lt;/item&gt;    &lt;item name=&quot;android:colorBackgroundCacheHint&quot;&gt;@null&lt;/item&gt;    &lt;item name=&quot;android:windowIsTranslucent&quot;&gt;true&lt;/item&gt;&lt;/style&gt;&lt;activity android:name=&quot;.ActivityB&quot;            android:theme=&quot;@style/Theme.Custom.Transparent&quot;&gt;</code></pre><p>然后看一下跳转时的生命周期：</p><pre><code>D/CodingRabbit: Activity A: onPauseD/CodingRabbit: Activity B: onCreateD/CodingRabbit: Activity B: onStartD/CodingRabbit: Activity B: onResume</code></pre><p>与上面的区别是，Activity A 并没有走 <code>onStop()</code> 方法。</p><p>按下返回键后：</p><pre><code>D/CodingRabbit: Activity B: onPauseD/CodingRabbit: Activity A: onResumeD/CodingRabbit: Activity B: onStopD/CodingRabbit: Activity B: onDestroy</code></pre><h3 id="说说-Apk-的打包过程？"><a href="#说说-Apk-的打包过程？" class="headerlink" title="说说 Apk 的打包过程？"></a>说说 Apk 的打包过程？</h3><p>先上个图：</p><p><img src="/img/682616-20191129131701331-804618503.png"></p><p>流程基本分为以下几步：</p><ol><li>打包资源文件，生成R.java文件，使用的是 aapt</li><li>处理aidl文件，生成相应的Java文件</li><li>编译项目源代码，生成class文件，使用的是 javac</li><li>转换所有的class文件，生成classes.dex文件，使用的是 dex 工具</li><li>打包生成APK文件，使用的是 apkbuilder</li><li>对APK文件进行签名，使用的是 jarsigner</li><li>对签名后的APK文件进行对齐处理，使用的是 zipalign</li></ol><h3 id="说说-Service-与-Activity-的几种通信方式"><a href="#说说-Service-与-Activity-的几种通信方式" class="headerlink" title="说说 Service 与 Activity 的几种通信方式"></a>说说 Service 与 Activity 的几种通信方式</h3><p>如果是后台、前台 Service，可以通过广播的方式通信；如果是绑定 Service，需要通过 Binder 方式通信；如果是 IntentService，可以直接调用 startService 向 IntentService 发送请求。</p><h3 id="介绍一下-IntentService"><a href="#介绍一下-IntentService" class="headerlink" title="介绍一下 IntentService"></a>介绍一下 IntentService</h3><p>Service 有一个派生类是 IntentService，IntentService 比父类 Service 而言，最大特点是其回调函数<code>onHandleIntent</code>中可以<strong>直接进行耗时操作，不必再开线程</strong>。其原理是 IntentService 利用了 HandlerThread，它<strong>在初始化时已属于工作线程</strong>，所以之后的所有操作都是在工作线程中。IntentService 还有一个特点，就是多次调用 onHandleIntent 函数（也就是有多个耗时任务要执行），多个耗时任务会按<strong>顺序依次执行</strong>。原理是其内置的 Handler <strong>关联了任务队列</strong>，Handler 通过 Looper 取任务执行是顺序执行的。这个特点就能解决多个耗时任务需要顺序依次执行的问题。而如果仅用 Service，开多个线程去执行耗时操作，就很难管理。</p><h3 id="介绍一下-JobScheduler"><a href="#介绍一下-JobScheduler" class="headerlink" title="介绍一下 JobScheduler"></a>介绍一下 JobScheduler</h3><p>JobScheduler 是基于条件执行任务的系统机制，在 Android 5.0 中引入。它的出现是为了解决 Android 对后台任务的限制。它会在特定的条件下执行，可以保证执行，但无法保证执行的时间。</p><p>可以通过新建 JobInfo 并新建一个继承自 JobService 的类，重写<code>onStartJob()</code>和<code>onStopJob()</code>，然后使用 JobScheduler.schedule() 的方式向系统提交任务。JobScheduler 是系统服务，其实例需要通过 <code>Context.getSystemService(Context.JOB_SCHEDULER_SERVICE)</code> 来获取。</p><h3 id="介绍一下-Context-和-ContextWrapper-和-ContextImpl"><a href="#介绍一下-Context-和-ContextWrapper-和-ContextImpl" class="headerlink" title="介绍一下 Context 和 ContextWrapper 和 ContextImpl"></a>介绍一下 Context 和 ContextWrapper 和 ContextImpl</h3><p>ContextWrapper 使用了装饰器模式，它包装了一个 Context，这个 Context 实例会通过<code>ContextWrapper.attachBaseContext()</code>方法来赋值。ContextImpl 是 Context 的具体实现，像调用<code>startActivity()</code>之类的方法都是由它来具体实现的。</p><h3 id="Application-Context-和-Activity-Context-的区别？"><a href="#Application-Context-和-Activity-Context-的区别？" class="headerlink" title="Application Context 和 Activity Context 的区别？"></a>Application Context 和 Activity Context 的区别？</h3><p>Application Context 只有一个实例，无论在何处获取，获取的都是同一个实例；而 Activity Context 获取的是当前 Activtiy 的 Context 实例。</p><p>Application Context 如果要用来启动 Activity，需要添加 FLAG_ACTIVITY_NEW_TASK 标识，以启动一个新的任务栈。Activity Context 可以直接启动 Activity</p><h3 id="介绍一下-AsyncTask"><a href="#介绍一下-AsyncTask" class="headerlink" title="介绍一下 AsyncTask"></a>介绍一下 AsyncTask</h3><p>AsyncTask 是一个适合执行短时任务的工具类，它帮我们处理了 Thread 和 Handler 之间的协作，从而让我们不用直接对这两种类进行操作。它比较适合执行短期任务，如果要执行长时间的任务，那还是使用 Executor、ThreadPoolExecutor 或者 FutureTask。</p><p>使用它需要继承 AsyncTask 类并重写四个方法：</p><ul><li><code>onPreExecute()</code>：任务开始执行前的回调，此时在主线程</li><li><code>doInBackground()</code>：任务开始执行的回调，此时在子线程</li><li><code>onProgressUpdate()</code>：任务有进展时的回调，在主线程</li><li><code>onPostExecute()</code>：任务完成时的回调，在主线程</li></ul><p>AsyncTask 类有三个泛型类：</p><ul><li>Params：参数的类型</li><li>Progress：进度值的单位</li><li>Result：任务结束后返回结果的类型</li></ul><p>它必须要在主线程新建实例，它的任务只会执行一次。</p><p>它的内部实现是采用了线程池机制，每个线程只能执行一个任务，避免了线程不安全的问题。</p><p>它的线程池有两个，分别是<strong>工作线程池</strong>和<strong>备用线程池</strong>。当工作线程无法执行任务时，任务会被放到备用线程池中。方法是通过调用<code>ThreadPoolExecutor.setRejectedExecutionHandler()</code>指定一个 Handler 来处理无法执行的问题。</p><p>工作线程池：该线程池有<strong>1个核心线程</strong>，<strong>最大线程数量为50</strong>，空闲时间为3秒，任务队列使用的是 LinkedBlockingQueue。</p><p>备用线程池：5个核心线程，没有非核心线程，任务队列使用的也是 LinkedBlockingQueue。</p><p>默认情况下，<strong>备用线程池不启用</strong>。</p><h3 id="AsyncTask-有什么不足？"><a href="#AsyncTask-有什么不足？" class="headerlink" title="AsyncTask 有什么不足？"></a>AsyncTask 有什么不足？</h3><p>它的生命周期与 Activity 不是绑定的，导致 Activity 销毁后，AsyncTask 还是会继续执行，直到<code>onPostExecute()</code>，这需要进行额外的处理。还有，如果在执行任务期间，Activity 由于某种原因重新创建了（比如屏幕旋转或销毁又恢复），AsyncTask 执行结束也不会更新 UI 了，甚至还有可能引起<code>NullPointerException</code>。<br>另外，AsyncTask 的线程池数量是 50，后来被修改为 20，所以执行能力有限。</p><h3 id="为什么不能在子线程更新-UI？"><a href="#为什么不能在子线程更新-UI？" class="headerlink" title="为什么不能在子线程更新 UI？"></a>为什么不能在子线程更新 UI？</h3><p>原则上来说，是为了线程安全。</p><p>因为 Android 在访问 UI 时是没有加锁的，如果能在多个线程下访问 UI，则有可能会导致 UI 处于不可预期的状态。如果要给 UI 加锁，会让 UI 控件变得复杂和低效，同时也有可能会引起其他线程的阻塞。所以在 Android 中，每当更新 UI 的时候，会有 layout 过程，这个过程中会调用到<code>ViewRootImpl.checkThread()</code>检查当前线程，如果不是主线程，就会直接抛出异常。</p><p>那么，子线程有能力更新 UI 吗？有。在<code>onCreate()</code>方法中去更新 UI，是可以的，因为这个时候 ViewRootImpl 尚未创建，还没有到 layout 阶段，所以此时是可以修改 UI 的。</p><h3 id="ANR-定位和修正"><a href="#ANR-定位和修正" class="headerlink" title="ANR 定位和修正?"></a>ANR 定位和修正?</h3><p>ANR 的出现是由于主线程的 Looper 无法在规定时间内取出下一条消息导致的。每当发生 ANR，可以在 <code>/data/anr/traces.txt</code> 文件中找到 ANR 产生的代码位置，然后就可以根据它修正。</p><p>同时，尽量避免在 BroadcastReceiver 中进行耗时操作，如果超过10秒，则会引起 ANR。主线程上的阈值是 5 秒。Service 中后台、前台、绑定 Service 分别是 20秒、5秒和200秒。</p><h3 id="有什么方法可以避免-OOM"><a href="#有什么方法可以避免-OOM" class="headerlink" title="有什么方法可以避免 OOM ?"></a>有什么方法可以避免 OOM ?</h3><p>可以从四个方面着手。</p><p>首先是减小对象的内存占用，其次是内存对象的重复利用，然后是避免对象的内存泄露，最后是内存使用策略优化。</p><p>1）使用更加轻量的数据结构</p><p>例如，我们可以考虑使用ArrayMap/SparseArray而不是HashMap等传统数据结构，下图演示了HashMap的简要工作原理，相比起Android系统专门为移动操作系统编写的ArrayMap容器，在大多数情况下，都显示效率低下，更占内存。通常的HashMap的实现方式更加消耗内存，因为它需要一个额外的实例对象来记录Mapping操作。另外，SparseArray更加高效在于他们避免了对key与value的autobox自动装箱，并且避免了装箱后的解箱。</p><p>2）避免在Android里面使用Enum</p><p>3）减小Bitmap对象的内存占用</p><p>Bitmap是一个极容易消耗内存的大胖子，减小创建出来的Bitmap的内存占用是很重要的，通常来说有下面2个措施：</p><p>inSampleSize：缩放比例，在把图片载入内存之前，我们需要先计算出一个合适的缩放比例，避免不必要的大图载入。</p><p>decode format：解码格式，选择ARGB_8888/RBG_565/ARGB_4444/ALPHA_8，存在很大差异。</p><p>4）使用更小的图片</p><p>在设计给到资源图片的时候，我们需要特别留意这张图片是否存在可以压缩的空间，是否可以使用一张更小的图片。尽量使用更小的图片不仅仅可以减少内存的使用，还可以避免出现大量的InflationException。假设有一张很大的图片被XML文件直接引用，很有可能在初始化视图的时候就会因为内存不足而发生InflationException，这个问题的根本原因其实是发生了OOM。</p><p>在Android上面最常用的一个缓存算法是LRU(Least Recently Use)</p><p>5）复用系统自带的资源</p><p>Android系统本身内置了很多的资源，例如字符串/颜色/图片/动画/样式以及简单布局等等，这些资源都可以在应用程序中直接引用。这样做不仅仅可以减少应用程序的自身负重，减小APK的大小，另外还可以一定程度上减少内存的开销，复用性更好。但是也有必要留意Android系统的版本差异性，对那些不同系统版本上表现存在很大差异，不符合需求的情况，还是需要应用程序自身内置进去。</p><p>6）注意在ListView/GridView等出现大量重复子组件的视图里面对ConvertView的复用</p><p>7）Bitmap对象的复用</p><p>在ListView与GridView等显示大量图片的控件里面需要使用LRU的机制来缓存处理好的Bitmap。</p><p>利用inBitmap的高级特性提高Android系统在Bitmap分配与释放执行效率上的提升(3.0以及4.4以后存在一些使用限制上的差异)。使用inBitmap属性可以告知Bitmap解码器去尝试使用已经存在的内存区域，新解码的bitmap会尝试去使用之前那张bitmap在heap中所占据的pixel data内存区域，而不是去问内存重新申请一块区域来存放bitmap。利用这种特性，即使是上千张的图片，也只会仅仅只需要占用屏幕所能够显示的图片数量的内存大小。</p><p>8）避免在onDraw方法里面执行对象的创建</p><p>类似onDraw等频繁调用的方法，一定需要注意避免在这里做创建对象的操作，因为他会迅速增加内存的使用，而且很容易引起频繁的gc，甚至是内存抖动。</p><p>9）StringBuilder</p><p>在有些时候，代码中会需要使用到大量的字符串拼接的操作，这种时候有必要考虑使用StringBuilder来替代频繁的“+”。</p><p>避免对象的内存泄露</p><p>内存对象的泄漏，会导致一些不再使用的对象无法及时释放，这样一方面占用了宝贵的内存空间，很容易导致后续需要分配内存的时候，空闲空间不足而出现OOM。显然，这还使得每级Generation的内存区域可用空间变小，gc就会更容易被触发，容易出现内存抖动，从而引起性能问题。</p><p>10）注意Activity的泄漏</p><p>通常来说，Activity的泄漏是内存泄漏里面最严重的问题，它占用的内存多，影响面广，我们需要特别注意以下两种情况导致的Activity泄漏：</p><p>内部类引用导致Activity的泄漏</p><p>最典型的场景是Handler导致的Activity泄漏，如果Handler中有延迟的任务或者是等待执行的任务队列过长，都有可能因为Handler继续执行而导致Activity发生泄漏。此时的引用关系链是Looper -&gt; MessageQueue -&gt; Message -&gt; Handler -&gt; Activity。为了解决这个问题，可以在UI退出之前，执行remove Handler消息队列中的消息与runnable对象。或者是使用Static + WeakReference的方式来达到断开Handler与Activity之间存在引用关系的目的。</p><p>Activity Context被传递到其他实例中，这可能导致自身被引用而发生泄漏。</p><p>内部类引起的泄漏不仅仅会发生在Activity上，其他任何内部类出现的地方，都需要特别留意！我们可以考虑尽量使用static类型的内部类，同时使用WeakReference的机制来避免因为互相引用而出现的泄露。</p><p>11）考虑使用Application Context而不是Activity Context</p><p>对于大部分非必须使用Activity Context的情况（Dialog的Context就必须是Activity Context），我们都可以考虑使用Application Context而不是Activity的Context，这样可以避免不经意的Activity泄露。</p><p>12）注意临时Bitmap对象的及时回收</p><p>虽然在大多数情况下，我们会对Bitmap增加缓存机制，但是在某些时候，部分Bitmap是需要及时回收的。例如临时创建的某个相对比较大的bitmap对象，在经过变换得到新的bitmap对象之后，应该尽快回收原始的bitmap，这样能够更快释放原始bitmap所占用的空间。</p><p>需要特别留意的是Bitmap类里面提供的createBitmap()方法：</p><p>这个函数返回的bitmap有可能和source bitmap是同一个，在回收的时候，需要特别检查source bitmap与return bitmap的引用是否相同，只有在不等的情况下，才能够执行source bitmap的recycle方法。</p><p>13）注意WebView的泄漏</p><p>Android中的WebView存在很大的兼容性问题，不仅仅是Android系统版本的不同对WebView产生很大的差异，另外不同的厂商出货的ROM里面WebView也存在着很大的差异。更严重的是标准的WebView存在内存泄露的问题，看这里WebView causes memory leak - leaks the parent Activity。所以通常根治这个问题的办法是为WebView开启另外一个进程，通过AIDL与主进程进行通信，WebView所在的进程可以根据业务的需要选择合适的时机进行销毁，从而达到内存的完整释放。</p><p>14）资源文件需要选择合适的文件夹进行存放</p><p>我们知道hdpi/xhdpi/xxhdpi等等不同dpi的文件夹下的图片在不同的设备上会经过scale的处理。例如我们只在hdpi的目录下放置了一张100100的图片，那么根据换算关系，xxhdpi的手机去引用那张图片就会被拉伸到200200。需要注意到在这种情况下，内存占用是会显著提高的。对于不希望被拉伸的图片，需要放到assets或者nodpi的目录下。</p><p>15）谨慎使用static对象</p><p>因为static的生命周期过长，和应用的进程保持一致，使用不当很可能导致对象泄漏，在Android中应该谨慎使用static对象。</p><p>16）特别留意单例对象中不合理的持有</p><p>虽然单例模式简单实用，提供了很多便利性，但是因为单例的生命周期和应用保持一致，使用不合理很容易出现持有对象的泄漏。</p><p>17）珍惜Services资源</p><p>18）优化布局层次，减少内存消耗</p><p>越扁平化的视图布局，占用的内存就越少，效率越高。我们需要尽量保证布局足够扁平化，当使用系统提供的View无法实现足够扁平的时候考虑使用自定义View来达到目的。</p><p>19）谨慎使用“抽象”编程</p><p>很多时候，开发者会使用抽象类作为”好的编程实践”，因为抽象能够提升代码的灵活性与可维护性。然而，抽象会导致一个显著的额外内存开销：他们需要同等量的代码用于可执行，那些代码会被mapping到内存中，因此如果你的抽象没有显著的提升效率，应该尽量避免他们。</p><p>20）谨慎使用多进程</p><p>使用多进程可以把应用中的部分组件运行在单独的进程当中，这样可以扩大应用的内存占用范围，但是这个技术必须谨慎使用，绝大多数应用都不应该贸然使用多进程，一方面是因为使用多进程会使得代码逻辑更加复杂，另外如果使用不当，它可能反而会导致显著增加内存。当你的应用需要运行一个常驻后台的任务，而且这个任务并不轻量，可以考虑使用这个技术。</p><p>一个典型的例子是创建一个可以长时间后台播放的Music Player。如果整个应用都运行在一个进程中，当后台播放的时候，前台的那些UI资源也没有办法得到释放。类似这样的应用可以切分成2个进程：一个用来操作UI，另外一个给后台的Service。</p><h3 id="什么情况导致内存泄漏？"><a href="#什么情况导致内存泄漏？" class="headerlink" title="什么情况导致内存泄漏？"></a>什么情况导致内存泄漏？</h3><p>非静态内部类持有外部类的实例导致内存泄漏。</p><p>Activity 实例被静态实例持有，导致 Activity 无法被释放。</p><p>Cursor 未关闭。</p><p>自定义的监听器未清空。</p><h3 id="介绍一下-LruCache"><a href="#介绍一下-LruCache" class="headerlink" title="介绍一下 LruCache"></a>介绍一下 LruCache</h3><h3 id="Android-线程有没有上限？"><a href="#Android-线程有没有上限？" class="headerlink" title="Android 线程有没有上限？"></a>Android 线程有没有上限？</h3><p>当然有上限。但这个值并不固定的，分配给应用程序的内存空间是有限的，当创建线程消耗的资源大于分配的内存时，就会导致 Out of Memory。</p><h3 id="ListView-重用的是什么？"><a href="#ListView-重用的是什么？" class="headerlink" title="ListView 重用的是什么？"></a>ListView 重用的是什么？</h3><p>ConvertView 是从 AbsListView 的 RecyclerBin 中拿出来的 ScrapView。该 View 在首次 layout 过程时会通过 LayoutInflator 创建，在之后展示在屏幕上时会传入<code>Adapter.getView()</code>中，可以对它进行复用，避免再次渲染。</p><h3 id="屏幕适配的处理技巧都有哪些？"><a href="#屏幕适配的处理技巧都有哪些？" class="headerlink" title="屏幕适配的处理技巧都有哪些？"></a>屏幕适配的处理技巧都有哪些？</h3><ol><li>基于自适应尺寸的 wrap_content、match_parent，weight 避免固定的尺寸单位。</li><li>使用基于控件相对位置的 RelativeLayout，现在更加推荐使用约束布局 ConstraintLayout，对于布局性能以及扁平化更具有优势。</li><li>考虑使用自动拉伸的 .9 图或者使用矢量图，矢量图可以保证图片不受拉伸影响而导致失真。</li><li>布局使用限定符。</li></ol><h3 id="如何实现-ViewPager-Fragment-的懒加载？"><a href="#如何实现-ViewPager-Fragment-的懒加载？" class="headerlink" title="如何实现 ViewPager + Fragment 的懒加载？"></a>如何实现 ViewPager + Fragment 的懒加载？</h3><p>懒加载主要是处理 Fragment 第一次对用户可见、每次对用户可见、每次对用户不可见。在这些时间点交给实现类来做像网络请求、中断、数据处理等。</p><p>Fragment 的生命周期是这样的：<code>onAttach()</code>→<code>onCreate()</code>→<code>onCreatedView()</code>→<code>onActivityCreated()</code>→<code>onStart()</code>→<code>onResume()</code>→<code>onPause()</code>→<code>onStop()</code>→<code>onDestroyView()</code>→<code>onDestroy()</code>→<code>onDetach()</code>。</p><p>在这里面，我们需要关注的是这几个方法：<code>onCreatedView()</code> + <code>onActivityCreated()</code> + <code>onResume</code> + <code>onPause</code> + <code>onDestroyView</code>。还有两个非生命周期方法：<code>setUserVisibleHint()</code> 和 <code>onHiddenChanged()</code>。</p><p>在 ViewPager + Fragment 的配合时，我们在大多数情况下使用的是 FragmentPagerAdapter 或者 FragmentPagerStateAdapter，前者在 Fragment 不见的时候不会走<code>onDetach()</code>方法，而后者会。</p><p>对于 Fragment 的可见状况，我们需要<strong>两个标志位</strong>：**Fragment 创建完成的标志位<code>isViewCreated</code><strong>和</strong>第一次可见的标志位<code>isFirstVisible</code><strong>。对于它不可见的状态，和再次回到可见状态的判断，我们还需要再加一个标志位：</strong><code>currentVisibleState</code>**。</p><h3 id="Recycleview-和-ListView-的区别"><a href="#Recycleview-和-ListView-的区别" class="headerlink" title="Recycleview 和 ListView 的区别"></a>Recycleview 和 ListView 的区别</h3><p>缓存机制不同。ListView 中是 RecyclerBin 类，有 ActiveViews 和 ScrapViews 两个数组，用于存放正显示在屏幕上的 View 和暂时看不见的 View。<strong>它缓存的是 View</strong>。而 RecyclerView 中是 Recycler 类，比 ListView 要多两级缓存，有 AttachedScrapView、CacheViews、支持用户自定义的 ViewCacheExtension 和 RecyclerPool。<strong>它缓存的是 ViewHolder。</strong></p><p>RecyclerView 支持局部刷新，ListView 不支持。</p><h3 id="自定义-View-的流程是什么？"><a href="#自定义-View-的流程是什么？" class="headerlink" title="自定义 View 的流程是什么？"></a>自定义 View 的流程是什么？</h3><p>自定义 View 分为两大块：<strong>自定义控件</strong>和<strong>自定义容器</strong>。</p><p>自定义View必须重写两个构造方法：</p><ul><li>只有 Context 参数的 ，用于在java代码中new对象使用 </li><li>Context + AttributSet。 主要用于解析在 xml 中的自定义属性</li></ul><p>重写三个方法：</p><ul><li><code>onMesure</code>：计算出控件的大小</li><li><code>onLayout</code>：计算出控件的位置 </li><li><code>onDraw</code>：进行绘制  </li></ul><p>布局过程：</p><ol><li>measure过程：调用了<code>measureChildren</code>方法，执行了所有子控件的<code>measure</code>方法测绘出所有的子控件的大小。<br>调用<code>setMeasureDimension</code>方法设置测绘后的大小。</li><li>layout过程：调用<code>requestLayout</code>方法，<code>layout</code>方法。在调用<code>getChildCount</code>方法后获取到子条目数量，用循环遍历出每一个子条目的对象。 通过子控件的<code>layout</code>方法 给子控件设置摆放位置。</li><li>draw过程：首先调用ViewGroup的<code>dispatchDraw()</code>方法绘制ViewGroup。然后调用View中的<code>draw</code>方进行绘制。 </li></ol><h3 id="View-的事件传递机制是怎样的？"><a href="#View-的事件传递机制是怎样的？" class="headerlink" title="View 的事件传递机制是怎样的？"></a>View 的事件传递机制是怎样的？</h3><p>由电信号转换为输入事件，然后交给了 InputManagerService，再交给 WindowInputEventReceiver，最后经过传递交给了 ViewRootImpl 的<code>processPointEvent</code>方法，其中又调用了 DecorView 的<code>dispatchPointerEvent</code>方法，又调用了<code>dispatchTouchEvent</code>方法，该方法在 View 中。同时，DecorView 也重写了<code>dispatchTouchEvent</code>方法，它将事件交给了 Activity，<em>（你问我如何交的？在 Activity 的 <code>onAttach()</code>方法中，就设置了一个 Callback 给 DecorView。）</em> Activity 重写了<code>dispatchTouchEvent</code>方法，在其中调用了 PhoneWindow 的<code>superDispatchTouchEvent</code>方法，PhoneWindow 接着调用了 DecorView 的<code>superDispatchTouchEvent</code>方法，在这个方法里又调用了<code>super.dispatchTouchEvent()</code>，而 DecorView 的 super 其实就是 ViewGroup，也就是兜兜转转交给了 DecorView，再按照分发机制从 ViewGroup 下发到所有的子 View。</p><p><code>ViewGroup.dispatchTouchEvent()</code>会先判断是否要拦截事件，通过<code>onInterceptTouchEvent</code>方法，如果不拦截，就开始给合适的子 View 进行事件的派发，也就是调用子 View 的<code>dispatchTouchEvent</code>。如果有任意一个子 View 消耗此次事件，也即<code>dispatchTouchEvent</code>返回了<code>true</code>，那么派发就中止，表示事件已经被消耗；如果没有任何一个子 View 消耗此次事件，也即所有的子 View 的<code>dispatchTouchEvent</code>都返回了<code>false</code>，那么 ViewGroup 就自己消耗此次事件。如果 ViewGroup 也没有消耗，那就会再向上返回，直到 Activity 的<code>onTouchEvent</code>方法。</p><p><code>View.onTouchEvent()</code>方法是在<code>View.dispatchTouchEvent()</code>中被调用的，返回<code>true</code>表示消耗此次事件，返回<code>false</code>表示不消耗。如果不消耗，那么在同一个事件序列中，就不再接收到事件了。</p><p><code>ViewGroup.onInterceptTouchEvent()</code>方法是在<code>ViewGroup.dispatchTouchEvent()</code>中被调用的，用来判断是否要拦截某个事件。如果当前 ViewGroup 拦截了某个事件，那么在同一个事件序列当中，此方法不会被再次调用，返回结果表示是否拦截当前事件。这个方法只有 ViewGroup 中有，View 中没有。它起到的作用是<strong>分流</strong>，返回<code>false</code>或者返回<code>super.xxx</code>是向下级 View 或者 ViewGroup 传递，返回<code>true</code>是把事件交给自己的<code>onTouchEvent</code>处理。</p><p><strong>ViewGroup默认不拦截任何事件。</strong></p><h3 id="onTouchListener、onTouchEvent、onClickListener的优先级"><a href="#onTouchListener、onTouchEvent、onClickListener的优先级" class="headerlink" title="onTouchListener、onTouchEvent、onClickListener的优先级"></a>onTouchListener、onTouchEvent、onClickListener的优先级</h3><p><code>onTouchListener</code> &gt;&gt; <code>onTouchEvent</code> &gt;&gt; <code>onClickListener</code> &gt;&gt; <code>onClick</code></p><h3 id="Handler、Looper、MessageQueue、Message-的关系"><a href="#Handler、Looper、MessageQueue、Message-的关系" class="headerlink" title="Handler、Looper、MessageQueue、Message 的关系"></a>Handler、Looper、MessageQueue、Message 的关系</h3><p><strong>Message</strong>：负责承载要传递的数据，包括消息的 code，要传递的参数等等。Message 中有个『<strong>池</strong>』的概念，其实就是一个静态变量<code>sPool</code>，它本身包含下一条消息的引用，Message 每次使用<code>obtain()</code>方法拿取的时候，是拿取的队列的头，然后将<code>sPool</code>置为队列的第二个值。这个数据结构是个链表。</p><p><strong>MessageQueue</strong>：负责维护 Message 的生命周期，提供<code>enqueueMessage()</code>和<code>next()</code>两个方法，用来做『进』『出』的操作。Message 如果不用了，那么就把它回收，也就是清空它的内部数据，但是不销毁这个实例，这样下次有新消息的时候，就直接赋值，而不用建立新的 Message 实例，节省内存空间。在『出』操作的时候，还会去判断 Message 的发送时间是不是到了，如果还没到，就等待相应的时间，等到时间到了，取出并返回，这里也是用一个死循环来实现的。同时会有<code>nativePollOnce()</code>方法来实现阻塞，而不是让死循环一直运行。</p><p><strong>Looper</strong>：一个死循环，使用 ThreadLocal 机制去获取当前调用它的线程下的 Looper 实例。prepare 的过程中，会实例化一个 MessageQueue。loop 过程中，会尝试调用<code>MessageQueue.next()</code>方法，来获取 Message，如果有的话，就给取出的 Message 中的 handler 发送消息，让该 handler 来处理这个 Message。如果没有的话，在<code>next()</code>方法中会一直被阻塞。</p><p><strong>Handler</strong>：负责处理 Message。在初始化时可以传入 Looper，那它就会在对应的线程下处理 Message。在调用<code>Handler.post()</code>方法的时候，<strong>新建的 Message 会被 Handler 交给 Looper 中的 MessageQueue</strong>，并使用它的<code>enqueueMessage()</code>添加到<code>Message.next</code>中。</p><h3 id="主线程的-Looper-死循环为什么不会导致-ANR？"><a href="#主线程的-Looper-死循环为什么不会导致-ANR？" class="headerlink" title="主线程的 Looper 死循环为什么不会导致 ANR？"></a>主线程的 Looper 死循环为什么不会导致 ANR？</h3><p>这个问题其实算是偷换概念。</p><p>首先，死循环不是造成 ANR 的必然原因，ANR 是因为<strong>消息队列中的消息没有得到及时处理才造成的</strong>，比如 BroadcastReceiver 的<code>onReceive()</code>方法中处理事务超过了10秒，比如<code>onTouch()</code>事件超过了5秒，才会导致 ANR。</p><p>第二，主线程的 Looper 死循环，最多也就会导致个 OOM，但是<strong>主线程在没有消息时也会休眠、进入阻塞状态</strong>，当有新消息来临时，再被唤醒，分发消息，实际上<strong>对于内存的消耗非常小</strong>。</p><p>第三，如果主线程的 Looper 不循环了，那<code>main()</code>方法就抛出一个异常结束了，就整个应用就退出了。</p><h3 id="Looper-多次-prepare-会不会有问题？"><a href="#Looper-多次-prepare-会不会有问题？" class="headerlink" title="Looper 多次 prepare 会不会有问题？"></a>Looper 多次 prepare 会不会有问题？</h3><p>会。会抛出 RuntimeException：Only one Looper may be created per thread。</p><h3 id="App-点击到-Activity-出现的流程？"><a href="#App-点击到-Activity-出现的流程？" class="headerlink" title="App 点击到 Activity 出现的流程？"></a>App 点击到 Activity 出现的流程？</h3><ol><li>源进程调用<code>startActivity()</code>，最终会调用到<code>Instrumentation.execStartActivity()</code>方法；</li><li>通过 Binder 调用 ActivityTaskManagerService 的<code>startActivity()</code>方法；</li><li>ATMS 会使用 ActivityStack 类和 ActivityStackSupervisor 类来处理 Task 与 Activity 的入栈操作；</li><li>接着在<code>ActivityStackSupervisor.realStartActivityLocked()</code>方法中，使用提交事务的方法，创建一个启动 Activity 的事务，并提交给 ClientLifecycleManager；</li><li>ClientLifecycleManager 会通过 Binder 调用 ActivityThread 的<code>scheduleTransaction()</code>方法，该方法会向 ActivityThread 中的 Handler 发送一个消息；</li><li>Handler 接收消息后，利用 TransactionExecutor 按顺序执行事务；</li><li>在这个『启动 Activity』的事务回调中，又调用了 ActivityThread 的<code>handleLaunchActivity()</code>方法，进而又调用了<code>performLaunchActivity()</code>方法；</li><li>在这个方法中，利用反射创建了 Activity 的实例，如果需要的话，还利用反射创建了 Application 的实例，并调用<code>Activity.attach()</code>方法，创建 PhoneWindow、绑定 Context；</li><li>最后调用了<code>Instrumentation.callActivityOnCreate()</code>方法，执行了 Activity 的<code>onCreate()</code>生命周期方法；</li><li>接着 TransactionExecutor 又开始执行生命周期事务，最后依次调用到<code>onStart()</code>、<code>onResume()</code>。</li></ol><p><a href="https://www.jianshu.com/p/a72c5ccbd150">一个APP从启动到主页面显示经历了哪些过程？</a></p><h3 id="介绍一下-Binder"><a href="#介绍一下-Binder" class="headerlink" title="介绍一下 Binder"></a>介绍一下 Binder</h3><h3 id="介绍一下优化相关的"><a href="#介绍一下优化相关的" class="headerlink" title="介绍一下优化相关的"></a>介绍一下优化相关的</h3><p>启动优化、内存优化、埋点优化等等。</p><h3 id="Serializable-和-Parcelable-有什么不同？"><a href="#Serializable-和-Parcelable-有什么不同？" class="headerlink" title="Serializable 和 Parcelable 有什么不同？"></a>Serializable 和 Parcelable 有什么不同？</h3><p>Serializable 和 Parcelable 都是用来序列化/反序列化，方便将对象在网络上进行传输或本地保存。</p><p>Serializable 是 Java 提供的类，在使用时只需要 implement Serializable，然后声明一个 serialVersionUID 就可以了。</p><p>Parcelable 是 Android 提供的类，在使用时相对复杂。</p><ul><li>类本身要实现 Parcelable 接口</li><li>有一个非空的静态成员变量叫<code>CREATOR</code>，并且它要实现<code>Parcelable.Creator</code>接口<ul><li>覆写<code>createFromParcel(Parcel in)</code>方法</li><li>覆写<code>newArray(int size)</code>方法</li></ul></li><li>覆写<code>describeContents()</code>方法</li><li>覆写<code>writeToParcel(Parcel dest, int flags)</code>方法</li></ul><p>两种类的对比如下：</p><ol><li>Serializable 代码量少，Parcelable 代码量多。</li><li>在内存间传递数据的时候，Parcelable 比 Serializable 性能高、内存开销方面较小，所以推荐使用 Parcelable；而在需要保存数据到本地或者进行网络传输时，使用 Serializable。</li><li>Serializable 在序列化时使用的是<strong>反射</strong>的技术，会产生大量的临时变量，从而引起频繁的 GC。而 Parcelable 方式的实现原理是将一个完整的对象进行<strong>字节化</strong>，而<strong>字节化</strong>之后的每一部分都是 Intent 所支持的数据类型，这样也就实现传递对象的功能了。</li></ol><h3 id="Jetpack-介绍一下"><a href="#Jetpack-介绍一下" class="headerlink" title="Jetpack 介绍一下"></a>Jetpack 介绍一下</h3><p>Jetpack 是一套库，它里面有非常多的由 Google 提供的标准库，比如 Data Binding、Lifecycle、LiveData、Navigation、Room、ViewModel、WorkManager 等。意图将开发中用到的方方面面的第三方库都进行『消灭』。</p><h3 id="排查内存泄漏"><a href="#排查内存泄漏" class="headerlink" title="排查内存泄漏"></a>排查内存泄漏</h3><h3 id="常见的算法"><a href="#常见的算法" class="headerlink" title="常见的算法"></a>常见的算法</h3><h3 id="100-MB的大图如何显示-？"><a href="#100-MB的大图如何显示-？" class="headerlink" title="100 MB的大图如何显示 ？"></a>100 MB的大图如何显示 ？</h3><p>利用 BitmapRegionDecoder —— 区域解码器，有了这个我们就可以自定义一块矩形的区域，然后根据手势来移动矩形区域的位置就能慢慢看到整张图片了。</p><h2 id="Flutter-部分"><a href="#Flutter-部分" class="headerlink" title="Flutter 部分"></a>Flutter 部分</h2>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> 职场 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 Glide 的一切</title>
      <link href="/2020-03-28/glide/"/>
      <url>/2020-03-28/glide/</url>
      
        <content type="html"><![CDATA[<p>Glide 是比较著名的图片加载库之一，类似的库还有 Picasso。这篇文章来讲讲 Glide 是如何加载图片到显示的，并且讲一讲它有哪些设计精妙的地方。</p><p>该文章使用的是 Glide 目前的最新版本<a href="https://search.maven.org/artifact/com.github.bumptech.glide/glide/4.11.0/jar">4.11.0</a>。</p><span id="more"></span><p>我们先看一下 Glide 在4.0+版本的基本用法。</p><pre><code class="java">// 单一 imageviewImageView imageView = (ImageView) findViewById(R.id.my_image_view);Glide.with(this).load(&quot;http://image.url&quot;).into(imageView);// list 中的 imageview@Override public View getView(int position, View recycled, ViewGroup container) &#123;  final ImageView myImageView;  if (recycled == null) &#123;    myImageView = (ImageView) inflater.inflate(R.layout.my_image_view, container, false);  &#125; else &#123;    myImageView = (ImageView) recycled;  &#125;  String url = myUrls.get(position);  Glide    .with(myFragment)    .load(url)    .centerCrop()    .placeholder(R.drawable.loading_spinner)    .into(myImageView);  return myImageView;&#125;</code></pre><p>通过两种调用方式，我们可以看出，Glide 用了非常经典的 Builder 设计模式，将各种参数收集、处理，最后调用<code>into()</code>方法，将图片交给 ImageView。接下来我们来一步步分析。</p><h2 id="with"><a href="#with" class="headerlink" title="with()"></a><code>with()</code></h2><p>首先看<code>Glide.with()</code>方法的源码，该方法有5个重载，大体相同，但也有不同的地方，我们在下面会解释：</p><pre><code class="java">@NonNullpublic static RequestManager with(@NonNull Context context) &#123;    return getRetriever(context).get(context);&#125;@NonNullpublic static RequestManager with(@NonNull Activity activity) &#123;    return getRetriever(activity).get(activity);&#125;@NonNullpublic static RequestManager with(@NonNull FragmentActivity activity) &#123;    return getRetriever(activity).get(activity);&#125;@NonNullpublic static RequestManager with(@NonNull Fragment fragment) &#123;    return getRetriever(fragment.getContext()).get(fragment);&#125;@SuppressWarnings(&quot;deprecation&quot;)@Deprecated@NonNullpublic static RequestManager with(@NonNull android.app.Fragment fragment) &#123;    return getRetriever(fragment.getActivity()).get(fragment);&#125;@NonNullpublic static RequestManager with(@NonNull View view) &#123;    return getRetriever(view.getContext()).get(view);&#125;</code></pre><p>可以看到，<code>with(android.app.Fragment)</code>方法已经被弃用了，取而代之的是<code>with(androidx.fragment.app.Fragment)</code>，我们接下来不再讨论被弃用的这个方法。</p><p>那么，这5个方法，有什么不同呢？</p><p>首先，从它们的传入参数可以看出，它们分别用在 Application 级别、Activity 级别、FragmentActivity 级别、Fragment 级别和 View 级别。</p><p>Application 级别意味着它可以用在 Service 里，甚至 Notification 的 Thumbnail 里。而其他的几个，只能用在主线程的 Activity 的 View 树中。</p><p>需要注意的是，**<code>with(View)</code>方法在 View 没有被<code>attach</code>之前无效**。并且该方法效率较低，不推荐使用。</p><p>接着看看这五个重载方法都调用的<code>getRetriever()</code>方法的代码：</p><pre><code class="java">@NonNullprivate static RequestManagerRetriever getRetriever(@Nullable Context context) &#123;    // context 可能为 null（比如用户就传了个 null），    // 但实际上它只会出现在 Fragment 的生命周期出现错误时    Preconditions.checkNotNull(        context,        &quot;You cannot start a load on a not yet attached View or a Fragment where getActivity() &quot;            + &quot;returns null (which usually occurs when getActivity() is called before the Fragment &quot;            + &quot;is attached or after the Fragment is destroyed).&quot;);    return Glide.get(context).getRequestManagerRetriever();&#125;@NonNullpublic RequestManagerRetriever getRequestManagerRetriever() &#123;    return requestManagerRetriever;&#125;</code></pre><p>可见<code>getRetriever()</code>方法实际上是在获取一个 <strong>RequestManger 的生成器</strong>。我们先把生成器放一边，先看看 Glide 是如何实例化和初始化的：</p><pre><code class="java">// 获取 Glide 的单例@NonNullpublic static Glide get(@NonNull Context context) &#123;    if (glide == null) &#123;        // 解析注解配置生成的类 com.bumptech.glide.GeneratedAppGlideModuleImpl        GeneratedAppGlideModule annotationGeneratedModule =            getAnnotationGeneratedGlideModules(context.getApplicationContext());        synchronized (Glide.class) &#123;            if (glide == null) &#123;                checkAndInitializeGlide(context, annotationGeneratedModule);            &#125;        &#125;    &#125;    return glide;&#125;// 只有拿到了 Glide.class 这个引用的锁才可以调用该方法@GuardedBy(&quot;Glide.class&quot;)private static void checkAndInitializeGlide(    @NonNull Context context, @Nullable GeneratedAppGlideModule generatedAppGlideModule) &#123;    if (isInitializing) &#123;        throw new IllegalStateException(            &quot;You cannot call Glide.get() in registerComponents(),&quot;                + &quot; use the provided Glide instance instead&quot;);    &#125;    isInitializing = true;    initializeGlide(context, generatedAppGlideModule);    isInitializing = false;&#125;@GuardedBy(&quot;Glide.class&quot;)private static void initializeGlide(    @NonNull Context context, @Nullable GeneratedAppGlideModule generatedAppGlideModule) &#123;    initializeGlide(context, new GlideBuilder(), generatedAppGlideModule);&#125;@GuardedBy(&quot;Glide.class&quot;)@SuppressWarnings(&quot;deprecation&quot;)private static void initializeGlide(    @NonNull Context context,    @NonNull GlideBuilder builder,    @Nullable GeneratedAppGlideModule annotationGeneratedModule) &#123;    // 解析 GlideModule 配置    Context applicationContext = context.getApplicationContext();    List&lt;com.bumptech.glide.module.GlideModule&gt; manifestModules = Collections.emptyList();    if (annotationGeneratedModule == null || annotationGeneratedModule.isManifestParsingEnabled()) &#123;        manifestModules = new ManifestParser(applicationContext).parse();    &#125;    if (annotationGeneratedModule != null        &amp;&amp; !annotationGeneratedModule.getExcludedModuleClasses().isEmpty()) &#123;        Set&lt;Class&lt;?&gt;&gt; excludedModuleClasses = annotationGeneratedModule.getExcludedModuleClasses();        Iterator&lt;com.bumptech.glide.module.GlideModule&gt; iterator = manifestModules.iterator();        while (iterator.hasNext()) &#123;            com.bumptech.glide.module.GlideModule current = iterator.next();            if (!excludedModuleClasses.contains(current.getClass())) &#123;                continue;            &#125;            if (Log.isLoggable(TAG, Log.DEBUG)) &#123;                Log.d(TAG, &quot;AppGlideModule excludes manifest GlideModule: &quot; + current);            &#125;            iterator.remove();        &#125;    &#125;    ...    RequestManagerRetriever.RequestManagerFactory factory =        annotationGeneratedModule != null            ? annotationGeneratedModule.getRequestManagerFactory()            : null;    builder.setRequestManagerFactory(factory);    for (com.bumptech.glide.module.GlideModule module : manifestModules) &#123;        module.applyOptions(applicationContext, builder);    &#125;    if (annotationGeneratedModule != null) &#123;        annotationGeneratedModule.applyOptions(applicationContext, builder);    &#125;    // 创建 Glide 实例    Glide glide = builder.build(applicationContext);    for (com.bumptech.glide.module.GlideModule module : manifestModules) &#123;        try &#123;        module.registerComponents(applicationContext, glide, glide.registry);        &#125; catch (AbstractMethodError e) &#123;        throw new IllegalStateException(            &quot;Attempting to register a Glide v3 module. If you see this, you or one of your&quot;                + &quot; dependencies may be including Glide v3 even though you&#39;re using Glide v4.&quot;                + &quot; You&#39;ll need to find and remove (or update) the offending dependency.&quot;                + &quot; The v3 module name is: &quot;                + module.getClass().getName(),            e);        &#125;    &#125;    if (annotationGeneratedModule != null) &#123;        annotationGeneratedModule.registerComponents(applicationContext, glide, glide.registry);    &#125;    applicationContext.registerComponentCallbacks(glide);        // glide 变量的声明方式是 private static volatile Glide glide; 使用了 volatile 关键字保证了可见性    Glide.glide = glide;&#125;</code></pre><p>在初始化工作中，主要是解析了 GlideModule，也即配置。在 Glide 4.0 中，有一个与 3.0 不一样的地方就在这里了：<strong>Glide 的 Module 配置不再是在 Manifest 中注册，而是通过在配置类上注解（@GlideModule）的方式来声明一个配置类</strong>。</p><p>它的使用方法如下：</p><pre><code class="java">@GlideModulepublic class GlideModuleExample extends AppGlideModule &#123;&#125;</code></pre><p>当我们编译时，因为如果要使用 Glide 4.0，我们必须在 app/build.gradle 中这样配置：</p><pre><code class="groovy">implementation &#39;com.github.bumptech.glide:glide:4.11.0&#39;annotationProcessor &#39;com.github.bumptech.glide:compiler:4.11.0&#39;</code></pre><p>也即 glide 有自己的注解处理系统，当我们编译完成后，会生成下面几个类：</p><p><img src="/img/68.png"></p><p>其中就有我们上面提到的<code>com.bumptech.glide.GeneratedAppGlideModuleImpl</code>类。</p><p>配置解析完成后，就通过<code>GlideBuilder.build()</code>方法来创建实例了。创建完成后，将该实例赋给一个静态的 volatile 的变量。来看看<code>build()</code>方法做了些什么：</p><pre><code class="java">@NonNullGlide build(@NonNull Context context) &#123;    // 新建一个源线程的线程池    if (sourceExecutor == null) &#123;        sourceExecutor = GlideExecutor.newSourceExecutor();    &#125;    // 新建一个缓存用的线程池    if (diskCacheExecutor == null) &#123;        diskCacheExecutor = GlideExecutor.newDiskCacheExecutor();    &#125;    // 新建一个动画用的线程池    if (animationExecutor == null) &#123;        animationExecutor = GlideExecutor.newAnimationExecutor();    &#125;    // 基于设备的一些信息设定缓存区域的大小    if (memorySizeCalculator == null) &#123;        memorySizeCalculator = new MemorySizeCalculator.Builder(context).build();    &#125;    // 监听网络状态，如果没有 android.permission.ACCESS_NETWORK_STATE 权限的话，就不监测    if (connectivityMonitorFactory == null) &#123;        connectivityMonitorFactory = new DefaultConnectivityMonitorFactory();    &#125;    // 根据之前获取的缓存区域的大小，决定要用哪种 bitmapPool    if (bitmapPool == null) &#123;        int size = memorySizeCalculator.getBitmapPoolSize();        if (size &gt; 0) &#123;            // 使用 LRU 算法的 Bitmap 池            bitmapPool = new LruBitmapPool(size);        &#125; else &#123;            // 使用空 Bitmap 池            bitmapPool = new BitmapPoolAdapter();        &#125;    &#125;    if (arrayPool == null) &#123;        arrayPool = new LruArrayPool(memorySizeCalculator.getArrayPoolSizeInBytes());    &#125;    if (memoryCache == null) &#123;        memoryCache = new LruResourceCache(memorySizeCalculator.getMemoryCacheSize());    &#125;    if (diskCacheFactory == null) &#123;        diskCacheFactory = new InternalCacheDiskCacheFactory(context);    &#125;    // Engine 用来管理上方初始化的各种线程池和缓存     if (engine == null) &#123;        engine =            new Engine(                memoryCache,                diskCacheFactory,                diskCacheExecutor,                sourceExecutor,                GlideExecutor.newUnlimitedSourceExecutor(),                animationExecutor,                isActiveResourceRetentionAllowed);    &#125;    if (defaultRequestListeners == null) &#123;        defaultRequestListeners = Collections.emptyList();    &#125; else &#123;        defaultRequestListeners = Collections.unmodifiableList(defaultRequestListeners);    &#125;    RequestManagerRetriever requestManagerRetriever =        new RequestManagerRetriever(requestManagerFactory);    return new Glide(        context,        engine,        memoryCache,        bitmapPool,        arrayPool,        requestManagerRetriever,        connectivityMonitorFactory,        logLevel,        defaultRequestOptionsFactory,        defaultTransitionOptions,        defaultRequestListeners,        isLoggingRequestOriginsEnabled,        isImageDecoderEnabledForBitmaps);&#125;</code></pre><p>可见 Glide 在初始化中做了很多的工作。</p><ol><li>首先初始化了3个线程池，分别用来处理线程、LRU缓存、动画</li><li>根据设备的具体信息，初始化缓存区域</li><li>初始化了一个 Engine 的实例用来管理上面实例化的东西</li><li>生成一个 RequestManagerRetriver 的实例，后面会用来获取 RequestManager</li><li>生成 Glide 实例</li></ol><h2 id="load"><a href="#load" class="headerlink" title="load()"></a><code>load()</code></h2><p>在调用with方法获取到RequestManager对象的前提下，调用load方法，并传递我们的url参数，来看下它的源码：</p><p><a href="https://www.cnblogs.com/guanmanman/p/7008259.html">继续看这里</a></p><h2 id="into"><a href="#into" class="headerlink" title="into()"></a><code>into()</code></h2><p><a href="https://www.cnblogs.com/guanmanman/p/7040942.html">继续看这里</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Glide </tag>
            
            <tag> 三方库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Context 和它的朋友们</title>
      <link href="/2020-03-24/context-and-its-friends/"/>
      <url>/2020-03-24/context-and-its-friends/</url>
      
        <content type="html"><![CDATA[<p>在 Android 开发中，最常打交道的就是 Context 了，我们创建 View/ViewGroup 要使用 Context；启动 Activity 需要 Context；新建 Service 需要 Context；哪怕是插件化、组件化开发中，最麻烦的部分也是使用 Context。</p><p>那么，既然这个东西这么重要，我们这篇文章就来说说 Context 与它的朋友们。</p><span id="more"></span><h2 id="Context-介绍"><a href="#Context-介绍" class="headerlink" title="Context 介绍"></a>Context 介绍</h2><p>Context 在英文中的意思是『上下文』，但在 Android 系统中，我更愿意将其称之为『执行环境』。比如创建 View/ViewGroup，我传入 Context，意在告诉 View/ViewGroup，你当前是在什么环境下被创建的，包括你在哪个进程里，包名是啥，pid 是啥，线程 tid 是啥，等等等等。如果没有这个 Context，被创建的 View/ViewGroup 也会发出灵魂三问：我是谁？我在哪儿？我要干什么？<img src="http://img.doutula.com/production/uploads/image/2016/05/22/20160522875204_LXZYPF.jpg" style="width: 120px"></img></p><p>大名鼎鼎的 Activity、Service 都是 Context 的派生类。如果有人有一天问你：Activity 为啥不是直接继承自 Context 的？ContextWrapper 是个啥？ContextImpl 又是个啥？Activity 的 Context 和 Application 的 Context 有啥区别？又有啥相同的地方？我希望你能自信地用这篇文章砸到他脸上，然后说：自己看！！！</p><h2 id="Context-类与相关类"><a href="#Context-类与相关类" class="headerlink" title="Context 类与相关类"></a>Context 类与相关类</h2><p>本人倾情手绘，展示了 Context 相关的类图，请上眼：</p><p><img src="/img/context-1589184230.png"></p><p>？？？不好意思，放错图了，是这个：</p><p><img src="/img/context-1589184470.png"></p><p>我们由上自下来讲讲这些类。</p><h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p>我们先来看看 Android 源码中对于 Context 的定义：</p><blockquote><p>Interface to global information about an application environment.  This is an abstract class whose implementation is provided by the Android system.  It allows access to application-specific resources and classes, as well as up-calls for application-level operations such as launching activities, broadcasting and receiving intents, etc.</p></blockquote><p>大意是 Context 是一个为 App 运行<strong>提供全局信息的接口</strong>（是广义上的接口，不是 interface）。这是一个抽象类，其具体实例由 Android 系统提供。它允许你访问一些 App 指定的资源和类，还有执行一些应用级别的操作比如启动 Activity 啦，广播啦，获取 intent 啦，等等。</p><p>它提供了很多方法，比较常用的有<code>getApplicationContext()</code>，<code>getAssets()</code>，<code>getString(int)</code>，<code>startActivity()</code>，<code>startService()</code>，<code>sendBroadcast()</code>等等等等。</p><p>那么由上面的定义我们知道，Context 是个抽象类，这些方法具体是由谁来实现的？又是何时初始化的？这里我们需要介绍下一个类—— ContextWrapper。</p><h3 id="ContextWrapper"><a href="#ContextWrapper" class="headerlink" title="ContextWrapper"></a>ContextWrapper</h3><p>如果没听过『装饰器模式』的话，可以看一下这一小段，如果你已经熟知『装饰器模式』，则可以温故而知新。</p><p>所谓『装饰器模式』，即给现有的对象提供新的功能，同时又不改变其结构。这种设计模式属性结构型设计，相当于对现有类的一个包装。</p><p>听起来是不是有点像代理？对！与代理十分类似，都是在原有类的基础上对其进行拓展，以达到我们的目的。</p><p>也有人问了，我继承不就完了，干嘛还要使用什么装饰器模式？我们要知道，Java 是单继承，如果你多级包装，子类会越来越多，层级越来越深，而利用装饰器模式则可以优雅解决这个问题。它<strong>动态地给一个对象添加一些额外的职责</strong>。就增加功能来说，装饰器模式相比继承<strong>更为灵活</strong>。</p><p>ContexWrapper 是在何处使用的装饰器模式呢？我们来看看源码：</p><pre><code class="java">public class ContextWrapper extends Context &#123;    Context mBase;    public ContextWrapper(Context base) &#123;        mBase = base;    &#125;</code></pre><p>看到没有，ContextWrapper 中包含了一个 Context 的实例，在后续的方法调用中，全部都会调用<code>mBase.xxx()</code>方法来完成任务：</p><pre><code class="java">@Overridepublic String getPackageName() &#123;    return mBase.getPackageName();&#125;@Overridepublic SharedPreferences getSharedPreferences(String name, int mode) &#123;    return mBase.getSharedPreferences(name, mode);&#125;@Overridepublic Resources getResources() &#123;    return mBase.getResources();    &#125;</code></pre><p>而 Activity、Application、Service 等，则是 ContexWrapper 的具体装饰者，每个人都有每个人的特点。</p><p>在上面的代码中，我们看到，ContextWrapper 中有 Context 类型的对象<code>mBase</code>，这个对象是在何时被传进来的呢？</p><h3 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h3><p>我们以 Application 为例，查看它调用<code>attachBaseContext()</code>的位置：</p><pre><code class="java">// android.app.Application.java@UnsupportedAppUsagefinal void attach(Context context) &#123;    attachBaseContext(context);    mLoadedApk = ContextImpl.getImpl(context).mPackageInfo;&#125;</code></pre><p>我们继续向上找，看谁调用了<code>Application.attach()</code>：</p><pre><code class="java">// android.app.Instrumentation.javastatic public Application newApplication(Class&lt;?&gt; clazz, Context context)        throws InstantiationException, IllegalAccessException,         ClassNotFoundException &#123;    Application app = (Application)clazz.newInstance();    app.attach(context);    return app;&#125;</code></pre><p>这里是使用反射机制获取了 Application 的 class，并新建了实例。那么，继续向上走：</p><pre><code class="java">// android.app.LoadedApk.javapublic Application makeApplication(boolean forceDefaultAppClass,        Instrumentation instrumentation) &#123;    if (mApplication != null) &#123;        return mApplication;    &#125;    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;makeApplication&quot;);    Application app = null;    String appClass = mApplicationInfo.className;    if (forceDefaultAppClass || (appClass == null)) &#123;        appClass = &quot;android.app.Application&quot;;    &#125;    try &#123;        java.lang.ClassLoader cl = getClassLoader();        if (!mPackageName.equals(&quot;android&quot;)) &#123;            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER,                    &quot;initializeJavaContextClassLoader&quot;);            initializeJavaContextClassLoader();            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);        &#125;        ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this); // 1        app = mActivityThread.mInstrumentation.newApplication(                 cl, appClass, appContext);   // 2        appContext.setOuterContext(app);    &#125; catch (Exception e) &#123;        if (!mActivityThread.mInstrumentation.onException(app, e)) &#123;            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);            throw new RuntimeException(                &quot;Unable to instantiate application &quot; + appClass                + &quot;: &quot; + e.toString(), e);        &#125;    &#125;    mActivityThread.mAllApplications.add(app);    mApplication = app;    if (instrumentation != null) &#123;        try &#123;            instrumentation.callApplicationOnCreate(app);  // 3        &#125; catch (Exception e) &#123;            if (!instrumentation.onException(app, e)) &#123;                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);                throw new RuntimeException(                    &quot;Unable to create application &quot; + app.getClass().getName()                    + &quot;: &quot; + e.toString(), e);            &#125;        &#125;    &#125;    // Rewrite the R &#39;constants&#39; for all library apks.    SparseArray&lt;String&gt; packageIdentifiers = getAssets().getAssignedPackageIdentifiers();    final int N = packageIdentifiers.size();    for (int i = 0; i &lt; N; i++) &#123;        final int id = packageIdentifiers.keyAt(i);        if (id == 0x01 || id == 0x7f) &#123;            continue;        &#125;        rewriteRValues(getClassLoader(), packageIdentifiers.valueAt(i), id);    &#125;    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);    return app;&#125;</code></pre><p>可以看到，在这段代码中，主要做了三件事：</p><ol><li>使用<code>ContextImpl.createAppContext()</code>创建了 ContextImpl 的实例</li><li>将 ContextImpl 的实例塞给了 Application </li><li>调用了<code>Application.onCreate()</code>生命周期方法</li></ol><p>那么至此，我们知道了，Application 中的<code>mBase</code>，实际上是 ContextImpl 的实例。这与上面的装饰器模式是不冲突的。</p><h3 id="ContextThemeWrapper"><a href="#ContextThemeWrapper" class="headerlink" title="ContextThemeWrapper"></a>ContextThemeWrapper</h3><p>Activity 直接继承自 ContextThemeWrapper，它是 ContextWrapper 的一个拓展类，里面包含了<strong>主题相关的变量</strong>：</p><pre><code class="java">public class ContextThemeWrapper extends ContextWrapper &#123;    private int mThemeResource;    private Resources.Theme mTheme;    private LayoutInflater mInflater;    private Configuration mOverrideConfiguration;    private Resources mResources;&#125;</code></pre><p>Application 和 Service 都是继承自 ContextWrapper，里面没有包含主题相关的变量，所以，<strong>只有 Activity 能够使用主题资源</strong>。</p><h3 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h3><p>对于 Activity，我们也必须分析一下：</p><p>Activity 中的<code>attachBaseContext()</code>如下：</p><pre><code class="java">@Overrideprotected void attachBaseContext(Context newBase) &#123;    super.attachBaseContext(newBase);    if (newBase != null) &#123;        newBase.setAutofillClient(this);        newBase.setContentCaptureOptions(getContentCaptureOptions());    &#125;&#125;</code></pre><p>而这个方法是在 Activity 创建过程中的重要方法<code>attach()</code>中调用的：</p><pre><code class="java">final void attach(Context context, ActivityThread aThread,            Instrumentation instr, IBinder token, int ident,            Application application, Intent intent, ActivityInfo info,            CharSequence title, Activity parent, String id,            NonConfigurationInstances lastNonConfigurationInstances,            Configuration config, String referrer, IVoiceInteractor voiceInteractor,            Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken) &#123;        attachBaseContext(context);        ...&#125;</code></pre><p>这个方法又是在 ActivityThread 中被调用：</p><pre><code class="java">private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;    ...    ContextImpl appContext = createBaseContextForActivity(r);  // 1    Activity activity = null;    try &#123;        java.lang.ClassLoader cl = appContext.getClassLoader();        activity = mInstrumentation.newActivity(                cl, component.getClassName(), r.intent);  // 2        StrictMode.incrementExpectedActivityCount(activity.getClass());        r.intent.setExtrasClassLoader(cl);        r.intent.prepareToEnterProcess();        if (r.state != null) &#123;            r.state.setClassLoader(cl);        &#125;    &#125; catch (Exception e) &#123;        if (!mInstrumentation.onException(activity, e)) &#123;            throw new RuntimeException(                &quot;Unable to instantiate activity &quot; + component                + &quot;: &quot; + e.toString(), e);        &#125;    &#125;    ...    activity.attach(appContext, this, getInstrumentation(), r.token,                    r.ident, app, r.intent, r.activityInfo, title, r.parent,                    r.embeddedID, r.lastNonConfigurationInstances, config,                    r.referrer, r.voiceInteractor, window, r.configCallback,                    r.assistToken);  // 3    ...    if (r.isPersistable()) &#123;        mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); // 4    &#125; else &#123;        mInstrumentation.callActivityOnCreate(activity, r.state); // 4    &#125;    ...&#125;</code></pre><p>这段代码大体分为4步：</p><ol><li>使用<code>createBaseContextForActivity()</code>方法创建 ContextImpl 实例</li><li>创建 Activity 实例</li><li>调用<code>Activity.attach()</code>将 ContextImpl 实例赋值到 Activity 的<code>mBase</code>成员变量中</li><li>调用<code>Activity.onCreate()</code>生命周期方法</li></ol><h3 id="ContextImpl"><a href="#ContextImpl" class="headerlink" title="ContextImpl"></a>ContextImpl</h3><p>我们在上面知道了 ContextWrapper 中包装的这个 Context 对象，都是 ContextImpl 的实例，那这个类到底为什么如此手眼通天？我们来看看这个类。</p><p>这个类其实就是 Context 抽象类的<strong>具体实现</strong>，与资源、系统服务的通信，全部靠这个类。说这个类对于开发者来说是最重要的类，也不并不过分。它将我们上面提到的诸如<code>startActivity()</code>、<code>getAssets()</code>、<code>getResources()</code>之类的方法都实现了，我们来看看它的部分代码：</p><pre><code class="java">// android.app.ContextImpl.javaclass ContextImpl extends Context &#123;    ...    // 我们获取的 SharedPreference，来自于这儿，具体实现看来是 SharedPreferencesImpl 类，这里不多分析    private static ArrayMap&lt;String, ArrayMap&lt;File, SharedPreferencesImpl&gt;&gt; sSharedPrefsCache;    ...    final @NonNull ActivityThread mMainThread;  // 主线程    final @NonNull LoadedApk mPackageInfo;  // Apk 信息，包含包名、版本号等信息    private @Nullable ClassLoader mClassLoader;  // 加载 ContextImpl 类时使用的 ClassLoader    ...    private @NonNull Resources mResources;  // getResources() 拿到的对象    ...    private Context mOuterContext;   // 持有着外部 Context 的引用，也即 ContextWrapper 的实例    ...    private PackageManager mPackageManager;    ...    private final Object mSync = new Object();    ...    // 几个常用的路径    @GuardedBy(&quot;mSync&quot;)    private File mDatabasesDir;    @GuardedBy(&quot;mSync&quot;)    @UnsupportedAppUsage    private File mPreferencesDir;    @GuardedBy(&quot;mSync&quot;)    private File mFilesDir;    @GuardedBy(&quot;mSync&quot;)    private File mNoBackupFilesDir;    @GuardedBy(&quot;mSync&quot;)    private File mCacheDir;    @GuardedBy(&quot;mSync&quot;)    private File mCodeCacheDir;    ...    @Override    public Context getApplicationContext() &#123;        return (mPackageInfo != null) ?                mPackageInfo.getApplication() : mMainThread.getApplication();    &#125;    ...    @Override    public String getPackageName() &#123;        if (mPackageInfo != null) &#123;            return mPackageInfo.getPackageName();        &#125;        // No mPackageInfo means this is a Context for the system itself,        // and this here is its name.        return &quot;android&quot;;    &#125;    ...    @Override    public void startActivity(Intent intent, Bundle options) &#123;        warnIfCallingFromSystemProcess();        // Calling start activity from outside an activity without FLAG_ACTIVITY_NEW_TASK is        // generally not allowed, except if the caller specifies the task id the activity should        // be launched in. A bug was existed between N and O-MR1 which allowed this to work. We        // maintain this for backwards compatibility.        final int targetSdkVersion = getApplicationInfo().targetSdkVersion;        if ((intent.getFlags() &amp; Intent.FLAG_ACTIVITY_NEW_TASK) == 0                &amp;&amp; (targetSdkVersion &lt; Build.VERSION_CODES.N                        || targetSdkVersion &gt;= Build.VERSION_CODES.P)                &amp;&amp; (options == null                        || ActivityOptions.fromBundle(options).getLaunchTaskId() == -1)) &#123;            throw new AndroidRuntimeException(                    &quot;Calling startActivity() from outside of an Activity &quot;                            + &quot; context requires the FLAG_ACTIVITY_NEW_TASK flag.&quot;                            + &quot; Is this really what you want?&quot;);        &#125;        mMainThread.getInstrumentation().execStartActivity(                getOuterContext(), mMainThread.getApplicationThread(), null,                (Activity) null, intent, -1, options);    &#125;    ...    @Override    public void sendBroadcast(Intent intent) &#123;        warnIfCallingFromSystemProcess();        String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());        try &#123;            intent.prepareToLeaveProcess(this);            ActivityManager.getService().broadcastIntent(                    mMainThread.getApplicationThread(), intent, resolvedType, null,                    Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, false,                    getUserId());        &#125; catch (RemoteException e) &#123;            throw e.rethrowFromSystemServer();        &#125;    &#125;    ...&#125;</code></pre><p>还有很多，就不一一贴出了。</p><p>由这些代码我们现在能知道，我们知道，当我们使用 Context 中的方法时，真正的实现全部都在这里。当然，再具体的工作比如创建新的 Activity 实例，还得交由 ActivityThread 去做，暂且不表。</p><h2 id="getContext-和-getApplicationContext"><a href="#getContext-和-getApplicationContext" class="headerlink" title="getContext() 和 getApplicationContext()"></a>getContext() 和 getApplicationContext()</h2><p>这两个方法似乎在 Activity 和 Application 中都能调用。那他们是同一个对象吗？有什么不同呢？</p><p>由上面 <a href="#application">Application</a> 和 <a href="#activity">Activity</a> 部分我们知道，塞给 Application 和 Activity 的，是<code>new</code>了两次的 ContextImpl 实例，它们显然<strong>不是同一个对象</strong>。</p><p>那他们的区别在哪？先从高一点的层面来说，Application Context 显然无论你在哪儿调用，<strong>获取的都是同一个 ContextImpl 实例</strong>；但 Activity Context 获取的只能是<strong>当前 Activity 的 ContextImpl 实例</strong>，这样一来，一下子就能区分两种 Context 的使用场景。</p><p>如果从底层的角度呢，我们就要分别看看这两个 ContextImpl 创建的过程。在此之前，我先上一段 ContextImpl 的构造函数，方便下面进行对比：</p><pre><code class="java">private ContextImpl(@Nullable ContextImpl container, @NonNull ActivityThread mainThread,        @NonNull LoadedApk packageInfo, @Nullable String splitName,        @Nullable IBinder activityToken, @Nullable UserHandle user, int flags,        @Nullable ClassLoader classLoader, @Nullable String overrideOpPackageName) &#123;    ...&#125;</code></pre><h3 id="Application-中-ContextImpl-的创建过程"><a href="#Application-中-ContextImpl-的创建过程" class="headerlink" title="Application 中 ContextImpl 的创建过程"></a>Application 中 ContextImpl 的创建过程</h3><pre><code class="java">static ContextImpl createAppContext(ActivityThread mainThread, LoadedApk packageInfo,        String opPackageName) &#123;    if (packageInfo == null) throw new IllegalArgumentException(&quot;packageInfo&quot;);    ContextImpl context = new ContextImpl(null, mainThread, packageInfo, null, null, null, 0,            null, opPackageName);    context.setResources(packageInfo.getResources());    return context;&#125;</code></pre><p>可以看到，平淡无奇地调用了 ContextImpl 的构造函数，平淡无奇地给它塞了个 resource，就平淡无奇地返回了。这也就意味着，使用 Application Context 可以获取上下文中所有的基本信息，包括 PackageName、Resources 等。</p><h3 id="Activity-中-ContextImpl-的创建过程"><a href="#Activity-中-ContextImpl-的创建过程" class="headerlink" title="Activity 中 ContextImpl 的创建过程"></a>Activity 中 ContextImpl 的创建过程</h3><pre><code class="java">    static ContextImpl createActivityContext(ActivityThread mainThread,            LoadedApk packageInfo, ActivityInfo activityInfo, IBinder activityToken, int displayId,            Configuration overrideConfiguration) &#123;        if (packageInfo == null) throw new IllegalArgumentException(&quot;packageInfo&quot;);        String[] splitDirs = packageInfo.getSplitResDirs();        ClassLoader classLoader = packageInfo.getClassLoader();        if (packageInfo.getApplicationInfo().requestsIsolatedSplitLoading()) &#123;            Trace.traceBegin(Trace.TRACE_TAG_RESOURCES, &quot;SplitDependencies&quot;);            try &#123;                classLoader = packageInfo.getSplitClassLoader(activityInfo.splitName);                splitDirs = packageInfo.getSplitPaths(activityInfo.splitName);            &#125; catch (NameNotFoundException e) &#123;                // Nothing above us can handle a NameNotFoundException, better crash.                throw new RuntimeException(e);            &#125; finally &#123;                Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);            &#125;        &#125;        ContextImpl context = new ContextImpl(null, mainThread, packageInfo, activityInfo.splitName,                activityToken, null, 0, classLoader, null);        // Clamp display ID to DEFAULT_DISPLAY if it is INVALID_DISPLAY.        displayId = (displayId != Display.INVALID_DISPLAY) ? displayId : Display.DEFAULT_DISPLAY;        final CompatibilityInfo compatInfo = (displayId == Display.DEFAULT_DISPLAY)                ? packageInfo.getCompatibilityInfo()                : CompatibilityInfo.DEFAULT_COMPATIBILITY_INFO;        final ResourcesManager resourcesManager = ResourcesManager.getInstance();        // Create the base resources for which all configuration contexts for this Activity        // will be rebased upon.        context.setResources(resourcesManager.createBaseActivityResources(activityToken,                packageInfo.getResDir(),                splitDirs,                packageInfo.getOverlayDirs(),                packageInfo.getApplicationInfo().sharedLibraryFiles,                displayId,                overrideConfiguration,                compatInfo,                classLoader));        context.mDisplay = resourcesManager.getAdjustedDisplay(displayId,                context.getResources());        return context;    &#125;</code></pre><p>嗯。。明显不一样。一眼就能看出，Activity 的 Context 明显是用心的了好吗！！它里面会有一些与 Display 相关的信息，而 Application 的 Context 则没有。</p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><ol><li><p>似乎还有个<code>getApplication()</code>方法啊？这是个什么鬼？它跟<code>getApplicationContext()</code>有什么区别？</p><p>我们先看一下这两个方法获取的是不是同一个对象：</p><pre><code class="java">Context a = getApplication();Context b = getApplicationContext();System.out.println(a);System.out.println(b);</code></pre><p> 输出如下：</p><pre><code>I/System.out: android.app.Application@206b17eI/System.out: android.app.Application@206b17e</code></pre><p> 看来他们是同一个对象。那么 Android 为何要设计这两种方法，来获取同一个对象呢？我反正是没想明白。我觉得这很有可能是有什么历史原因造成的。虽然目前看来他们返回的是同一个对象，我们也不敢保证将来也会是这样。</p><p> 如果你想要获取在 Mainfest 中注册的那个 Application，你绝对不要调用 getApplicationContext() 然后强转成你的 Application，它俩并不是同一个实例。这也就意味着一件事，如果你在使用 BroadcastReceiver 时，虽然它不是一个 Context 对象，但在它的<code>onReceive()</code>方法中你能拿到 Context，你也只能调用<code>getApplicationContext()</code>方法。</p><p> 若想知道为什么两个是同一个实例，看<a href="https://www.jianshu.com/p/5328b73bb5e1">这篇文章</a>。</p></li><li><p>我们知道，四大组件中也会有 Context 出现（虽然 BroadcastReceiver、Service、ContentProvider 的 Context 是手动塞进去的），那么它们都能做些什么？</p><p> 来张表你就知道了（做成了图片，表会溢出，比较难看）：</p><p> <img src="/img/context-1589205829.png"></p><p> <strong>标注1</strong>：这几种情况下其实也能启动 Activity，但是必须要加上<code>FLAG_ACTIVITY_NEW_TASK</code>标识位，否则会抛出异常。但这种情况下启动 Activity 会让应用看起来『不那么正常』，所以尽量还是避免使用。<br> <strong>标注2</strong>：这几种情况下能正常渲染 Layout，但是使用的是 Android 的默认主题，与系统定义的主题无关了。<br> <strong>标注3</strong>：如果 receiver 是 null 时，可以使用，用于在 Android 4.2 及以上时获取 Sticky Broadcast 的 value。</p></li><li><p><code>getBaseContext()</code>有什么用？</p><p>如果你想在一个 Context 中访问另一个 Context 时使用。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Context </tag>
            
            <tag> Android Framework] </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Binder的一切</title>
      <link href="/2020-03-18/binder/"/>
      <url>/2020-03-18/binder/</url>
      
        <content type="html"><![CDATA[<h1 id="关于Binder的一切"><a href="#关于Binder的一切" class="headerlink" title="关于Binder的一切"></a>关于Binder的一切</h1><p>毫不夸张地说，Binder 是 Android 系统中最重要的特性之一。</p><p>正如其名『粘合剂』所喻，它是系统间各个组件的桥梁，Android 系统的开放式设计也很大程度上得益于这种及其方便的跨进程通信机制。</p><p>理解 Binder 对于理解整个 Android 系统有着非常重要的作用，Android 系统的四大组件，ActivityManagerServer，PackageManagerService 等系统服务无一不与 Binder 挂钩；如果对 Binder 不甚了解，那么就很难了解这些系统机制，从而仅仅浮游与表面，不懂 Binder 你都不好意思说自己会 Android 开发；要深入 Android，Binder 是必须迈出的一步。</p><p>这篇文章将由浅入深搞懂 Binder ：</p><span id="more"></span><ol><li><a href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%9A%84%E5%8E%9F%E7%90%86">多进程通信的原理是什么？</a></li><li><a href="#binder%E4%BB%8B%E7%BB%8D">何为 Binder？</a></li><li><a href="#binder%E5%AF%B9%E6%AF%94%E5%85%B6%E4%BB%96%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E6%B3%95%E7%9A%84%E4%BC%98%E5%8A%BF">为何用 Binder 而不用其他的方法？</a></li><li><a href="#binder%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6">Binder 的通信流程是什么样的？</a></li></ol><p>另外，推荐两篇文章。</p><p><a href="https://blog.csdn.net/universus/article/details/6211589">Binder设计与实现</a></p><p><a href="https://blog.csdn.net/luoshengyang/article/details/6618363">Android进程间通信（IPC）机制Binder简要介绍和学习计划</a></p><p>先看这里，再看这两篇文章，应该就差不多了。</p><h2 id="多进程通信的原理"><a href="#多进程通信的原理" class="headerlink" title="多进程通信的原理"></a>多进程通信的原理</h2><p>因为 Android 基于 Linux ，所以要谈多进行通信，就必须要谈到 Linux 下的多进程。</p><h3 id="进程隔离"><a href="#进程隔离" class="headerlink" title="进程隔离"></a>进程隔离</h3><blockquote><p>进程隔离是为<strong>保护操作系统中进程互不干扰</strong>而设计的一组不同硬件和软件的技术。这个技术是为了避免进程A写入进程B的情况发生。 进程的隔离实现，使用了<strong>虚拟地址空间</strong>。进程A的虚拟地址和进程B的虚拟地址不同，这样就防止进程A将数据信息写入进程B。</p></blockquote><p>以上来自维基百科；操作系统的不同进程之间，数据不共享；对于每个进程来说，它都天真地以为自己独享了整个系统，完全不知道其他进程的存在。因此一个进程需要与另外一个进程通信，需要某种系统机制才能完成。</p><h3 id="用户空间-内核空间"><a href="#用户空间-内核空间" class="headerlink" title="用户空间/内核空间"></a>用户空间/内核空间</h3><p>详细解释可以参考<a href="http://www.linfo.org/kernel_space.html">Kernel Space Definition</a>；简单理解如下：</p><p>Linux Kernel 是操作系统的核心，独立于普通的应用程序，<strong>可以访问受保护的内存空间</strong>，也有访问底层硬件设备的所有权限。</p><p>对于 Kernel 这么一个高安全级别的东西，显然是不容许其它的应用程序随便调用或访问的，所以需要对 Kernel 提供一定的保护机制，这个保护机制用来告诉那些应用程序，你只可以访问某些许可的资源，不许可的资源是拒绝被访问的，于是就把Kernel和上层的应用程序抽象地隔离开，分别称之为<strong>Kernel Space（内核空间）</strong> 和 <strong>User Space（用户空间）</strong>。</p><h3 id="系统调用-内核态-用户态"><a href="#系统调用-内核态-用户态" class="headerlink" title="系统调用/内核态/用户态"></a>系统调用/内核态/用户态</h3><p>虽然从逻辑上抽离出用户空间和内核空间；但是不可避免的的是，总有那么一些用户空间需要访问内核的资源；比如应用程序访问文件，网络是很常见的事情，怎么办呢？</p><blockquote><p>Kernel space can be accessed by user processes only through the use of system calls.</p></blockquote><p>用户空间访问内核空间的唯一方式就是<strong>系统调用</strong>；通过这个统一入口接口，所有的资源访问都是在内核的控制下执行，以免导致对用户程序对系统资源的越权访问，从而保障了系统的安全和稳定。用户软件良莠不齐，要是它们乱搞把系统玩坏了怎么办？因此对于某些特权操作必须交给安全可靠的内核来执行。</p><p>当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于<strong>内核运行态</strong>（或简称为<strong>内核态</strong>）此时处理器处于特权级最高的（0级）内核代码中执行。当进程在执行用户自己的代码时，则称其处于<strong>用户运行态</strong>（用户态）。即此时处理器在特权级最低的（3级）用户代码中运行。处理器在特权等级高的时候才能执行那些特权CPU指令。</p><h3 id="内核模块-驱动"><a href="#内核模块-驱动" class="headerlink" title="内核模块/驱动"></a>内核模块/驱动</h3><p>通过系统调用，用户空间可以访问内核空间，那么如果一个用户空间想与另外一个用户空间进行通信怎么办呢？很自然想到的是让操作系统内核添加支持；传统的 Linux 通信机制，比如 Socket ，管道等都是内核支持的；但是 Binder 并不是 Linux 内核的一部分，它是怎么做到访问内核空间的呢？Linux 的动态可加载内核模块（Loadable Kernel Module，LKM）机制解决了这个问题。</p><p><strong>模块</strong>是具有独立功能的程序，它可以被单独编译，但不能独立运行。它在运行时被链接到内核作为内核的一部分在内核空间运行。这样，Android系统可以通过添加一个内核模块运行在内核空间，用户进程之间的通过这个模块作为桥梁，就可以完成通信了。</p><p>在 Android 系统中，这个运行在内核空间的，负责各个用户进程通过 Binder 通信的内核模块叫做 <strong>Binder驱动</strong>;</p><p>驱动程序一般指的是设备驱动程序（Device Driver），是一种可以使计算机和设备通信的特殊程序。相当于硬件的接口，操作系统只有通过这个接口，才能控制硬件设备的工作。</p><p>驱动就是操作硬件的接口，为了支持 Binder 通信过程，Binder 使用了一种『硬件』，因此这个模块被称之为 Binder 驱动。</p><h2 id="Binder介绍"><a href="#Binder介绍" class="headerlink" title="Binder介绍"></a>Binder介绍</h2><p>Binder 的设计采用了面向对象的思想。</p><p>Binder 的通信模型有 4 个角色：<strong>Client</strong>、<strong>Server</strong>、<strong>Binder Driver（Binder 驱动）</strong>、<strong>ServiceManager</strong>。</p><p>想象一个情景：现在我要给我的一个同学寄一封信，信上要标明收信地址。那我怎么拿到这个地址呢？去翻一下我的毕业相册。而这个记录着同学们通信地址的毕业相册，就相当于一个通讯录。它在 Binder 的通信模型中扮演的是 ServiceManager 的角色。</p><p>当有了收信地址之后，找到邮局寄出去就好了。过几天同学就收到了明信片。那么这个邮局在 Binder 通信模型中扮演的是 Binder Driver 的角色，而作为寄信人的我就是 Client，收信人同学就是 Server。</p><p>上面的例子可以变成下面这个模型图：</p><div class="center-img"><p><img src="/img/7.png" alt="Binder通信模型图"></p></div><p>在 Binder 通信模型的四个角色里面，他们的代表都是『Binder』，这样，对于 Binder 通信的使用者而言，Server 里面的 Binder 和 Client 里面的 Binder 没有什么不同，一个 Binder 对象就代表了所有，它不用关心实现的细节，甚至不用关心驱动以及 ServiceManager 的存在：这就是抽象。</p><ul><li>通常意义下， Binder 指的是一种通信机制；我们说 AIDL 使用 Binder 进行通信，指的就是 Binder 这种进程间通信机制。</li><li>对于 Server 进程来说， Binder 指的是 Binder 本地对象。</li><li>对于 Client 来说， Binder 指的是 Binder 代理对象，它只是 Binder 本地对象的一个远程代理；对这个 Binder 代理对象的操作，会通过驱动最终转发到 Binder 本地对象上去完成；对于一个拥有 Binder 对象的使用者而言，它无须关心这是一个 Binder 代理对象还是 Binder 本地对象；对于代理对象的操作和对本地对象的操作对它来说没有区别。</li><li>对于传输过程而言， Binder 是可以进行跨进程传递的对象； Binder 驱动会对具有跨进程传递能力的对象做特殊处理：自动完成代理对象和本地对象的转换。</li></ul><blockquote><p>面向对象思想的引入将进程间通信转化为通过对某个 Binder 对象的引用调用该对象的方法，而其独特之处在于 Binder 对象是一个可以跨进程引用的对象，它的实体（本地对象）位于一个进程中，而它的引用（代理对象）却遍布于系统的各个进程之中。最诱人的是，这个引用和 java 里引用一样既可以是<strong>强类型</strong>，也可以是<strong>弱类型</strong>，而且可以从一个进程传给其它进程，让大家都能访问同一 Server ，就象将一个对象或引用赋值给另一个引用一样。 Binder 模糊了进程边界，淡化了进程间通信过程，整个系统仿佛运行于同一个面向对象的程序之中。形形色色的 Binder 对象以及星罗棋布的引用仿佛粘接各个应用程序的胶水，这也是 Binder 在英文里的原意。</p></blockquote><h2 id="Binder对比其他进程间通信的方法的优势"><a href="#Binder对比其他进程间通信的方法的优势" class="headerlink" title="Binder对比其他进程间通信的方法的优势"></a>Binder对比其他进程间通信的方法的优势</h2><p>让我们带着问题去看这一段。</p><blockquote><p>Linux下有那么多进程间通信方式，为什么 Android 偏偏选择了用 Binder？</p></blockquote><p>我们先来看看Linux下都有哪些进程间通信方式。</p><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><h4 id="1-Pipeline（管道）"><a href="#1-Pipeline（管道）" class="headerlink" title="1. Pipeline（管道）"></a>1. Pipeline（管道）</h4><p>管道作为进程间通信方式，由来已久。也基本上是Linux中使用得最多的进程间通信方式。</p><pre><code class="bash">$history | grep &#39;gradlew&#39;</code></pre><p>上面的代码就完成了一次最简单的管道通信方式。<code>history</code>进程将自己的输出结果放入管道，<code>grep</code>进程从中取出结果，并进行筛选，得出我们最后想要的结果。</p><p>这个是<strong>匿名管道</strong>最简单的例子，管道又分为<a href="https://en.wikipedia.org/wiki/Named_pipe"><strong>有名管道</strong></a>和<a href="https://en.wikipedia.org/wiki/Anonymous_pipe"><strong>匿名管道</strong></a>，就不在这里详细展开了。</p><p>管道的通信模型如下图：</p><div class="center-img"><p><img src="/img/8.png" alt="管理通信模型"></p></div><p>管道可用于进程间的通信，管道是由内核管理的一个缓存区， 相当于我们放入内存中的一个<strong>纸条</strong>。管道的一端连接一个进程的输出，这个进程会向管道中放入信息。另一端连接一个进程的输入，这个进程取出被放入管道的信息。</p><p>这个缓存区不需要很大，在 Linux 中，默认的管道空间大小是 <a href="https://en.wikipedia.org/w/index.php?title=Pipeline_(Unix)#Implementation">64KB</a>。当管道中没有信息的话，从管道中读取的进程会等待，直到另一端的进程放入信息。当管道被放满信息的时候，尝试放入信息的进程会等待，直到另一端的进程取出信息。当两个进程都终结的时候，管道也自动消失。</p><p><strong>缺点</strong>: 在创建时分配一个管道时，缓存区大小比较有限；并不适合 Android 大量的进程间通信。</p><h4 id="2-Message-Queue（消息队列）"><a href="#2-Message-Queue（消息队列）" class="headerlink" title="2. Message Queue（消息队列）"></a>2. Message Queue（消息队列）</h4><p>消息队列提供了一种从一个进程向另一个进程发送一个数据块的方法。每个数据块都被认为含有一个类型，接收进程可以独立地接收含有不同类型的数据结构。我们可以通过发送消息来避免命名管道的同步和阻塞问题。但是消息队列与命名管道一样，每个数据块都有一个最大长度的限制。</p><p><span style="color: green">#TODO 日后详细展开</span></p><p><strong>缺点</strong>: 信息复制两次，额外的 CPU 消耗；不合适频繁或信息量大的通信。</p><h4 id="3-Shared-Memory（共享内存）"><a href="#3-Shared-Memory（共享内存）" class="headerlink" title="3. Shared Memory（共享内存）"></a>3. Shared Memory（共享内存）</h4><p>顾名思义，共享内存就是允许两个不相关的进程访问同一个逻辑内存。共享内存是在两个正在运行的进程之间共享和传递数据的一种非常有效的方式。不同进程之间共享的内存通常安排为同一段物理内存。进程可以将同一段共享内存连接到它们自己的地址空间中，所有进程都可以访问共享内存中的地址。</p><p><span style="color: green">#TODO 日后详细展开</span></p><p><strong>优点</strong>：<strong>无须复制</strong>，共享缓冲区直接付附加到进程虚拟地址空间，速度快；<br><strong>缺点</strong>：进程间的同步问题操作系统无法实现，必须各进程利用同步工具解决。同时，安全问题也比较突出，如果 Android 采用共享内存无异于将每个 App 放在一个内存中，这样是非常不安全的。</p><h4 id="4-Socket（套接字）"><a href="#4-Socket（套接字）" class="headerlink" title="4. Socket（套接字）"></a>4. Socket（套接字）</h4><p>通常作为更通用的接口，传输效率低，主要用于不同机器或跨网络的通信。</p><p><span style="color: green">#TODO 日后详细展开</span></p><h4 id="5-Semaphore（信号量）"><a href="#5-Semaphore（信号量）" class="headerlink" title="5. Semaphore（信号量）"></a>5. Semaphore（信号量）</h4><p>常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段，并不太适合 Android 的进程间通信。</p><h4 id="6-Signal（信号）"><a href="#6-Signal（信号）" class="headerlink" title="6. Signal（信号）"></a>6. Signal（信号）</h4><p>适用于<strong>进程中断控制</strong>，比如非法内存访问，杀死某个进程等；</p><p><strong>缺点</strong>：不适用于信息交换。</p><h3 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h3><ul><li><p>从性能的角度</p><p>  数据拷贝次数：Binder数据拷贝<strong>只需要一次</strong>，而管道、消息队列、Socket 都需要2次，但共享内存方式一次内存拷贝都不需要；从性能角度看，Binder 性能仅次于共享内存。</p></li><li><p>从稳定性的角度</p><p>  Binder 是<strong>基于 C/S 架构</strong>的。简单解释下 C/S 架构，是指客户端（Client）和服务端（Server）组成的架构，Client 端有什么需求，直接发送给 Server 端去完成，架构清晰明朗，Server 端与 Client 端相对独立，稳定性较好；而共享内存实现方式复杂，没有客户与服务端之别，需要充分考虑到访问临界资源的并发同步问题，否则可能会出现死锁等问题；从这稳定性角度看，Binder 架构优越于共享内存。</p></li></ul><p>仅仅从以上两点，各有优劣，还不足以支撑 Google 去采用 Binder 作为 IPC 机制，那么更重要的原因是——</p><ul><li><p>从安全的角度</p><p>  传统 Linux IPC 的接收方无法获得对方进程可靠的 UID/PID，从而无法鉴别对方身份；而 Android 作为一个开放的开源体系，拥有非常多的开发平台，App 来源甚广，因此手机的安全显得额外重要；对于普通用户，绝不希望从 App 商店下载偷窥隐私数据、后台造成手机耗电等等问题，传统 Linux IPC 无任何保护措施，完全由上层协议来确保。Android <strong>为每个安装好的应用程序分配了自己的 UID</strong>，故进程的 UID 是鉴别进程身份的重要标志，前面提到 C/S 架构，Android 系统中对外只暴露 Client 端，Client 端将任务发送给 Server 端，Server 端会根据权限控制策略，判断 UID/PID 是否满足访问权限，目前权限控制很多时候是通过弹出权限询问对话框，让用户选择是否运行。</p></li><li><p>从语言层面的角度</p><p>  大家多知道 Linux 是基于 C 语言（面向过程的语言），而 Android 是基于 Java 语言（面向对象的语言），而对于 Binder 恰恰也符合面向对象的思想，将进程间通信转化为通过对某个 Binder 对象的引用调用该对象的方法，而其独特之处在于 Binder 对象是一个可以<strong>跨进程引用</strong>的对象，它的实体位于一个进程中，而它的引用却遍布于系统的各个进程之中。可以从一个进程传给其它进程，让大家都能访问同一 Server，就像将一个对象或引用赋值给另一个引用一样。</p><p>  Binder 模糊了进程边界，淡化了进程间通信过程，整个系统仿佛运行于同一个面向对象的程序之中。从语言层面，Binder 更适合基于面向对象语言的 Android 系统，对于Linux系统可能会有点『水土不服』。另外，Binder 是为 Android 这类系统而生，而并非 Linux 社区没有想到 Binder IPC 机制的存在，也并非 Linux 现有的 IPC 机制不够好，相反地，经过这么多优秀工程师的不断打磨，依然非常优秀，每种 Linux 的 IPC 机制都有其存在的价值，同时在 Android 系统中也依然采用了大量 Linux 现有的 IPC 机制，根据每类 IPC 的原理特性，因地制宜，不同场景特性往往会采用其下最适宜的。比如在 Android 中的 Zygote 进程的 IPC 采用的是 Socket 机制，Android 中的 Kill Process 采用的 Signal 机制等等。而 Binder 更多则用在 system_server 进程与上层 App 层的 IPC 交互。</p></li><li><p>从公司战略的角度</p><p>  众所周知，Linux 内核是开源的系统，所开放源代码许可协议由 GPL 保护，该协议具有『病毒式感染』的能力。</p><p>  怎么理解这句话呢？受 GPL 保护的 Linux Kernel 是运行在<strong>内核空间</strong>，对于上层的任何类库、服务、应用等运行在<strong>用户空间</strong>，一旦进行 System Call（系统调用），调用到底层 Kernel，那么也必须遵循 GPL 协议。 而 Android 之父 Andy Rubin 对于 GPL 显然是不能接受的，为此，Google 巧妙地将 GPL 协议控制在内核空间，将用户空间的协议采用 Apache-2.0 协议（允许基于 Android 的开发商不向社区反馈源码），同时在 GPL 协议与 Apache-2.0 之间的 Lib 库中采用 BSD 证授权方法，有效隔断了 GPL 的传染性。此举虽有较大争议，但至少目前能够解决 Android 『被传染』，让 GPL 止步于内核空间，这是 Google 在 GPL Linux 下开源与商业化共存的一个成功典范。</p></li></ul><p>综合上述 5 点，可知 Binder 是 Android 系统上层进程间通信的不二选择。</p><h2 id="Binder通信机制"><a href="#Binder通信机制" class="headerlink" title="Binder通信机制"></a>Binder通信机制</h2><p>先上一张Binder的工作流程图:<br><img src="/img/6.png" alt="Binder工作流程图"></p><p>然后我们还是用刚才那个例子来解释上面的流程图。</p><p>首先是有一个 ServiceManager，刚开始这个通讯录是空白的，然后 Server 进程向 ServiceManager 注册一个映射关系表，比如同学把自己的地址<code>北京市 xx 区 xx 街道</code>写进通讯录，那么就形成了一张表（或者是 Map）：</p><pre><code>徐同学 —&gt; 北京市 xx 区 xx 街道</code></pre><p>之后 Client 进程想要和 Server 进程通信，首先向 ServiceManager 查询地址，ServiceManager 收到查询的请求之后，返回查询结果给 Client。注意到这里不管是 Server 进程注册，还是 Client 查询，都是经过 Binder 驱动的，这也正是 Binder 驱动的作用所在，先不急，下面的原理会分析到。</p><p>这时候我就拿着地址就开始寄信。当我把信件放扔进邮筒，之后的工作就是由邮局去完成了。邮递员从邮筒取出明信片，然后跨越千山万水将明信片送<br>达，也就是 Binder 驱动去完成通信的转发。</p><p>接下来我们来详细解释一下它的通信原理。</p><h3 id="Binder-跨进程通信原理"><a href="#Binder-跨进程通信原理" class="headerlink" title="Binder 跨进程通信原理"></a>Binder 跨进程通信原理</h3><p>上文给出了 Binder 的通信模型，指出了通信过程的四个角色: <strong>Client</strong>, <strong>Server</strong>, <strong>ServiceManager</strong>, <strong>Binder Driver</strong>。但是我们仍然不清楚 Client 到底是如何与 Server 完成通信的。</p><p>跨进程通信是需要内核空间做支持的。传统的 IPC 机制如管道、Socket 都是内核的一部分，因此通过内核支持来实现进程间通信自然是没问题的。但是 Binder 并不是 Linux 系统内核的一部分，那怎么办呢？这就得益于Linux 的<strong>动态内核可加载模块</strong>（Loadable Kernel Module，LKM）的机制。</p><blockquote><p>模块是具有独立功能的程序，它可以被单独编译，但是不能独立运行。它在运行时被链接到内核作为内核的一部分运行。</p></blockquote><p>这样，Android 系统就可以通过<strong>动态添加一个内核模块运行在内核空间</strong>，用户进程之间通过这个内核模块作为桥梁来实现通信。</p><p>于是，在 Android 系统中，这个运行在内核空间的可加载模块就叫 Binder Driver。</p><p>传统的进程间通信，采用的是上面说过的6种方案，它们的机制，无非都是先将数据从发送方进程拷贝到内核缓存区，然后再将数据从内核缓存区拷贝到接收方进程，通过两次拷贝来实现的数据交换。如下图：</p><p><img src="/img/9.jpg" alt="传统IPC机制"></p><p>而 Binder 别出心裁的地方就在于，它只需要拷贝一次数据，就可以完成数据交换，这得益于一种叫<strong>内存映射</strong>（<code>mmap()</code>）的概念。</p><blockquote><p><code>mmap()</code>是操作系统中一种内存映射的方法。</p><p>简单地讲就是将用户空间的一块内存区域映射到内核空间。</p><p>映射关系建立后，用户对这块内存区域的修改可以直接反应到内核空间；反之内核空间对这段区域的修改也能直接反应到用户空间。内存映射能减少数据拷贝次数，实现用户空间和内核空间的高效互动。两个空间各自的修改能直接反映在映射的内存区域，从而被对方空间及时感知。也正因为如此，内存映射能够提供对进程间通信的支持。</p></blockquote><p>Binder正是基于<code>mmap()</code>来实现的。但是<code>mmap()</code>通常是用在<strong>有物理介质的文件系统上</strong>的。举例来说，进程中的用户区域是不能直接和物理设备打交道的，如果想要把磁盘上的数据读取到进程的用户区域，需要两次拷贝（磁盘 –&gt; 内核空间 –&gt; 用户空间）；通常在这种场景下<code>mmap()</code>就能发挥作用，通过在物理介质和用户空间之间建立映射，减少数据的拷贝次数，用内存读写取代 I/O 读写，提高文件读取效率。</p><p>而 Binder 并不存在物理介质，因此 Binder 驱动使用 <code>mmap()</code> 并不是为了在物理介质和用户空间之间建立映射，而是用来在内核空间<strong>创建用于接收数据的缓存空间</strong>。</p><p>一次完整的 Binder IPC 通信过程通常是这样：</p><ol><li>首先 Binder 驱动在内核空间创建一个<strong>数据接收缓存区</strong>； </li><li>接着在内核空间开辟一块<strong>内核缓存区</strong>，建立内核缓存区和内核中数据接收缓存区之间的映射关系，以及内核中数据接收缓存区和接收进程用户空间地址的映射关系；</li><li>发送方进程通过系统调用 <code>copy_from_user()</code> 将数据 copy 到内核中的内核缓存区，由于内核缓存区和接收进程的用户空间存在内存映射，因此也就相当于把数据发送到了接收进程的用户空间，这样便完成了一次进程间的通信。</li></ol><p>如下图所示：</p><div class="center-img"><p><img src="/img/10.png" alt="Binder内存映射机制"></p></div><p><a href="https://blog.csdn.net/universus/article/details/6211589">Android Binder 设计与实现</a>一文中对 Client、Server、ServiceManager、Binder 驱动有很详细的描述，以下是部分摘录：</p><blockquote><h4 id="Binder-驱动"><a href="#Binder-驱动" class="headerlink" title="Binder 驱动"></a><strong>Binder 驱动</strong></h4><p>Binder 驱动就如同路由器一样，是整个通信的核心；驱动负责进程之间 Binder 通信的建立，Binder 在进程之间的传递，Binder 引用计数管理，数据包在进程之间的传递和交互等一系列底层支持。</p><h4 id="ServiceManager-与实名-Binder"><a href="#ServiceManager-与实名-Binder" class="headerlink" title="ServiceManager 与实名 Binder"></a><strong>ServiceManager 与实名 Binder</strong></h4><p>ServiceManager 和 DNS 类似，作用是将字符形式的 Binder 名字转化成 Client 中对该 Binder 的引用，使得 Client 能够通过 Binder 的名字获得对 Binder 实体的引用。注册了名字的 Binder 叫实名 Binder，就像网站一样除了除了有 IP 地址意外还有自己的网址。Server 创建了 Binder，并为它起一个字符形式，可读易记得名字，将这个 Binder 实体连同名字一起以数据包的形式通过 Binder 驱动发送给 ServiceManager ，通知 ServiceManager 注册一个名为“张三”的 Binder，它位于某个 Server 中。驱动为这个穿越进程边界的 Binder 创建位于内核中的实体节点以及 ServiceManager 对实体的引用，将名字以及新建的引用打包传给 ServiceManager。ServiceManger 收到数据后从中取出名字和引用填入查找表。</p><p>细心的读者可能会发现，ServierManager 是一个进程，Server 是另一个进程，Server 向 ServiceManager 中注册 Binder 必然涉及到进程间通信。当前实现进程间通信又要用到进程间通信，这就好像蛋可以孵出鸡的前提却是要先找只鸡下蛋！Binder 的实现比较巧妙，就是预先创造一只鸡来下蛋。ServiceManager 和其他进程同样采用 Binder 通信，ServiceManager 是 Server 端，有自己的 Binder 实体，其他进程都是 Client，需要通过这个 Binder 的引用来实现 Binder 的注册，查询和获取。ServiceManager 提供的 Binder 比较特殊，它没有名字也不需要注册。当一个进程使用 BINDER SETCONTEXT_MGR 命令将自己注册成 ServiceManager 时 Binder 驱动会自动为它创建 Binder 实体（这就是那只预先造好的那只鸡）。其次这个 Binder 实体的引用在所有 Client 中都固定为 0 而无需通过其它手段获得。也就是说，一个 Server 想要向 ServiceManager 注册自己的 Binder 就必须通过这个 0 号引用和 ServiceManager 的 Binder 通信。类比互联网，0 号引用就好比是域名服务器的地址，你必须预先动态或者手工配置好。要注意的是，这里说的 Client 是相对于 ServiceManager 而言的，一个进程或者应用程序可能是提供服务的 Server，但对于 ServiceManager 来说它仍然是个 Client。</p><h4 id="Client-获得实名-Binder-的引用"><a href="#Client-获得实名-Binder-的引用" class="headerlink" title="Client 获得实名 Binder 的引用"></a><strong>Client 获得实名 Binder 的引用</strong></h4><p>Server 向 ServiceManager 中注册了 Binder 以后， Client 就能通过名字获得 Binder 的引用了。Client 也利用保留的 0 号引用向 ServiceManager 请求访问某个 Binder: 我申请访问名字叫张三的 Binder 引用。ServiceManager 收到这个请求后从请求数据包中取出 Binder 名称，在查找表里找到对应的条目，取出对应的 Binder 引用作为回复发送给发起请求的 Client。从面向对象的角度看，Server 中的 Binder 实体现在有两个引用：一个位于 ServiceManager 中，一个位于发起请求的 Client 中。如果接下来有更多的 Client 请求该 Binder，系统中就会有更多的引用指向该 Binder ，就像 Java 中一个对象有多个引用一样。</p></blockquote><p>至此，我们大致能总结出 Binder 通信过程：</p><ol><li>首先，一个进程使用一个命令通过 Binder 驱动将自己<strong>注册</strong>成为 ServiceManager；</li><li>接着，Server 进程通过驱动向 ServiceManager 中注册 Binder（Server 中的 Binder 实体），表明可以对外提供服务。驱动为这个 Binder 创建位于内核中的<strong>实体节点</strong>以及 ServiceManager 对实体的<strong>引用</strong>，将<strong>名字以及新建的引用打包传给 ServiceManager</strong>，ServiceManger 将其填入查找表。</li><li>最后，Client 通过名字，在 Binder 驱动的帮助下从 ServiceManager 中获取到对 Binder 实体的引用，通过这个引用就能实现和 Server 进程的通信。</li></ol><p>我们看到整个通信过程都需要 Binder 驱动的接入。下图能更加直观的展现整个通信过程（为了进一步抽象通信过程以及呈现上的方便，下图我们忽略了 Binder实体及其引用的概念）：</p><div class="center-img"><p><img src="/img/11.jpg" alt="Binder通信过程"></p></div><h3 id="Binder-通信中的代理模式"><a href="#Binder-通信中的代理模式" class="headerlink" title="Binder 通信中的代理模式"></a>Binder 通信中的代理模式</h3><p>我们已经解释清楚 Client、Server 借助 Binder 驱动完成跨进程通信的实现机制了，但是还有个问题会让我们困惑。A 进程想要 B 进程中某个对象（object）是如何实现的呢？毕竟它们分属不同的进程，A 进程没法直接使用 B 进程中的对象实例。</p><p>前面我们介绍过跨进程通信的过程都有 Binder 驱动的参与，因此在数据流经 Binder 驱动的时候驱动会对数据做一层转换。当 A 进程想要获取 B 进程中的 object 时，驱动并不会真的把 object 返回给 A，而是返回了一个跟 object 看起来一模一样的代理对象 objectProxy，这个 objectProxy 具有和 object 一模一样的方法，但是这些方法并没有 B 进程中 object 对象那些方法的能力，这些方法只需要把把请求参数交给驱动即可。对于 A 进程来说和直接调用 object 中的方法是一样的。</p><p>当 Binder 驱动接收到 A 进程的消息后，发现这是个 objectProxy 就去查询自己维护的表单，一查发现这是 B 进程 object 的代理对象。于是就会去通知 B 进程调用 object 的方法，并要求 B 进程把返回结果发给自己。当驱动拿到 B 进程的返回结果后就会转发给 A 进程，一次通信就完成了。</p><p>上面的代理模式可以归结为下图：<br><img src="/img/12.png" alt="Binder的代理模式"></p><p>现在我们可以对 Binder 做个更加全面的定义了：</p><ul><li>从进程间通信的角度看，Binder 是一种<strong>进程间通信的机制</strong>；</li><li>从 Server 进程的角度看， Binder 指的是 <strong>Server 中的 Binder 实体对象</strong>； </li><li>从 Client 进程的角度看，Binder 指的是对 <strong>Binder 代理对象</strong>，是 Binder 实体对象的一个远程代理；</li><li>从传输过程的角度看，Binder 是一个<strong>可以跨进程传输的对象</strong>；Binder 驱动会对这个跨越进程边界的对象对一点点特殊处理，自动完成代理对象和本地对象之间的转换。</li></ul><h2 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h2><p>在写例子之前，我们先介绍一下接下来要出场的几位角色：</p><p><strong>1. IInterface</strong></p><p>IInterface 是 Binder 接口的基类，每当有一个 Binder 类的接口，都要继承于该接口。它的定义很简单：</p><pre><code class="JAVA">// android.os.IInterfacepackage android.os;public interface IInterface&#123;    // 在返回实例时不要进行显式强转，而是必须使用这个方法来转换成 IBinder。    public IBinder asBinder();&#125;</code></pre><p>只有一个方法<code>asBinder()</code>，用来返回对应的 Binder 对象。</p><p><strong>2. IBinder</strong></p><p>IBinder 是一个接口，约定了一些常量，比如 transaction code 的范围值、最大的 IPC 数量等等。</p><div class="center-img"><p><img src="/img/binder-1588152047.png"></p></div><p>IBinder 代表了一种<strong>跨进程传输的能力</strong>，实现这个接口就意味着这个对象能进行跨进程传递。</p><p>它最重要的一个方法就是<code>transact()</code>。而 Binder 实现了 IBinder 接口，我们一会看看它做了什么。</p><p><strong>3. Binder</strong></p><p>Binder 实现了 IBinder 定义的操作，它是 Android IPC 的基础，平常接触到的各种 Manager（ActivityManager, ServiceManager 等），以及绑定 Service 时都在使用它进行跨进程操作。</p><p>Android 官方建议的是：日常开发中一般不需要我们再实现 IBinder，直接使用系统提供的 Binder 即可。</p><p>它的存在不会影响一个应用的生命周期，只要创建它的进程在运行它就一直可用。</p><p>通常我们需要在顶级的组件（Service, Activity, ContentProvider）中使用它，这样系统才知道你的进程应该一直被保留。</p><p>它的两个关键方法，第一个是实现了 IBinder 的<code>transact()</code>：</p><pre><code class="java">public final boolean transact(int code, @NonNull Parcel data, @Nullable Parcel reply,        int flags) throws RemoteException &#123;    if (false) Log.v(&quot;Binder&quot;, &quot;Transact: &quot; + code + &quot; to &quot; + this);    if (data != null) &#123;        data.setDataPosition(0);    &#125;    boolean r = onTransact(code, data, reply, flags);    if (reply != null) &#123;        reply.setDataPosition(0);    &#125;    return r;&#125;</code></pre><p>它的过程，实际上就是调用了它的<code>onTransact</code>方法，然后将执行成功与否返回。继续看看<code>onTransact</code>：</p><pre><code class="java">protected boolean onTransact(int code, @NonNull Parcel data, @Nullable Parcel reply,        int flags) throws RemoteException &#123;    if (code == INTERFACE_TRANSACTION) &#123;  // 获取描述符        ...        return true;    &#125; else if (code == DUMP_TRANSACTION) &#123;  // 转存 Binder 信息        ...        return true;    &#125; else if (code == SHELL_COMMAND_TRANSACTION) &#123;   // 执行 SHELL 命令        ...        return true;    &#125;    return false;&#125;</code></pre><p>没有什么特别的，只是处理了三种情况。而我们自定义 Binder，或者使用系统生成的 Binder 时，往往都会自己实现<code>onTransact</code>方法，所以这里不用特别关注。</p><p>好，介绍完角色们，接下来要讲讲剧本了。</p><p>平时在开发中，实现 IPC 机制时，最多使用的是 <a href="https://developer.android.com/guide/components/aidl.html">AIDL（Android Interface Definition Language）</a>。当我们定义好 AIDL 文件，在编译时编译器会帮我们生成代码实现 IPC 通信。</p><p>Android 在这一点上，代码的可读性并不高。比如一个 MyClass.aidl 的文件在经过编译时生成的 MyClass.java 中，会包含一个 MyClass 接口、一个 Stub 静态抽象类和一个 Proxy 静态类。Proxy 是 Stub 的静态内部类，Stub 又是 BookManager 的静态内部类，这就造成了可读性和可理解性的问题。</p><p>但是 Android 这样设计是有它的道理的。如果有多个 AIDL 文件时，这些类在同一个文件里，可以有效避免 Stub 和 Proxy 的重名问题。</p><p>我们先来写一个简单的 AIDL 文件：</p><pre><code class="java">// IPerson.aidlpackage com.debuglife.aidl.test;// Declare any non-default types here with import statementsinterface IPerson &#123;    void setName(String aString);    String getName();&#125;</code></pre><p>可以见到，我们只需要声明一个接口，并在其中定义方法即可。编译一次后，就会在<code>app/build/generated/aidl_source_output_dir/debug/out</code>中找到对应的生成类（与 AIDL 文件同名，但扩展名会换为 .java），我们来看看生成后的代码，注释中会解释每一部分的用途：</p><pre><code class="java">// IPerson.javapackage com.debuglife.aidl.test;public interface IPerson extends android.os.IInterface &#123;    // 本地 IPC 实现的『存根』类    public static abstract class Stub extends android.os.Binder implements com.debuglife.aidl.test.IPerson &#123;        // 一个唯一标识该 Binder 类的字符串        private static final java.lang.String DESCRIPTOR = &quot;com.debuglife.aidl.test.IPerson&quot;;        // 构造函数里调用 attachInterface 方法，然后将自身的静态实例和标识符传入父类 Binder 类中        public Stub() &#123;            this.attachInterface(this, DESCRIPTOR);        &#125;        // 将 IBinder 对象转换成 com.debuglife.aidl.test.IPerson 接口        // 如果需要的话，会生成一个 Proxy        // 如果需要通信的 Client 和 Server 在同一个进程中，那意味着可以直接使用该对象的实例，就不用         public static com.debuglife.aidl.test.IPerson asInterface(android.os.IBinder obj) &#123;            if ((obj == null)) &#123;                return null;            &#125;            // 通过刚才设定的 DESCRIPTOR 来确定对应的接口是否正确            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);            // 判断 Client 和 Server 是否在同一个进程内            if (((iin != null) &amp;&amp; (iin instanceof com.debuglife.aidl.test.IPerson))) &#123;                // 如果是，则直接返回实例                return ((com.debuglife.aidl.test.IPerson) iin);            &#125;            // 如果不是，则要新建 Proxy 并返回 Proxy 的实例            return new com.debuglife.aidl.test.IPerson.Stub.Proxy(obj);        &#125;        // 复写 IInterface 的 asBinder 方法，用来返回与 IPerson 相对应的 Binder 对象        @Override        public android.os.IBinder asBinder() &#123;            return this;        &#125;        // 该方法是每次通信时会被调用        // 参数：int code 标识码，类似 Handler 中的 msg.what        // Parcel data 发送的数据        // Parcel reply 返回的数据        // int flags 附加的标识位，0表示正常通信，FLAG_ONEWAY 表示单向通信        @Override        public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123;            java.lang.String descriptor = DESCRIPTOR;            switch (code) &#123;                // 询问接收方（被调用方）接口描述符                case INTERFACE_TRANSACTION: &#123;                    reply.writeString(descriptor);                    return true;                &#125;                case TRANSACTION_setName: &#123;                    data.enforceInterface(descriptor);                    java.lang.String _arg0;                    _arg0 = data.readString();                    // 此处的 setName 调用的是 IPerson 中的 setName 方法。                    // 如果 Client 和 Server 在同一个进程中，那么实现 setName 方法的，是该 Binder 对象                    // 如果 Client 和 Server 不在同一个进程中，那么实现 setName 方法的，是 Proxy 对象                    this.setName(_arg0);                    reply.writeNoException();                    return true;                &#125;                case TRANSACTION_getName: &#123;                    data.enforceInterface(descriptor);                    // 同上                    java.lang.String _result = this.getName();                    reply.writeNoException();                    reply.writeString(_result);                    return true;                &#125;                default: &#123;                    return super.onTransact(code, data, reply, flags);                &#125;            &#125;        &#125;        // Proxy 是当 Client 和 Server 不是同一个进程时使用的        private static class Proxy implements com.debuglife.aidl.test.IPerson &#123;            private android.os.IBinder mRemote;            Proxy(android.os.IBinder remote) &#123;                mRemote = remote;            &#125;            @Override            public android.os.IBinder asBinder() &#123;                return mRemote;            &#125;            public java.lang.String getInterfaceDescriptor() &#123;                return DESCRIPTOR;            &#125;            @Override            public void setName(java.lang.String aString) throws android.os.RemoteException &#123;                android.os.Parcel _data = android.os.Parcel.obtain();                android.os.Parcel _reply = android.os.Parcel.obtain();                try &#123;                    _data.writeInterfaceToken(DESCRIPTOR);                    _data.writeString(aString);                    // 被代理的 Binder.Stub 的 transact 方法，然后这里面会接着调用 onTransact 方法                    mRemote.transact(Stub.TRANSACTION_setName, _data, _reply, 0);                    _reply.readException();                &#125; finally &#123;                    _reply.recycle();                    _data.recycle();                &#125;            &#125;            @Override            public java.lang.String getName() throws android.os.RemoteException &#123;                android.os.Parcel _data = android.os.Parcel.obtain();                android.os.Parcel _reply = android.os.Parcel.obtain();                java.lang.String _result;                try &#123;                    _data.writeInterfaceToken(DESCRIPTOR);                    // 同上                    mRemote.transact(Stub.TRANSACTION_getName, _data, _reply, 0);                    _reply.readException();                    _result = _reply.readString();                &#125; finally &#123;                    _reply.recycle();                    _data.recycle();                &#125;                return _result;            &#125;        &#125;        // 这两个静态常量是用来在 Binder 通信过程中，唯一标识一次传输的。类似`startActivityForResult()`中的 code。        // Binder 通信时，Client 向 Server 发起请求，Server 向 Client 返回请求，必须要有一个『鸡毛信』来确定这次沟通找对了人。// 在这个例子中，它们的值分别是 IBinder.FIRST_CALL_TRANSACTION + 0 和 IBinder.FIRST_CALL_TRANSACTION + 1，也就是 1 和 2。        // 如果有多个方法，那就会有多个常量，值也会继续递增。        static final int TRANSACTION_setName = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);        static final int TRANSACTION_getName = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1);    &#125;    // AIDL 文件中定义的两个方法，被照搬过来，同时抛出异常，方便捕获    public void setName(java.lang.String aString) throws android.os.RemoteException;    public java.lang.String getName() throws android.os.RemoteException;&#125;</code></pre><p>Android Studio 会提醒我们<strong>不要编辑这个文件</strong>。其实编辑了也会被重新覆盖掉。因为 AIDL 生成的文件是按照严格的通信格式来生成的，不允许修改，否则在 Binder 通信过程中就会出现错误。</p><p>我们来总结一下 IPersion.java 中都有些什么：</p><ul><li>IPerson 接口，继承了 IInterface 接口；</li><li>在 AIDL 文件中声明的两个方法<code>setName()</code>和<code>getName()</code>。不同的是，它抛出了<code>android.os.RemoteException</code>异常；</li><li>静态抽象类<code>Stub</code>；</li><li>Stub 类中的私有静态类<code>Proxy</code>。</li></ul><p>好，现在我们应该写一个 Service，作为 Server 端。Server 端当然要想办法实现刚才定义的<code>setName</code>和<code>getName</code>：</p><pre><code class="java">package com.debuglife.aidl.test;import android.app.Service;import android.content.Intent;import android.os.Binder;import android.os.IBinder;import android.os.Parcel;import android.os.RemoteException;import android.util.Log;import androidx.annotation.Nullable;public class AIDLService extends Service &#123;    private String name;    private Binder binder = new IPerson.Stub() &#123;        @Override        public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123;            return super.onTransact(code, data, reply, flags);        &#125;        @Override        public void setName(String s) throws RemoteException &#123;            name = s;        &#125;        @Override        public String getName() throws RemoteException &#123;            return name;        &#125;    &#125;;    @Nullable    @Override    public IBinder onBind(Intent intent) &#123;        // 在此处返回了上面声明的 Binder 实例        return binder;    &#125;&#125;</code></pre><p>接下来，便需要将这个 Service 加入 AndroidManifest 中：</p><pre><code class="xml">&lt;service    android:name=&quot;.AIDLService&quot;    android:enabled=&quot;true&quot;    android:exported=&quot;true&quot; &gt;    &lt;intent-filter&gt;        &lt;action android:name=&quot;com.debuglife.aidl.test.IPersonService&quot; /&gt;    &lt;/intent-filter&gt;&lt;/service&gt;</code></pre><p>此处的 action，是给跨进程通信的 App 使用的，现在暂时用不到。</p><p>至此，Server 端的工作完成，接下来就要看看如何向这个 Server 端发送消息了。</p><p>我们先来个『C/S同进程』的例子，在当前工程下，再来个 MainActivity：</p><pre><code class="java">IPerson iPerson;ServiceConnection conn = new ServiceConnection(&#123;    @Override    void onServiceConnected(ComponentName name, IBinder service) &#123;        // 将 service 转换为 IPerson         iPerson = IPerson.Stub.asInterface(service);    &#125;    @Override    void onServiceDisconnected(ComponentName name) &#123;    &#125;&#125;);@Overridevoid onCreate(Bundle savedInstanceState) &#123;    super.onCreate(savedInstanceState);    setContentView(R.layout.activity_main);    Intent intent = new Intent(this, AIDLService.class);    bindService(intent, conn, Context.BIND_AUTO_CREATE);    iPerson.setName(&quot;DebugLife&quot;);    System.out.println(iPerson.getName());&#125;@Overridevoid onDestroy() &#123;    unbindService(conn);    super.onDestroy();&#125;</code></pre><p>思路很清晰，使用<code>bindService</code>方法，将目标 Service 绑定，然后在 ServiceConnection 的回调中，将 iPerson 赋值为 Binder 实例，这样，在接下来就可以调用 IPerson 定义的方法了。</p><p>那么『C/S 不同进程』的，是什么步骤呢？</p><ol><li>我们需要将 Server 端的 AIDL 文件，按原路径拷贝到 Client 端工程中，并且编译一遍，生成对应的 java 文件。</li><li>在<code>bindService</code>时，要使用下面的方法：</li></ol><pre><code class="java">Intent intent = new Intent();intent.action = &quot;com.debuglife.aidl.test.IPersonService&quot;;  // 这是刚才我们在 Server 端的 manifest 中定义的 actionintent.setPackage(&quot;com.cy198706.review&quot;);  // 在 Android 5.0 之后，IPC 通信需要使用显式 Intent，也即指定接收者bindService(intent, conn, Context.BIND_AUTO_CREATE);</code></pre><p>这样，就能达到 IPC 的目的了。</p><p>有的同学要问了，你这光传个 String 啊，我要传对象怎么办？</p><p>在<a href="2020-04-14-serializable-and-parcelable.md">Serializable和Parcelable</a>一文中，我们提到了，IPC 中，是可以传递 Parcelable 的，那么，在此处，只需要将对象转换为 Parcelable，就可以做到了。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Android Framework </tag>
            
            <tag> Binder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于线程安全的一切</title>
      <link href="/2020-03-16/thread-safety/"/>
      <url>/2020-03-16/thread-safety/</url>
      
        <content type="html"><![CDATA[<p>自从多线程这个概念被发明之后，在开发中就无时无刻不得操心线程安全的问题。</p><p>但是，在了解线程安全之前，我们先来了解一下 Java 的内存模型，搞明白线程是如何工作的。</p><span id="more"></span><h2 id="Java-的内存模型-——-JMM"><a href="#Java-的内存模型-——-JMM" class="headerlink" title="Java 的内存模型 —— JMM"></a>Java 的内存模型 —— JMM</h2><p>JMM(Java Memory Model),是一种基于计算机内存模型（定义了共享内存系统中多线程程序读写操作行为的规范），屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。保证共享内存的<strong>原子性、可见性、有序性</strong>。</p><p>用一张图来展示一个多线程的执行场景：</p><p><img src="/img/49.png"></p><p>线程 A 和线程 B 分别对主内存的变量进行读写操作。其中主内存中的变量为<strong>共享变量</strong>,也就是说此变量只此一份，多个线程间共享。但是线程不能直接读写主内存的共享变量，每个线程都有自己的工作内存，线程需要读写主内存的共享变量时需要先将该变量拷贝一份副本到自己的工作内存，然后在自己的工作内存中对该变量进行所有操作，线程工作内存对变量副本完成操作之后需要将结果同步至主内存。</p><p>:::tip<br>线程的工作内存是线程私有内存，线程间无法互相访问对方的工作内存。<br>:::</p><p>为了便于理解，用图来描述一下线程对变量赋值的流程。</p><p><img src="/img/50.png"></p><p>那么问题来了，线程工作内存怎么知道什么时候又是怎样将数据同步到主内存呢？ 这里就轮到 JMM 出场了。 JMM 规定了何时以及如何做线程工作内存与主内存之间的数据同步。现在可以介绍刚才提到的三个特性了：</p><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><blockquote><p>对共享内存的一次操作（有可能包含有多个子操作）要么全部执行（生效），且中间过程不能被任何外部因素打断；要么全部都不执行（都不生效）。</p></blockquote><p>举个典型的例子，银行转账问题：比如 A 和 B 同时向 C 转账10万元。如果转账操作不具有原子性，A 在向 C 转账时，读取了 C 的余额为20万，然后加上转账的10万，计算出此时应该有30万，但还未来及将30万写回 C 的账户，此时 B 的转账请求过来了，B 发现 C 的余额为20万，然后将其加10万并写回。然后 A 的转账操作继续——将30万写回 C 的余额。这种情况下 C 的最终余额为30万，而非预期的40万。</p><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><blockquote><p>可见性是指，当多个线程并发访问共享变量时，一个线程对共享变量的修改，其它线程能够立即看到。</p></blockquote><p>CPU 从主内存中读数据的效率相对来说不高，现在主流的计算机中，都有几级缓存。每个线程读取共享变量时，都会将该变量加载进其对应 CPU 的高速缓存里，修改该变量后，CPU 会立即更新该缓存，但并不一定会立即将其写回主内存（实际上写回主内存的时间不可预期）。此时其它线程（尤其是不在同一个 CPU 上执行的线程）访问该变量时，从主内存中读到的就是旧的数据，而非第一个线程更新后的数据。</p><p>这一点是操作系统或者说是硬件层面的机制，所以很多应用开发人员经常会忽略。</p><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><blockquote><p>有序性指的是，程序执行的顺序按照代码的先后顺序执行。在单线程环境下，程序的执行都是有序的，但是在多线程环境下，JMM 为了性能优化，编译器和处理器会对指令进行重排，程序的执行会变成无序。</p></blockquote><p>以下面这段代码为例</p><pre><code class="java">boolean started = false; // 语句1long counter = 0L; // 语句2counter = 1; // 语句3started = true; // 语句4</code></pre><p>从代码顺序上看，上面四条语句应该依次执行，但实际上 JVM 真正在执行这段代码时，并不保证它们一定完全按照此顺序执行。</p><p>处理器为了提高程序整体的执行效率，可能会对代码进行优化，其中的一项优化方式就是调整代码顺序，按照更高效的顺序执行代码。</p><p>讲到这里，有人要着急了——什么，CPU 不按照我的代码顺序执行代码，那怎么保证得到我们想要的效果呢？实际上，大家大可放心，CPU 虽然并不保证完全按照代码顺序执行，但它会保证程序最终的执行结果和代码顺序执行时的结果一致。</p><h2 id="线程安全的本质"><a href="#线程安全的本质" class="headerlink" title="线程安全的本质"></a>线程安全的本质</h2><p>其实第一张图的例子是有问题的，主内存中的变量是共享的，所有线程都可以访问读写，而线程工作内存又是线程私有的，线程间不可互相访问。那在多线程场景下，图上的线程 A 和线程 B 同时来操作共享内存里的同一个变量，那么主内存内的此变量数据就会被破坏。也就是说主内存内的此变量不是线程安全的。<br>我们来看个代码小例子帮助理解。</p><pre><code class="java">public class ThreadDemo &#123;    private int x = 0;    private void count() &#123;        x++;    &#125;    public void runTest() &#123;        new Thread(() -&gt; &#123;            for(int i = 0; i &lt; 1000000; i++) &#123;                count();            &#125;            System.out.println(&quot;final x from 1: &quot; + num);        &#125;).start();        new Thread(() -&gt; &#123;            for(int i = 0; i &lt; 1000000; i++) &#123;                count();            &#125;            System.out.println(&quot;final x from 2: &quot; + num);        &#125;).start();    &#125;    public static void main(String[] args) &#123;        new ThreadDemo().runTest();    &#125;&#125;</code></pre><p>示例代码中<code>runTest()</code>方法2个线程分别执行 10000000 次<code>count()</code>方法,<br><code>count()</code>方法中只执行简单的<code>x++</code>操作,理论上每次执行<code>runTest()</code>方法应该有一个线程输出的<code>x</code>结果应该是<code>2000000</code>。但实际的运行结果并非我们所想：</p><pre><code>final x from 1: 1010599final x from 2: 1909131</code></pre><p>出现这样的结果的原因也就是我们上面所说的，在多线程环境下，我们主内存的<code>x</code>变量的数据被破坏了。我们都知道完成一次<code>i++</code>相当于执行了两句代码：</p><pre><code class="java">int tmp = x + 1;x = tmp;</code></pre><p>在多线程环境下就会出现这种情况：在执行完<code>int tmp = x + 1;</code>这行代码时就<strong>发生了线程切换</strong>，当线程再次切回来的时候，<code>x</code>就会被<strong>重复赋值</strong>，导致出现上面的运行结果，2个线程都无法输出<code>2000000</code>。</p><p>下图描述了示例代码的执行时序：</p><p><img src="/img/51.png"></p><p>那么 Java 是如何来解决上述问题来保证线程安全，保证共享内存的原子性、可见性、有序性的呢？</p><h2 id="Java-中如何解决线程安全问题"><a href="#Java-中如何解决线程安全问题" class="headerlink" title="Java 中如何解决线程安全问题"></a>Java 中如何解决线程安全问题</h2><p>Java 中提供了几种方法，来保证线程安全。</p><h3 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a><code>synchronized</code>关键字</h3><h4 id="保证原子性"><a href="#保证原子性" class="headerlink" title="保证原子性"></a>保证原子性</h4><p><code>synchronized</code>通过<a href="https://www.hollischuang.com/archives/2030">Monitor（监视锁）</a>来保证⽅法内部或代码块内部资源（数据）的互斥访问，从而实际目标代码段同一时间只会被一个线程执行，进而保证了目标代码段的原子性。这是一种以牺牲性能为代价的方法。</p><p>::: tip<br>关于 Monitor 和 synchronized 实现原理了解可以看下这2篇文章：<a href="http://www.hollischuang.com/archives/1883">Synchronized 的实现原理</a>、 <a href="https://www.hollischuang.com/archives/2030">Moniter 的实现原理</a><br>:::</p><p>可以看看下面的动图，看看 Monitor 是如何工作的：</p><p><img src="/img/52.gif"></p><p>被<code>synchronized</code>关键字描述的方法或代码块在多线程环境下<strong>同一时间只能由一个线程进行访问</strong>，在持有当前 Monitor 的线程执行完成之前，其他线程想要调用相关方法就必须进行排队，直到持有当前 Monitor 的线程执行结束，释放 Monitor ，下一个线程才可获取 Monitor 执行。<br>如果存在多个 Monitor 的情况时，多个 Monitor 之间是<strong>不互斥</strong>的。</p><blockquote><p>多个 Monitor 的情况出现在自定义多个锁分别来描述不同的方法或代码块，<code>synchronized</code>在描述代码块时可以指定自定义 Monitor ，默认为 <code>this</code>即当前类。</p></blockquote><p><img src="/img/53.gif"></p><h4 id="保证可见性"><a href="#保证可见性" class="headerlink" title="保证可见性"></a>保证可见性</h4><p>保证多线程环境下对监视资源的数据同步。即任何线程在获取到 Monitor 后的第⼀时间，会先将共享内存中的数据复制到⾃⼰的缓存中；任何线程在释放 Monitor 的第⼀时间，会先将缓存中的数据复制到共享内存中。</p><h4 id="保证线程间操作的有序性"><a href="#保证线程间操作的有序性" class="headerlink" title="保证线程间操作的有序性"></a>保证线程间操作的有序性</h4><p><code>synchronized</code>的原子性保证了由其描述的方法或代码操作具有有序性，同一时间只能由最多只能有一个线程访问，不会触发 JMM 指令重排机制</p><h3 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a><code>volatile</code>关键字</h3><h4 id="volatile作用"><a href="#volatile作用" class="headerlink" title="volatile作用"></a><code>volatile</code>作用</h4><p>保证被<code>volatile</code>关键字描述变量的操作具有可见性和有序性（禁止指令重排）</p><p>::: tip 注意</p><ol><li><code>volatile</code>只对基本类型 (<code>byte</code>、<code>char</code>、<code>short</code>、<code>int</code>、<code>long</code>、<code>float</code>、<code>double</code>、<code>boolean</code>) 的赋值操作和对象的引⽤赋值操作有效。</li><li>对于<code>i++</code>此类复合操作， <code>volatile</code>无法保证其有序性和原子性。</li><li>相对<code>synchronized</code>来说<code>volatile</code>更加轻量一些。<br>:::</li></ol><h3 id="CAS（Compare-and-Swap）"><a href="#CAS（Compare-and-Swap）" class="headerlink" title="CAS（Compare and Swap）"></a>CAS（Compare and Swap）</h3><p><code>java.util.concurrent.atomic</code>包提供了一系列的<code>AtomicBoolean</code>、<code>AtomicInteger</code>、<code>AtomicLong</code>等类。使用这些类来声明变量可以保证对其操作具有原子性来保证线程安全。</p><p>实现原理上与<code>synchronized</code>使用 Monitor（监视锁）保证资源在多线程环境下阻塞互斥访问<strong>不同</strong>，<code>java.util.concurrent.atomic</code>包下的各种原子类基于<strong>CAS(CompareAndSwap) 操作原理实现</strong>。</p><p>::: tip CAS<br><a href="https://www.jianshu.com/p/ae25eb3cfb5d">CAS</a> 又称无锁操作，一种乐观锁策略，原理就是多线程环境下各线程访问共享变量不会加锁阻塞排队，线程不会被挂起。通俗来讲就是一直循环对比，如果有访问冲突则重试，直到没有冲突为止。<br>:::</p><p>刚才提到的<code>x++</code>操作，就可以使用<code>AtomicInteger</code>类来完成：</p><pre><code class="java">private AtomicInteger x = new AtomicInteger(0);private void count() &#123;    x.incrementAndGet();&#125;AtomicInteger x = new AtomicInteger();new Thread(() -&gt; &#123;    for(int i = 0; i &lt; 1000000; i++) &#123;        count();    &#125;&#125;).start();</code></pre><p>现在再检查输出：</p><pre><code>final x from 1: 1941014final x from 2: 2000000</code></pre><h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a><code>Lock</code></h3><p>锁机制由来已久，在 Linux 中也频繁使用了锁机制来保证线程安全。</p><p>Java 提供了一系列的锁操作方法。在<code>java.util.concurrent</code> 包下，有一个<code>Lock</code>接口。主要有 <code>ReentrantLock</code>，<code>ReentrantReadWriteLock.ReadLock</code>，<code>ReentrantReadWriteLock.WriteLock</code> 实现类。与 <code>synchronized</code> 不同是 <code>Lock</code> 提供了获取锁和释放锁等相关接口，使得使用上更加灵活，同时也可以做更加复杂的操作。</p><p>之前的例子可以做出如下修改：</p><pre><code class="java">private int num = 0;ReentrantReadWriteLock lock = new ReentrantReadWriteLock();Lock readLock = lock.readLock();Lock writeLock = lock.writeLock();private void count() &#123;    writeLock.lock();    try &#123;        num++;    &#125; finally &#123;        writeLock.unlock();    &#125;&#125;...</code></pre><p>输入结果：</p><pre><code>final x from 1: 1707334final x from 2: 2000000</code></pre><p>关于 Lock 实现原理和更详细的使用推荐以下2篇文章：<br><a href="https://juejin.im/post/5ab9a5b46fb9a028ce7b9b7e#heading-2">Lock锁的使用</a><br><a href="https://juejin.im/entry/5b4ddf6d6fb9a04f97650336">Lock锁源码分析</a></p><h2 id="一些其他的问题"><a href="#一些其他的问题" class="headerlink" title="一些其他的问题"></a>一些其他的问题</h2><blockquote><p>Q: 既然锁和synchronized即可保证原子性也可保证可见性，为何还需要volatile？</p></blockquote><p><code>synchronized</code>和锁需要通过操作系统来仲裁谁获得锁，开销比较高，而<code>volatile</code>开销小很多。因此在只需要保证可见性的条件下，使用<code>volatile</code>的性能要比使用锁和<code>synchronized</code>高得多。</p><blockquote><p>Q: 既然锁和synchronized可以保证原子性，为什么还需要AtomicInteger这种的类来保证原子操作？</p></blockquote><p>锁和<code>synchronized</code>需要通过操作系统来仲裁谁获得锁，开销比较高，而<code>AtomicInteger</code>是通过 CPU 级的 CAS 操作来保证原子性，开销比较小。所以使用<code>AtomicInteger</code>的目的还是为了提高性能。</p><blockquote><p>Q: <code>synchronized</code>既可修饰非静态方法，也可修饰静态方法，还可修饰代码块，也能修饰类，有何区别？</p></blockquote><ul><li><strong>修饰一个非静态方法</strong>：被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象；</li><li><strong>修饰一个静态的方法</strong>：其作用的范围是整个静态方法，作用的对象是这个类的所有对象；</li><li><strong>修饰一个代码块</strong>：被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象；</li><li><strong>修饰一个类</strong>：是给这个类加锁，作用的对象是这个类的所有对象。</li></ul><p>synchronized 当遇见异常时，就会自动释放；而 ReentrantLock 在遇见异常时，不会自动释放，所以，都会在 try-catch 的 finally 块里进行释放</p><p>ReentrantLock 可以传入 bool fair 使用公平锁</p><p>ReentrantReadWriteLock readLock() 和 writeLock() </p><p>wait() 会强制当前线程挂起等待，直到其他线程在同一个对象上调用 notify() 或者 notifyAll()</p><p>synchronized ：<strong>对象头</strong>和 monitor。nomitor 是一个保存在对象头中的一个对象。对象头是在新建对象时，在堆中建立了对象头和对象数据，里面包含锁、hashCode 等数据。monitor 使用的是计数器方式来实现同步机制的。它的同步机制是 JVM 对操作系统级别的 Mutex Lock（互斥锁）的管理过程，运行是内核态。</p><p>锁自旋：线程的阻塞和唤醒需要 CPU 从用户态转换为核心态，而频繁的阻塞和唤醒对 CPU 来说是负担很重的工作，所以 Java 引入了自旋锁的操作。默认是开启的。所谓自旋，就是执行一段无意义的循环，不会被立即挂起，等待看看当前持有锁的线程是否被很快被释放。缺陷：它要占用 CPU，有可能白白浪费资源。</p><p>轻量级锁：对于一块同步代码，虽然会有多个不同线程去执行，但这些线程是在不同的时间段交替请求锁对象，所以不存在锁竞争情况。可以避免阻塞和唤醒操作。适合线程交替执行同步块的志合。如果存在同一时间访问同一个锁的场合，则轻量级锁会变为重量级锁。</p><p>重量级锁：synchronized 就是重量级锁。</p><p>偏向锁。如果一个线程获得了偏向锁，在接下来的一段时间没有其他线程与它抢占锁，那么持有偏向锁的线程下次再次进入或退出同步代码块，就不需要再进行抢占锁和释放锁的操作。baisedLocking。一旦出现竞争，偏向锁会被撤销，并膨胀成轻量级锁。</p><p>DVM 对 JVM 做了哪些优化：</p><ol><li>Dalvik 是 Google 公司自己设计的基于 Java 的虚拟机。5.0之前叫DVM，5.0之后叫 ART（Android Runtime）</li><li>大多数实现与 JVM 相同</li><li>使用了 Dex 文件。传统 Java 是将 Java 源代码转换成 .class 文件，而 Android 中是将所有文件打包成 classes.dex 文件，去掉了 class 文件中的冗余字段（比如重复的字符常量），结构也更加紧凑，所以在它的解析阶段，效率会更高，提高了类的查找和加载速度。</li><li>DMV 的指令集架构基于寄存器 &amp;&amp; 栈堆结构，而 JVM 的指令集是基于栈结构来执行的。指令会变长，但是指令条数会变少，执行更加快速。</li><li>Android 系统的第一个 Dalvik 虚拟机是由 Zygote 进程创建的，应用程序是由 Zygote fork 出来的，于是，DVM 内存中的堆被划分为了两部分：ActiveHeap 和 Zygote Heap。Zygote 进程创建 Dalvik 虚拟机时，只有一个堆，但是 Zygote 进行在 fork 第一个应用程序的进程之前 ，会将已经使用的那部分堆内存划分为一部分，其余的划分为另一部分。前者就是 ZygoteHeap，后者就是 ActiveHeap。以后，无论是 Zygote 进程还是应用程序进程，只要使用堆，就在 ActiveHeap 上进行；这就能使用 Zygote 堆能尽量减少拷贝操作。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Thread </tag>
            
            <tag> Thread-Safe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于线程池的一切</title>
      <link href="/2020-03-14/thread-pool/"/>
      <url>/2020-03-14/thread-pool/</url>
      
        <content type="html"><![CDATA[<p>线程池（Thread Pool）对于<strong>限制应用程序中同一时刻运行的线程数</strong>很有用。因为每启动一个新线程都会有相应的性能开销，每个线程都需要给栈分配一些内存等等。</p><p>我们可以把并发执行的任务传递给一个线程池，来替代为每个并发执行的任务都启动一个新的线程。只要池里<strong>有空闲的线程</strong>，任务就会分配给一个线程执行。在线程池的内部，任务被插入一个<strong>阻塞队列</strong>（Blocking Queue ），线程池里的线程会去<strong>取这个队列里的任务</strong>。当一个新任务插入队列时，一个空闲线程就会成功的从队列中取出任务并且执行它。</p><p>线程池经常应用在多线程服务器上。每个通过网络到达服务器的连接都被包装成一个任务并且传递给线程池。线程池的线程会并发的处理连接上的请求。</p><p>合理利用线程池能够带来三个好处。</p><ol><li>降低资源消耗。通过重复利用已创建的线程<strong>降低线程创建和销毁造成的消耗</strong>。</li><li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能<strong>立即执行</strong>。</li><li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池<strong>可以进行统一的分配，调优和监控</strong>。但是要做到合理的利用线程池，必须对其原理了如指掌。</li></ol><span id="more"></span><h2 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h2><p><code>java.util.concurrent</code>包中提供了一个叫<code>ThreadPoolExecutor</code>的类，用来创建线程池：</p><pre><code class="java">public ThreadPoolExecutor(int corePoolSize,                              int maximumPoolSize,                              long keepAliveTime,                              TimeUnit unit,                              BlockingQueue&lt;Runnable&gt; workQueue,                              ThreadFactory threadFactory,                              RejectedExecutionHandler handler) &#123;    ...&#125;</code></pre><p>它在创建时最多可以传入7个参数，分别是：</p><p><strong><code>corePoolSize</code><strong>：线程池的</strong>核心线程</strong>数量。当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到<strong>需要执行的任务数大于线程池核心线程数量时就不再创建</strong>。如果调用了线程池的<code>prestartAllCoreThreads</code>方法，线程池会提前创建并启动所有基本线程。核心线程不会自动回收，但如果调用了线程池的<code>allowCoreThreadTimeOut()</code>方法，核心线程空闲时间达到<code>keepAliveTime</code>之后，就会被回收。</p><p><strong><code>maximumPoolSize</code><strong>：线程池的</strong>最大</strong>大小。也即线程池内能容纳的<strong>最大的线程数量</strong>。<code>线程池最大数量 - 核心线程数 = 非核心线程数</code>。非核心线程在空间时间达到<code>keepAliveTime</code>之后，就会被回收。</p><p>**<code>keepAliveTime</code>和<code>unit</code>**：当线程的数量大于<code>corePoolSize</code>的时候，线程的存活时间。<code>keepAliveTime</code>和<code>unit</code>两个参数要配合使用。<code>unit</code>的可选值有<code>DAYS</code>|<code>HOURS</code>|<code>MINUTES</code>|<code>SECONDS</code>|<code>MILLISECONDS</code>|<code>MICROSECONDS</code>|<code>NANOSECONDS</code>，超时后就会回收。无论选用哪种<code>unit</code>，在传入后都会被转成 NanoSeconds。</p><p><strong><code>workQueue</code><strong>：持有等待被执行的任务的队列，也即我们常说的</strong>阻塞队列</strong>。这个队列只会持有通过调用<code>execute()</code>方法提交的 Runnable 任务。BlockingQueue 实例可选的有以下几种：</p><ul><li>ArrayBlockingQueue：是一个基于<strong>数组结构的有界阻塞队列</strong>，此队列按 FIFO（先进先出）原则对元素进行排序。</li><li>LinkedBlockingQueue：一个基于<strong>链表结构的阻塞队列</strong>，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法<code>Executors.newFixedThreadPool()</code>使用了这个队列。</li><li>SynchronousQueue：一个<strong>不存储元素的阻塞队列</strong>。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法<code>Executors.newCachedThreadPool</code>使用了这个队列。</li><li>PriorityBlockingQueue：一个<strong>具有优先级有无限阻塞队列</strong>。</li><li>DelayedWorkQueue: 一个<strong>具有延迟执行功能的队列</strong></li></ul><p>**<code>threadFactory</code>**：执行器创建一个新的线程时会用到的工厂。可以通过线程工厂给每个创建出来的线程设置更有意义的名字，Debug 和定位问题时非常又帮助。</p><p>**<code>handler</code>**：饱和策略。当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。以下是 JDK1.5 提供的四种策略。</p><ul><li>AbortPolicy：直接抛出异常</li><li>CallerRunsPolicy：<strong>只用调用者所在线程</strong>来运行任务。</li><li>DiscardOldestPolicy：丢弃队列里<strong>最近的一个任务</strong>，并执行当前任务。</li><li>DiscardPolicy：不处理，丢弃掉。</li></ul><p>当然也可以根据应用场景需要来实现 RejectedExecutionHandler 接口自定义策略。如记录日志或持久化不能处理的任务。</p><blockquote><p>在 Android 的 AsyncTask 中就使用了 RejectedExecutionHandler 来实现了备用线程池。</p></blockquote><h2 id="向线程池提交任务"><a href="#向线程池提交任务" class="headerlink" title="向线程池提交任务"></a>向线程池提交任务</h2><p>向线程池提交任务有两个方法：<code>execute()</code>和<code>submit()</code>，我们来看看两个方法的源码，比较下有什么不同：</p><p>**<code>execute()</code>**：</p><pre><code class="java"> /** * 在未来的某个时间执行给定的任务。该任务有可能在一个新的线程或者是已存在的线程中执行。 * * 如果任务无法被添加，要么就是因为它的执行器被回收了，要么就是达到了线程池的最大容量，该任务就会触发拒绝策略。 */public void execute(Runnable command) &#123;    if (command == null)        throw new NullPointerException();    // 获得当前线程的生命周期对应的二进制状态码        int c = ctl.get();    // 判断当前线程数量是否小于核心线程数量，如果小于就直接创建线程执行任务，创建成功直接跳出，失败则接着往下走.    if (workerCountOf(c) &lt; corePoolSize) &#123;        if (addWorker(command, true))            return;        c = ctl.get();    &#125;    // 判断线程池是否为RUNNING状态，并且将任务添加至队列中    if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;        int recheck = ctl.get();        // 审核线程池的状态，如果不是RUNNING状态，直接移出队列中        if (!isRunning(recheck) &amp;&amp; remove(command))            reject(command);        // 如果当前线程数量为0，则单独创建线程，而不指定任务.        else if (workerCountOf(recheck) == 0)            addWorker(null, false);    &#125;    // 如果不满足上述条件，尝试创建一个非核心线程来执行任务，如果创建失败，调用 reject() 方法.    else if (!addWorker(command, false))        reject(command);&#125;</code></pre><p><code>addWorker()</code>方法是创建线程主要的方法，我们简单看一下：</p><pre><code class="java">private boolean addWorker(Runnable firstTask, boolean core) &#123;    retry:    for (;;) &#123;        // 获得当前线程的状态        int c = ctl.get();        int rs = runStateOf(c);        // 只在必要的情况下检查队列是否为空        if (rs &gt;= SHUTDOWN &amp;&amp;            ! (rs == SHUTDOWN &amp;&amp;                firstTask == null &amp;&amp;                ! workQueue.isEmpty()))            return false;        for (;;) &#123;            // 获取正在工作的线程数量            int wc = workerCountOf(c);            if (wc &gt;= CAPACITY ||                wc &gt;= (core ? corePoolSize : maximumPoolSize))                return false;            if (compareAndIncrementWorkerCount(c))                break retry;            c = ctl.get();  // Re-read ctl            if (runStateOf(c) != rs)                continue retry;            // else CAS failed due to workerCount change; retry inner loop        &#125;    &#125;    boolean workerStarted = false;    boolean workerAdded = false;    Worker w = null;    try &#123;        // 新建一个 Worker        w = new Worker(firstTask);        final Thread t = w.thread;        if (t != null) &#123;            // 使用 Lock 机制向池中添加工作线程            final ReentrantLock mainLock = this.mainLock;            mainLock.lock();            try &#123;                // Recheck while holding lock.                // Back out on ThreadFactory failure or if                // shut down before lock acquired.                int rs = runStateOf(ctl.get());                if (rs &lt; SHUTDOWN ||                    (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123;                    if (t.isAlive()) // precheck that t is startable                        throw new IllegalThreadStateException();                    workers.add(w);                    int s = workers.size();                    if (s &gt; largestPoolSize)                        largestPoolSize = s;                    workerAdded = true;                &#125;            &#125; finally &#123;                mainLock.unlock();            &#125;            if (workerAdded) &#123;                t.start();                workerStarted = true;            &#125;        &#125;    &#125; finally &#123;        if (! workerStarted)            addWorkerFailed(w);    &#125;    return workerStarted;&#125;</code></pre><p>**<code>submit()</code>**：</p><pre><code class="java">public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) &#123;    if (task == null) throw new NullPointerException();    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);    execute(ftask);    return ftask;&#125;protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) &#123;    return new FutureTask&lt;T&gt;(callable);&#125;public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; &#123;    ...&#125;public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123;    void run();&#125;</code></pre><p>可以看出，<code>submit()</code>最终还是会去调用<code>execute()</code>方法来执行任务。不同的地方在于，<code>submit()</code>会返回一个包装好的任务，是一个 Future 对象。所以，通常情况下，在<strong>不需要线程执行返回结果值时，我们使用<code>execute()</code>方法</strong>。 而当我们<strong>需要返回值时，则使用<code>submit()</code>方法</strong>，他会返回一个 Future 对象。Future 不仅仅可以获得一个结果，他还可以被取消，我们可以通过调用<code>Future.cancel()</code>方法，取消一个Future 的执行。</p><h2 id="线程池的终止"><a href="#线程池的终止" class="headerlink" title="线程池的终止"></a>线程池的终止</h2><p>线程 run 方法跑完之后，就正常结束了，但是线程池也是有关闭的办法的。</p><ol><li><code>shutdown()</code>：关闭线程池，不再接收新的任务，但已经添加的任务不受影响。</li><li><code>shutdownNow()</code>：尝试停止所有正在执行的任务，停止处理正在等待的任务，并且返回一个正在等待执行的任务列表。</li></ol><h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p>举个例子来看看线程池的用法：</p><pre><code class="java">import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;public class ThreadPoolTest &#123;    private final ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(            3, 5, 1,            TimeUnit.MINUTES,            new ArrayBlockingQueue&lt;Runnable&gt;(50));    public void test() &#123;        for (int i = 0; i &lt; 10; i++) &#123;            final int j = i;            threadPoolExecutor.execute(() -&gt; &#123;                try &#123;                    Thread.sleep(3000);                    String info = String.format(&quot;第%d次 - 当前线程%s&quot;, j, Thread.currentThread().getName());                    System.out.println(info);                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;);        &#125;        ((Runnable) () -&gt; &#123;            try &#123;                Thread.sleep(5000);                threadPoolExecutor.shutdown();            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;).run();    &#125;    public static void main(String[] args) &#123;        new ThreadPoolTest().test();    &#125;&#125;</code></pre><p>输出结果如下：</p><pre><code>第0次 - 当前线程pool-1-thread-1第1次 - 当前线程pool-1-thread-2第2次 - 当前线程pool-1-thread-3第3次 - 当前线程pool-1-thread-1第5次 - 当前线程pool-1-thread-2第4次 - 当前线程pool-1-thread-3第8次 - 当前线程pool-1-thread-3第6次 - 当前线程pool-1-thread-1第7次 - 当前线程pool-1-thread-2第9次 - 当前线程pool-1-thread-3</code></pre><p>从结果可以看出，虽然是按照结果执行了10次任务，但是并不是按照放入的顺序执行的。</p><h2 id="线程池的分类"><a href="#线程池的分类" class="headerlink" title="线程池的分类"></a>线程池的分类</h2><p>默认的线程池是ThreadPoolExecutor，那么系统是不是提供了一些个性化的线程池供我们在各种情况下使用呢？</p><p>答案是有的。我们看看下图，有6种线程池可供选择：</p><p><img src="/img/54.png"></p><p>我们分别来简单介绍一下：</p><h3 id="1-CachedThreadPool"><a href="#1-CachedThreadPool" class="headerlink" title="1. CachedThreadPool"></a>1. CachedThreadPool</h3><p>它的声明如下：</p><pre><code class="java">public static ExecutorService newCachedThreadPool() &#123;    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,                                    60L, TimeUnit.SECONDS,                                    new SynchronousQueue&lt;Runnable&gt;());&#125;</code></pre><p>根据它的构造方法，我们可以看出它的特性：</p><ul><li>没有核心线程。</li><li>60 秒 timeout。</li><li>采用 SynchronousQueue 队列</li></ul><p>如果线程处理任务速度小于提交任务的速度，则会不断地创建新的线程，这时需要注意不要过度创建，应采取措施调整双方速度，不然线程创建太多会影响性能。从其特点可以看出，CachedThreadPool适用于有大量需要立即执行的耗时少的任务的情况。比较适合<strong>执行很多短期异步的小程序或者负载较轻的服务器</strong>。</p><h3 id="2-FixedThreadPool"><a href="#2-FixedThreadPool" class="headerlink" title="2. FixedThreadPool"></a>2. FixedThreadPool</h3><p>它的声明如下：</p><pre><code class="java">public static ExecutorService newFixedThreadPool(int nThreads) &#123;    return new ThreadPoolExecutor(nThreads, nThreads,                                    0L, TimeUnit.MILLISECONDS,                                    new LinkedBlockingQueue&lt;Runnable&gt;());&#125;</code></pre><p>根据它的构造方法，我们可以看出它的特性：</p><ul><li>无论线程池多大，全部是核心线程，没有非核心线程。</li><li>因为全部是核心线程，所以不会回收。</li><li>采用 LinkedBlockingQueue 队列。</li></ul><p>这个非常适合<strong>执行长期任务</strong>，因为线程不会回收，能更快地响应执行任务的请求，性能会比较好。</p><h3 id="3-ScheduledThreadPool"><a href="#3-ScheduledThreadPool" class="headerlink" title="3. ScheduledThreadPool"></a>3. ScheduledThreadPool</h3><p>它的声明如下：</p><pre><code class="java">public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123;        return new ScheduledThreadPoolExecutor(corePoolSize);&#125;public class ScheduledThreadPoolExecutor        extends ThreadPoolExecutor &#123;    public ScheduledThreadPoolExecutor(int corePoolSize) &#123;        super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,            new DelayedWorkQueue());    &#125;&#125;</code></pre><p>根据它的构造方法，我们可以看出它的特性：</p><ul><li>核心线程数量固定，非核心线程数量无上限</li><li>非核心线程在工作完成后会立刻被回收。</li><li>采用 DelayedWorkQueue 队列。</li></ul><p>ScheduledThreadPool 适合<strong>执行延时任务以及有固定周期的重复任务</strong>。</p><h3 id="4-SingleThreadExecutor"><a href="#4-SingleThreadExecutor" class="headerlink" title="4. SingleThreadExecutor"></a>4. SingleThreadExecutor</h3><p>它的声明如下：</p><pre><code class="java">public static ExecutorService newSingleThreadExecutor() &#123;        return new FinalizableDelegatedExecutorService            (new ThreadPoolExecutor(1, 1,                                    0L, TimeUnit.MILLISECONDS,                                    new LinkedBlockingQueue&lt;Runnable&gt;()));&#125;static class FinalizableDelegatedExecutorService    extends DelegatedExecutorService &#123;    FinalizableDelegatedExecutorService(ExecutorService executor) &#123;        super(executor);    &#125;    protected void finalize() &#123;        super.shutdown();    &#125;&#125;</code></pre><p>根据它的构造方法，我们可以看出它的特性：</p><ul><li>只有一个线程，且为核心线程。</li><li>线程不会被回收。</li><li>采用 LinkedBlockingQueue 队列。</li><li>在调用 finalize() 方法触发 GC 时，会关掉线程池。</li></ul><p>适合<strong>一个任务一个任务按执行的场景</strong>。</p><h3 id="5-SingleThreadScheduledExecutor"><a href="#5-SingleThreadScheduledExecutor" class="headerlink" title="5. SingleThreadScheduledExecutor"></a>5. SingleThreadScheduledExecutor</h3><p>它的声明如下：</p><pre><code class="java">public static ScheduledExecutorService newSingleThreadScheduledExecutor() &#123;        return new DelegatedScheduledExecutorService            (new ScheduledThreadPoolExecutor(1));&#125;</code></pre><p>它最终还是创建了一个 ScheduledThreadPoolExecutor，只不过核心线程数为1，它的特性也很明显：</p><ul><li>只有一个核心线程，非核心线程数量无上限</li><li>非核心线程在工作完成后会立刻被回收。</li><li>采用 DelayedWorkQueue 队列。</li><li>可以延期执行任务</li></ul><p>它综合了 SingleThreadExecutor 和 ScheduledThreadPool，适合<strong>执行一个接一个的延期任务</strong>。</p><h3 id="6-WorkStealingPool（JDK-1-8之后）"><a href="#6-WorkStealingPool（JDK-1-8之后）" class="headerlink" title="6. WorkStealingPool（JDK 1.8之后）"></a>6. WorkStealingPool（JDK 1.8之后）</h3><p>它的声明如下：</p><pre><code class="java">public static ExecutorService newWorkStealingPool(int parallelism) &#123;    return new ForkJoinPool        (parallelism,            ForkJoinPool.defaultForkJoinWorkerThreadFactory,            null, true);&#125;</code></pre><p>作为 JDK 1.8 之后加入的『后起之秀』，这个线程池必然有一些过人之处。文档上介绍的是这样的：</p><blockquote><p>创建一个含有足够多线程的线程池，来维持相应的<strong>并行级别</strong>，它会通过工作窃取的方式，使得多核的 CPU 不会闲置，总会有活着的线程让 CPU 去运行。</p><p>实际的线程数量可能会动态地增加或减少。</p><p>工作窃取线程池无法保证任务的执行顺序与添加顺序一致。</p></blockquote><p>工作窃取不是什么 Java 独有的东西，.NET 的 TPL 库早就存在好几年了。所谓工作窃取，指的是闲置的线程去处理本不属于它的任务。</p><p>每个处理器核，都有一个队列存储着需要完成的任务。对于多核的机器来说，当一个核对应的任务处理完毕后，就可以去帮助其他的核处理任务。</p><p>它的本质是 ForkJoinPool，在 JDK 1.7 版本中加入的。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你真的了解 Activity 吗？</title>
      <link href="/2020-02-28/activity/"/>
      <url>/2020-02-28/activity/</url>
      
        <content type="html"><![CDATA[<p>Activity 几乎是所有 Android 开发者最熟悉的陌生人了。</p><p>说它熟悉，是因为每个开发者在进行开发时，第一个要面对的对象就是 Activity，应用界面的跳转、UI的显示全部都要依托Activity。</p><p>说它陌生，是因为几乎很少有开发者能把 Activity、Window、View、DecorView、WindowManager、ViewRootImpl 错综复杂的关系理清。</p><p>当我们打开 Android Studio，建立一个新的应用，编译启动项目，手机上出现了『Hello World!』，有没有想过这些问题：</p><blockquote><p>Activity 是由谁来实例化的？</p><p>Window 是个啥？</p><p>经常听说 DecorView，它是个普通的 View 吗？它的作用是什么？</p><p>WindowManager 起了什么作用？</p><p>Activity 是如何将内容显示到屏幕上的？</p><p>宋慧乔与宋仲基为什么要离婚？</p></blockquote><p>带着这些问题，我们来揭开它的面纱，一起走近科学，看看『Hello World!』背后的故事。</p><span id="more"></span><h2 id="万物之源-Activity"><a href="#万物之源-Activity" class="headerlink" title="万物之源 - Activity"></a>万物之源 - Activity</h2><p>在每一个 Application 之下，就是各种各样的 Activity 了，要呈现任何内容，都要经过 Activity 之手。那么 Activity 是以什么形式显示的呢？</p><p>在官方文档上，是这样定义 Activity 的。</p><blockquote><p>An activity is a single, focused thing that the user can do. Almost all activities interact with the user, so the Activity class takes care of creating a window for you in which you can place your UI with setContentView(View). While activities are often presented to the user as full-screen windows, they can also be used in other ways: as floating windows (via a theme with R.attr.windowIsFloating set), Multi-Window mode or embedded into other windows.</p><p>机翻：<br>Activity 是一个独立的，能与用户交互的东西。几乎所有的Activity都会与用户产生交互，所以Activity类会帮你创建一个Window，来让你通过<code>setContentView(View)</code>的方式，把UI展示出来。通常情况下，与用户交互的都是全屏Window，当然也可以有悬浮窗（通过在主题中设置<code>R.attr.windowIsFloating</code>来启用）、多窗口，或者集成到其他的Window中。</p></blockquote><p>我们来简单看一下Activity之下的内容的层级关系：</p><div style="text-align:center; width: 100%"><img src="/img/23.png"></img></div><p>可以看出，Activity 中会有 WindowManger 来管理 Window，而 Window 之下就是各种 ViewGroup 和 View 了。我们是怎么的推导出这个层级关系的呢？我们先从 Activity 的创建开始。</p><p>Activity的实例是由 ActivityThread 创建的，在其中有个名为<code>performLaunchActivity()</code>的方法，在这里面创建了Activity的实例。</p><pre><code class="java">// ActivityThread.java/**  Core implementation of activity launch. */private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;    ...    ComponentName component = r.intent.getComponent();    ...    ContextImpl appContext = createBaseContextForActivity(r);    Activity activity = null;    try &#123;        java.lang.ClassLoader cl = appContext.getClassLoader();        activity = mInstrumentation.newActivity(                cl, component.getClassName(), r.intent);        StrictMode.incrementExpectedActivityCount(activity.getClass());        r.intent.setExtrasClassLoader(cl);        r.intent.prepareToEnterProcess();        if (r.state != null) &#123;            r.state.setClassLoader(cl);        &#125;    &#125; catch (Exception e) &#123;        if (!mInstrumentation.onException(activity, e)) &#123;            throw new RuntimeException(                &quot;Unable to instantiate activity &quot; + component                + &quot;: &quot; + e.toString(), e);        &#125;    &#125;    ...    Window window = null;    if (r.mPendingRemoveWindow != null &amp;&amp; r.mPreserveWindow) &#123;        window = r.mPendingRemoveWindow;        r.mPendingRemoveWindow = null;        r.mPendingRemoveWindowManager = null;    &#125;    appContext.setOuterContext(activity);    activity.attach(appContext, this, getInstrumentation(), r.token,            r.ident, app, r.intent, r.activityInfo, title, r.parent,            r.embeddedID, r.lastNonConfigurationInstances, config,            r.referrer, r.voiceInteractor, window, r.configCallback,            r.assistToken);&#125;</code></pre><p>可以看到，Activity的实例是由Instrumentation来创建的，而且将ClassLoader传入，看来是利用了反射原理创建的。具体的我们之后再分析。#FLAG</p><p>来从<code>Activity.attach()</code>开始看看源码吧。</p><pre><code class="java">// Activity.javafinal void attach(Context context, ActivityThread aThread,        Instrumentation instr, IBinder token, int ident,        Application application, Intent intent, ActivityInfo info,        CharSequence title, Activity parent, String id,        NonConfigurationInstances lastNonConfigurationInstances,        Configuration config, String referrer, IVoiceInteractor voiceInteractor,        Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken) &#123;    ...    mWindow = new PhoneWindow(this, window, activityConfigCallback);    ...    mWindow.setWindowManager(        (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),        mToken, mComponent.flattenToString(),        (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0);    ...    mWindowManager = mWindow.getWindowManager();&#125;</code></pre><p>由上面的代码我们能够知道，Activity中的Window实例是一个叫PhoneWindow的东西。Activity在这里创建了一个新的PhoneWindow，并给它设置一个WindowManager。</p><p>在看PhoneWindow之前，先看看Window的定义：</p><pre><code class="java">// Window.java/** * 一个抽象类，top-level的窗口，用来呈现样式，掌管行为。 * 该类的实例应该被用做最顶层的视图，并且需要被添加到 window manager。 * 它提供了标准的 UI 策略包括但不限于背景、标题区域、默认的按键处理等等。 * * 目前该类唯一的实现类就是 android.view.PhoneWindow，当你需要一个Window的时候，就得实例化这个类。 */public abstract class Window &#123;    ...&#125;</code></pre><p>做为Android中Window类的唯一实现类，我们再看看PhoneWindow的定义：</p><pre><code class="java">// PhoneWindow.javapublic class PhoneWindow extends Window implements MenuBuilder.Callback &#123;    ...    // PhoneWindow中的顶级View——DecorView    private DecorView mDecor;    ...    boolean mIsFloating;  // 是否为悬浮窗    ...    private LayoutInflater mLayoutInflater;  // LayoutInflater    private TextView mTitleView;  // 窗口标题    ...    private AudioManager mAudioManager;    private KeyguardManager mKeyguardManager;    private MediaSessionManager mMediaSessionManager; // 如Window中所说的，包含一些事件的处理    ...</code></pre><p>在PhoneWindow的成员变量里，我们看到了DecorView。可见Window的顶级View就是DecorView了。而DecorView又是一个ViewGroup，它可以拥有无数的子View，所以刚才图里的层级关系得到了佐证。</p><h2 id="一人之下，万人之上-Window"><a href="#一人之下，万人之上-Window" class="headerlink" title="一人之下，万人之上 - Window"></a>一人之下，万人之上 - Window</h2><p>我们知道，微软 Windows® 操作系统中有窗口（Window）的概念，那么在 Android 中有没有这个概念呢？</p><p>答案是有的。Activity 是附加在 Window 上展示的，还有例如 Dialog、Toast 也是会单独展示在一个 Window 上。</p><p>刚才我们说过了，Acitivty中，用于显示内容的，就是Window了。那么Window的内容来自于哪儿呢？</p><p>我们从上面<code>ActivityThread.performLaunchActivity()</code>方法继续向下走：</p><pre><code class="java">// ActivityThread.jaa    ...    activity.attach(appContext, this, getInstrumentation(), r.token,            r.ident, app, r.intent, r.activityInfo, title, r.parent,            r.embeddedID, r.lastNonConfigurationInstances, config,            r.referrer, r.voiceInteractor, window, r.configCallback,            r.assistToken);    ...    activity.mCalled = false;    if (r.isPersistable()) &#123;        mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);    &#125; else &#123;        mInstrumentation.callActivityOnCreate(activity, r.state);    &#125;</code></pre><p>看到这里了吧，调用了Activity的<code>onCreate()</code>方法。</p><p>我们知道，在Activity的<code>onCreate()</code>方法中，绝大多数情况下，我们要使用<code>setContentView(R.layout.layout_main)</code>来显示内容，如果这句代码被注释掉，那Activity中就是一片空白。好，我们就由此为入口，看看<code>R.layout.layout_main</code>究竟是怎样被添加到Window里的。</p><p><code>setContentView()</code>的源码如下，非常简单：</p><pre><code class="java">// Activity.java/**    * Set the activity content from a layout resource.  The resource will be    * inflated, adding all top-level views to the activity.    *    * @param layoutResID Resource ID to be inflated.    */public void setContentView(@LayoutRes int layoutResID) &#123;    getWindow().setContentView(layoutResID);     // 设置actionBar    initWindowDecorActionBar(); &#125;</code></pre><p>高尔基先生教导我们：事出反常必有妖。越是简单的东西，背后的东西肯定越复杂，我们来看看<code>getWindow().setContentView(layoutResID)</code>这句代码都经历了些什么。</p><p> <code>Activity.getWindow()</code>获取的是其成员变量PhoneWindow，所以这句代码其实是调用了<code>PhoneWindow.setContentView()</code>：</p><pre><code class="java">// PhoneWindow.java@Overridepublic void setContentView(int layoutResID) &#123;    // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window    // decor, when theme attributes and the like are crystalized. Do not check the feature    // before this happens.    // 初始化DecorView和mContentParent    if (mContentParent == null) &#123;        installDecor();    &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;        mContentParent.removeAllViews();    &#125;    if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;        final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,                getContext());        transitionTo(newScene);    &#125; else &#123;        // 渲染布局        mLayoutInflater.inflate(layoutResID, mContentParent);    &#125;    mContentParent.requestApplyInsets();    // 通知Activity我初始化完啦！    final Callback cb = getCallback();    if (cb != null &amp;&amp; !isDestroyed()) &#123;        cb.onContentChanged();    &#125;    mContentParentExplicitlySet = true;&#125;</code></pre><p>这里面我们提取两个点：<code>mContentParent</code>和<code>installDecor()</code>。</p><p><code>mContentParent</code>的声明如下：</p><pre><code class="java">// This is the view in which the window contents are placed. It is either// mDecor itself, or a child of mDecor where the contents go.ViewGroup mContentParent;</code></pre><p>意思是这个ViewGroup放的是Window里的内容。它要么是<code>mDecor</code>（也就是DecorView），要么是<code>mDecor</code>的一个子View。<br>在第一次初始化的时候，<code>mContentParent</code>显然是<code>null</code>，那其初始化必然就在<code>installDecor()</code>中了。</p><pre><code class="java">// PhoneWindow.javaprivate void installDecor() &#123;    mForceDecorInstall = false;    if (mDecor == null) &#123;        mDecor = generateDecor(-1);        ...    &#125; else &#123;        mDecor.setWindow(this);    &#125;    if (mContentParent == null) &#123;        mContentParent = generateLayout(mDecor);        // 各种对mContentParent和mDecor的初始化，如Title、Icon等        ...    &#125;&#125;</code></pre><p>当初次进入此方法时，<code>mDecor</code>为<code>null</code>，便会调用<code>generateDecor()</code>方法：</p><pre><code class="java">// PhoneWindow.javaprotected DecorView generateDecor(int featureId) &#123;    // 系统进程没有 application context，在这种情况下，我们需要直接使用我们现有的 context。    // 其他的情况下我们直接用 application context，这样就不用太依附于 activity。    Context context;    if (mUseDecorContext) &#123;        Context applicationContext = getContext().getApplicationContext();        if (applicationContext == null) &#123;            context = getContext();        &#125; else &#123;            context = new DecorContext(applicationContext, getContext());            if (mTheme != -1) &#123;                context.setTheme(mTheme);            &#125;        &#125;    &#125; else &#123;        context = getContext();    &#125;    return new DecorView(context, featureId, this, getAttributes());&#125;</code></pre><p>可以看到，在这里创建了DecorView的实例，Window的根View出现了。</p><p>并且在<code>installDecor()</code>时，也要初始化mContentParent，通过调用<code>generateLayout(DecorView)</code>实现：</p><pre><code class="java">protected ViewGroup generateLayout(DecorView decor) &#123;    // 各种初始化与条件判断    ...    // Inflate the window decor.    int layoutResource;    // 判断当前是什么类型的Window，从而给layoutResource赋值特定的id值。    // 如 R.layout.screen_swipe_dismiss、R.layout.screen_title_icons等    // 这里也有大量的 requestFeature() 的调用，    // 也间接解释了为什么 requestFeature() 方法一定要在 setContentView() 之前调用    ...    mDecor.startChanging();  // 1    mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);  // 2    ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);  // 3    ...    mDecor.setWindowFrame(frame);    mDecor.setElevation(mElevation);    mDecor.setClipToOutline(mClipToOutline);    ...    mDecor.finishChanging(); // 4    return contentParent;  // 5&#125;</code></pre><p>在这个方法中，使用了刚刚创建的DecorView。</p><ol><li><code>startChanging()</code>方法会将DecorView中的一个<code>mChanging</code>的Flag置为<code>true</code>；该Flag主要目的是防止DecorView收到<code>drawableChanged()</code>事件时，出现冲突。</li><li><code>onResourcesLoaded()</code>方法中会调用<code>addView()</code>方法将<code>layoutResource</code>渲染过后的view添加为自身的子View。无论<code>layoutResource</code>最后被赋予什么值，它一定会包含<code>Window.ID_ANROID_CONTENT</code>。</li><li><code>Window.ID_ANDROID_CONTENT</code>的定义是这样的：</li></ol><pre><code class="java">// Window.java/*** 主 layout 的 xml 文件中必须含有的 ID 值*/public static final int ID_ANDROID_CONTENT = com.android.internal.R.id.content;</code></pre><p>而这个<code>findViewById()</code>是PhoneWindow的父类Window中的方法，如下：</p><pre><code class="java">// Window.java/*** Finds a view that was identified by the &#123;@code android:id&#125; XML attribute* that was processed in &#123;@link android.app.Activity#onCreate&#125;.* &lt;p&gt;* This will implicitly call &#123;@link #getDecorView&#125; with all of the associated side-effects.* &lt;p&gt;* &lt;strong&gt;Note:&lt;/strong&gt; In most cases -- depending on compiler support --* the resulting view is automatically cast to the target class type. If* the target class type is unconstrained, an explicit cast may be* necessary.** @param id the ID to search for* @return a view with given ID if found, or &#123;@code null&#125; otherwise* @see View#findViewById(int)* @see Window#requireViewById(int)*/@Nullablepublic &lt;T extends View&gt; T findViewById(@IdRes int id) &#123;    return getDecorView().findViewById(id);&#125;</code></pre><p><code>getDecorView()</code>是Window中的抽象方法，当然由PhoneWindow来实现：</p><pre><code class="java">@Overridepublic final @NonNull View getDecorView() &#123;    if (mDecor == null || mForceDecorInstall) &#123;        installDecor();    &#125;    return mDecor;&#125;</code></pre><p>说白了，就是拿到了刚刚初始化完的mDecor！DecorView是一个ViewGroup，调用它的<code>findViewById()</code>最终会调用到<code>View.findViewById()</code>，具体的代码就不贴了，无非就是递归查找。</p><p>这一句的目的是，找到DecorView中ID值为<code>ID_ANDROID_CONTENT</code>的View，赋值给<code>contentParent</code>。</p><ol start="4"><li><code>finishChanging()</code>方法将DecorView中的<code>mChanging</code>Flag置为<code>false</code>，同时调用一下它的<code>drawableChanged()</code>方法。</li><li>返回<code>contentParent</code>，这样<code>mContentParent</code>初始化完毕。</li></ol><p>好，现在mDecor有了，mContentParent有了，就调用</p><pre><code class="java">mLayoutInflater.inflate(layoutResID, mContentParent);</code></pre><p>来将xml布局文件画到这上面。</p><p>经过上面的步骤，现在DecorView已经初始化完毕，可是还没有被添加到Window上呢？</p><p>什么时候添加上去的呢？这里必须要介绍Activity的创建与生命周期了。</p><h3 id="Activity的创建与生命周期"><a href="#Activity的创建与生命周期" class="headerlink" title="Activity的创建与生命周期"></a>Activity的创建与生命周期</h3><p>在上面<code>Activity.attach()</code>方法中，我们看到传入了一个ActivityThread的实例，这个ActivityThread是个啥？</p><pre><code class="java">// ActivityThread.java/** * 管理一个应用进程的主线程上的所有执行任务，计划和执行活动、广播和其他的操作，而Activity Manager只管发送请求就好啦 * * &#123;@hide&#125; */public final class ActivityThread extends ClientTransactionHandler &#123;&#125;</code></pre><p>在文章的开头讲过，<code>Activity.attach()</code>是由ActivityThread来调用的，因为Activity的实例就是由ActivityThread来创建的！</p><p>那么，它必然也会监听Activity生命周期内的所有事件。</p><p>上一张老掉牙的图，来看看Activity的生命周期。</p><p><img src="/img/22.png"></p><p>通过查看ActivityThread的代码，我们发现，在<code>handleResumeActivity()</code>方法中，首先会调用 Activity 的<code>onResume()</code>方法，接着会调用 Activity 的<code>makeVisible()</code>方法，正是在<code>makeVisible()</code>方法中，DecorView才真正的完成了显示过程，到这里 Activity 的视图才能被用户看到，代码如下：</p><pre><code class="java">// ActivityThread.java@Overridepublic void handleResumeActivity(IBinder token, boolean finalStateRequest, boolean isForward,        String reason) &#123;    // 这里最终会调用到Activity的 onResume() 方法    final ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason);    ...    final Activity a = r.activity;    ...    // The window is now visible if it has been added, we are not    // simply finishing, and we are not starting another activity.    if (!r.activity.mFinished &amp;&amp; willBeVisible &amp;&amp; r.activity.mDecor != null &amp;&amp; !r.hideForNow) &#123;        if (r.activity.mVisibleFromClient) &#123;            r.activity.makeVisible();        &#125;    &#125;&#125;</code></pre><pre><code class="java">// Activity.javavoid makeVisible() &#123;    if (!mWindowAdded) &#123;        ViewManager wm = getWindowManager();        wm.addView(mDecor, getWindow().getAttributes());  // 将DecorView添加到Window上        mWindowAdded = true;    &#125;    mDecor.setVisibility(View.VISIBLE);&#125;// getWindowManager()获取的是Activity中的成员变量`mWindowManager`/** Retrieve the window manager for showing custom windows. */public WindowManager getWindowManager() &#123;    return mWindowManager;&#125;</code></pre><p>还记得这个<code>mWindowManager</code>是来自于哪儿吗？是了，这是<code>Activity.attach()</code>的时候，获取的mWindow中的WindowManager。可以去翻翻上面<code>attach()</code>的代码瞧瞧。</p><p>好，事情似乎已经来到了最后一步，就是<code>WindowManager.addView()</code>了，下一节我们看看WindowManager是如何将DecorView添加到Window上的。</p><h2 id="权倾朝野-WindowManager"><a href="#权倾朝野-WindowManager" class="headerlink" title="权倾朝野 - WindowManager"></a>权倾朝野 - WindowManager</h2><p>WindowManager，听起来就很高大上，Window中所有内容的生死大权，都掌握在它的手里。</p><p>而实际上它只是一个接口，并不是一个类。继承自ViewManager。</p><pre><code class="java">// WindowManager.java/** * 一个接口，app 们用来与window manager通讯的。 * * 每一个window manager的实例都与一个特定的 Display 绑定。要获取不同的 Display 的 WindowManager， * 调用 Context.createDisplayContext() 来获取那个 Display 的 Context，然后用  * Context.getSystemService(Context.WINDOW_SERVICE) 来获取它的 WindowManager。 *  * 最简单的在其他 Display 上显示 window 的方法是创建一个 Presentation，Presentation 会自动地为 * 这个 Display 获取 WindowManager 和 Context。 * * 这个类的主要作用，是与WindowManagerService打交道，将App与WindowManagerService连接在一起。 * */@SystemService(Context.WINDOW_SERVICE)public interface WindowManager extends ViewManager &#123;&#125;</code></pre><p>然后是ViewManager类，很简单：</p><pre><code class="java">// ViewManager.java/**   * 这个接口能让你为Activity添加和删除子view。要获取该类的实例，调用Context.getSystemService()。  */public interface ViewManager&#123;    public void addView(View view, ViewGroup.LayoutParams params);    public void updateViewLayout(View view, ViewGroup.LayoutParams params);    public void removeView(View view);&#125;</code></pre><p>为了方便解释下面的内容，我们还是再贴一次<code>Activity.attach()</code>的部分代码：</p><pre><code class="java">// Activity.javafinal void attach(Context context, ActivityThread aThread,        Instrumentation instr, IBinder token, int ident,        Application application, Intent intent, ActivityInfo info,        CharSequence title, Activity parent, String id,        NonConfigurationInstances lastNonConfigurationInstances,        Configuration config, String referrer, IVoiceInteractor voiceInteractor,        Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken) &#123;    ...     mWindow.setWindowManager(            (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),            mToken, mComponent.flattenToString(),            (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0);    if (mParent != null) &#123;        mWindow.setContainer(mParent.getWindow());    &#125;    mWindowManager = mWindow.getWindowManager();    ...</code></pre><p>其实第一次看到这里的时候，我有点疑惑，为啥不直接通过这种方式来设置<code>mWindow</code>的WindowManager呢？</p><pre><code class="java">mWindowManager = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE);mWindow.setWindowManager(mWindowManager, mToken, mComponent.flattenToString(),            (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0);</code></pre><p>这样就不必再搞个<code>mWindowManager = mWindow.getWindowManager()</code>出来了啊？</p><p>事实证明，我还是Too young, sometimes to naive。我们来看看<code>mWindow.setWindowManager()</code>干了些啥，就知道为啥我的方法行不通了：</p><pre><code class="java">// Window.java/**    * Set the window manager for use by this Window to, for example,    * display panels.  This is &lt;em&gt;not&lt;/em&gt; used for displaying the    * Window itself -- that must be done by the client.    *    * @param wm The window manager for adding new windows.    */public void setWindowManager(WindowManager wm, IBinder appToken, String appName,        boolean hardwareAccelerated) &#123;    mAppToken = appToken;    mAppName = appName;    mHardwareAccelerated = hardwareAccelerated;    // 这里还来了个双重保险    if (wm == null) &#123;        wm = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);     &#125;    mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this);&#125;</code></pre><p>这一着狸猫换太子真是有够妙！这哪里是个简单的 setter 方法啊！</p><p>原来这个WindowManager并不是通过系统提供的<code>getSystemService()</code>方法搞出来的实例，而是又自己想办法搞了个新的玩意出来！</p><p>先将WindowManager强转成它的一个实现类WindowManagerImpl，然后调用了它的<code>createLocalWindowManager(Window)</code>方法，将WindowManager直接实例化成了WindowManagerImpl。</p><p>而<code>createLocalWindowManager()</code>方法里则是简单到不能再简单的一句代码：</p><pre><code class="java">public WindowManagerImpl createLocalWindowManager(Window parentWindow) &#123;    return new WindowManagerImpl(mContext, parentWindow);&#125;</code></pre><p>说白了，这个<code>mWindowManager</code>与<code>(WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE)</code>压根就不是同一个实例，它是新<code>new</code>出来的一个WindowManagerImpl实例。</p><p>这下好了，冤有头债有主，这下我们可知道<code>addView()</code>最终是由谁来实现了，就是这个WindowManagerImpl类。来看看它的代码：</p><pre><code class="java">// WindowManagerImpl.javapublic final class WindowManagerImpl implements WindowManager &#123;    ...    private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();    ...    @Override    public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123;        applyDefaultToken(params);        mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);    &#125;&#125;</code></pre><p>WindowManagerGlobal是单例模式，看来是要与很多WindowManagerImpl的实例进行沟通。而且在调用<code>addView()</code>时，所以的要素全有了：</p><ol><li>要添加的View</li><li>该View的LayoutParams</li><li>Display（也即要显示的屏幕）</li><li>要添加到的Window（也即PhoneWindow实例）</li></ol><p>万事俱备只欠东风，我们来看看<code>WindowManagerGlobal.addView()</code>最后是如何把View添加到Window上的吧！</p><pre><code class="java">// WindowManagerGlobal.javapublic void addView(View view, ViewGroup.LayoutParams params,        Display display, Window parentWindow) &#123;    // 各种null检查    ...    final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;    if (parentWindow != null) &#123;        // 如果当前窗口需要被添加为另一个窗口的附属窗口(子窗口)，则需要父窗口视自己的情况对当前窗口的布局参数进行调整        parentWindow.adjustLayoutParamsForSubWindow(wparams);    &#125;    // 又是一个相当重要的类，后面会详细讲    ViewRootImpl root;    View panelParentView = null;    // 因为是单例的Global类，所以线程同步非常重要    synchronized (mLock) &#123;        ...        // If this is a panel window, then find the window it is being        // attached to for future reference.        if (wparams.type &gt;= WindowManager.LayoutParams.FIRST_SUB_WINDOW &amp;&amp;                wparams.type &lt;= WindowManager.LayoutParams.LAST_SUB_WINDOW) &#123;            final int count = mViews.size();            for (int i = 0; i &lt; count; i++) &#123;                if (mRoots.get(i).mWindow.asBinder() == wparams.token) &#123;                    panelParentView = mViews.get(i);                &#125;            &#125;        &#125;        root = new ViewRootImpl(view.getContext(), display);  // 1        view.setLayoutParams(wparams);        mViews.add(view);        mRoots.add(root);        mParams.add(wparams);        // do this last because it fires off messages to start doing things        try &#123;            // 将作为窗口的控件设置给ViewRootImpl.这个动作将导致ViewRootImpl向WMS添加新的窗口、            // 申请Surface以及托管控件在Surface上的重绘工作，            // 这才是真正意义上完成了窗口的添加工作。            root.setView(view, wparams, panelParentView);  // 2        &#125; catch (RuntimeException e) &#123;            // BadTokenException or InvalidDisplayException, clean up.            if (index &gt;= 0) &#123;                removeViewLocked(index, true);            &#125;            throw e;        &#125;    &#125;    public void updateViewLayout(View view, ViewGroup.LayoutParams params) &#123;        if (view == null) &#123;            throw new IllegalArgumentException(&quot;view must not be null&quot;);        &#125;        if (!(params instanceof WindowManager.LayoutParams)) &#123;            throw new IllegalArgumentException(&quot;Params must be WindowManager.LayoutParams&quot;);        &#125;        final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams)params;        view.setLayoutParams(wparams);        synchronized (mLock) &#123;            int index = findViewLocked(view, true);            ViewRootImpl root = mRoots.get(index);            mParams.remove(index);            mParams.add(index, wparams);            root.setLayoutParams(wparams, false);        &#125;    &#125;    @UnsupportedAppUsage    public void removeView(View view, boolean immediate) &#123;        if (view == null) &#123;            throw new IllegalArgumentException(&quot;view must not be null&quot;);        &#125;        synchronized (mLock) &#123;            int index = findViewLocked(view, true);            View curView = mRoots.get(index).getView();            removeViewLocked(index, immediate);            if (curView == view) &#123;                return;            &#125;            throw new IllegalStateException(&quot;Calling with view &quot; + view                    + &quot; but the ViewAncestor is attached to &quot; + curView);        &#125;    &#125;&#125;</code></pre><p>我们能看出，WindowManagerGlobal的职责如下：</p><ol><li>统一管理整个进程中所有窗口的信息。包括控件、布局参数以及ViewRootImpl这三个元素。</li><li>WindowManagerGlobal将窗口的创建、销毁、布局更新等任务交给了ViewRootImpl完成。</li></ol><p>根据的1和2两句代码，又引出了一个非常重要的类——ViewRootImpl。关于它，我们得单开一篇文章来讲讲。这里只简单带过一下：</p><pre><code class="java">// ViewRootImpl.java/** * View 层级的最顶端，在View和WindowManager实现了一些必要的协议。这个类是WindowManagerGlobal * 的大部分内部详细实现。 */@SuppressWarnings(&#123;&quot;EmptyCatchBlock&quot;, &quot;PointlessBooleanExpression&quot;&#125;)public final class ViewRootImpl implements ViewParent,        View.AttachInfo.Callbacks, ThreadedRenderer.DrawCallbacks &#123;    ...    // 这个类是建立硬件输入设备与软件关联的一个类，    // 也是窗口接收来自 InputDispatcher 的输入事件的管道    InputChannel mInputChannel;    // WindowInputEventReceiver 用于接收输入设备的输入事件，重要的事件回调在其 onInputEvent(InputEvent) 方法中    WindowInputEventReceiver mInputEventReceiver;    IWindowSession mWindowSession;    public ViewRootImpl(Context context, Display display) &#123;        ...        // 从 WindowManagerGlobal 中获取一个IWindowSession的实例。        // 它是ViewRootImpl和 WindowManagerService（以下简称WMS）进行通信的代理        mWindowSession = WindowManagerGlobal.getWindowSession();        ...    &#125;    // FallbackEventHandler是一个处理未经任何人消费的输入事件的场所.    mFallbackEventHandler = new PhoneFallbackEventHandler(context);    ...     /**     * We have one child     */    public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123;        synchronized (this) &#123;            if (mView == null) &#123;                mView = view;  // 将传入的 DecorView 保存到 mView                ...                mFallbackEventHandler.setView(view);                ...                int res; /* = WindowManagerImpl.ADD_OKAY; */                /**                 * 在添加窗口之前，先通过requestLayout方法在主线程上安排一次『遍历』。                 * 所谓『遍历』是指ViewRootImpl中的核心方法performTraversal()。                 * 这个方法实现对控件树进行measure、layout、向WMS申请修改窗口属性以及重绘的所有工作。                 */                requestLayout();                                // 此处新建了 InputChannel 的实例，但并未进行初始化，而是直接将给了 WindowSession 去进行初始化。                // 这也标志着在当前 Window 和 InputManagerService 中间，正式建立了接受设备事件的通道。                if ((mWindowAttributes.inputFeatures                        &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) &#123;                         mInputChannel = new InputChannel();                &#125;                ...                try &#123;                    ...                    /**                     *上文刚讲过 mWindowSession 是个 Binder 类，它的实现类是 Session，                     * 将通过 IPC 远程调用（即调用另一个进程中的）Session 的 addToDisplay 方法把窗口添加进WMS中。                     * 完成这个操作后，mWindow 已经被添加到指定对象中而且 mInputChannel（如果不为空）已经准备好接收事件                     * 只是由于这个窗口没有进行过relayout()，因此它还没有有效的Surface可以进行绘制                      */                    res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,                            getHostVisibility(), mDisplay.getDisplayId(), mTmpFrame,                            mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,                            mAttachInfo.mOutsets, mAttachInfo.mDisplayCutout, mInputChannel,                            mTempInsets);                &#125; catch (RemoteException e) &#123;                    ...                &#125; finally &#123;                    ...                &#125;                ...                // 如果mInputChannel不为空，则创建mInputEventReceiver，用于接受输入事件。                // 注意第二个参数传递的是Looper.myLooper()，即 mInputEventReceiver 将在主线程上                // 触发输入事件的读取与 onInputEvent()。这是应用程序可以在 onTouch() 等事件响应中                // 直接进行UI操作等根本原因。                if (mInputChannel != null) &#123;                    ...                    mInputEventReceiver = new WindowInputEventReceiver(mInputChannel,                            Looper.myLooper());                &#125;                ...                view.assignParent(this);                ...            &#125;        &#125;    &#125;&#125;</code></pre><p>接着分析代码可以看到mWindowSession的类型是：IWindowSession，并且是通过WindowManagerGlobal.getWindowSession()初始化的:</p><pre><code class="java">public static IWindowSession getWindowSession() &#123;    synchronized (WindowManagerGlobal.class) &#123;        if (sWindowSession == null) &#123;            try &#123;                InputMethodManager imm = InputMethodManager.getInstance();                IWindowManager windowManager = getWindowManagerService();                sWindowSession = windowManager.openSession(                        new IWindowSessionCallback.Stub() &#123;                            @Override                            public void onAnimatorScaleChanged(float scale) &#123;                                ValueAnimator.setDurationScale(scale);                            &#125;                        &#125;,                        imm.getClient(), imm.getInputContext());            &#125; catch (RemoteException e) &#123;                throw e.rethrowFromSystemServer();            &#125;        &#125;        return sWindowSession;    &#125;&#125;</code></pre><p>而getWindowSession方法里，则是跨进程调用openSession方法获取，我们来看看WindowManagerService里的openSession方法：</p><pre><code class="java">public class WindowManagerService extends IWindowManager.Stub implements Watchdog.Monitor, WindowManagerPolicy.WindowManagerFuncs &#123;    @Override    public IWindowSession openSession(IWindowSessionCallback callback, IInputMethodClient client,            IInputContext inputContext) &#123;        if (client == null) throw new IllegalArgumentException(&quot;null client&quot;);        if (inputContext == null) throw new IllegalArgumentException(&quot;null inputContext&quot;);        Session session = new Session(this, callback, client, inputContext);        return session;    &#125;&#125;</code></pre><p>于是这里的window被交给了IWindowSession.aidl的实现类Session中：</p><pre><code class="java">// Session.java/** * 这个类代表了一个 * This class represents an active client session.  There is generally one * Session object per process that is interacting with the window manager. */class Session extends IWindowSession.Stub implements IBinder.DeathRecipient &#123;    @Override    public int addToDisplay(IWindow window, int seq, WindowManager.LayoutParams attrs,            int viewVisibility, int displayId, Rect outFrame, Rect outContentInsets,            Rect outStableInsets, Rect outOutsets,            DisplayCutout.ParcelableWrapper outDisplayCutout, InputChannel outInputChannel,            InsetsState outInsetsState) &#123;        return mService.addWindow(this, window, seq, attrs, viewVisibility, displayId, outFrame,                outContentInsets, outStableInsets, outOutsets, outDisplayCutout, outInputChannel,                outInsetsState);    &#125;&#125;</code></pre><p>此处的<code>mService</code>自然就是WindowManagerService喽，也就是绕完一圈，还是把<code>addWindow()</code>的工作交给了WindowManagerService。我们来看看WindowManagerService里是怎样添加Window的：</p><pre><code class="java">final WindowHashMap mWindowMap = new WIndowHashMap();public int addWindow(Session session, IWindow client, int seq,            LayoutParams attrs, int viewVisibility, int displayId, Rect outFrame,            Rect outContentInsets, Rect outStableInsets, Rect outOutsets,            DisplayCutout.ParcelableWrapper outDisplayCutout, InputChannel outInputChannel,            InsetsState outInsetsState) &#123;    ...    WindowState parentWindow = null;    ...    synchronized (mGlobalLock) &#123;        ...        final WindowState win = new WindowState(this, session, client, token, parentWindow,                    appOp[0], seq, attrs, viewVisibility, session.mUid,                    session.mCanAddInternalSystemWindow);        ...        // From now on, no exceptions or errors allowed!        ...        win.attach();        mWindowMap.put(client.asBinder(), win);        win.initAppOpsState();    &#125;&#125;</code></pre><p>刚才从ViewRootImpl开始，直到这里添加Window结束，整个流程可以归结为下面二图：</p><p><img src="/img/24.png"><br><img src="/img/25.png"></p><p>如此一来，Window的添加请求就交给WMS去处理了，在WMS内部会为每一个应用保留一个单独的Session。在 WMS 端会创建一个WindowState对象用来表示当前添加的窗口。 WMS负责管理这里些 WindowState 对象。至此，Window的添加过程就结束了。</p><p>至于Window的删除和更新过程，举一反三，也是使用WindowManagerGlobal对ViewRootImpl的操作，最终也是通过Session的IPC跨进程通信通知到WMS。整个过程的本质都是同出一辙的。</p><p>至此，从Activity的创建，到内容显示在屏幕上，已经基本完成，背后的工作还需要交给WindowServiceManager以及硬件层面的一此工作，也就不在我们的讨论范围里了。</p><p>最后再来一张整体的流程图，我们再梳理一下：</p><p><img src="/img/26.png"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Activity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 Butter Knife</title>
      <link href="/2020-02-13//"/>
      <url>/2020-02-13//</url>
      
        <content type="html"><![CDATA[<p>这篇文章讲一下 Butterknife，但是后面会引申到 Android Jetpack 中的 DataBinding。</p>]]></content>
      
      
      <categories>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> butterknife </tag>
            
            <tag> 源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于注解</title>
      <link href="/2020-02-03/annotation/"/>
      <url>/2020-02-03/annotation/</url>
      
        <content type="html"><![CDATA[<p>Annotation 是 JDK1.5 之后加入到 Java 中的，它其实就是代码里的特殊标记, 用于替代配置文件，也就是说，传统方式通过配置文件告诉类如何运行，有了注解技术后，开发人员可以通过注解<strong>告诉类如何运行</strong>。它提供了一种安全的<strong>类似注释的机制</strong>，用来将信息或元数据（metadata）与程序元素（类、方法、成员变量等）进行关联。它像一种修饰符一样，应用于包、类型、构造方法、方法、成员变量、参数及本地变量的声明语句中。</p><span id="more"></span><p>注解是以<code>@注解名</code>在代码中存在的，根据注解参数的个数，我们可以将注解分为：</p><ul><li>标记注解</li><li>单值注解</li><li>完整注解 </li></ul><p>它们都不会直接影响到程序的语义，只是作为注解（标识）存在，我们可以通过反射机制编程实现对这些元数据（用来描述数据的数据）的访问。</p><p>下图展示了 Java 中常见的注解的分类：</p><div class="center-img"><p><img src="/img/annotation-1588558927.png"></p></div><h2 id="标准注解"><a href="#标准注解" class="headerlink" title="标准注解"></a>标准注解</h2><p>Java中有三个最基本的标准注解：</p><ul><li><code>@Override</code>: 限定重写父类方法, 该注解只能用于方法。</li><li><code>@Deprecated</code>: 用于表示某个程序元素（类, 方法等）已过时。</li><li><code>@SuppressWarnings</code>: 抑制编译器警告。</li></ul><p>注解属性的类型只能是如下类型：String 类型、8大基本数据类型（int, float, boolean, byte, double, char, long, short）、Class类型、枚举类型、注解类型以及以上类型的一维数组。如果一个注解只有一个属性，并且这个属性的名称为<code>value</code>的话，那么使用注解时<strong>可以省略</strong><code>value=</code>部分，如将<code>@MyAnnotation(value=&quot;XXX&quot;)</code>替换为<code>@MyAnnotation(&quot;xxx&quot;)</code>。</p><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>提到注解，也不得不提一下『<strong>元注解</strong>』。元注解即『<strong>注解的注解</strong>』，专门负责注解其他的注解。在Java中有几种常用的元注解，分别如下：</p><ul><li><code>@Retention</code>：标识什么时候使用该注解。</li><li><code>@Documented</code>：注解是否将包含在Javadoc中。</li><li><code>@Target</code>：注解将用于什么地方。</li><li><code>@Inherited</code>：是否允许子类继承该注解。</li><li><code>@Repeatable</code>：允许对某个元素多次使用同一个注解。</li></ul><p>其中，Repeatable 是在 jdk1.8 中引进的。我们简单地解释一下这几种元注解。</p><h3 id="1-Retention"><a href="#1-Retention" class="headerlink" title="1. Retention"></a>1. <strong>Retention</strong></h3><p>Retention 元注解，表示需要<strong>在什么级别保存该注解信息</strong>（生命周期）。如果注解类型声明中不存在 Retention 注解，则保留策略默认为 <code>RetentionPolicy.CLASS</code>。可选的 RetentionPoicy 参数包括：</p><table><thead><tr><th>枚举常量</th><th>描述</th></tr></thead><tbody><tr><td><code>RetentionPolicy.SOURCE</code></td><td>停留在 java 源文件，会被编译器丢弃</td></tr><tr><td><code>RetentionPolicy.CLASS</code></td><td>停留在 class 文件中，但会被VM丢弃（默认）</td></tr><tr><td><code>RetentionPolicy.RUNTIME</code></td><td>内存中的字节码，VM 将在运行时也保留注解，因此可以通过反射机制读取注解的信息</td></tr></tbody></table><h3 id="2-Documented"><a href="#2-Documented" class="headerlink" title="2. Documented"></a>2. <strong>Documented</strong></h3><p>Documented 将注解包含在 Javadoc 中。</p><p>使用该注解，表示某一个类型的注释将通过 Javadoc 或者类似的工具进行文档化，应使用此类型来注释这些类型的声明，其注释会影响由其客户端注释的元素的使用。如果类型声明是用 Documented 来注释的，则其注释将成为注释元素的公共 API 的一部分。</p><h3 id="3-Target"><a href="#3-Target" class="headerlink" title="3. Target"></a>3. <strong>Target</strong></h3><p>Target 说明了注解<strong>所修饰的对象范围</strong>：Annotation 可被用于 packages、types（类、接口、枚举、Annotation 类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数）。在 Annotation 类型的声明中使用了 Target 可更加明晰其修饰的目标。只有元注解类型直接用于注解时，Target 元注释才有效。如果元注解类型用作另一种注解类型的成员，则无效。如果注释类型声明中不存在 Target 元注释，则声明的类型可以用在任一程序元素上。如果存在这样的元注释，则编译器强制实施指定的使用限制。</p><table><thead><tr><th>枚举常量</th><th>描述</th></tr></thead><tbody><tr><td><code>ElementType.CONSTRUCTOR</code></td><td>构造器声明</td></tr><tr><td><code>ElementType.FIELD</code></td><td>成员变量、对象、属性（包括enum实例）</td></tr><tr><td><code>ElementType.LOCAL_VARIABLE</code></td><td>局部变量声明</td></tr><tr><td><code>ElementType.METHOD</code></td><td>方法声明</td></tr><tr><td><code>ElementType.PACKAGE</code></td><td>包声明</td></tr><tr><td><code>ElementType.PARAMETER</code></td><td>参数声明</td></tr><tr><td><code>ElementType.TYPE</code></td><td>类、接口（包括注解类型)或enum声明</td></tr></tbody></table><p>举个例子，Retrofit2中有个<code>@Field</code>注解，我们看看它的源码：</p><pre><code class="java">// Field.javaimport java.lang.annotation.Annotation;import java.lang.annotation.Documented;import java.lang.annotation.Retention;import java.lang.annotation.Target;@Documented@Target(PARAMETER)@Retention(RUNTIME)public @interface Field &#123;  String value();  /** Specifies whether the &#123;@linkplain #value() name&#125; and value are already URL encoded. */  boolean encoded() default false;&#125;</code></pre><p>其 Target 注解的常量类型为<code>PARAMETER</code>，表示<code>Field</code>这个注解适用于<strong>参数</strong>，如果这个注解用在了方法上，那就不起任何作用。</p><h3 id="4-Inherited"><a href="#4-Inherited" class="headerlink" title="4. Inherited"></a>4. <strong>Inherited</strong></h3><p>Inherited 允许子类继承父类中的注解，注释类型被自动继承。</p><p>如果在注释类型声明中存在 Inherited 元注释，并且用户在某一类声明中查询该注释类型，同时该类声明中没有此类型的注释，则将在该类的超类中自动查询该注释类型。此过程会重复进行，直到找到此类型的注释或到达了该类层次结构的顶层 (Object) 为止。如果没有超类具有该类型的注释，则查询将指示当前类没有这样的注释。如果使用注释类型注释类以外的任何事物，此元注释类型都是无效的。此元注释仅促成从超类继承注释，对已实现接口的注释无效。</p><h3 id="5-Repeatable"><a href="#5-Repeatable" class="headerlink" title="5. Repeatable"></a>5. <strong>Repeatable</strong></h3><p>Repeatable 表示被标记的注解可以<strong>多次应用于相同的声明或类型</strong>。举例如下：</p><p>先声明一个重复注解类：</p><pre><code class="java">@Repeatable(Tip.class)public @interface Tip &#123;    String dayOfMonth() default &quot;1&quot;;    String dayOfWeek() default &quot;Monday&quot;;    int hour() default 12;&#125;</code></pre><p>再声明一个容器注解类：</p><pre><code class="java">@Retention(RetentionPolicy.RUNTIME)public @interface Tips &#123;    Tip[] value();&#125;</code></pre><p>然后是使用：</p><pre><code class="java">@Tip(dayOfMonth = &quot;10&quot;)@Tip(dayOfWeek = &quot;Tuesday&quot;, hour = 15)public class RepetableAnnotation&#123;    @Tip(dayOfMonth = &quot;20&quot;)    @Tip(dayOfWeek = &quot;Friday&quot;, hour = 23)    public void doPeriodicTip()&#123;&#125;    public static void main(String[] args) throws NoSuchMethodException &#123;        Method doPeriodicTip = RepetableAnnotation.class.getMethod(&quot;doPeriodicTip&quot;);        Tips tips = doPeriodicTip.getAnnotation(Tips.class);        System.out.println(&quot;获取标记方法上的重复注解：&quot;);        for (Tip tip: tips.value())&#123;            System.out.println(tip);        &#125;        System.out.println(&quot;获取标记类上的重复注解：&quot;);        if (RepetableAnnotation.class.isAnnotationPresent(Tips.class))&#123;            Tips = RepetableAnnotation.class.getAnnotation(Tips.class);            for (Tip Tip: Tips.value())&#123;                System.out.println(Tip);            &#125;        &#125;    &#125;&#125;</code></pre><p>运行结果如下：</p><pre><code>获取标记方法上的重复注解：Tip(hour=12, dayOfMonth=10, dayOfWeek=Monday)Tip(hour=23, dayOfMonth=1, dayOfWeek=Friday)获取标记类上的重复注解：Tip(hour=12, dayOfMonth=10, dayOfWeek=Monday)Tip(hour=15, dayOfMonth=1, dayOfWeek=Tuesday)</code></pre><h2 id="注解的用途"><a href="#注解的用途" class="headerlink" title="注解的用途"></a>注解的用途</h2><p>注解在大多数时候，它的用途就是『简化代码，让你专注做重要的事情』。当然，不同的注解有不同的功能，下面列出四个主要的功能：</p><ol><li><strong>生成文档</strong>，通过代码里标识的元数据生成 Javadoc 文档。</li><li><strong>编译检查</strong>，通过代码里标识的元数据让编译器在编译期间进行检查验证。</li><li><strong>编译时动态处理</strong>，编译时通过代码里标识的元数据动态处理，例如动态生成代码。</li><li><strong>运行时动态处理</strong>，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例。</li></ol><p>下面我们用一个栗子，来介绍一下注解的基本原理。</p><h2 id="注解的实现原理"><a href="#注解的实现原理" class="headerlink" title="注解的实现原理"></a>注解的实现原理</h2><pre><code class="java">// CustomTargetType.java/** * 定义一个可以注解在 class,interface,enum 上的注解 */import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface CustomTargetType &#123;    String value() default &quot;我是定义在类、接口、枚举类上的注解元素 value 的默认值&quot;;&#125;</code></pre><pre><code class="java">// CustomTargetField.java/** * 定义一个可以注解在FIELD上的注解 */import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface CustomTargetField &#123;    String value() default &quot;我是定义在字段上的注解元素 value 的默认值&quot;;&#125;</code></pre><pre><code class="java">// CustomTargetMethod.java/** * 定义一个可以注解在METHOD上的注解 */import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface CustomTargetMethod &#123;    String value() default &quot;我是定义在方法上的注解元素 value 的默认值&quot;;&#125;</code></pre><pre><code class="java">// CustomTargetParameter.java/** * 定义一个可以注解在PARAMETER上的注解 */import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(ElementType.PARAMETER)@Retention(RetentionPolicy.RUNTIME)public @interface CustomTargetParameter &#123;    String value() default &quot;我是定义在参数上的注解元素 value 的默认值&quot;;&#125;</code></pre><p>注解定义完毕后，我们写一个测试类来处理上面的注解：</p><pre><code class="java">// AnnotationTest.java@CustomTargetTypepublic class AnnotationTest &#123;    @CustomTargetField    private String mField = &quot;我是字段&quot;;    @CustomTargetMethod(&quot;测试方法&quot;)    public void test(@CustomTargetParameter String args) &#123;        System.out.println(&quot;参数值 === &quot; + args);    &#125;    public static void main(String[] args) &#123;        // 获取类上的注解 CustomTargetType        CustomTargetType t = AnnotationTest.class.getAnnotation(CustomTargetType.class);        System.out.println(&quot;类上的注解值 === &quot; + t.value());        CustomTargetMethod tm = null;        try &#123;            // 根据反射获取 AnnotationTest 类上的 test 方法            Method method = AnnotationTest.class.getDeclaredMethod(&quot;test&quot;,String.class);            // 获取方法上的注解 CustomTargetMethod            tm = method.getAnnotation(CustomTargetMethod.class);            System.out.println(&quot;方法上的注解值 === &quot; + tm.value());            // 获取方法上的所有参数注解，循环所有注解找到 CustomTargetParameter 注解            Annotation[][] annotations = method.getParameterAnnotations();            for(Annotation[] tt : annotations)&#123;                for(Annotation t1:tt)&#123;                    if(t1 instanceof CustomTargetParameter)&#123;                        System.out.println(&quot;参数上的注解值 === &quot;+((CustomTargetParameter) t1).value());                    &#125;                &#125;            &#125;            method.invoke(new AnnotationTest(), &quot;改变默认参数&quot;);            // 获取 AnnotationTest 类上字段 mField 的注解 CustomTargetField            CustomTargetField fieldAn = AnnotationTest.class.getDeclaredField(&quot;mField&quot;).getAnnotation(CustomTargetField.class);            System.out.println(&quot;字段上的注解值 === &quot; + fieldAn.value());        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p>运行结果如下：</p><pre><code class="java">类上的注解值 === 我是定义在类、接口、枚举类上的注解元素 value 的默认值参数上的注解值 === 我是定义在参数上的注解元素 value 的默认值参数值 === 改变默认参数方法上的注解值 === 测试方法字段上的注解值 === 我是定义在字段上的注解元素 value 的默认值</code></pre><p>它们是如何工作的呢？</p><p>我们观察上方的栗子，不难看出，每个注解有三个要素：</p><ul><li>注解声明</li><li>使用注解的元素</li><li>操作注解使其生效 - 由注解处理器来完成</li></ul><p>注解声明和使用注解的元素不必多说，我们详细讲讲注解处理器是如何处理注解的。</p><h2 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器"></a>注解处理器</h2><p>::: tips 什么是注解处理器？<br>注解处理器是（Annotation Processor）是 javac 的一个工具，用来在<strong>编译时扫描和处理注解</strong>。你可以自定义注解处理器去处理一些事务。一个注解处理器它<strong>以 java 代码</strong>或者<strong>编译过的字节码</strong>作为输入，生成文件（通常是 java 文件）。这些生成的 java 文件不能修改，并且会同其手动编写的 java 代码一样会被 javac 编译。说白了就是把标记了注解的类、变量等作为输入内容，经过注解处理器处理，生成想要生成的 java 代码。<br>:::</p><h3 id="AbstractProcessor"><a href="#AbstractProcessor" class="headerlink" title="AbstractProcessor"></a>AbstractProcessor</h3><p>处理器的写法有固定的套路，继承AbstractProcessor。如下：</p><pre><code class="java">public abstract class AbstractProcessor implements Processor &#123;    // 使用 processingEvn 初始化处理器    // 如果同一个对象的该方法被调用多次，将会抛出 IllegalStateException 异常    public synchronized void init(ProcessingEnvironment processingEnv) &#123;        if (initialized)            throw new IllegalStateException(&quot;Cannot call init more than once.&quot;);        Objects.requireNonNull(processingEnv, &quot;Tool provided null ProcessingEnvironment&quot;);        this.processingEnv = processingEnv;        initialized = true;    &#125;    // 如果注解处理器类被 @SupportedAnnotationTypes 注解过，则返回该注解处理器支持的注解类的名称 Set    // 如果没有，就返回一个空 Set    public Set&lt;String&gt; getSupportedAnnotationTypes() &#123;            SupportedAnnotationTypes sat = this.getClass().getAnnotation(SupportedAnnotationTypes.class);            if  (sat == null) &#123;                if (isInitialized())                    processingEnv.getMessager().printMessage(Diagnostic.Kind.WARNING,                                                             &quot;No SupportedAnnotationTypes annotation &quot; +                                                             &quot;found on &quot; + this.getClass().getName() +                                                             &quot;, returning an empty set.&quot;);                return Collections.emptySet();            &#125;            else                return arrayToSet(sat.value());        &#125;    // 如果注解处理器类被 @SupportedSourceVersion 注解过，则返回该注解支持的最小 source version    // 如果没有，返回 SourceVersion#RELEASE_6    public SourceVersion getSupportedSourceVersion() &#123;        SupportedSourceVersion ssv = this.getClass().getAnnotation(SupportedSourceVersion.class);        SourceVersion sv = null;        if (ssv == null) &#123;            sv = SourceVersion.RELEASE_6;            if (isInitialized())                processingEnv.getMessager().printMessage(Diagnostic.Kind.WARNING,                                                         &quot;No SupportedSourceVersion annotation &quot; +                                                         &quot;found on &quot; + this.getClass().getName() +                                                         &quot;, returning &quot; + sv + &quot;.&quot;);        &#125; else            sv = ssv.value();        return sv;    &#125;    // 主要的处理过程，重写这个方法来扫描并处理你的注解，生成 java 代码    public abstract boolean process(Set&lt;? extends TypeElement&gt; annotations,                                    RoundEnvironment roundEnv);&#125;</code></pre><p>我们会在<a href="/butterknife/">这篇文章</a>里详细解释如何使用自定义注解。</p><p>::: details 废弃</p><h2 id="注解处理器-1"><a href="#注解处理器-1" class="headerlink" title="注解处理器"></a>注解处理器</h2><p>不同的程序元素，其注解处理器的处理方式不太一样，我们需要各个分析。</p><h3 id="Class-注解处理器"><a href="#Class-注解处理器" class="headerlink" title="Class 注解处理器"></a>Class 注解处理器</h3><p>我们从<code>AnnotationTest.class.getAnnotation()</code>方法开始入手。<strong>下方代码基于 jdk1.8</strong>：</p><pre><code class="java">// Class.java@SuppressWarnings(&quot;unchecked&quot;)public &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass) &#123;    Objects.requireNonNull(annotationClass);    return (A) annotationData().annotations.get(annotationClass);&#125;</code></pre><p>瞧，这个方法本身居然还使用了<code>@SuppressWarnings</code>注解呢。</p><p>这个方法是实现了<code>java.lang.reflect.AnnotatedElement</code>接口中的<code>getAnnotation()</code>方法：</p><pre><code class="java">// java.lang.reflect.AnnotatedElement.java// 如果元素有注解的话，返回元素的注解，否则返回 null。&lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass);</code></pre><p><code>java.lang.reflect.AnnotatedElement</code>接口是所有程序元素（Class、Method 和 Constructor）的父接口，所以程序通过反射获取了某个类的 AnnotatedElement 对象之后，程序就可以调用该对象的如下 4 个方法来访问 Annotation 信息：</p><ol><li><code>&lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass)</code>: 返回改程序元素上<strong>存在的、指定类型的注解</strong>，如果该类型注解不存在，则返回 null。</li><li><code>Annotation[] getAnnotations()</code>:返回该程序元素上存在的<strong>所有注解</strong>。</li><li><code>Annotation[] getDeclaredAnnotations()</code>：返回直接存在于此元素上的<strong>所有注解</strong>。与第2个方法不同的地方在于，<strong>该方法将忽略继承的注解</strong>（如果没有注解直接存在于此元素上，则返回长度为零的一个数组）。</li><li><code>boolean is AnnotationPresent(Class&lt;?extends Annotation&gt; annotationClass)</code>:判断该程序元素上<strong>是否包含指定类型的注解</strong>，存在则返回<code>true</code>，否则返回<code>false</code>。</li></ol><p>然后接着分析上面的代码：</p><pre><code class="java">// Class.java// Annotations cache@SuppressWarnings(&quot;UnusedDeclaration&quot;)private volatile transient AnnotationData annotationData;private AnnotationData annotationData() &#123;    while (true) &#123; // 重复获取直到成功        AnnotationData annotationData = this.annotationData;        int classRedefinedCount = this.classRedefinedCount;        // 判断是否为旧注解        // 因为 JVM 调用 RedefineClass() 方法时，annotationData 的值可能会发生改变，        // 此时，必须要刷新一次 annotationData        if (annotationData != null &amp;&amp;            annotationData.redefinedCount == classRedefinedCount) &#123;            return annotationData;        &#125;        // 空注解或旧注解，就创建新的注解实例        AnnotationData newAnnotationData = createAnnotationData(classRedefinedCount);        // 将新建的 annotationData 关联到这个类上        // 最终会调用到 native 层的 compareAndSwapObject        if (Atomic.casAnnotationData(this, annotationData, newAnnotationData)) &#123;            return newAnnotationData;        &#125;    &#125;&#125;</code></pre><p>这段代码旨在将类的注解取出，并放在一个用 transient 修饰的变量中，用于缓存。</p><p>第一次调用该方法时，annotationData 为 null，则需要新建 annotationData 的实例，并关联到类上。</p><p>AnnotationData 类的声明如下：</p><pre><code class="java">// annotation data that might get invalidated when JVM TI RedefineClasses() is calledprivate static class AnnotationData &#123;    // 用以存储 annotations 的 map    final Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations;    final Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations;    // 记录创建了几次 annotationData，用于与 Class.classRedefinedCount 进行对比，    // 以决定是否要刷新 annotationData    final int redefinedCount;    AnnotationData(Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations,                    Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations,                    int redefinedCount) &#123;        this.annotations = annotations;        this.declaredAnnotations = declaredAnnotations;        this.redefinedCount = redefinedCount;    &#125;&#125;</code></pre><p>最后来梳理一下整个反射注解的工作原理：</p><p>首先，我们通过<strong>键值对</strong>的形式可以<strong>为注解属性赋值</strong>，像这样：@Hello（value = “hello”）。</p><p>接着，你用注解修饰某个元素，编译器将在编译期扫描每个类或者方法上的注解，会做一个基本的检查，你的这个注解是否允许作用在当前位置，最后会将注解信息<strong>写入元素的属性表</strong>。</p><p>然后，当你进行反射的时候，虚拟机将所有生命周期在 RUNTIME 的注解取出来放到一个 map 中，并创建一个 AnnotationInvocationHandler 实例，把这个 map 传递给它。</p><p>最后，虚拟机将采用 JDK 动态代理机制生成一个目标注解的代理类，并初始化好处理器。<br>:::</p><p>我也写了一篇单独的文章 - 《<a href="2020-04-10-about-retrofit">Retrofit 实现原理解析</a>》，来作为注解使用的最佳解析。</p>]]></content>
      
      
      <categories>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于几种常见的缓存算法</title>
      <link href="/2020-01-07/cache-algorithms/"/>
      <url>/2020-01-07/cache-algorithms/</url>
      
        <content type="html"><![CDATA[<p>目前常见的几种缓存算法包括但不限于 <a href="#fifo-%E7%AE%97%E6%B3%95">FIFO</a>、<a href="#lru-%E7%AE%97%E6%B3%95">LRU</a>、<a href="#lfu-%E7%AE%97%E6%B3%95">LFU</a>、<a href="#mru-%E7%AE%97%E6%B3%95">MRU</a>。下面我们一一介绍并深入一下。</p><span id="more"></span><h2 id="FIFO-算法"><a href="#FIFO-算法" class="headerlink" title="FIFO 算法"></a>FIFO 算法</h2><p>FIFO（First In First Out）是比较常见的算法了，队列（Queue）就是实现了这种算法的最好例子。这是最简单、最公平的一种算法思想，它认为<strong>如果一个数据是最先进入的，那么在将来它被访问的可能性是最小的。空间满的时候，最先进入的数据会被淘汰掉</strong>。</p><p>下图展示 FIFO 算法在访问顺序是 A、B、C、D、E、D、F 的情况下，缓存列表的更新情况（链表大小假定为4）：</p><div class="center-img"><p><img src="/img/cache-1588212789.png"></p><p><em>白色代表无数据，灰色代表未更新数据，绿色代表被更新数据</em></p></div><p>FIFO 的实现比较简单，可以维护一个FIFO队列，按照时间顺序将各数据链接起来组成队列，并将置换指针指向队列的队首。再进行置换时，只需把置换指针所指的数据（页面）顺次换出，并把新加入的数据插到队尾即可。</p><p><strong>优点</strong>：实现简单</p><p><strong>缺点</strong>：判断一个缓存算法优劣的指标就是命中率，而 FIFO 算法的一个显著的缺点是，在某些特定的时刻，命中率反而会随着缓存量的增加而减少，这称为 <strong>Belady 现象</strong>。产生 Belady 现象的原因是，FIFO 置换算法<strong>与进程访问内存的动态特征是不相容的</strong>，被置换的数据往往是被频繁访问的，或者没有给进程分配足够的缓存空间，因此 FIFO 算法会使一些数据<strong>频繁地被替换和重新申请内存</strong>，从而导致命中率降低。因此，现在几乎不再使用 FIFO 算法。</p><h2 id="LRU-算法"><a href="#LRU-算法" class="headerlink" title="LRU 算法"></a>LRU 算法</h2><h3 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h3><p>LRU（Least recently used）算法会根据数据的<strong>历史访问记录</strong>来进行淘汰数据，其核心思想是『<strong>如果数据最近被访问过，那么将来被访问的几率也更高</strong>』。</p><p>下图展示了访问顺序是 A、B、C、D、E、D、F 情况下，缓存列表的更新情况：</p><div class="center-img"><p><img src="/img/cache-1588220432.png"></p><p><em>白色代表无数据，灰色代表未更新数据，绿色代表被更新数据</em></p></div><p>由上图可以总结一下 LRU 算法的几个特点：</p><ol><li>新来的数据会插入链表的头部</li><li>如果链表已满（达到最大长度），则会丢弃掉链表尾部的数据</li><li>如果访问时命中，则要移动数据的位置<sup><a href="#%E6%B3%A81">注1</a></sup></li></ol><p>LRU 的实现一般是使用 LinkedHashMap，即包含了用来表示『位置』的双向链表，也包含用来『存储和获取』的 HashMap。</p><p><strong>优点</strong>：实现起来相对简单。</p><p><strong>缺点</strong>：当存在热点数据时，LRU 的效率很好；但偶发性的、周期性的批量操作会导致 LRU 命中率急剧下降，缓存污染情况比较严重。</p><p>我们来写个代码简单实现一下 LRU 算法：</p><pre><code class="java">import java.util.LinkedHashMap;import java.util.Map;import java.util.logging.Level;import java.util.logging.Logger;public class LruCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; &#123;    private int cacheSize;    public LruCache(int cacheSize) &#123;        // 三个参数分别是：初始大小、负载因子、是否开启访问顺序（accessOrder）        // 开启访问顺序后，被命中的数据会移动到链表的头部        super(16, (float) 0.75, true);        this.cacheSize = cacheSize;    &#125;    // 复写该方法，来决定是否要移除最旧的数据，该方法在 LinkedHashMap 中默认返回 false    protected boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest) &#123;        return size() &gt; cacheSize;    &#125;    public void print()    &#123;        Iterator&lt;K&gt; itr = this.keySet().iterator();        while (itr.hasNext()) &#123;            System.out.print(itr.next() + &quot; &quot;);        &#125;        System.out.println();    &#125;    public static void main(String[] args) &#123;        LruCache&lt;String, Integer&gt; lruCache = new LruCache&lt;String, Integer&gt;(4);        for(int i = 0; i &lt; 10; i++) &#123;            lruCache.put(&quot;K&quot; + i, i);        &#125;        lruCache.print();        lruCache.put(&quot;K10&quot;, 10);        lruCache.print();        lruCache.get(&quot;K7&quot;);        lruCache.print();    &#125;&#125;</code></pre><p>输出结果如下：</p><pre><code>K6 K7 K8 K9K7 K8 K9 K10K8 K9 K10 K7</code></pre><p>很明显这个实现类是<span style="color: red; font-weight: bold;">线程不安全</span>的，因为 LinkedHashMap 本身就是<span style="color: red; font-weight: bold;">线程不安全</span>的。</p><h3 id="LRU-K"><a href="#LRU-K" class="headerlink" title="LRU-K"></a>LRU-K</h3><p>LRU-K 中的 K 代表<strong>最近使用的次数</strong>，所以，LRU 可以被认为是 LRU-1。LRU-K 的主要目的是为了解决 LRU 算法『缓存污染』的问题，其核心思想是将『<strong>最近使用过1次</strong>』的判断标准扩展为『<strong>最近使用过K次</strong>』。</p><p>于是，相比 LRU，LRU-K 需要多维护一个队列，用于记录所有缓存数据被访问的历史。只有当数据的访问次数达到 K 次的时候，才将数据放入缓存。当需要淘汰数据时，LRU-K 会淘汰<strong>第 K 次访问时间距当前时间最大的数据</strong>。</p><h3 id="Android-中的-LruCache"><a href="#Android-中的-LruCache" class="headerlink" title="Android 中的 LruCache"></a>Android 中的 LruCache</h3><p>Android 中的 LruCache 实现与上面直接使用 LinkedHashMap 的特性不一样，它自定义了数据插入的位置、获取的策略和丢弃的策略。</p><p>话不多说，直接上代码，在注释中进行详解：</p><pre><code class="java">// android.util.LruCache.javapackage android.util;import java.util.LinkedHashMap;import java.util.Map;/** * 这是一个缓存，里面的数据都是强引用，包含有限数量的数据。 * 每次当某个数据被访问，它会被移动到队列的头部。当缓存已满，新数据来临时，队列尾部的数据会被丢弃，GC 就可以回收它了。 *  * 如果你缓存的数据需要被显式地释放掉，那就重写 entryRemoved 方法。 * * 如果缓存未命中时，需要计算并获取对应的key，重写 create 方法。 *  * 默认情况下，缓存的大小以 Entry 的个数界决的，你可以重写 sizeOf 方法用不同的单位来决定缓存空间的大小。 * 比如，下面这个缓存的上限是 4MB 的 bitmap： * * int cacheSize = 4 * 1024 * 1024; // 4MiB * LruCache&lt;String, Bitmap&gt; bitmapCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) &#123; *     protected int sizeOf(String key, Bitmap value) &#123; *         return value.getByteCount(); *     &#125; * &#125; * * 这个 LruCache 类是线程安全的。可以用下面的方法来安全地插入和获取数据： * * synchronized (cache) &#123; *   if (cache.get(key) == null) &#123; *       cache.put(key, value); *   &#125; * &#125; * * 该类不允许 null key 或者 null value。当 get、put、remove 方法返回 null 时，它的意思很明确：key 不在缓存中 */public class LruCache&lt;K, V&gt; &#123;    private final LinkedHashMap&lt;K, V&gt; map;    private int size;    private int maxSize;    // 插入次数    private int putCount;    // 新建次数    private int createCount;    // 丢弃次数    private int evictionCount;    // 命中次数    private int hitCount;    // 未命中次数    private int missCount;    // maxSize 就是没有重写 sizeOf 方法的缓存大小，也即 Entry 的条目数量    public LruCache(int maxSize) &#123;        if (maxSize &lt;= 0) &#123;            throw new IllegalArgumentException(&quot;maxSize &lt;= 0&quot;);        &#125;        this.maxSize = maxSize;        this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true);    &#125;    public void resize(int maxSize) &#123;        if (maxSize &lt;= 0) &#123;            throw new IllegalArgumentException(&quot;maxSize &lt;= 0&quot;);        &#125;        synchronized (this) &#123;            this.maxSize = maxSize;        &#125;        trimToSize(maxSize);    &#125;    public final V get(K key) &#123;        if (key == null) &#123;            throw new NullPointerException(&quot;key == null&quot;);        &#125;        V mapValue;        synchronized (this) &#123;            mapValue = map.get(key);            if (mapValue != null) &#123;                hitCount++;                return mapValue;            &#125;            missCount++;        &#125;        // 尝试根据 key 创建一个 value。        // 因为这段代码不是同步的，所以在 create 方法结束的时候，map 的内容可能已经变化了。        // 如果 create 方法返回的值与 map 中的值冲突，我们就释放 create 的值，并保留 map 中的值。        // 目前 create 总是返回 null。        V createdValue = create(key);        if (createdValue == null) &#123;            return null;        &#125;        synchronized (this) &#123;            createCount++;            mapValue = map.put(key, createdValue);            if (mapValue != null) &#123;                // There was a conflict so undo that last put                map.put(key, mapValue);            &#125; else &#123;                size += safeSizeOf(key, createdValue);            &#125;        &#125;        if (mapValue != null) &#123;            entryRemoved(false, key, createdValue, mapValue);            return mapValue;        &#125; else &#123;            trimToSize(maxSize);            return createdValue;        &#125;    &#125;    // value 会被放到队列的头部    public final V put(K key, V value) &#123;        if (key == null || value == null) &#123;            throw new NullPointerException(&quot;key == null || value == null&quot;);        &#125;        V previous;        synchronized (this) &#123;            putCount++;            size += safeSizeOf(key, value);            previous = map.put(key, value);            if (previous != null) &#123;                size -= safeSizeOf(key, previous);            &#125;        &#125;        if (previous != null) &#123;            entryRemoved(false, key, previous, value);        &#125;        trimToSize(maxSize);        return previous;    &#125;    private void trimToSize(int maxSize) &#123;        while (true) &#123;            K key;            V value;            synchronized (this) &#123;                if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) &#123;                    throw new IllegalStateException(getClass().getName()                            + &quot;.sizeOf() is reporting inconsistent results!&quot;);                &#125;                if (size &lt;= maxSize) &#123;                    break;                &#125;                // BEGIN LAYOUTLIB CHANGE                // get the last item in the linked list.                // This is not efficient, the goal here is to minimize the changes                // compared to the platform version.                Map.Entry&lt;K, V&gt; toEvict = null;                for (Map.Entry&lt;K, V&gt; entry : map.entrySet()) &#123;                    toEvict = entry;                &#125;                // END LAYOUTLIB CHANGE                if (toEvict == null) &#123;                    break;                &#125;                key = toEvict.getKey();                value = toEvict.getValue();                map.remove(key);                size -= safeSizeOf(key, value);                evictionCount++;            &#125;            entryRemoved(true, key, value, null);        &#125;    &#125;    public final V remove(K key) &#123;        if (key == null) &#123;            throw new NullPointerException(&quot;key == null&quot;);        &#125;        V previous;        synchronized (this) &#123;            previous = map.remove(key);            if (previous != null) &#123;                size -= safeSizeOf(key, previous);            &#125;        &#125;        if (previous != null) &#123;            entryRemoved(false, key, previous, null);        &#125;        return previous;    &#125;    // 这个方法在调用时，是线程不安全的    // 当有 Entry 被丢弃或删除时调用。    protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) &#123;&#125;    // 这个方法在调用时，是线程不安全的    protected V create(K key) &#123;        return null;    &#125;    ...    private int safeSizeOf(K key, V value) &#123;        int result = sizeOf(key, value);        if (result &lt; 0) &#123;            throw new IllegalStateException(&quot;Negative size: &quot; + key + &quot;=&quot; + value);        &#125;        return result;    &#125;    ...&#125;</code></pre><p>可见，Android 对 LruCache 有了自己的实现，最重要的是，它是<strong>线程安全</strong>的，但是效率会相对低一些，不过缓存的使用概率本身相对较低，所以稍低的效率也是可以忍受的。</p><h2 id="LFU-算法"><a href="#LFU-算法" class="headerlink" title="LFU 算法"></a>LFU 算法</h2><p>LFU（Least Frequently Used，最近最少使用）也是一种常见的缓存算法。它认为<strong>如果一个数据在最近一段时间很少被访问到，那么可以认为在将来它被访问的可能性也很小。因此，当空间满时，最小频率访问的数据最先被淘汰</strong>。</p><p>在实现时，考虑到 LFU 会淘汰访问频率最小的数据，我们需要一种合适的方法<strong>按大小顺序</strong>维护数据访问的频率。LFU 算法本质上可以看做是一个 top K 问题(K = 1)，即选出频率最小的元素，因此我们很容易想到可以用<strong>二项堆</strong>来选择频率最小的元素，这样的实现比较高效。最终实现策略为小顶堆+哈希表。</p><p><strong>缺点</strong>：最新加入的数据常常会被踢除，因为其起始方法次数少。</p><h2 id="MRU-算法"><a href="#MRU-算法" class="headerlink" title="MRU 算法"></a>MRU 算法</h2><p>MRU（Most Recently Used，最近最常使用）算法的思想与 LRU 算法正好相反，它认为<strong>如果一个数据最近被访问过，那么它接下来被访问的概率就会更低</strong>。</p><h2 id="附注"><a href="#附注" class="headerlink" title="附注"></a>附注</h2><h3 id="注1"><a href="#注1" class="headerlink" title="注1"></a>注1</h3><p>在移动数据的位置时，在 java1.7（含）之前采用的是<strong>头插法</strong>，数据会被移动到<strong>链表的头部</strong>。而在 java1.8 之后，采用了<strong>尾插法</strong>，所以移动数据的话，就会被移动到<strong>链表的尾部</strong>。</p><p>我们看看代码是如何写的：</p><pre><code class="java">// LinkedHashMap java1.7public class LinkedHashMap&lt;K,V&gt;    extends HashMap&lt;K,V&gt;    implements Map&lt;K,V&gt; &#123;        private transient Entry&lt;K,V&gt; header;    ...    public V get(Object key) &#123;        Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)getEntry(key);        if (e == null)            return null;        e.recordAccess(this);        return e.value;    &#125;    ...    private static class Entry&lt;K,V&gt; extends HashMap.Entry&lt;K,V&gt; &#123;        Entry&lt;K,V&gt; before, after;        ...        private void addBefore(Entry&lt;K,V&gt; existingEntry) &#123;            after  = existingEntry;            before = existingEntry.before;            before.after = this;            after.before = this;        &#125;        void recordAccess(HashMap&lt;K,V&gt; m) &#123;            LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m;            if (lm.accessOrder) &#123;                lm.modCount++;                remove();                // 这里可以看出，将被访问的 Entry 重新放置在了 header 的前面，也即成为了新的链表头                addBefore(lm.header);            &#125;        &#125;    &#125;    ...&#125;</code></pre><pre><code class="java">// LinkedHashMap java1.8public class LinkedHashMap&lt;K,V&gt;    extends HashMap&lt;K,V&gt;    implements Map&lt;K,V&gt; &#123;    ...    /**     * The head (eldest) of the doubly linked list.     */    transient LinkedHashMap.Entry&lt;K,V&gt; head;    // 表头，最老的数据    /**     * The tail (youngest) of the doubly linked list.     */    transient LinkedHashMap.Entry&lt;K,V&gt; tail;    // 表尾，最新的数据    ...    public V get(Object key) &#123;        Node&lt;K,V&gt; e;        if ((e = getNode(hash(key), key)) == null)            return null;        if (accessOrder)            afterNodeAccess(e);        return e.value;    &#125;    void afterNodeAccess(Node&lt;K,V&gt; e) &#123; // move node to last        LinkedHashMap.Entry&lt;K,V&gt; last;        if (accessOrder &amp;&amp; (last = tail) != e) &#123;            LinkedHashMap.Entry&lt;K,V&gt; p =                (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;            p.after = null;            if (b == null)                head = a;            else                b.after = a;            if (a != null)                a.before = b;            else                last = b;            if (last == null)                head = p;            else &#123;                p.before = last;                last.after = p;            &#125;            tail = p;            ++modCount;        &#125;    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 生活技能 </tag>
            
            <tag> 缓存算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap 解析</title>
      <link href="/2020-01-05/hashmap/"/>
      <url>/2020-01-05/hashmap/</url>
      
        <content type="html"><![CDATA[<p>在 Java 和 Android 的开发中，我相信没有人没用过 HashMap 了吧。这几乎是 Java 中最重要的类之一，作为 Key-Value 存储类型的典范，我们在学会使用的同时，也必须要明白 HashMap 内部的实现原理，同时也必须知道它的一些衍生类，以及它们的用法。</p><span id="more"></span><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>话不多说，先来看一下 HashMap 在官方文档里的定义：</p><blockquote><p>HashMap 是 Map 接口基于哈希表的实现。这个实现提供了所有可用的对 map 的操作，而且还允许插入 null 值和 null 键。</p><p>HashMap 与 Hashtable 类差不多，但 HashMap 是异步的，并且允许 null 值/键。这个类无法保证 map 内元素的顺序；更特别的是，它也无法保证能一直按照某个顺序排列。</p></blockquote><p>Map 接口有三个比较重要的具体实现类：<strong>HashMap</strong>、<strong>WeakHashMap</strong> 和 <strong>TreeMap</strong>。HashMap 还有一个重要的子类 <strong>LinkedHashMap</strong>，它们几个都是非线程安全的类。</p><p>我们可以通过一张图简单了解一下它们之间的关系：</p><div align="center"><p><img src="/img/56.png"></p></div><p>可以看到，刚才官方文档中提到的 Hashtable，也是 Map 的一个实现类，它的官方描述中有这么一段：</p><blockquote><p>不像 collection 的实现那样，Hashtable 是同步的。如果不要求线程安全，那你可以使用 HashMap 来替代 Hashtable；如果你对线程安全要求非常高，那推荐你使用 java.util.concurrent.ConcurrentHashMap 来替代 Hashtable。</p></blockquote><p>后面我们会讨论 <a href="#hashtable">Hashtable</a> 和 <a href="#concurrenthashmap">ConcurrentHashMap</a>。</p><h2 id="HashMap-的数据结构"><a href="#HashMap-的数据结构" class="headerlink" title="HashMap 的数据结构"></a>HashMap 的数据结构</h2><p>HashMap 的数据结构是我们非常常用的数据结构，就是由<strong>数组和链表组合构成</strong>的数据结构。如下图所示：</p><div align="center"><p><img src="/img/57.png"></p></div><p>数组的每个位置都存储了一个key-value这样的实例，在 Java 7 中叫Entry，在 Java 8 中叫Node。这个数组每个元素原本都是 null，在 put 插入数据的时候会根据 key 值的 hash 去计算一个 index 值。</p><p>比如我调用<code>put(&quot;debugLife&quot;, 42)</code>，这个时候会通过哈希函数计算出插入的位置，比如说 index 为2吧，那结果就如下图所示：</p><div align="center"><p><img src="/img/58.png"></p></div><p>那么，只用一个数组就好了呀，为啥还要用到链表？</p><p>原因很简单，数组长度有限，在有限的长度里使用哈希，会有很大概率出现不同的 key 的计算出的 index 结果相同。比如我调用<code>put(&quot;lifeDebug, 24)</code>计算出的 index 也为2，就会出现下面的情况：</p><div align="center"><p><img src="/img/59.png"></p></div><p>上面 index 为2的两对key-value形成了一个链表。这点我们可以通过查看 Node 的代码来佐证：</p><pre><code class="java">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;    final int hash;    final K key;    V value;    Node&lt;K,V&gt; next;    ...&#125;</code></pre><p>那么问题来了，如果两次计算的 index 相同，那新的 Node 在插入的时候，是怎么插入的？</p><p>在 Java 8 之前是<strong>头插法</strong>，也即新来的 Node 会取代原来的 Node，原有值就被推到链表中去，像上面的图一样。</p><p>但是从 Java 8 之后，就采用<strong>尾部插入</strong>了。为什么呢？这个要先从 HashMap 的<strong>扩容机制</strong>说起。</p><h3 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h3><p>刚才上面提到了，数组的长度是有限的，当数据多次插入，达到一定的数量之后，就会进行<strong>扩容（resize）</strong>。扩容的因素有两个：</p><ul><li>Capacity：HashMap 当前的容量</li><li>LoadFactor：负载因子，默认值是<code>0.75f</code></li></ul><pre><code class="java">/** * The load factor used when none specified in constructor. */static final float DEFAULT_LOAD_FACTOR = 0.75f;</code></pre><p>负载因子可以理解为，如果当前容量是100，存75个还没事，但存第76个的时候，就要进行扩容。我们来看看代码：</p><pre><code class="java">public V put(K key, V value) &#123;    return putVal(hash(key), key, value, false, true);&#125;final V putVal(int hash, K key, V value, boolean onlyIfAbsent,                boolean evict) &#123;    ...    if (++size &gt; threshold)        resize();&#125;// 扩容的阈值（容量 * 负载因子)int threshold;// 默认的容量，必须是2的幂static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16// 如果构造函数未指定的话，负载因子就是0.75fstatic final float DEFAULT_LOAD_FACTOR = 0.75f;</code></pre><p>而扩容也并不是简单地扩大点容量就完事了，我们来简单看一下<code>resize()</code>的代码：</p><pre><code class="java">// 初始化或者扩容为原来的2倍。// 如果内容为 null，分配默认容量大小的区域。// 如果不是，因为我们使用了『2次幂扩展』，所有的元素要么待在原来的 index，要么就在新 table 里偏移『2次幂』个位置。final Node&lt;K,V&gt;[] resize() &#123;    Node&lt;K,V&gt;[] oldTab = table;    int oldCap = (oldTab == null) ? 0 : oldTab.length;    int oldThr = threshold;    int newCap, newThr = 0;    if (oldCap &gt; 0) &#123;        // 数据量已经到最大值 1 &lt;&lt; 30了，就将阈值设置为 Integer.MAX_VALUE 吧，也不用扩容了，还扩啥扩        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;            threshold = Integer.MAX_VALUE;            return oldTab;        &#125;        // 新的容量是旧容量 * 2，新的阈值也是旧的阈值 * 2        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;                oldCap &gt;= DEFAULT_INITIAL_CAPACITY)            newThr = oldThr &lt;&lt; 1;    &#125;    // 数据量为0，但是旧阈值大于0，新的容量就是旧的阈值    else if (oldThr &gt; 0)        newCap = oldThr;    // 数据量为0，旧阈值等于0，新的容量就是默认容量，新的阈值就是默认容量 * 默认负载因子    else &#123;        newCap = DEFAULT_INITIAL_CAPACITY;        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);    &#125;    // 经过上面的处理，新的阈值还是0的话，就进行对比：    // 如果：新的容量小于最大容量 且 用户设置的阈值小于最大容量的话，新的阈值就是用户设置的阈值    // 否则：新的阈值就是 Integer.MAX_VALUE    if (newThr == 0) &#123;        float ft = (float)newCap * loadFactor;        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?                (int)ft : Integer.MAX_VALUE);    &#125;    // 设置新的阈值    threshold = newThr;    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)    // 先申请一个长度为之前2倍的新数组    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];    // 清空原有数组    table = newTab;    if (oldTab != null) &#123;        // 开始循环处理旧数组        for (int j = 0; j &lt; oldCap; ++j) &#123;            Node&lt;K,V&gt; e;            // 如果旧数组[j]元素不为 null            if ((e = oldTab[j]) != null) &#123;                // 把旧数组[j]置为 null                oldTab[j] = null;                // 如果旧数组[j]的next无Node，也即该index上只有它自己                if (e.next == null)                    // e.hash &amp; (newCap - 1) 是在计算该元素的 index                    newTab[e.hash &amp; (newCap - 1)] = e;                // 如果旧数组[j]是红黑树节点，就调用它的split方法，将其子节点复制到新数组中                else if (e instanceof TreeNode)                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);                // 保留之前数据的顺序                else &#123;                    Node&lt;K,V&gt; loHead = null, loTail = null;                    Node&lt;K,V&gt; hiHead = null, hiTail = null;                    Node&lt;K,V&gt; next;                    do &#123;                        // 获取该节点的 next                        next = e.next;                        if ((e.hash &amp; oldCap) == 0) &#123;                            if (loTail == null)                                loHead = e;                            else                                loTail.next = e;                            loTail = e;                        &#125;                        else &#123;                            if (hiTail == null)                                hiHead = e;                            else                                hiTail.next = e;                            hiTail = e;                        &#125;                    &#125; while ((e = next) != null);                    if (loTail != null) &#123;                        loTail.next = null;                        newTab[j] = loHead;                    &#125;                    if (hiTail != null) &#123;                        hiTail.next = null;                        newTab[j + oldCap] = hiHead;                    &#125;                &#125;            &#125;        &#125;    &#125;    return newTab;&#125;</code></pre><p>可以看得出来，扩容基本上分为两步：</p><ol><li>将数组的容量扩展为原来的2倍</li><li>重新计算所有 Node 的 hash 值，也即 rehash，并插入到新数组中</li></ol><p>那么，为什么要 rehash？直接扩容不就完事了？</p><p>这样做是不行的，因为数组的容量扩大后，<strong>计算 index 的规则也发生了变化</strong>。</p><p>index 的计算规则是<code>index = key.hash &amp; (capacity - 1)</code>，之前 capacity 16，变成了 32 的话，值明显就不一样了哇。</p><p>好，回到刚才提到的头插尾插。</p><p>我们来举个例子，如果现在我们采用头插法，HashMap 的容量是2，负载因子是0.75，那么在插入第二个元素的时候，就要准备扩容了。</p><p>现在我们往这个容量是2的数组里用<strong>不同线程</strong>插入 C、B、A 三个 Entry（头插法是 Java8 之前的哦，要叫 Entry 的哦），那么，在数据插入之后，扩容之前，数据结构可能是下面这样：</p><div align="center"><p><img src="/img/60.png"></p></div><p>我们可以看到链表的指向是 A-&gt;B-&gt;C，因为使用的是头插法，同一 index 时，<strong>新元素总是会被放在链表头的位置</strong>。</p><p>resize()之后，旧数组中同一个 index 上的链表，其 Entry 可能会被分配到其他的 index 上，也即出现下面的情况：</p><div align="center"><p><img src="/img/61.png"></p></div><p>那么待3个线程都调整完毕后，就有可能出现下面的情况：</p><div align="center"><p><img src="/img/62.png"></p></div><p>出现了！无限循环！ 因为 HashMap 是线程不安全的啊！</p><div align="center"><p><img src="/img/loop.jpg"></p></div><p>而尾插法就不会出现这样的问题。使用头插时会改变链表上的顺序，但是如果使用尾插，在扩容时会保持链表元素原本的顺序，就不会出现链表成环的问题了。也就是说原本是A-&gt;B，在扩容后那个链表还是A-&gt;B：</p><div align="center"><p><img src="/img/63.png"></p></div><p>总结起来就是：</p><ol><li>Java 7 在多线程操作 HashMap 时可能引起死循环，原因是扩容转移后前后链表顺序倒置，在转移过程中修改了原来链表中节点的引用关系。</li><li>Java 8 在同样的前提下并不会引起死循环，原因是扩容转移后前后链表顺序不变，保持之前节点的引用关系。</li></ol><p>但这并不意味着在 Java 8 中可以把 HashMap 用于多线程。从源码的<code>put/get</code>方法中，没有任何同步机制，也就是说，无法保证你某个线程<code>put</code>进去的值，再<code>get</code>的时候还是原值，所以，还是无法保证线程安全。如果要线程安全，请使用 <a href="#hashtable">Hashtable</a> 或者 <a href="#concurrenthashmap">ConcurrentHashMap</a>。 </p><h2 id="均匀分布"><a href="#均匀分布" class="headerlink" title="均匀分布"></a>均匀分布</h2><p>从上面的代码里，我们看到了，HashMap 默认初始化长度是<code>1 &lt;&lt; 4</code>，也就是16。那么为什么是16呢？我们来看一下。</p><p>HashMap 使用了位运算来得到『16』这个数字，我们都知道，位运算比算数运算的效率要高很多，之所以选择16这个数字，是为了服务将 key 映射到index 的这个算法（前面提到过）：</p><pre><code class="java">index = key.hash &amp; (capacity - 1)</code></pre><p>比如我们有个 key 为<code>wtf</code>，它的 hashCode 值是<code>118057</code>，转换为二进制是<code>11100110100101001</code>，使用capacity的默认值16，capacity - 1 是15，转换为二进制是<code>1111</code>，那么套入 index 计算公式的话，就是：</p><pre><code class="java">index = 0b11100110100101001 &amp; 0b1111index = 9</code></pre><p>至于为什么要使用16，而不是14、19、25，是因为使用2次幂数字的时候，减去1，转换为二进制全为1，这种情况下，<code>&amp;</code>出来的结果等同于 hashCode 后几位的值。这种位运算的速度可比取余的方法性能高多了。同时，只要 hashcode 本身分布均匀，index 的分布就是均匀的。</p><p>那么，为什么8和32也是2次幂，偏偏选择了16？其实8和32也都可以，可能只是作者认为这个数字比较符合常用吧。</p><p>另外，还有个小知识点：Hashmap中的链表大小超过8个时会<strong>自动转化为红黑树</strong>，当删除小于6时<strong>重新变为链表</strong>。这是因为根据**<a href="https://zh.wikipedia.org/zh-hans/%E6%B3%8A%E6%9D%BE%E5%88%86%E4%BD%88">泊松分布</a><strong>，在负载因子默认为0.75的时候，单个 hash 槽内元素个数为8的</strong>概率小于百万分之一**，所以将7作为一个分水岭，等于7的时候不转换，大于等于8的时候才进行转换，小于等于6的时候就化为链表。</p><h2 id="equals-方法和-hashCode-方法"><a href="#equals-方法和-hashCode-方法" class="headerlink" title="equals 方法和 hashCode 方法"></a>equals 方法和 hashCode 方法</h2><p>我们有时为了对比两个对象是否相等，会重写<code>equals()</code>方法，那么，我们是不是也需要重写<code>hashCode()</code>方法呢？</p><p>答案是，如果你的对象要放在 HashMap 中的话，需要。</p><p>在 Java 中，所有的对象都继承自 Object 类，Obejct 类中有两个方法<code>equals()</code>和<code>hashCode()</code>，用于比较两个对象是否相等。当我们**未重写<code>equals()</code>**时，比较的是两个对象的内存地址，如果是<code>new</code>了两个对象的话，那肯定不同。</p><p>刚才我们提到过，HashMap 是通过 hashCode 来计算 index 的，当我们去<code>get</code>的时候，很可能会拿到一个在链表上的值，那么如何确定是链表上的哪个值呢？是了，通过<code>equals()</code>，我们来看看它的代码部分：</p><pre><code class="java">public V get(Object key) &#123;    Node&lt;K,V&gt; e;    return (e = getNode(hash(key), key)) == null ? null : e.value;&#125;final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;        (first = tab[(n - 1) &amp; hash]) != null) &#123;        if (first.hash == hash &amp;&amp; // always check first node            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))            return first;        if ((e = first.next) != null) &#123;            if (first instanceof TreeNode)                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);            do &#123;                // 就是这里啦，对比 hash 和 equals                if (e.hash == hash &amp;&amp;                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                    return e;            &#125; while ((e = e.next) != null);        &#125;    &#125;    return null;&#125;</code></pre><p>所以，如果我们对<code>equals()</code>方法进行了重写，那最好也对<code>hashCode()</code>方法进行重写，以保证相同的对象返回相同的 hash 值，不同的对象返回不同的 hash 值。</p><h2 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h2><p>这个 Map 的派生类是为了在<code>put/get</code>达到一定的线程安全，才出现的。它的解决方案比较粗暴，直接在<code>put/get</code>方法上加 synchronized 关键字，锁住方法。由此可见，并发度会比较低：</p><pre><code class="java">public synchronized V get(Object key) &#123;    Entry&lt;?,?&gt; tab[] = table;    int hash = key.hashCode();    int index = (hash &amp; 0x7FFFFFFF) % tab.length;    for (Entry&lt;?,?&gt; e = tab[index] ; e != null ; e = e.next) &#123;        if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;            return (V)e.value;        &#125;    &#125;    return null;&#125;</code></pre><p>所以，这个类必定会渐渐地退出舞台，在茫茫历史长河中被慢慢淹没。</p><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>这个必须要单独来一篇<a href="/concurrent-hashmap/">ConcurrentHashMap的文章</a>了。因为 ConcurrentHashMap 内部的原理比 HashMap 要复杂得多，如果赋在这下面，这篇就太长了。</p>]]></content>
      
      
      <categories>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络面试题</title>
      <link href="/2020-01-03/job-interview-network/"/>
      <url>/2020-01-03/job-interview-network/</url>
      
        <content type="html"><![CDATA[<p>一些网络方面的面试题</p><span id="more"></span><h2 id="一、HTTP-HTTPS-（⭐⭐⭐）"><a href="#一、HTTP-HTTPS-（⭐⭐⭐）" class="headerlink" title="一、HTTP/HTTPS （⭐⭐⭐）"></a>一、HTTP/HTTPS （⭐⭐⭐）</h2><h3 id="1、HTTP与HTTPS有什么区别？"><a href="#1、HTTP与HTTPS有什么区别？" class="headerlink" title="1、HTTP与HTTPS有什么区别？"></a>1、HTTP与HTTPS有什么区别？</h3><p>HTTPS 是一种通过计算机网络进行安全通信的传输协议。HTTPS 经由 HTTP 进行通信，但利用 SSL/TLS 来加密数据包。HTTPS 开发的主要目的是<strong>提供对网站服务器的身份认证</strong>，保护交换数据的隐私与完整性。</p><p>HTTPS 和 HTTP 的概念：</p><p>HTTPS（全称：Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的 HTTP 通道，简单讲<strong>是 HTTP 的安全版</strong>。即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。 它是一个 URI scheme（抽象标识符体系），句法类同<code>http:</code>体系。用于安全的 HTTP 数据传输。<code>https:</code>URL 表明它使用了 HTTP，但 HTTPS 存在不同于 HTTP 的默认端口及一个加密/身份验证层（在 HTTP 与 TCP 之间）。这个系统的最初研发由网景公司进行，提供了身份验证与加密通讯方法，现在它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。</p><p>超文本传输协议 (HTTP-Hypertext transfer protocol) 是一种详细规定了浏览器和万维网服务器之间互相通信的规则，通过因特网传送万维网文档的数据传送协议。</p><p>HTTPS 协议需要到 CA（Certificate Agent 证书机构）申请证书，一般免费证书很少，需要交费。</p><p>HTTP 和 HTTPS 用的端口也不一样，前者是<code>80</code>，后者是<code>443</code>。HTTP 的连接很简单，是无状态的， HTTPS 协议是由 SSL + HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 HTTP 协议安全。</p><p>HTTPS 解决的问题：</p><ol><li>信任主机的问题。采用 HTTPS 的 SERVER 必须从 CA 申请一个用于证明服务器用途类型的证书。改证书只有用于对应的 SERVER 的时候，客户度才信任次主机。</li><li>防止通讯过程中的数据的泄密和被篡改。</li></ol><p>如下图所示，可以很明显的看出两个的区别：</p><p><img src="http://blog.cigis-cloud.com/aaji-1591191396.png" alt="HTTP &amp; HTTPS"></p><p><em>注：TLS是SSL的升级替代版，具体发展历史可以参考传输层安全性协议。</em></p><p>HTTP 与 HTTPS 在写法上的区别也是前缀的不同，客户端处理的方式也不同，具体说来：</p><ul><li>如果 URL的协议是HTTP，则客户端会打开一条到服务端端口<code>80</code>（默认）的连接，并向其发送老的HTTP请求。</li><li>如果 URL的协议是HTTPS，则客户端会打开一条到服务端端口<code>443</code>（默认）的连接，然后与服务器握手，以二进制格式与服务器交换一些SSL的安全参数，附上加密的 HTTP请求。</li></ul><p>所以你可以看到，HTTPS比HTTP多了一层与SSL的连接，这也就是客户端与服务端SSL握手的过程，整个过程主要完成以下工作：</p><ul><li>交换协议版本号</li><li>选择一个两端都了解的密码</li><li>对两端的身份进行认证</li><li>生成临时的会话密钥，以便加密信道</li></ul><p>SSL握手是一个相对比较复杂的过程，更多关于SSL握手的过程细节可以参考TLS/SSL握手过程</p><p>SSL/TSL的常见开源实现是OpenSSL，OpenSSL是一个开放源代码的软件库包，应用程序可以使用这个包来进行安全通信，避免窃听，同时确认另一端连接者的身份。这个包广泛被应用在互联网的网页服务器上。更多源于OpenSSL的技术细节可以参考OpenSSL。</p><h3 id="2、HTTP1-1和HTTP1-0及2-0的区别？"><a href="#2、HTTP1-1和HTTP1-0及2-0的区别？" class="headerlink" title="2、HTTP1.1和HTTP1.0及2.0的区别？"></a>2、HTTP1.1和HTTP1.0及2.0的区别？</h3><h4 id="HTTP1-0和HTTP1-1的一些区别"><a href="#HTTP1-0和HTTP1-1的一些区别" class="headerlink" title="HTTP1.0和HTTP1.1的一些区别"></a>HTTP1.0和HTTP1.1的一些区别</h4><p>HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：</p><ol><li><strong>缓存处理。</strong> 在HTTP1.0中主要使用header里的If-Modified-Since，Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since， If-Match， If-None-Match等更多可供选择的缓存头来控制缓存策略。</li><li><strong>带宽优化及网络连接的使用。</strong> HTTP1.0中，存在一些<strong>浪费带宽</strong>的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且<strong>不支持断点续传</strong>功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li><li><strong>错误通知的管理。</strong> 在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li><li><strong>Host头处理。</strong> 在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</li><li><strong>长连接。</strong> HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</li></ol><h4 id="SPDY"><a href="#SPDY" class="headerlink" title="SPDY"></a>SPDY</h4><p>在讲HTTP1.1和HTTP2.0的区别之前，还需要说下<a href="https://www.chromium.org/spdy">SPDY</a>，它是HTTP1.x的优化方案：</p><p>2012年Google如一声惊雷提出了SPDY的方案，优化了HTTP1.X的请求延迟，解决了HTTP1.X的安全性，具体如下：</p><ol><li><strong>降低延迟。</strong> 针对HTTP高延迟的问题，SPDY优雅的采取了多路复用（multiplexing）。多路复用通过多个请求stream共享一个 TCP 连接的方式，解决了HOL blocking的问题，降低了延迟同时提高了带宽的利用率。</li><li><strong>请求优先级（request prioritization）。</strong> 多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。SPDY允许给每个request设置优先级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的 HTML 内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。</li><li><strong>HEADER 压缩。</strong> 前面提到 HTTP1.x 的 HEADER 很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。</li><li><strong>基于 HTTPS 的加密协议传输。</strong> 大大提高了传输数据的可靠性。</li><li><strong>服务端推送（server push）。</strong> 采用了 SPDY 的网页，例如我的网页有一个<code>style.css</code>的请求，在客户端收到<code>style.css</code>数据的同时，服务端会将<code>style.js</code>的文件推送给客户端，当客户端再次尝试获取<code>style.js</code>时就可以直接从缓存中获取到，不用再发请求了。</li></ol><p>SPDY构成图：</p><p><img src="http://blog.cigis-cloud.com/aaji-1591192400.png" alt="SPDY设计模型"></p><p>SPDY位于HTTP之下，TCP和SSL之上，这样可以轻松兼容老版本的HTTP协议(将HTTP1.x的内容封装成一种新的frame格式)，同时可以使用已有的SSL功能。</p><p>但是在 HTTP2.0 推出之后，SPDY 就渐渐地退出历史舞台了。</p><h4 id="HTTP2-0-和-HTTP1-X-相比的新特性"><a href="#HTTP2-0-和-HTTP1-X-相比的新特性" class="headerlink" title="HTTP2.0 和 HTTP1.X 相比的新特性"></a>HTTP2.0 和 HTTP1.X 相比的新特性</h4><ol><li><strong>新的二进制格式（Binary Format）。</strong> HTTP1.x 的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认<code>0</code>和<code>1</code>的组合。基于这种考虑 HTTP2.0 的协议解析决定采用二进制格式，实现方便且健壮。</li><li><strong>多路复用（MultiPlexing）。</strong> 即连接共享，即每一个 request 都是是用作连接共享机制的。一个 request 应一个 id，这样一个连接上可以有多个 request，每个连接的 request 可以随机的混杂在一起，接收方可以根据 request 的 id 将 request 再归属到各自不同的服务端请求里面。</li><li><strong>HEADER 压缩。</strong> 如上文中所言，对前面提到过 HTTP1.x 的 HEADER 带有大量信息，而且每次都要重复发送，HTTP2.0 使用 encoder 来减少需要传输的 HEADER 大小，通讯双方各自缓存一份 HEADER FIELDS 表，既避免了重复 HEADER 的传输，又减小了需要传输的大小。</li><li><strong>服务端推送（server push）。</strong> 同 SPDY 一样，HTTP2.0 也具有 server push 功能。</li></ol><p><a href="https://juejin.im/entry/5981c5df518825359a2b9476">需要更深的理解请点击这里</a></p><h3 id="3、HTTPS-请求慢的解决办法"><a href="#3、HTTPS-请求慢的解决办法" class="headerlink" title="3、HTTPS 请求慢的解决办法"></a>3、HTTPS 请求慢的解决办法</h3><h4 id="1、不通过DNS解析，直接访问IP"><a href="#1、不通过DNS解析，直接访问IP" class="headerlink" title="1、不通过DNS解析，直接访问IP"></a>1、不通过DNS解析，直接访问IP</h4><p>经过 DNS 的解析，必然会增加一些时长，如果再出现诸如 <strong>DNS 污染</strong>等情况，则会直接导致无法访问到目标主机。</p><h4 id="2、解决连接无法复用"><a href="#2、解决连接无法复用" class="headerlink" title="2、解决连接无法复用"></a>2、解决连接无法复用</h4><p>HTTP1.0 协议头里可以设置<code>Connection:Keep-Alive</code>或者<code>Connection:Close</code>，选择是否允许在一定时间内复用连接（时间可由服务器控制）。但是这对 App 端的请求成效不大，因为 App 端的请求比较分散且时间跨度相对较大。</p><h5 id="方案1-基于tcp的长连接-主要）"><a href="#方案1-基于tcp的长连接-主要）" class="headerlink" title="方案1. 基于tcp的长连接 (主要）"></a>方案1. 基于tcp的长连接 (主要）</h5><p>移动端建立一条自己的<strong>长链接通道</strong>，通道的实现是基于 TCP 协议。基于 TCP 的 Socket 编程技术难度相对复杂很多，而且需要自己定制协议。但信息的上报和推送变得更及时，请求量爆发的时间点还能减轻服务器压力（避免频繁创建和销毁连接）。</p><h5 id="方案2-HTTP-LONG-POLLING"><a href="#方案2-HTTP-LONG-POLLING" class="headerlink" title="方案2. HTTP LONG-POLLING"></a>方案2. HTTP LONG-POLLING</h5><p>客户端在初始状态发送一个 POLLING 请求到服务器，服务器并不会马上返回业务数据，而是等待有新的业务数据产生的时候再返回，所以链接会一直被保持。一但结束当前连接，马上又会发送一个新的 POLLING 请求，如此反复，保证一个连接被保持。</p><p>但这种方法也存在一些问题：</p><ol><li>增加了服务器的压力</li><li>网络环境复杂场景下，需要考虑怎么重建健康的连接通道</li><li>POLLING 的方式稳定性不好</li><li>POLLING 的r esponse 可能会被中间代理缓存</li></ol><h5 id="方案3-HTTP-Streaming"><a href="#方案3-HTTP-Streaming" class="headerlink" title="方案3. HTTP Streaming"></a>方案3. HTTP Streaming</h5><p>和 LONG-POLLING 不同的是，Streaming 方式通过在 server response 的头部增加<code>Transfer Encoding:chuncked</code>来告诉客户端后续还有新的数据到来。</p><p>它也存在问题：</p><ol><li>有些代理服务器会等待服务器的 response 结束之后才将结果推送给请求客户端。Streaming 不会结束 response。</li><li>业务数据无法按照请求分割</li></ol><h5 id="方案4-WebSocket"><a href="#方案4-WebSocket" class="headerlink" title="方案4. WebSocket"></a>方案4. WebSocket</h5><p>和传统的 TCPSocket相似，基于 TCP 协议，提供双向的数据通道。它的优势是提供了 message 的概念，比基于字节流的TCPSocket使用更简单。技术较新，不是所有浏览器都提供了支持。</p><h4 id="3、解决head-of-line-blocking"><a href="#3、解决head-of-line-blocking" class="headerlink" title="3、解决head of line blocking"></a>3、解决head of line blocking</h4><p>它的原因是队列的<strong>第一个数据包（队头）受阻</strong>而导致整列数据包受阻。</p><p>使用<strong>http pipelining</strong>，确保几乎在同一时间把 request 发向了服务器</p><h3 id="4、HTTP的request和response的协议组成"><a href="#4、HTTP的request和response的协议组成" class="headerlink" title="4、HTTP的request和response的协议组成"></a>4、HTTP的request和response的协议组成</h3><h4 id="1、Request"><a href="#1、Request" class="headerlink" title="1、Request"></a>1、Request</h4><p>客户端发送一个 HTTP 请求到服务器的请求消息格式：</p><blockquote><p>请求行（request line）+ 请求头部（request header fields）+ 空行 + 请求数据（可选）。</p></blockquote><p>如下例所示：</p><pre><code>GET /test.jpg HTTP/1.1Host: img.example.comUser-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML， like Gecko) Chrome/51.0.2704.106 Safari/537.36Accept: image/webp，image/*，*/*;q=0.8Referer: http://www.example.com/Accept-Encoding: gzip， deflate， sdchts=1598909872</code></pre><p>第一部分：请求行，<strong>用来说明请求类型</strong>，要访问的资源以及所使用的HTTP版本。请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本。常见的请求类型有<code>GET</code>、<code>POST</code>、<code>PUT</code>、<code>DELETE</code>、<code>OPTIONS</code>、<code>HEAD</code>、<code>TRACE</code>、<code>CONNECT</code>、<code>PATCH</code>等。<br>上例中的<code>GET</code>说明请求类型为GET，<code>/test.jpg</code>为要访问的资源，该行的最后一部分说明使用的是 HTTP1.1 版本。</p><p>第二部分：请求头部，紧接着请求行之后的部分，用来说明服务器要使用的附加信息。<br>从第二行起为请求头部，HOST 将指出请求的目的地。User-Agent，服务器端和客户端脚本都能访问它，它是浏览器类型检测逻辑的重要基础。该信息由你的浏览器来定义，并且在每个请求中自动发送。</p><p>第三部分：空行，请求头部后面的空行是必须的。空行只能包括<code>&lt;CR&gt;&lt;LF&gt;</code>，并且不能有空格符。<br><strong>即使第四部分的请求数据为空，也必须有空行。</strong></p><p>第四部分：请求数据，也叫主体，可以添加任意的其他数据。</p><h4 id="2、Response组成"><a href="#2、Response组成" class="headerlink" title="2、Response组成"></a>2、Response组成</h4><p>一般情况下，服务器接收并处理客户端发过来的请求后会返回一个HTTP的响应消息。</p><p>HTTP响应也由四个部分组成，分别是：</p><blockquote><p>状态行（status line) + 消息报头（response header fields） + 空行 + 响应正文（可选）。</p></blockquote><p>如下例所示：</p><pre><code>HTTP/1.1 200 OKDate: Mon, 23 May 2005 22:38:34 GMTContent-Type: text/html; charset=UTF-8Content-Length: 155Last-Modified: Wed, 08 Jan 2003 23:11:55 GMTServer: Apache/1.3.3.7 (Unix) (Red-Hat/Linux)ETag: &quot;3f80f-1b6-3e1cb03b&quot;Accept-Ranges: bytesConnection: close&lt;html&gt;  &lt;head&gt;    &lt;title&gt;An Example Page&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;p&gt;Hello World, this is a very simple HTML document.&lt;/p&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p>第一部分：状态行，由 HTTP 协议版本号，状态码，状态消息三部分组成。<br>上例中第1行为状态行，<code>HTTP/1.1</code>表明 HTTP 版本为 1.1 版本，状态码为<code>200</code>，状态消息为<code>OK</code>。</p><p>第二部分：消息报头，用来说明客户端要使用的一些附加信息。<br>上例中第2-9行为消息报头。如<code>Content-Type</code>指定了 MIME 类型的 HTML<code>text/html</code>，编码类型是<code>UTF-8</code>。</p><p>第三部分：空行，消息报头后面的空行是必须的。空行只能包括<code>&lt;CR&gt;&lt;LF&gt;</code>，并且不能有空格符。</p><p>第四部分：响应正文，服务器返回给客户端的文本信息。<br>上例中从第11行开始的部分为响应正文。</p><p><a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol">了解更多传送门</a></p><h3 id="5、谈谈对-HTTP-缓存的了解"><a href="#5、谈谈对-HTTP-缓存的了解" class="headerlink" title="5、谈谈对 HTTP 缓存的了解"></a>5、谈谈对 HTTP 缓存的了解</h3><p>HTTP 的缓存机制也是依赖于 Request/Response Header Fields 里的参数来实现的，它决定最终响应<strong>是从缓存中取</strong>，<strong>还是从服务端重新拉取</strong>，HTTP 的缓存机制的流程如下所示：</p><p><img src="http://blog.cigis-cloud.com/aaji-1591232610.png" alt="HTTP 缓存机制"></p><p>HTTP 的缓存可以分为两种：</p><ul><li><strong>强制缓存：</strong> 需要服务端参与判断是否继续使用缓存，当客户端第一次请求数据时，服务端返回了缓存的过期时间（Expires 与 Cache-Control），没有过期就可以继续使用缓存，否则则不适用，无需再向服务端询问。</li><li><strong>对比缓存：</strong> 需要服务端参与判断是否继续使用缓存，当客户端第一次请求数据时，服务端会将缓存标识（Last-Modified/If-Modified-Since 与 Etag/If-None-Match）与数据一起返回给客户端，客户端将两者都备份到缓存中，再次请求数据时，客户端将上次备份的缓存标识发送给服务端，服务端根据缓存标识进行判断，如果返回<code>304</code>，则表示通知客户端可以继续使用缓存。<br>强制缓存优先于对比缓存。</li></ul><p>上面提到强制缓存使用的的两个标识：</p><ul><li><strong>Expires：</strong> Expires 可以通俗地解释为<strong>缓存到期时间</strong>。即客户端首次请求时，服务端会记录下 Expires 值；客户端下一次请求时，如果请求时间小于服务端返回的到期时间，则直接使用缓存数据，否则使用服务端返回的数据。Expires 是服务端生成的，在使用时要注意客户端和服务端的时间误差。</li><li><strong>Cache-Control：</strong> 由于上面的 Expires 有个时间校验的问题，所以在 HTTP1.1 中采用了 Cache-Control 替代 Expires。它的取值有以下几种：<ul><li><code>private</code>: 客户端可以缓存</li><li><code>public</code>: 客户端和代理服务器都可缓存</li><li><code>max-age=xxx</code>: 缓存的内容将在 xxx 秒后失效</li><li><code>no-cache</code>: 需要使用对比缓存来验证缓存数据</li><li><code>no-store</code>: 所有内容都不会缓存，强制缓存，对比缓存都不会触发</li></ul></li></ul><p>我们再来看看对比缓存的两个标识 Last-Modified 和 If-Modified-Since：</p><p>Last-Modified 表示资源上次修改的时间。当客户端首次发送请求时，服务端返回资源上次修改的时间：</p><pre><code>Last-Modified: Tue, 12 Jan 2016 09:31:27 GMT</code></pre><p>客户端再次发送，会在 header fields 里携带<code>If-Modified-Since</code>。将上次服务端返回的资源时间上传给服务端。</p><pre><code>If-Modified-Since: Tue, 12 Jan 2016 09:31:27 GMT</code></pre><p>服务端接收到客户端发来的资源修改时间，与自己当前的资源修改时间进行对比，如果自己的资源修改时间大于客户端发来的资源修改时间，则说明资源做过修改， 则返回<code>200</code>表示需要重新请求资源，否则返回<code>304</code>表示资源没有被修改，可以继续使用缓存。</p><p>上面是一种<strong>时间戳标记资源是否修改</strong>的方法，还有一种<strong>资源标识码 ETag</strong> 的方式来标记是否修改，如果标识码发生改变，则说明资源已经被修改，<strong>ETag 优先级高于 Last-Modified</strong>。</p><p>ETag 是资源文件的一种标识码，当客户端首次发送请求时，服务端会返回当前资源的标识码：</p><pre><code>ETag: &quot;5694c7ef-24dc&quot;</code></pre><p>客户端再次发送，会在 header fields 里携带上次服务端返回的资源标识码：</p><pre><code>If-None-Match:&quot;5694c7ef-24dc&quot;</code></pre><p>服务端接收到客户端发来的资源标识码，则会与自己当前的资源码进行比较，如果不同，则说明资源已经被修改，则返回<code>200</code>，如果相同则说明资源没有被修改，返回<code>304</code>，客户端可以继续使用缓存。</p><h3 id="6、HTTP长连接。"><a href="#6、HTTP长连接。" class="headerlink" title="6、HTTP长连接。"></a>6、HTTP长连接。</h3><p>HTTP1.0 是短连接，HTTP1.1 默认是长连接，也就是默认 Connection 的值就是<code>keep-alive</code>。但是长连接实质是指的 TCP 连接，而不是HTTP 连接，毕竟 HTTP 是应用层协议（第7层），TCP 是传输层协议（第4层）。TCP 连接是一个双向的通道，它是可以保持一段时间不关闭的，因此实际上我们常说的『HTTP 长连接』指的是『TCP 长连接』。</p><h4 id="HTTP1-1-为什么要用使用-TCP-长连接？"><a href="#HTTP1-1-为什么要用使用-TCP-长连接？" class="headerlink" title="HTTP1.1 为什么要用使用 TCP 长连接？"></a>HTTP1.1 为什么要用使用 TCP 长连接？</h4><p><strong>TCP 长连接可以复用</strong>。即长连接情况下，多个 HTTP 请求可以复用同一个 TCP 连接，这就<strong>节省了很多 TCP 连接建立和断开的消耗。</strong></p><p>此外，长连接并不是永久连接的。如果一段时间内（具体的时间长短，是可以在header当中进行设置的，也就是所谓的超时时间），这个连接没有HTTP 请求发出的话，那么这个长连接就会被断掉。</p><p><a href="https://www.jianshu.com/p/3fc3646fad80">需要更深的理解请点击这里</a></p><h3 id="7、HTTPS-加密原理。"><a href="#7、HTTPS-加密原理。" class="headerlink" title="7、HTTPS 加密原理。"></a>7、HTTPS 加密原理。</h3><p>加密算法的类型基本上分为了两种：</p><ul><li><strong>对称加密</strong>。加密用的密钥和解密用的密钥是同一个，比较有代表性的就是 AES 加密算法；其它常见的还有 DES、RC4、RC5 等。</li><li><strong>非对称加密</strong>。加密用的密钥称为<strong>公钥</strong>，解密用的密钥称为<strong>私钥</strong>，经常使用到的 RSA 加密算法就是非对称加密的。</li></ul><p>此外，还有Hash加密算法</p><p>HASH算法：MD5， SHA1， SHA256</p><p>相比较对称加密而言，非对称加密<strong>安全性更高</strong>，但是<strong>加解密耗费的时间更长</strong>，速度慢。</p><p><a href="https://juejin.im/post/5b48b0d7e51d4519962ea383#heading-23">想了解更多加密算法请点击这里</a></p><p>HTTPS = HTTP + SSL，HTTPS 的加密就是在 SSL 层中完成的。</p><p>这就要从 CA 证书讲起了。CA 证书其实就是数字证书，是由 CA 机构颁发的。至于 CA 机构的权威性，那么是毋庸置疑的，所有人都是信任它的。CA 证书内一般会包含以下内容：</p><ul><li>证书的颁发机构、版本</li><li>证书的使用者</li><li>证书的公钥</li><li>证书的有效时间</li><li>证书的数字签名 Hash 值和签名 Hash 算法</li><li>…</li></ul><h4 id="客户端如何校验-CA-证书？"><a href="#客户端如何校验-CA-证书？" class="headerlink" title="客户端如何校验 CA 证书？"></a>客户端如何校验 CA 证书？</h4><p>CA 证书中的 Hash 值，其实是用证书的私钥进行加密后的值（证书的私钥不在 CA 证书中）。然后客户端得到证书后，利用证书中的公钥去解密该 Hash 值，得到 Hash-a ；然后再利用证书内的签名 Hash 算法去生成一个 Hash-b 。最后比较 Hash-a 和 Hash-b 这两个的值。如果相等，那么证明了该证书是对的，服务端是可以被信任的；如果不相等，那么就说明该证书是错误的，可能被篡改了，浏览器会给出相关提示，无法建立起 HTTPS 连接。除此之外，还会校验 CA 证书的有效时间和域名匹配等。</p><h4 id="HTTPS-中的-SSL-握手建立过程"><a href="#HTTPS-中的-SSL-握手建立过程" class="headerlink" title="HTTPS 中的 SSL 握手建立过程"></a>HTTPS 中的 SSL 握手建立过程</h4><p> 假设现在有客户端 C 和服务器 S ：</p><ol><li>首先，C 访问 S ，比如我们用浏览器打开一个网页 <a href="http://www.baidu.com/">www.baidu.com</a> ，这时，浏览器就是 C ，百度的服务器就是 S 了。这时候 C 会生成一个随机数<code>1</code>，把<strong>随机数<code>1</code><strong>、自己</strong>支持的 SSL 版本号</strong>以及<strong>支持的加密算法</strong>等这些信息告诉 S 。</li><li>S 知道这些信息后，先确认一下双方的加密算法，再生成一个随机数<code>2</code>，并将随机数<code>2</code>和 CA 颁发给自己的证书一同返回给 C 。</li><li>C 得到 CA 证书后，会去校验该 CA 证书的有效性（校验方法在上面说过），校验通过后，生成一个随机数<code>3</code>，然后用证书中的公钥加密随机数<code>3</code>并传输给 S 。</li><li>S 得到加密后的随机数<code>3</code>，然后利用私钥进行解密，得到真正的随机数<code>3</code>。</li><li>最后，C 和 S 都有随机数<code>1</code>、随机数<code>2</code>、随机数<code>3</code>，然后双方利用这三个随机数生成一个<strong>对话密钥</strong>。之后传输内容就是利用对话密钥来进行加解密了。这时就是利用了<strong>对称加密</strong>，一般用的都是 AES 算法。</li><li>C 通知 S，指明后面的通讯用对话密钥来完成，同时通知 S 和 C 的握手过程结束。</li><li>S 通知 C，指明后面的通讯用对话密钥来完成，同时通知 C 和 S 的握手过程结束。</li><li>SSL 的握手部分结束，SSL 安全通道的数据通讯开始，C 和 S 开始使用相同的对话密钥进行数据通讯。</li></ol><p>如下图所示：</p><p><img src="http://blog.cigis-cloud.com/aaji-1591239714.jpg" alt="SSL 握手过程"></p><p>简化如下：</p><ol><li>客户端和服务端建立 SSL 握手，客户端通过 CA 证书来确认服务端的身份；</li><li>互相传递三个随机数，之后通过这随机数来生成一个密钥；</li><li>互相确认密钥，然后握手结束；</li><li>数据通讯开始，都使用同一个对话密钥来加解密；</li></ol><p>可以发现，在 HTTPS 加密原理的过程中把对称加密和非对称加密都利用了起来。即利用了非对称加密安全性高的特点，又利用了对称加密速度快，效率高的好处。</p><p><a href="https://juejin.im/entry/5a9ac15bf265da239e4d8831#comment">需要更深的理解请点击这里</a></p><h3 id="8、HTTPS-如何防范中间人攻击？"><a href="#8、HTTPS-如何防范中间人攻击？" class="headerlink" title="8、HTTPS 如何防范中间人攻击？"></a>8、HTTPS 如何防范中间人攻击？</h3><h4 id="什么是中间人攻击？"><a href="#什么是中间人攻击？" class="headerlink" title="什么是中间人攻击？"></a>什么是中间人攻击？</h4><p>当数据传输发生在一个设备（PC/手机）和网络服务器之间时，攻击者使用其技能和工具将自己置于两个端点之间并截获数据；尽管交谈的两方认为他们是在与对方交谈，但是实际上他们是在与干坏事的人交流，这便是中间人攻击。中间人攻击是在运行在 HTTP 协议中的网络传输中常见的攻击手段，这种手段在 HTTP 协议中无法防御，因为 C/S 双方都无法确认对方的身份。</p><h4 id="中间人攻击有几种攻击方式？"><a href="#中间人攻击有几种攻击方式？" class="headerlink" title="中间人攻击有几种攻击方式？"></a>中间人攻击有几种攻击方式？</h4><ol><li><p><strong>嗅探</strong>。嗅探或数据包嗅探是一种用于捕获流进和流出系统/网络的数据包的技术。网络中的数据包嗅探就好像电话中的监听。</p></li><li><p><strong>数据包注入</strong>。在这种技术中，攻击者会将恶意数据包注入常规数据中。这样用户便不会注意到文件/恶意软件，因为它们是合法通讯流的一部分。</p></li><li><p><strong>会话劫持</strong>。在你登录进你的银行账户和退出登录这一段期间便称为一个会话。这些会话通常都是黑客的攻击目标，因为它们包含潜在的重要信息。在大多数案例中，黑客会潜伏在会话中，并最终控制它。</p></li><li><p><strong>SSL剥离</strong>。在 SSL 剥离攻击中，攻击者使 SSL/TLS 协议剥落，随之协议便从安全的 HTTPS 协议变成了不安全的 HTTP 协议。</p></li></ol><h4 id="HTTPS-如何防范中间人攻击："><a href="#HTTPS-如何防范中间人攻击：" class="headerlink" title="HTTPS 如何防范中间人攻击："></a>HTTPS 如何防范中间人攻击：</h4><p>请见 HTTPS 加密原理。</p><h3 id="9、有哪些响应码，分别都代表什么意思？"><a href="#9、有哪些响应码，分别都代表什么意思？" class="headerlink" title="9、有哪些响应码，分别都代表什么意思？"></a>9、有哪些响应码，分别都代表什么意思？</h3><ul><li><code>1**</code> 信息，服务器收到请求，需要请求者继续执行操作</li><li><code>2**</code> 成功，操作被成功接收并处理</li><li><code>3**</code> 重定向，需要进一步的操作以完成请求</li><li><code>4**</code> 客户端错误，请求包含语法错误或无法完成请求</li><li><code>5**</code> 服务器错误，服务器在处理请求的过程中发生了错误</li></ul><h2 id="二、TCP-UDP-（⭐⭐⭐）"><a href="#二、TCP-UDP-（⭐⭐⭐）" class="headerlink" title="二、TCP/UDP （⭐⭐⭐）"></a>二、TCP/UDP （⭐⭐⭐）</h2><h3 id="1、为什么tcp要经过三次握手，四次挥手？"><a href="#1、为什么tcp要经过三次握手，四次挥手？" class="headerlink" title="1、为什么tcp要经过三次握手，四次挥手？"></a>1、为什么tcp要经过三次握手，四次挥手？</h3><p>一次典型的无数据传输的 TCP 连接（包括建立连接、关闭连接）过程如下图所示：</p><p><img src="https://notes.shichao.io/tcpv1/figure_13-1_600.png" alt="TCP 连接过程"></p><h4 id="重要标志位"><a href="#重要标志位" class="headerlink" title="重要标志位"></a>重要标志位</h4><ul><li>**<code>ACK（Acknowledge）</code>**：TCP协议规定，只有 ACK=1 时表示有效，也规定连接建立后所有发送的报文的ACK必须为1</li><li><strong><code>SYN（Synchronization）</code><strong>：在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个</strong>连接请求报文</strong>。对方若同意建立连接，则应在响应报文中使 SYN=1 和 ACK=1。因此， SYN 置 1 就表示这是一个连接请求或连接接受报文。</li><li>**<code>Seq（Sequence Number）</code>**：序号，标识当前握/挥手已经进行到了哪一步。</li><li><strong><code>FIN（finish）</code><strong>：用来释放一个连接。当 FIN=1 时，表明此报文段的发送方的数据已经发送完毕，并要求</strong>释放连接</strong>。</li><li><strong>`ISN（Initial Sequence Number）</strong>：初始序号值。</li></ul><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p><strong>第一次：</strong> 建立连接。客户端发送连接请求报文段，将 SYN 置为<code>1</code>，Seq 为<code>ISN(c)</code>；然后，客户端进入 SYN_SEND 状态，等待服务器的确认；</p><p><strong>第二次：</strong> 服务器收到 SYN 报文段。服务器收到客户端的 SYN 报文段，需要对这个 SYN 报文段进行确认，设置 ACK 为<code>ISN(c)+1</code>；同时，自己自己还要发送 SYN 请求信息，设置 SYN为<code>1</code>，Seq 设置为<code>ISN(s)</code>；服务器端将上述所有信息放到一个报文段（即 SYN + ACK 报文段）中，一并发送给客户端，此时服务器进入 SYN_RECV 状态；</p><p><strong>第三次：</strong> 客户端收到服务器的 SYN + ACK 报文段，然后将 ACK 设置为<code>ISN(s)+1</code>，Seq 设置为<code>ISN(c)+1</code>，向服务器发送 ACK 报文段，这个报文段发送完毕以后，客户端和服务器端都进入 ESTABLISHED 状态，完成 TCP 三次握手。</p><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p><strong>第一次：</strong> 主机1（可以是客户端，也可以是服务器端），设置 Seq 为<code>K</code>，设置 ACK 为<code>L</code>，向主机2发送一个 FIN 报文段；此时，主机1进入 FIN_WAIT_1 状态；这表示主机1没有数据要发送给主机2了；</p><p><strong>第二次：</strong> 主机2收到了主机1发送的 FIN 报文段，设置 Seq 为<code>L</code>，设置 ACK 为<code>K+1</code>，向主机1回一个 ACK 报文段；主机1进入 FIN_WAIT_2 状态；主机2告诉主机1，我『同意』你的关闭请求；</p><p><strong>第三次：</strong> 主机2向主机1发送 FIN 报文段，设置 Seq 为<code>L</code>，设置 ACK 为<code>K+1</code>，请求关闭连接，同时主机2进入 LAST_ACK 状态；</p><p><strong>第四次：</strong> 主机1收到主机2发送的 FIN 报文段，设置 Seq 为<code>K</code>，设置 ACK 为<code>L+1</code>，向主机2发送 ACK 报文段，然后主机1进入 TIME_WAIT 状态；主机2收到主机1的 ACK 报文段以后，就关闭连接；此时，主机1等待2 MSL 后依然没有收到回复，则证明 Server 端已正常关闭，那好，主机1也可以关闭连接了。</p><p>『三次握手』的目的是『<strong>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误</strong>』。主要目的是防止 Server 端一直等待，浪费资源。换句话说，即是为了保证服务端能收接受到客户端的信息并能做出正确的应答而进行前两次（第一次和第二次）握手，为了保证客户端能够接收到服务端的信息并能做出正确的应答而进行后两次（第二次和第三次）握手。</p><p>『四次挥手』原因是因为<strong>TCP是全双工模式</strong>，接收到 FIN 时意味将没有数据再发来，但是还是可以继续发送数据。</p><h3 id="2、TCP-可靠传输原理实现（滑动窗口）。"><a href="#2、TCP-可靠传输原理实现（滑动窗口）。" class="headerlink" title="2、TCP 可靠传输原理实现（滑动窗口）。"></a>2、TCP 可靠传输原理实现（滑动窗口）。</h3><ul><li><strong>确认和重传。</strong> 接收方收到报文后就会进行确认，发送方一段时间没有收到确认就会重传。</li><li><strong>数据校验。</strong></li><li><strong>数据合理分片与排序。</strong> TCP会对数据进行分片，接收方会缓存为按序到达的数据，重新排序后再提交给应用层。</li><li><strong>流程控制。</strong> 当接收方来不及接收发送的数据时，则会提示发送方降低发送的速度，防止包丢失。</li><li><strong>拥塞控制。</strong> 当网络发生拥塞时，减少数据的发送。</li></ul><p><a href="http://blog.chinaunix.net/uid-26275986-id-4109679.html">关于滑动窗口、流量控制、拥塞控制实现原理请点击这里</a></p><h3 id="3、TCP-和-UDP-的区别？"><a href="#3、TCP-和-UDP-的区别？" class="headerlink" title="3、TCP 和 UDP 的区别？"></a>3、TCP 和 UDP 的区别？</h3><ol><li><p>TCP 基于连接，UDP 基于无连接；</p></li><li><p>TCP 对系统资源的要求较多，UDP 较少；</p></li><li><p>UDP 程序结构较简单；</p></li><li><p>TCP 是流模式，UDP 是数据报模式 ；</p></li><li><p>TCP 保证数据可靠性，UDP 可能丢包；</p></li><li><p>TCP 保证数据顺序，UDP 不保证。</p></li></ol><h3 id="4、如何设计在-UDP-上层保证-UDP-的可靠性传输？"><a href="#4、如何设计在-UDP-上层保证-UDP-的可靠性传输？" class="headerlink" title="4、如何设计在 UDP 上层保证 UDP 的可靠性传输？"></a>4、如何设计在 UDP 上层保证 UDP 的可靠性传输？</h3><p>传输层无法保证数据的可靠传输，只能通过应用层来实现了。实现的方式可以参照 TCP 可靠性传输的方式。如不考虑拥塞处理，可靠 UDP 的简单设计如下：</p><ol><li>添加 Seq/ACK 机制，确保数据发送到对端；</li><li>添加发送和接收缓冲区，主要是用户超时重传；</li><li>添加超时重传机制。</li></ol><p>具体过程即是：送端发送数据时，生成一个随机seq=x，然后每一片按照数据大小分配seq。数据到达接收端后接收端放入缓存，并发送一个ack=x的包，表示对方已经收到了数据。发送端收到了ack包后，删除缓冲区对应的数据。时间到后，定时任务检查是否需要重传数据。</p><p>目前有如下开源程序利用udp实现了可靠的数据传输。分别为RUDP、RTP、UDT:</p><p>1、RUDP（Reliable User Datagram Protocol）</p><p>RUDP 提供一组数据服务质量增强机制，如拥塞控制的改进、重发机制及淡化服务器算法等。</p><p>2、RTP（Real Time Protocol）</p><p>RTP为数据提供了具有实时特征的端对端传送服务，如在组播或单播网络服务下的交互式视频音频或模拟数据。</p><p>3、UDT（UDP-based Data Transfer Protocol）</p><p>UDT的主要目的是支持高速广域网上的海量数据传输。</p><p><a href="https://www.jianshu.com/p/6c73a4585eba">关于RUDP、RTP、UDT的更多介绍请查看此处</a></p><h2 id="三、其它重要网络概念-（⭐⭐）"><a href="#三、其它重要网络概念-（⭐⭐）" class="headerlink" title="三、其它重要网络概念 （⭐⭐）"></a>三、其它重要网络概念 （⭐⭐）</h2><h3 id="1、socket断线重连怎么实现，心跳机制又是怎样实现？"><a href="#1、socket断线重连怎么实现，心跳机制又是怎样实现？" class="headerlink" title="1、socket断线重连怎么实现，心跳机制又是怎样实现？"></a>1、socket断线重连怎么实现，心跳机制又是怎样实现？</h3><h4 id="socket概念"><a href="#socket概念" class="headerlink" title="socket概念"></a>socket概念</h4><p>套接字（socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。</p><p>为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP／IP协议交互提供了套接字(Socket)接口。应 用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。</p><h4 id="建立socket连接"><a href="#建立socket连接" class="headerlink" title="建立socket连接"></a>建立socket连接</h4><p>建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket ，另一个运行于服务器端，称为ServerSocket 。</p><p>套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。</p><ul><li>服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。</li><li>客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端- - 套接字的地址和端口号，然后就向服务器端套接字提出连接请求。<br>连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发 给客户端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。</li></ul><h4 id="SOCKET连接与TCP连接"><a href="#SOCKET连接与TCP连接" class="headerlink" title="SOCKET连接与TCP连接"></a>SOCKET连接与TCP连接</h4><p>创建Socket连接时，可以指定使用的传输层协议，Socket可以支持不同的传输层协议（TCP或UDP），当使用TCP协议进行连接时，该Socket连接就是一个TCP连接。</p><h4 id="Socket连接与HTTP连接"><a href="#Socket连接与HTTP连接" class="headerlink" title="Socket连接与HTTP连接"></a>Socket连接与HTTP连接</h4><p>由于通常情况下Socket连接就是TCP连接，因此Socket连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开。但在实际网 络应用中，客户端到服务器之间的通信往往需要穿越多个中间节点，例如路由器、网关、防火墙等，大部分防火墙默认会关闭长时间处于非活跃状态的连接而导致 Socket 连接断连，因此需要通过轮询告诉网络，该连接处于活跃状态。</p><p>而HTTP连接使用的是“请求—响应”的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器端才能回复数据。</p><p>很多情况下，需要服务器端主动向客户端推送数据，保持客户端与服务器数据的实时与同步。此时若双方建立的是Socket连接，服务器就可以直接将数 据传送给客户端；若双方建立的是HTTP连接，则服务器需要等到客户端发送一次请求后才能将数据传回给客户端，因此，客户端定时向服务器端发送连接请求， 不仅可以保持在线，同时也是在“询问”服务器是否有新的数据，如果有就将数据传给客户端。TCP(Transmission Control Protocol)　传输控制协议</p><h4 id="socket断线重连实现"><a href="#socket断线重连实现" class="headerlink" title="socket断线重连实现"></a>socket断线重连实现</h4><p>正常连接断开客户端会给服务端发送一个fin包，服务端收到fin包后才会知道连接断开。<br>而断网断电时客户端无法发送fin包给服务端，所以服务端没办法检测到客户端已经短线。<br>为了缓解这个问题，服务端需要有个心跳逻辑，就是服务端检测到某个客户端多久没发送任何数据过来就认为客户端已经断开，<br>这需要客户端定时向服务端发送心跳数据维持连接。</p><h4 id="心跳机制实现"><a href="#心跳机制实现" class="headerlink" title="心跳机制实现"></a>心跳机制实现</h4><p>长连接的实现：心跳机制，应用层协议大多都有HeartBeat机制，通常是客户端每隔一小段时间向服务器发送一个数据包，通知服务器自己仍然在线。并传输一些可能必要的数据。使用心跳包的典型协议是IM，比如QQ/MSN/飞信等协议</p><p>1、在TCP的机制里面，本身是存在有心跳包的机制的，也就是TCP的选项：SO_KEEPALIVE。<br>系统默认是设置的2小时的心跳频率。但是它检查不到机器断电、网线拔出、防火墙这些断线。<br>而且逻辑层处理断线可能也不是那么好处理。一般，如果只是用于保活还是可以的。通过使用TCP的KeepAlive机制（修改那个time参数），可以让连接每隔一小段时间就产生一些ack包，以降低被踢掉的风险，当然，这样的代价是额外的网络和CPU负担。</p><p>2、应用层心跳机制实现。</p><h3 id="2、Cookie与Session的作用和原理。"><a href="#2、Cookie与Session的作用和原理。" class="headerlink" title="2、Cookie与Session的作用和原理。"></a>2、Cookie与Session的作用和原理。</h3><ul><li>Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中。</li><li>Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。</li></ul><h4 id="Session："><a href="#Session：" class="headerlink" title="Session："></a>Session：</h4><p>由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的。</p><p>具体到Web中的Session指的就是用户在浏览某个网站时，从进入网站到浏览器关闭所经过的这段时间，也就是用户浏览这个网站所花费的时间。因此从上述的定义中我们可以看到，Session实际上是一个特定的时间概念。</p><p>当客户端访问服务器时，服务器根据需求设置Session，将会话信息保存在服务器上，同时将标示Session的SessionId传递给客户端浏览器，</p><p>浏览器将这个SessionId保存在内存中，我们称之为无过期时间的Cookie。浏览器关闭后，这个Cookie就会被清掉，它不会存在于用户的Cookie临时文件。</p><p>以后浏览器每次请求都会额外加上这个参数值，服务器会根据这个SessionId，就能取得客户端的数据信息。</p><p>如果客户端浏览器意外关闭，服务器保存的Session数据不是立即释放，此时数据还会存在，只要我们知道那个SessionId，就可以继续通过请求获得此Session的信息，因为此时后台的Session还存在，当然我们可以设置一个Session超时时间，一旦超过规定时间没有客户端请求时，服务器就会清除对应SessionId的Session信息。</p><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>Cookie是由服务器端生成，发送给User-Agent（一般是web浏览器），浏览器会将Cookie的key/value保存到某个目录下的文本文件内，下次请求同一网站时就发送该Cookie给服务器（前提是浏览器设置为启用Cookie）。Cookie名称和值可以由服务器端开发自己定义，对于JSP而言也可以直接写入Sessionid，这样服务器可以知道该用户是否合法用户以及是否需要重新登录等。</p><h3 id="3、IP报文中的内容。"><a href="#3、IP报文中的内容。" class="headerlink" title="3、IP报文中的内容。"></a>3、IP报文中的内容。</h3><p><img src="http://blog.cigis-cloud.com/aaji-1591249793.jpg" alt="IP 报文结构图"></p><p>版本：IP协议的版本，目前的IP协议版本号为4，下一代IP协议版本号为6。</p><p>首部长度：IP报头的长度。固定部分的长度（20字节）和可变部分的长度之和。共占4位。最大为1111，即10进制的15，代表IP报头的最大长度可以为15个32bits（4字节），也就是最长可为15*4=60字节，除去固定部分的长度20字节，可变部分的长度最大为40字节。</p><p>服务类型：Type Of Service。</p><p>总长度：IP报文的总长度。报头的长度和数据部分的长度之和。</p><p>标识：唯一的标识主机发送的每一分数据报。通常每发送一个报文，它的值加一。当IP报文长度超过传输网络的MTU（最大传输单元）时必须分片，这个标识字段的值被复制到所有数据分片的标识字段中，使得这些分片在达到最终目的地时可以依照标识字段的内容重新组成原先的数据。</p><p>标志：共3位。R、DF、MF三位。目前只有后两位有效，DF位：为1表示不分片，为0表示分片。MF：为1表示“更多的片”，为0表示这是最后一片。</p><p>片位移：本分片在原先数据报文中相对首位的偏移位。（需要再乘以8）</p><p>生存时间：IP报文所允许通过的路由器的最大数量。每经过一个路由器，TTL减1，当为0时，路由器将该数据报丢弃。TTL 字段是由发送端初始设置一个 8 bit字段.推荐的初始值由分配数字 RFC 指定，当前值为 64。发送 ICMP 回显应答时经常把 TTL 设为最大值 255。</p><p>协议：指出IP报文携带的数据使用的是那种协议，以便目的主机的IP层能知道要将数据报上交到哪个进程（不同的协议有专门不同的进程处理）。和端口号类似，此处采用协议号，TCP的协议号为6，UDP的协议号为17。ICMP的协议号为1，IGMP的协议号为2.</p><p>首部校验和：计算IP头部的校验和，检查IP报头的完整性。</p><p>源IP地址：标识IP数据报的源端设备。</p><p>目的IP地址：标识IP数据报的目的地址。</p><p>最后就是可变部分和数据部分。</p><h2 id="四、常见网络流程机制-（⭐⭐）"><a href="#四、常见网络流程机制-（⭐⭐）" class="headerlink" title="四、常见网络流程机制 （⭐⭐）"></a>四、常见网络流程机制 （⭐⭐）</h2><h3 id="1、浏览器输入地址到返回结果发生了什么？"><a href="#1、浏览器输入地址到返回结果发生了什么？" class="headerlink" title="1、浏览器输入地址到返回结果发生了什么？"></a>1、<a href="https://segmentfault.com/a/1190000006879700">浏览器输入地址到返回结果发生了什么？</a></h3><p>总体来说分为以下几个过程:</p><p>1、DNS解析，此外还有DNSy优化（DNS缓存、DNS负载均衡）</p><p>2、TCP连接</p><p>3、发送HTTP请求</p><p>4、服务器处理请求并返回HTTP报文</p><p>5、浏览器解析渲染页面</p><p>6、连接结束</p><h4 id="Web前端的本质"><a href="#Web前端的本质" class="headerlink" title="Web前端的本质"></a>Web前端的本质</h4><p>将信息快速并友好的展示给用户并能够与用户进行交互。</p><h4 id="如何尽快的加载资源（网络优化）？"><a href="#如何尽快的加载资源（网络优化）？" class="headerlink" title="如何尽快的加载资源（网络优化）？"></a>如何尽快的加载资源（网络优化）？</h4><p>答案就是能不从网络中加载的资源就不从网络中加载，当我们合理使用缓存，将资源放在浏览器端，这是最快的方式。如果资源必须从网络中加载，则要考虑缩短连接时间，即DNS优化部分;减少响应内容大小，即对内容进行压缩。另一方面，如果加载的资源数比较少的话，也可以快速的响应用户。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Handler 和它的朋友们</title>
      <link href="/2020-01-02/handler-and-its-friends/"/>
      <url>/2020-01-02/handler-and-its-friends/</url>
      
        <content type="html"><![CDATA[<p>Android 中的进程间通信，采用 Binder 机制，那线程间通信呢？Android 给出了一个机制 —— Handler。</p><p>一提起 Handler，就不得不提到它的<strong>全家</strong>：</p><ul><li>Message</li><li>MessageQueue</li><li>Looper</li><li>Handler</li></ul><p>我们来一个个地解释一下。</p><span id="more"></span><h2 id="Message-——-信件"><a href="#Message-——-信件" class="headerlink" title="Message —— 信件"></a>Message —— 信件</h2><p>Message 在何时都会代表『消息』的意思。在 Android 中消息还会附带一些其他的数据，供<strong>暂存消息的 MessageQueue</strong> 和<strong>分发消息的 Looper</strong> 以及<strong>处理消息的 Handler</strong>使用。</p><p>Message 中包含可供 Handler 使用的三个字段，分别是<strong>两个<code>int</code>字段</strong>和<strong>一个<code>Object</code>字段</strong>。</p><p>我们来看看 Message 的定义：</p><pre><code class="java">// android.os.Message// 注意，虽然 Message 的构造函数是 public的，但最好的获取 Message 的方法还是使用 Message.obtain() 或者是 Handler.obtainMessage() 方法，它会从回收池子中拿出一个对象来public final class Message implements Parcelable &#123;    // 消息的 code，可以让接收者辨认这是哪个消息    // 每一个 Handler 应对 code 时都有自己的命名空间，所以你不用担心会与其他的 Handler 有冲突    public int what;    // arg1 和 arg2 相比较 setData(Bundle) 来说是消耗很低，如果你只需要暂存几个 int 值的话，可以用这两个参数    public int arg1;    public int arg2;    // 想存啥就存啥，但是要存储的数据必须是一个 Parcelable 对象    // 注意在Android 4.0之前不支持 Parcelable 对象    public Object obj;    ...    /*package*/ Bundle data;    // 存储着要处理消息的 Handler 的实例    @UnsupportedAppUsage    /*package*/ Handler target;    // 要处理消息时，可以回调的方法    @UnsupportedAppUsage    /*package*/ Runnable callback;    // 有时会链式存储下一条消息    @UnsupportedAppUsage    /*package*/ Message next;    // 池子锁    public static final Object sPoolSync = new Object();    // 一个池，用来暂存消息，这样如果需要新消息实例的话，就直接使用池里的，而不用再新建实例了    private static Message sPool;    private static int sPoolSize = 0;    private static final int MAX_POOL_SIZE = 50;    // 从全局池中拿出一个新的消息，在很多情况下可以避免生成一个新的对象    public static Message obtain() &#123;        synchronized (sPoolSync) &#123;            if (sPool != null) &#123;                Message m = sPool;                sPool = m.next;                m.next = null;                m.flags = 0; // clear in-use flag                sPoolSize--;                return m;            &#125;        &#125;        return new Message();    &#125;    // obtain() 方法的各种重载方法，但最后都会调用上面的方法    // 比如比较常用的 obtain(Handler)    // 与 obtain() 相同，但是会把 target 设置为传入的 Handler    public static Message obtain(Handler h) &#123;        Message m = obtain();        m.target = h;        return m;    &#125;    ...    // 将一个 Message 实例扔回全局池中    // 在调用完这个方法后，你绝对不能再动这个 Message，因为它已经被释放了。    // 回收一个正在队列中或正在被传递给 Handler 的消息是错误的    public void recycle() &#123;        if (isInUse()) &#123;            if (gCheckRecycle) &#123;                throw new IllegalStateException(&quot;This message cannot be recycled because it &quot;                        + &quot;is still in use.&quot;);            &#125;            return;        &#125;        recycleUnchecked();    &#125;    // 回收一个可能正在使用的 Message    // 该方法会在 MessageQueue 内部使用，也会在 Looper 抛弃 Message 时使用    void recycleUnchecked() &#123;        // 标记为 FLAG_IN_USE，并清空它内部的东西        // Mark the message as in use while it remains in the recycled object pool.        // Clear out all other details.        flags = FLAG_IN_USE;        what = 0;        arg1 = 0;        arg2 = 0;        obj = null;        replyTo = null;        sendingUid = UID_NONE;        workSourceUid = UID_NONE;        when = 0;        target = null;        callback = null;        data = null;        synchronized (sPoolSync) &#123;            if (sPoolSize &lt; MAX_POOL_SIZE) &#123;                next = sPool;                sPool = this;                sPoolSize++;            &#125;        &#125;    &#125;    // 将 Message 发送到 Handler，也即 target 变量    public void sendToTarget() &#123;        target.sendMessage(this);    &#125;&#125;</code></pre><p>从上面的代码，我们可以看出几个 Message 的特性：</p><ol><li>有一个『回收池』的概念，如果 Message 完成使命之后被抛弃，那这个 Message 实例会被清空数据并扔到回收池中。如果再需要新建 Message 实例的时候，就直接从池中拿，避免了新建 Message 实例。</li><li>如果要新建 Message 实例，使用<code>Message.obtain()</code>方法，而不是调用<code>new Message()</code>。</li><li>Message 本身包含了一个 Handler 的引用，存储在 target 成员变量中，在发送消息时，会调用<code>target.sendMessage(this)</code>将自身传递到 Handler 中。</li></ol><h2 id="MessageQueue-——-邮筒"><a href="#MessageQueue-——-邮筒" class="headerlink" title="MessageQueue —— 邮筒"></a>MessageQueue —— 邮筒</h2><p>在 MessageQueue 的类注释里写着：</p><blockquote><p> Low-level class holding the list of messages to be dispatched by a Looper.  Messages are not added directly to a MessageQueue, but rather through Handler objects associated with the Looper.<br> 它是一个低等级的类，拿着一堆 Message 等待 Looper 来分发。Message 并不是直接就添加到 MessageQueue 中，而是通过与 Looper 关联的 Handler 来操作的。</p></blockquote><p>MessageQueue 最重要的功能当然就是维护本身的队列，提供进、出的方法给 Looper，以及掌管 Message 的生命周期。</p><p>我们分别来看看这几种特性是如何完成的。</p><pre><code class="java">// android.os.MessageQueue.javapublic final class MessageQueue &#123;    // 如果是 true，表示消息队列能退出    @UnsupportedAppUsage    private final boolean mQuitAllowed;    ...    @UnsupportedAppUsage    Message mMessages;    // 添加消息    boolean enqueueMessage(Message msg, long when) &#123;        // 各种判断        ...        synchronized (this) &#123;            // 如果正在退出，就不能添加了            // 同时还得回收这个消息            if (mQuitting) &#123;                IllegalStateException e = new IllegalStateException(                        msg.target + &quot; sending message to a Handler on a dead thread&quot;);                Log.w(TAG, e.getMessage(), e);                msg.recycle();                return false;            &#125;            msg.markInUse();            msg.when = when;            Message p = mMessages;            boolean needWake;            // 如果 MessageQueue 中没有消息            if (p == null || when == 0 || when &lt; p.when) &#123;                msg.next = p;                mMessages = msg;                needWake = mBlocked;            &#125; else &#123;                // Inserted within the middle of the queue.  Usually we don&#39;t have to wake                // up the event queue unless there is a barrier at the head of the queue                // and the message is the earliest asynchronous message in the queue.                needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();                Message prev;                // 循环查看 Message.next，如有，就继续查看 next，如果没有，就把消息添加到队尾 Message.next 中                for (;;) &#123;                    prev = p;                    p = p.next;                    if (p == null || when &lt; p.when) &#123;                        break;                    &#125;                    if (needWake &amp;&amp; p.isAsynchronous()) &#123;                        needWake = false;                    &#125;                &#125;                msg.next = p; // invariant: p == prev.next                prev.next = msg; // 然后把当前 Message 赋值到上一个 Message 的 next 中             &#125;            // We can assume mPtr != 0 because mQuitting is false.            if (needWake) &#123;                nativeWake(mPtr);            &#125;        &#125;        return true;    &#125;    // 获取队头消息    @UnsupportedAppUsage    Message next() &#123;        // 如果 Looper 已经完蛋了，就返回 null 了        final long ptr = mPtr;        if (ptr == 0) &#123;            return null;        &#125;        int pendingIdleHandlerCount = -1; // -1 only during first iteration        int nextPollTimeoutMillis = 0;        for (;;) &#123;            if (nextPollTimeoutMillis != 0) &#123;                Binder.flushPendingCommands();            &#125;            nativePollOnce(ptr, nextPollTimeoutMillis);            synchronized (this) &#123;                // Try to retrieve the next message.  Return if found.                final long now = SystemClock.uptimeMillis();                Message prevMsg = null;                Message msg = mMessages;                if (msg != null &amp;&amp; msg.target == null) &#123;                    // Stalled by a barrier.  Find the next asynchronous message in the queue.                    do &#123;                        prevMsg = msg;                        msg = msg.next;                    &#125; while (msg != null &amp;&amp; !msg.isAsynchronous());                &#125;                if (msg != null) &#123;                    if (now &lt; msg.when) &#123;                        // 还没到发送消息的时候，就设置一个超时，等时间到了再唤醒它                        nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);                    &#125; else &#123;                        // 到发送消息的时候了，获取它                        mBlocked = false;                        if (prevMsg != null) &#123;                            prevMsg.next = msg.next;                        &#125; else &#123;                            mMessages = msg.next;                        &#125;                        msg.next = null;                        if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);                        msg.markInUse();                        return msg;                    &#125;                &#125; else &#123;                    // No more messages.                    nextPollTimeoutMillis = -1;                &#125;                ...            &#125;            ...        &#125;    &#125;    ...    // 根据 Handler 和 what 移除 Message，同时要回收这个 Message    void removeMessages(Handler h, int what, Object object) &#123;        ...        synchronized (this) &#123;            Message p = mMessages;            ...            p.recycleUnchecked();        &#125;        ...    &#125;&#125;</code></pre><p>读完上面的代码，我们可以发现，其实 MessageQueue 并不想我们想象的，有一个真实的『队列』存在，而是用 Message 的 next，建立了一个链表，形成了所谓的『队列』。在『进』的流程里比较简单，就是建立链表的过程；而『出』的流程相对复杂一些，是利用了一个死循环，因为每条 Message 都有自己『要被发送』的时间戳，如果时间没到，那还要等待一下，如果时间已到，就取出，并把其它的 Message 向队头提一位。</p><p>可以用两个流程图来展示『进』与『出』：</p><p><img src="/img/30.png"></p><h2 id="Looper-——-马车"><a href="#Looper-——-马车" class="headerlink" title="Looper —— 马车"></a>Looper —— 马车</h2><p>Looper 是一个死循环。它负责不停地读取 MessageQueue 中的消息，如果一旦有消息，就拿出来，扔给 Handler，然后又进入自己的小圈子里不问世事。一旦 MessageQuee 里没有消息了，那它也就结束自己的工作。</p><p>我们看看它的代码：</p><pre><code class="java">// android.os.Looper.java/**  * Class used to run a message loop for a thread.  Threads by default do  * not have a message loop associated with them; to create one, call  * &#123;@link #prepare&#125; in the thread that is to run the loop, and then  * &#123;@link #loop&#125; to have it process messages until the loop is stopped.  *  * &lt;p&gt;Most interaction with a message loop is through the  * &#123;@link Handler&#125; class.  *  * &lt;p&gt;This is a typical example of the implementation of a Looper thread,  * using the separation of &#123;@link #prepare&#125; and &#123;@link #loop&#125; to create an  * initial Handler to communicate with the Looper.  *  * &lt;pre&gt;  *  class LooperThread extends Thread &#123;  *      public Handler mHandler;  *  *      public void run() &#123;  *          Looper.prepare();  *  *          mHandler = new Handler() &#123;  *              public void handleMessage(Message msg) &#123;  *                  // process incoming messages here  *              &#125;  *          &#125;;  *  *          Looper.loop();  *      &#125;  *  &#125;&lt;/pre&gt;  */public final class Looper &#123;    ...    @UnsupportedAppUsage    static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();    @UnsupportedAppUsage    private static Looper sMainLooper;  // guarded by Looper.class    private static Observer sObserver;    @UnsupportedAppUsage    final MessageQueue mQueue;    final Thread mThread;    /** 将当前线程初始化为一个 Looper。      * 之后，在真正启动这个 Looper 之前，你就可以用这个 Looper 去创建 Handler了。      * 在调用完 prepare() 之后一定要调用 loop() 方法，如果要停止，则调用 quit()      */    public static void prepare() &#123;        prepare(true);    &#125;    private static void prepare(boolean quitAllowed) &#123;        if (sThreadLocal.get() != null) &#123;            throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);        &#125;        sThreadLocal.set(new Looper(quitAllowed));    &#125;    /**     * 将当前线程初始化为一个 Looper，并将其当做应用的 main looper。     * 介个方法是由 Android 来调用的，所以理论上来说，你应该压根用不到这个方法。     */    public static void prepareMainLooper() &#123;        prepare(false);        synchronized (Looper.class) &#123;            if (sMainLooper != null) &#123;                throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;);            &#125;            sMainLooper = myLooper();        &#125;    &#125;    /**     * 返回应用的 main looper，在应用的主线程里存活的那个     */    public static Looper getMainLooper() &#123;        synchronized (Looper.class) &#123;            return sMainLooper;        &#125;    &#125;    ...    /**     * 开始监听 message queue，一定记得要调用 quit() 来停止 Looper     */    public static void loop() &#123;        // 拿到调用此方法的当前线程下的 Looper 实例        final Looper me = myLooper();        if (me == null) &#123;            throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&#39;t called on this thread.&quot;);        &#125;        final MessageQueue queue = me.mQueue;        ...        // 开启自闭模式        for (;;) &#123;            Message msg = queue.next(); // 可能会 block，因为在 MessageQueue.next() 中，                                        // 调用了 nativePollOnce 方法，可能会引起阻塞。                                        // 也就是说，没有消息的时候，Looper 就在这儿『等着』。            if (msg == null) &#123;                // 木有 message，意味着 message queue 正在 quit                // 一旦 return，这个 Looper 就结束了                return;            &#125;            // 各种检查            ...                        try &#123;                // 发送消息                msg.target.dispatchMessage(msg);                ...            &#125; catch (Exception exception) &#123;                ...            &#125; finally &#123;                ...            &#125;            ...        &#125;    &#125;    /**     * 从 sThreadLocal 中获取当前线程下的 Looper     * 此处利用了 ThreadLocal，某个线程下存储的数据，只有这个线程能读取，其他线程不可以，从而达到     * 线程与 Looper 的『绑定』效果     */    public static @Nullable Looper myLooper() &#123;        return sThreadLocal.get();    &#125;    /**     * 返回当前线程下 Looper 的 MessageQueue。     * 该方法必须从一个正在跑 Looper 的线程下调用，否则就会抛出 NullPointerException。     */    public static @NonNull MessageQueue myQueue() &#123;        return myLooper().mQueue;    &#125;    // 初始化    private Looper(boolean quitAllowed) &#123;        mQueue = new MessageQueue(quitAllowed);        mThread = Thread.currentThread();    &#125;    ...    // 返回当前线程是否是 Looper 的线程    public boolean isCurrentThread() &#123;        return Thread.currentThread() == mThread;    &#125;    ...    public interface Observer &#123;        // Message 分发之前被调用        Object messageDispatchStarting();        // Message 被 Handler 处理过了之后调用        void messageDispatched(Object token, Message msg);        // Message 处理过程中出现异常时调用        void dispatchingThrewException(Object token, Message msg, Exception exception);    &#125;</code></pre><p>Looper 类比较清晰，职责也相对单一，就是用死循环的方式，一直通过<code>MessageQueue.next()</code>方法获取 Message，然后调用<code>msg.target.dispatchMessage(msg)</code>方法，将 Message 交给 Handler 处理（<code>msg.target</code>是 Handler 类型）。</p><p>等任务全部处理完成后，<code>使用 MessageQueue.quit()</code> 清空消息，结束 Looper 的循环。</p><p>有一个比较经典的但是又很无厘头的问题：主线程的 Looper 死循环为什么不会导致 ANR？</p><p>这个问题其实算是偷换概念。</p><p>首先，死循环不是造成 ANR 的必然原因，ANR 是因为消息队列中的消息没有得到及时处理才造成的，比如 BroadcastReceiver 的<code>onReceive()</code>方法中处理事务超过了10秒，比如<code>onTouch()</code>事件超过了5秒，才会导致 ANR。</p><p>第二，主线程的 Looper 死循环，最多也就会导致个 OOM，但是主线程在没有消息时也会休眠、进入阻塞状态，当有新消息来临时，再被唤醒，分发消息，实际上对于内存的消耗非常小。</p><p>第三，如果主线程的 Looper 不循环了，那<code>main()</code>方法就抛出一个异常结束了，就整个应用就退出了。</p><p>另外，我们看到，<code>prepare()</code>方法中使用到了 ThreadLocal 的机制，该机制的描述是：<strong>A 线程下使用了 <code>ThreadLocal.set()</code> 方法存储了某个资源，那么只有在 A 线程下才能通过 <code>ThreadLocal.get()</code> 方法拿到这个资源，从而实现了资源隔离</strong>。对 ThreadLocal 的详解，在<a href="/threadlocal/">这篇文章</a>里。</p><h2 id="Handler-——-邮递员"><a href="#Handler-——-邮递员" class="headerlink" title="Handler —— 邮递员"></a>Handler —— 邮递员</h2><p>Handler 顾名思义就是处理者。当接到 Message 的时候，就马不停蹄地开始工作。它的头脑很简单，给我活我就干，没活我就等着。</p><p>我们在初始化 Handler 的时候，有几种方式：</p><ol><li>直接调用<code>new Handler()</code>。</li></ol><p>我们来看看在这种情况下 Handler 的构造函数。</p><pre><code class="java">// android.os.Handler.javapublic Handler() &#123;    this(null, false);&#125;public Handler(@Nullable Callback callback, boolean async) &#123;    // 检查持有该实例的类是否会导致内存泄漏    if (FIND_POTENTIAL_LEAKS) &#123;        final Class&lt;? extends Handler&gt; klass = getClass();        if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;                (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123;            Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; +                klass.getCanonicalName());        &#125;    &#125;    // 调用了 Looper.myLooper() 方法，来获取 Looper 的实例。    // 刚才上面讲过了，只能获取当前线程下的 Looper，所以，一般情况下，我们 new 一个 Handler 的时候，都是    // 在主线程下，那这个 mLooper 其实就是 Main Looper    mLooper = Looper.myLooper();    // 如果一个线程被创建了，但是它的 Looper 没有调用过 prepare()，也就是没有启用，那获取到的 Looper 就是空    if (mLooper == null) &#123;        throw new RuntimeException(            &quot;Can&#39;t create handler inside thread &quot; + Thread.currentThread()                    + &quot; that has not called Looper.prepare()&quot;);    &#125;    mQueue = mLooper.mQueue;    mCallback = callback;    mAsynchronous = async;&#125;</code></pre><ol start="2"><li>创建 Handler 实例时传入 Looper。</li></ol><p>同样地，也看看这种情况下，会调用哪个构造函数：</p><pre><code class="java">// android.os.Handler.javapublic Handler(@NonNull Looper looper) &#123;        this(looper, null, false);&#125;public Handler(@NonNull Looper looper, @Nullable Callback callback, boolean async) &#123;    mLooper = looper;    mQueue = looper.mQueue;    mCallback = callback;    mAsynchronous = async;&#125;</code></pre><p>有了 Looper 就可以直接赋值了，Handler 也并不关心当前的 Looper 是在哪个线程下，干就完了。</p><p>我们也观察到，Handler 的几个重载的构造函数里，总会有 Callback 参数，言下之意，是 Handler 在某个节点，应该会调用这个 Callback。我们来看看代码是不是这么写的，从 Looper 向 Handler 发送消息开始：</p><pre><code class="java">// android.os.Handler.javapublic void dispatchMessage(@NonNull Message msg) &#123;    if (msg.callback != null) &#123;        handleCallback(msg);    &#125; else &#123;        if (mCallback != null) &#123;            if (mCallback.handleMessage(msg)) &#123;                return;            &#125;        &#125;        handleMessage(msg);    &#125;&#125;// 子类必须要实现这个方法，才能获取 Message// 但它不是抽象方法，所以可以不实现该方法public void handleMessage(@NonNull Message msg) &#123;&#125;</code></pre><p>是了，如果在 Message 中有 Callback，那就直接回调 Message 中的 Callback，下面的就不走了。</p><p>如果给 Handler 设置了 Callback，那就调用，如果该 Callback 的实现类里，返回了<code>true</code>，那就不再调用 handleMessage 方法；如果返回了<code>false</code>，那就再调用一次 handleMessage 方法。</p><p>Callback 的定义是这样的：</p><pre><code class="java">// 你可以用 Callback 接口来初始化一个 Handler，这样你就不用去继承 Handler 然后去实现一堆方法了// 说白了，就是简单地实现一个回调功能public interface Callback &#123;    // 返回 true 的话，就不再继续处理    boolean handleMessage(@NonNull Message msg);&#125;</code></pre><p>刚才在 Looper 的代码中看到，<code>msg.target.diapatch()</code>是在向 Handler 发送消息，那<code>msg.target</code>是什么时候被赋值的呢？</p><p>我们来看 Handler 中最著名的<code>post()</code>方法。</p><pre><code class="java">// android.os.Handler.java// 把一个 Runnable 的实例添加到 MessageQueue 中。// 这个 Runnable 将会运行在 Handler 所在的线程上。// 返回 true 的话，就是正确地放入了 MessageQueue，否则就返回 false，通常是因为 MessageQueue 正在退出public final boolean post(@NonNull Runnable r) &#123;    return sendMessageDelayed(getPostMessage(r), 0);&#125;// 向 MessageQueue 中添加一个 Message，如果有延时，那就在这个时间段（current time + delayMillis）再添加// 这个 Message 回头能在 handleMessage 里拿到，当前，所在的线程也是 Hanlder 绑定的线程// 添加成功后返回 true，添加失败返回 false// 添加成功不代表一定能被处理public final boolean sendMessageDelayed(@NonNull Message msg, long delayMillis) &#123;    if (delayMillis &lt; 0) &#123;        delayMillis = 0;    &#125;    return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);&#125;// 在一个绝对时间（毫秒）时，将 Message 添加到 MessageQueue 中// 这个时间是基于 android.os.SystemClock#uptimeMillis// 这个 Message 回头能在 handleMessage 里拿到，当前，所在的线程也是 Hanlder 绑定的线程// 添加成功后返回 true，添加失败返回 false// 添加成功不代表一定能被处理public boolean sendMessageAtTime(@NonNull Message msg, long uptimeMillis) &#123;    MessageQueue queue = mQueue;    if (queue == null) &#123;        RuntimeException e = new RuntimeException(                this + &quot; sendMessageAtTime() called with no mQueue&quot;);        Log.w(&quot;Looper&quot;, e.getMessage(), e);        return false;    &#125;    return enqueueMessage(queue, msg, uptimeMillis);&#125;private boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg,        long uptimeMillis) &#123;    // 赋值了，将 msg.target 赋值为自身的实例    msg.target = this;     msg.workSourceUid = ThreadLocalWorkSource.getUid();    if (mAsynchronous) &#123;        msg.setAsynchronous(true);    &#125;    return queue.enqueueMessage(msg, uptimeMillis);&#125;</code></pre><p>也就是说，Handler 不光只是处理消息，也要负责将消息添加到 MessageQueue 中。</p><p>关于这四大天王的关系，可以用一个关系图来展示一下：</p><p><img src="/img/31.png"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Handler </tag>
            
            <tag> Android Framwork </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非技术面试题</title>
      <link href="/2020-01-02/job-interview-other/"/>
      <url>/2020-01-02/job-interview-other/</url>
      
        <content type="html"><![CDATA[<p>一些非技术向的面试题。</p><span id="more"></span><h2 id="非技术面试题"><a href="#非技术面试题" class="headerlink" title="非技术面试题"></a>非技术面试题</h2><h3 id="一、高频题集-（⭐⭐⭐）"><a href="#一、高频题集-（⭐⭐⭐）" class="headerlink" title="一、高频题集 （⭐⭐⭐）"></a>一、高频题集 （⭐⭐⭐）</h3><h4 id="1、你觉得安卓开发最关键的技术在哪里？"><a href="#1、你觉得安卓开发最关键的技术在哪里？" class="headerlink" title="1、你觉得安卓开发最关键的技术在哪里？"></a>1、你觉得安卓开发最关键的技术在哪里？</h4><p>技术是没有止境的，所以肯定会不断有演进和难点。</p><p>一. 底层和框架如何更好地设计及优化以适应业务的高速增长。说起来很简单，低耦合高扩展，做起来是需要长期经验积累。</p><p>二. 我抛几个细节难点：</p><ul><li>插件化如何使插件的 Manifest 生效</li><li>H5 容器如何更好地优化和兼容</li><li>App 端优化，这是个没止境的话题，网络、图片、动画、内存、电量等等随着优化的加深，你会发现不能局限在客户端，服务端也需要深入。</li><li>SPDY 的优点并入 HTTP 2.0 你们有在测试或用吗？</li><li>Fresco 出来前你是不是觉得图片缓存已经到头了？</li><li>Android App 为什么整体流畅性总是被诟病？……</li></ul><p>三. 如果你觉得没有难点或者难点在兼容、UI 之类问题上，那么可能两个原因：</p><ul><li>公司业务发展过慢，对技术的需求不够迫切</li><li>个人长时间在业务开发上，这个对于走技术路线的人来说挺麻烦的，不主动去接触学习的话，n 年以后也还是这个样子为了更好的个人成长，这两点都是需要注意和解决的问题。</li></ul><h4 id="2、你还要什么了解和要问的吗？"><a href="#2、你还要什么了解和要问的吗？" class="headerlink" title="2、你还要什么了解和要问的吗？"></a>2、你还要什么了解和要问的吗？</h4><p>你在公司的一天是如何度过的？</p><p>能否给我简单介绍下贵公司业务与战略的未来发展？</p><p>贵公司最让你自豪的企业文化是什么？（适合大公司）</p><p>团队、公司现在面临的最大挑战是什么？</p><p>对于未来加入这个团队，你对我的期望是什么？</p><p>您觉得我哪方面知识需要深入学习或者我的不足在那些方面，今后我该注意什么*？</p><p>你还可以问下项目团队多少人，主要以什么方向为主，一年内的目标怎样，团队气氛怎样，等内容着手。</p><h4 id="3、研究比较深入的领域有哪些？"><a href="#3、研究比较深入的领域有哪些？" class="headerlink" title="3、研究比较深入的领域有哪些？"></a>3、研究比较深入的领域有哪些？</h4><h4 id="4、自己最擅长的技术点，最感兴趣的技术领域和技术？"><a href="#4、自己最擅长的技术点，最感兴趣的技术领域和技术？" class="headerlink" title="4、自己最擅长的技术点，最感兴趣的技术领域和技术？"></a>4、自己最擅长的技术点，最感兴趣的技术领域和技术？</h4><h4 id="5、项目中用了哪些开源库，如何避免因为引入开源库而导致的安全性和稳定性问题？"><a href="#5、项目中用了哪些开源库，如何避免因为引入开源库而导致的安全性和稳定性问题？" class="headerlink" title="5、项目中用了哪些开源库，如何避免因为引入开源库而导致的安全性和稳定性问题？"></a>5、项目中用了哪些开源库，如何避免因为引入开源库而导致的安全性和稳定性问题？</h4><h4 id="6、说下你都看过那些技术书籍，你是如何自学的。你觉得自己的优势与弱点是什么。"><a href="#6、说下你都看过那些技术书籍，你是如何自学的。你觉得自己的优势与弱点是什么。" class="headerlink" title="6、说下你都看过那些技术书籍，你是如何自学的。你觉得自己的优势与弱点是什么。"></a>6、说下你都看过那些技术书籍，你是如何自学的。你觉得自己的优势与弱点是什么。</h4><h4 id="7、说下项目中遇到的棘手问题，包括技术，交际和沟通。"><a href="#7、说下项目中遇到的棘手问题，包括技术，交际和沟通。" class="headerlink" title="7、说下项目中遇到的棘手问题，包括技术，交际和沟通。"></a>7、说下项目中遇到的棘手问题，包括技术，交际和沟通。</h4><h4 id="8、说下你近几年的规划？"><a href="#8、说下你近几年的规划？" class="headerlink" title="8、说下你近几年的规划？"></a>8、说下你近几年的规划？</h4><h4 id="9、对加班怎么看（不要太浮夸，现实一点哦）？"><a href="#9、对加班怎么看（不要太浮夸，现实一点哦）？" class="headerlink" title="9、对加班怎么看（不要太浮夸，现实一点哦）？"></a>9、对加班怎么看（不要太浮夸，现实一点哦）？</h4><h4 id="10、介绍你做过的哪些项目。"><a href="#10、介绍你做过的哪些项目。" class="headerlink" title="10、介绍你做过的哪些项目。"></a>10、介绍你做过的哪些项目。</h4><h4 id="11、你并非毕业于名牌院校？"><a href="#11、你并非毕业于名牌院校？" class="headerlink" title="11、你并非毕业于名牌院校？"></a>11、你并非毕业于名牌院校？</h4><h4 id="12、为什么要离职"><a href="#12、为什么要离职" class="headerlink" title="12、为什么要离职?"></a>12、为什么要离职?</h4><h4 id="13、当你的开发任务很紧张，你怎么去做代码优化的？"><a href="#13、当你的开发任务很紧张，你怎么去做代码优化的？" class="headerlink" title="13、当你的开发任务很紧张，你怎么去做代码优化的？"></a>13、当你的开发任务很紧张，你怎么去做代码优化的？</h4><h3 id="二、次高频题集-（⭐⭐）"><a href="#二、次高频题集-（⭐⭐）" class="headerlink" title="二、次高频题集 （⭐⭐）"></a>二、次高频题集 （⭐⭐）</h3><h4 id="1、对业内信息的关注渠道有哪些？"><a href="#1、对业内信息的关注渠道有哪些？" class="headerlink" title="1、对业内信息的关注渠道有哪些？"></a>1、对业内信息的关注渠道有哪些？</h4><h4 id="2、最近都读哪些书？"><a href="#2、最近都读哪些书？" class="headerlink" title="2、最近都读哪些书？"></a>2、最近都读哪些书？</h4><h4 id="3、给你一个项目，你怎么看待他的市场和技术的关系？"><a href="#3、给你一个项目，你怎么看待他的市场和技术的关系？" class="headerlink" title="3、给你一个项目，你怎么看待他的市场和技术的关系？"></a>3、给你一个项目，你怎么看待他的市场和技术的关系？</h4><h4 id="4、你以往的项目中，以你现在的眼光去评价项目的利弊？"><a href="#4、你以往的项目中，以你现在的眼光去评价项目的利弊？" class="headerlink" title="4、你以往的项目中，以你现在的眼光去评价项目的利弊？"></a>4、你以往的项目中，以你现在的眼光去评价项目的利弊？</h4><h4 id="5、对于非立项（KPI）项目，怎么推进？"><a href="#5、对于非立项（KPI）项目，怎么推进？" class="headerlink" title="5、对于非立项（KPI）项目，怎么推进？"></a>5、对于非立项（KPI）项目，怎么推进？</h4><h4 id="6、都使用过哪些自定义控件？"><a href="#6、都使用过哪些自定义控件？" class="headerlink" title="6、都使用过哪些自定义控件？"></a>6、都使用过哪些自定义控件？</h4><h4 id="7、除了简历上的工作经历，您还会去关注哪些领域？"><a href="#7、除了简历上的工作经历，您还会去关注哪些领域？" class="headerlink" title="7、除了简历上的工作经历，您还会去关注哪些领域？"></a>7、除了简历上的工作经历，您还会去关注哪些领域？</h4><h4 id="8、评价下自己，评价下自己的技术水平，个人代码量如何？"><a href="#8、评价下自己，评价下自己的技术水平，个人代码量如何？" class="headerlink" title="8、评价下自己，评价下自己的技术水平，个人代码量如何？"></a>8、评价下自己，评价下自己的技术水平，个人代码量如何？</h4><h4 id="9、你朋友对你的评价？"><a href="#9、你朋友对你的评价？" class="headerlink" title="9、你朋友对你的评价？"></a>9、你朋友对你的评价？</h4><h4 id="10、自己的优点和缺点是什么？并举例说明？"><a href="#10、自己的优点和缺点是什么？并举例说明？" class="headerlink" title="10、自己的优点和缺点是什么？并举例说明？"></a>10、自己的优点和缺点是什么？并举例说明？</h4><h4 id="11、你觉得你个性上最大的优点是什么？"><a href="#11、你觉得你个性上最大的优点是什么？" class="headerlink" title="11、你觉得你个性上最大的优点是什么？"></a>11、你觉得你个性上最大的优点是什么？</h4><h4 id="12、说说你最大的缺点？"><a href="#12、说说你最大的缺点？" class="headerlink" title="12、说说你最大的缺点？"></a>12、说说你最大的缺点？</h4><h4 id="13、最能概括你自己的三个词是什么？"><a href="#13、最能概括你自己的三个词是什么？" class="headerlink" title="13、最能概括你自己的三个词是什么？"></a>13、最能概括你自己的三个词是什么？</h4><h4 id="14、说说你的家庭？"><a href="#14、说说你的家庭？" class="headerlink" title="14、说说你的家庭？"></a>14、说说你的家庭？</h4><h4 id="15、除了本公司外，还应聘了哪些公司？（类似问题：当前的offer状况）"><a href="#15、除了本公司外，还应聘了哪些公司？（类似问题：当前的offer状况）" class="headerlink" title="15、除了本公司外，还应聘了哪些公司？（类似问题：当前的offer状况）"></a>15、除了本公司外，还应聘了哪些公司？（类似问题：当前的offer状况）</h4><h4 id="16、通过哪些渠道了解的招聘信息？"><a href="#16、通过哪些渠道了解的招聘信息？" class="headerlink" title="16、通过哪些渠道了解的招聘信息？"></a>16、通过哪些渠道了解的招聘信息？</h4><h4 id="17、你的业余爱好是什么？"><a href="#17、你的业余爱好是什么？" class="headerlink" title="17、你的业余爱好是什么？"></a>17、你的业余爱好是什么？</h4><h4 id="18、你做过的哪件事最令自己感到骄傲？"><a href="#18、你做过的哪件事最令自己感到骄傲？" class="headerlink" title="18、你做过的哪件事最令自己感到骄傲？"></a>18、你做过的哪件事最令自己感到骄傲？</h4><h4 id="19、谈谈你对跳槽的看法？"><a href="#19、谈谈你对跳槽的看法？" class="headerlink" title="19、谈谈你对跳槽的看法？"></a>19、谈谈你对跳槽的看法？</h4><h4 id="20、怎样看待学历和能力？"><a href="#20、怎样看待学历和能力？" class="headerlink" title="20、怎样看待学历和能力？"></a>20、怎样看待学历和能力？</h4><h4 id="21、您跟您的主管或直接上司有没有针对以上离职原因的这些问题沟通过？如果没有请说明原因。如果有请说一下过程和结果？"><a href="#21、您跟您的主管或直接上司有没有针对以上离职原因的这些问题沟通过？如果没有请说明原因。如果有请说一下过程和结果？" class="headerlink" title="21、您跟您的主管或直接上司有没有针对以上离职原因的这些问题沟通过？如果没有请说明原因。如果有请说一下过程和结果？"></a>21、您跟您的主管或直接上司有没有针对以上离职原因的这些问题沟通过？如果没有请说明原因。如果有请说一下过程和结果？</h4><h4 id="22、您觉得你关注的这些领域跟您目前从事的职业有哪些利弊关系？如果有请说明利弊关系？"><a href="#22、您觉得你关注的这些领域跟您目前从事的职业有哪些利弊关系？如果有请说明利弊关系？" class="headerlink" title="22、您觉得你关注的这些领域跟您目前从事的职业有哪些利弊关系？如果有请说明利弊关系？"></a>22、您觉得你关注的这些领域跟您目前从事的职业有哪些利弊关系？如果有请说明利弊关系？</h4><h4 id="23、您在选择工作中更看重的是什么？（可能是成长空间、培训机会、发挥平台、薪酬等答案）"><a href="#23、您在选择工作中更看重的是什么？（可能是成长空间、培训机会、发挥平台、薪酬等答案）" class="headerlink" title="23、您在选择工作中更看重的是什么？（可能是成长空间、培训机会、发挥平台、薪酬等答案）"></a>23、您在选择工作中更看重的是什么？（可能是成长空间、培训机会、发挥平台、薪酬等答案）</h4><h4 id="24、您可不可以说说您在薪酬方面的心里预期？"><a href="#24、您可不可以说说您在薪酬方面的心里预期？" class="headerlink" title="24、您可不可以说说您在薪酬方面的心里预期？"></a>24、您可不可以说说您在薪酬方面的心里预期？</h4><h4 id="25、有人说挣未来比挣钱更为重要，您怎么理解？"><a href="#25、有人说挣未来比挣钱更为重要，您怎么理解？" class="headerlink" title="25、有人说挣未来比挣钱更为重要，您怎么理解？"></a>25、有人说挣未来比挣钱更为重要，您怎么理解？</h4><h4 id="26、假设，某一天，在工作办公室走廊，您和一位同事正在抱怨上级陈某平时做事缺乏公平性，恰巧被陈某听到，您会怎么办？"><a href="#26、假设，某一天，在工作办公室走廊，您和一位同事正在抱怨上级陈某平时做事缺乏公平性，恰巧被陈某听到，您会怎么办？" class="headerlink" title="26、假设，某一天，在工作办公室走廊，您和一位同事正在抱怨上级陈某平时做事缺乏公平性，恰巧被陈某听到，您会怎么办？"></a>26、假设，某一天，在工作办公室走廊，您和一位同事正在抱怨上级陈某平时做事缺乏公平性，恰巧被陈某听到，您会怎么办？</h4><h4 id="27、怎么样处理工作和生活的关系？怎么处理在工作中遇到困难？请举例说明"><a href="#27、怎么样处理工作和生活的关系？怎么处理在工作中遇到困难？请举例说明" class="headerlink" title="27、怎么样处理工作和生活的关系？怎么处理在工作中遇到困难？请举例说明"></a>27、怎么样处理工作和生活的关系？怎么处理在工作中遇到困难？请举例说明</h4><h4 id="28、在您的现实生活中，您最不喜欢和什么样的人共事？为什么？举例说明。"><a href="#28、在您的现实生活中，您最不喜欢和什么样的人共事？为什么？举例说明。" class="headerlink" title="28、在您的现实生活中，您最不喜欢和什么样的人共事？为什么？举例说明。"></a>28、在您的现实生活中，您最不喜欢和什么样的人共事？为什么？举例说明。</h4><h4 id="29、在您认识的人中，有没有人不喜欢您？为什么不喜欢您？请举例说明。"><a href="#29、在您认识的人中，有没有人不喜欢您？为什么不喜欢您？请举例说明。" class="headerlink" title="29、在您认识的人中，有没有人不喜欢您？为什么不喜欢您？请举例说明。"></a>29、在您认识的人中，有没有人不喜欢您？为什么不喜欢您？请举例说明。</h4><h4 id="30、当老板-上司-同事-客户误会你，你会怎么办？"><a href="#30、当老板-上司-同事-客户误会你，你会怎么办？" class="headerlink" title="30、当老板/上司/同事/客户误会你，你会怎么办？"></a>30、当老板/上司/同事/客户误会你，你会怎么办？</h4><h4 id="31、当你发现其他部门的工作疏漏已经影响到您的工作绩效时，您怎么办？"><a href="#31、当你发现其他部门的工作疏漏已经影响到您的工作绩效时，您怎么办？" class="headerlink" title="31、当你发现其他部门的工作疏漏已经影响到您的工作绩效时，您怎么办？"></a>31、当你发现其他部门的工作疏漏已经影响到您的工作绩效时，您怎么办？</h4><h4 id="32、您希望在什么样的领导下工作？"><a href="#32、您希望在什么样的领导下工作？" class="headerlink" title="32、您希望在什么样的领导下工作？"></a>32、您希望在什么样的领导下工作？</h4><h4 id="33、我们工作与生活历程并不是一帆风顺的，谈谈您的工作或生活中出现的挫折或低潮期，您如何克服？"><a href="#33、我们工作与生活历程并不是一帆风顺的，谈谈您的工作或生活中出现的挫折或低潮期，您如何克服？" class="headerlink" title="33、我们工作与生活历程并不是一帆风顺的，谈谈您的工作或生活中出现的挫折或低潮期，您如何克服？"></a>33、我们工作与生活历程并不是一帆风顺的，谈谈您的工作或生活中出现的挫折或低潮期，您如何克服？</h4><h4 id="34、假如您的上司是一个非常严厉、领导手腕强硬，时常给您巨大压力的人，您觉得这种领导方式对您有何利、弊？"><a href="#34、假如您的上司是一个非常严厉、领导手腕强硬，时常给您巨大压力的人，您觉得这种领导方式对您有何利、弊？" class="headerlink" title="34、假如您的上司是一个非常严厉、领导手腕强硬，时常给您巨大压力的人，您觉得这种领导方式对您有何利、弊？"></a>34、假如您的上司是一个非常严厉、领导手腕强硬，时常给您巨大压力的人，您觉得这种领导方式对您有何利、弊？</h4><h4 id="35、您的领导给您布置了一项您以前从未触及过的任务，您打算如何去完成它？（如果有类似的经历说说完成的经历。"><a href="#35、您的领导给您布置了一项您以前从未触及过的任务，您打算如何去完成它？（如果有类似的经历说说完成的经历。" class="headerlink" title="35、您的领导给您布置了一项您以前从未触及过的任务，您打算如何去完成它？（如果有类似的经历说说完成的经历。)"></a>35、您的领导给您布置了一项您以前从未触及过的任务，您打算如何去完成它？（如果有类似的经历说说完成的经历。)</h4><h4 id="36、谈谈您以往职业生涯中最有压力的一、两件事，并说说是如何克服的。"><a href="#36、谈谈您以往职业生涯中最有压力的一、两件事，并说说是如何克服的。" class="headerlink" title="36、谈谈您以往职业生涯中最有压力的一、两件事，并说说是如何克服的。"></a>36、谈谈您以往职业生涯中最有压力的一、两件事，并说说是如何克服的。</h4><h4 id="37、谈谈您以往职业生涯中令您有成就感的一、两件事，并说说它给您的启示。"><a href="#37、谈谈您以往职业生涯中令您有成就感的一、两件事，并说说它给您的启示。" class="headerlink" title="37、谈谈您以往职业生涯中令您有成就感的一、两件事，并说说它给您的启示。"></a>37、谈谈您以往职业生涯中令您有成就感的一、两件事，并说说它给您的启示。</h4><h4 id="38、请您举一个例子，说明在完成一项重要任务时，您是怎样和他人进行有效合作的。"><a href="#38、请您举一个例子，说明在完成一项重要任务时，您是怎样和他人进行有效合作的。" class="headerlink" title="38、请您举一个例子，说明在完成一项重要任务时，您是怎样和他人进行有效合作的。"></a>38、请您举一个例子，说明在完成一项重要任务时，您是怎样和他人进行有效合作的。</h4><h4 id="39、当你要牺牲自己的某些方面与他人共事时，你会怎么办？"><a href="#39、当你要牺牲自己的某些方面与他人共事时，你会怎么办？" class="headerlink" title="39、当你要牺牲自己的某些方面与他人共事时，你会怎么办？"></a>39、当你要牺牲自己的某些方面与他人共事时，你会怎么办？</h4><h4 id="40、有时团队成员不能有效共事，当遇到这种问题时你是怎么处理的？你又是如何改善这类情况的？"><a href="#40、有时团队成员不能有效共事，当遇到这种问题时你是怎么处理的？你又是如何改善这类情况的？" class="headerlink" title="40、有时团队成员不能有效共事，当遇到这种问题时你是怎么处理的？你又是如何改善这类情况的？"></a>40、有时团队成员不能有效共事，当遇到这种问题时你是怎么处理的？你又是如何改善这类情况的？</h4><h4 id="41、我们有时不得不与自己不喜欢的人在一个团队工作，如果遇到这样的情况你会怎么办？"><a href="#41、我们有时不得不与自己不喜欢的人在一个团队工作，如果遇到这样的情况你会怎么办？" class="headerlink" title="41、我们有时不得不与自己不喜欢的人在一个团队工作，如果遇到这样的情况你会怎么办？"></a>41、我们有时不得不与自己不喜欢的人在一个团队工作，如果遇到这样的情况你会怎么办？</h4><h4 id="42、您对委任的任务完成不了时如何处理？"><a href="#42、您对委任的任务完成不了时如何处理？" class="headerlink" title="42、您对委任的任务完成不了时如何处理？"></a>42、您对委任的任务完成不了时如何处理？</h4><h4 id="43、说说您对下属布置的任务在时间方面是如何要求的？"><a href="#43、说说您对下属布置的任务在时间方面是如何要求的？" class="headerlink" title="43、说说您对下属布置的任务在时间方面是如何要求的？"></a>43、说说您对下属布置的任务在时间方面是如何要求的？</h4><h4 id="44、说说您在完成上司布置的任务时，在时间方面是如何要求自己的？"><a href="#44、说说您在完成上司布置的任务时，在时间方面是如何要求自己的？" class="headerlink" title="44、说说您在完成上司布置的任务时，在时间方面是如何要求自己的？"></a>44、说说您在完成上司布置的任务时，在时间方面是如何要求自己的？</h4><h4 id="45、您以往在领导岗位中，一个月内分别有哪些主要的工作任务？"><a href="#45、您以往在领导岗位中，一个月内分别有哪些主要的工作任务？" class="headerlink" title="45、您以往在领导岗位中，一个月内分别有哪些主要的工作任务？"></a>45、您以往在领导岗位中，一个月内分别有哪些主要的工作任务？</h4><h4 id="46、当您发现您的部属目前士气较低沉，您一般从哪些方面去调动？"><a href="#46、当您发现您的部属目前士气较低沉，您一般从哪些方面去调动？" class="headerlink" title="46、当您发现您的部属目前士气较低沉，您一般从哪些方面去调动？"></a>46、当您发现您的部属目前士气较低沉，您一般从哪些方面去调动？</h4><h4 id="47、说说您在以往领导岗位中出现管理失控的事例及事后的原因分析。您的部属在一个专业的问题上跟您发生争议，您如何对待这种事件？"><a href="#47、说说您在以往领导岗位中出现管理失控的事例及事后的原因分析。您的部属在一个专业的问题上跟您发生争议，您如何对待这种事件？" class="headerlink" title="47、说说您在以往领导岗位中出现管理失控的事例及事后的原因分析。您的部属在一个专业的问题上跟您发生争议，您如何对待这种事件？"></a>47、说说您在以往领导岗位中出现管理失控的事例及事后的原因分析。您的部属在一个专业的问题上跟您发生争议，您如何对待这种事件？</h4><h4 id="48、你对某某某互联网发生事情的看法？（直播答题等等）"><a href="#48、你对某某某互联网发生事情的看法？（直播答题等等）" class="headerlink" title="48、你对某某某互联网发生事情的看法？（直播答题等等）"></a>48、你对某某某互联网发生事情的看法？（直播答题等等）</h4><h4 id="49、怎么看待前端和后端？"><a href="#49、怎么看待前端和后端？" class="headerlink" title="49、怎么看待前端和后端？"></a>49、怎么看待前端和后端？</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>常见的10种排序算法</title>
      <link href="/2019-12-30/sorting-algorithms/"/>
      <url>/2019-12-30/sorting-algorithms/</url>
      
        <content type="html"><![CDATA[<p>算法虽然在平时用得并不是很多，但是一旦用到，就要命。算法也处处体现了解决问题的思路，做为程序员，算法应该人人掌握。</p><p>本篇文章总结一些业界比较常用的<strong>排序算法</strong>。</p><span id="more"></span><p>在撸算法之前，先说明几个术语：</p><ul><li>稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；</li><li>不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；</li><li>内排序：所有排序操作都在内存中完成；</li><li>外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</li><li>时间复杂度： 一个算法执行所耗费的时间。</li><li>空间复杂度：运行完一个程序所需内存的大小。</li></ul><p><img src="/img/algorithm-1590395511.png"></p><div style="text-align: center;"><p><em>n表示数据规模，k表示『桶』的个数</em></p></div><h2 id="算法分类："><a href="#算法分类：" class="headerlink" title="算法分类："></a>算法分类：</h2><p><img src="/img/algorithm-1590395522.png"></p><p>比较和非比较的区别</p><p>常见的快速排序、归并排序、堆排序、冒泡排序等属于比较排序。在排序的最终结果里，元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置。<br>在冒泡排序之类的排序中，问题规模为n，又因为需要比较n次，所以平均时间复杂度为O(n²)。在归并排序、快速排序之类的排序中，问题规模通过分治法消减为logN次，所以时间复杂度平均O(nlogn)。<br>比较排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，比较排序适用于一切需要排序的情况。</p><p>计数排序、基数排序、桶排序则属于非比较排序。非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr，计算arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置。<br>非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度O(n)。<br>非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。</p><h2 id="1-冒泡排序（Bubble-Sort）"><a href="#1-冒泡排序（Bubble-Sort）" class="headerlink" title="1. 冒泡排序（Bubble Sort）"></a>1. 冒泡排序（Bubble Sort）</h2><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 </p><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><p>比较相邻的元素。如果第一个比第二个大，就交换它们两个；<br>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；<br>针对所有的元素重复以上的步骤，除了最后一个；<br>重复步骤1~3，直到排序完成。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMjMyMzg0NDktMjE0NjE2OTE5Ny5naWY"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="java">/** * 冒泡排序 * * @param array * @return */public static int[] bubbleSort(int[] array) &#123;    if (array.length == 0)        return array;    for (int i = 0; i &lt; array.length; i++)        for (int j = 0; j &lt; array.length - 1 - i; j++)            if (array[j + 1] &lt; array[j]) &#123;  // 交换位置                int temp = array[j + 1];                array[j + 1] = array[j];                array[j] = temp;            &#125;    return array;&#125;</code></pre><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>最佳情况：T(n) = O(n)<br>最差情况：T(n) = O(n2)<br>平均情况：T(n) = O(n2)</p><h2 id="2-选择排序（Selection-Sort）"><a href="#2-选择排序（Selection-Sort）" class="headerlink" title="2. 选择排序（Selection Sort）"></a>2. 选择排序（Selection Sort）</h2><p>表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是<strong>不占用额外的内存空间了吧</strong>。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。</p><p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 </p><h3 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h3><p>n 个记录的直接选择排序可经过 n-1 趟直接选择排序得到有序结果。具体算法描述如下：</p><p>初始状态：无序区为R[1..n]，有序区为空；<br>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；<br>n-1趟结束，数组有序化了。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMjQ3MTk1OTAtMTQzMzIxOTgyNC5naWY"></p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="java">/** * 选择排序 * @param array * @return */public static int[] selectionSort(int[] array) &#123;    if (array.length == 0)        return array;    for (int i = 0; i &lt; array.length; i++) &#123;        int minIndex = i;        for (int j = i; j &lt; array.length; j++) &#123;            if (array[j] &lt; array[minIndex]) //找到最小的数                minIndex = j; //将最小数的索引保存        &#125;        int temp = array[minIndex];        array[minIndex] = array[i];        array[i] = temp;    &#125;    return array;&#125;</code></pre><h3 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h3><p>最佳情况：T(n) = O(n2)<br>最差情况：T(n) = O(n2)<br>平均情况：T(n) = O(n2)</p><h2 id="3-插入排序（Insertion-Sort）"><a href="#3-插入排序（Insertion-Sort）" class="headerlink" title="3. 插入排序（Insertion Sort）"></a>3. 插入排序（Insertion Sort）</h2><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><h3 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h3><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p><ol><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ol><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMjU2NDUyNzctMTE1MTEwMDAwMC5naWY"></p><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="java">/*** 插入排序* @param array* @return*/public static int[] insertionSort(int[] array) &#123;    if (array.length == 0)        return array;    int current;    for (int i = 0; i &lt; array.length - 1; i++) &#123;        current = array[i + 1];        int preIndex = i;        while (preIndex &gt;= 0 &amp;&amp; current &lt; array[preIndex]) &#123;            array[preIndex + 1] = array[preIndex];            preIndex--;        &#125;        array[preIndex + 1] = current;    &#125;    return array;&#125;</code></pre><h3 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h3><p>最佳情况：T(n) = O(n)<br>最坏情况：T(n) = O(n2)<br>平均情况：T(n) = O(n2)</p><h2 id="4-希尔排序（Shell-Sort）"><a href="#4-希尔排序（Shell-Sort）" class="headerlink" title="4. 希尔排序（Shell Sort）"></a>4. 希尔排序（Shell Sort）</h2><p>希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破O(n2）的第一批算法之一。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。</p><p>希尔排序是把记录按下表的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p><h3 id="算法描述-3"><a href="#算法描述-3" class="headerlink" title="算法描述"></a>算法描述</h3><p>我们来看下希尔排序的基本步骤，在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2…1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。</p><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p><ol><li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li><li>按增量序列个数k，对序列进行k 趟排序；</li><li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ol><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTE5MjY5OS8yMDE4MDMvMTE5MjY5OS0yMDE4MDMxOTA5NDExNjA0MC0xNjM4NzY2MjcxLnBuZw?x-oss-process=image/format,png"></p><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="java">/*** 希尔排序** @param array* @return*/public static int[] ShellSort(int[] array) &#123;    int len = array.length;    int temp, gap = len / 2;    while (gap &gt; 0) &#123;        for (int i = gap; i &lt; len; i++) &#123;            temp = array[i];            int preIndex = i - gap;            while (preIndex &gt;= 0 &amp;&amp; array[preIndex] &gt; temp) &#123;                array[preIndex + gap] = array[preIndex];                preIndex -= gap;            &#125;            array[preIndex + gap] = temp;        &#125;        gap /= 2;    &#125;    return array;&#125;</code></pre><h3 id="算法分析-3"><a href="#算法分析-3" class="headerlink" title="算法分析"></a>算法分析</h3><p>最佳情况：T(n) = O(n log2 n)<br>最坏情况：T(n) = O(n log2 n)<br>平均情况：T(n) = O(n log2 n)</p><h2 id="5-归并排序（Merge-Sort）"><a href="#5-归并排序（Merge-Sort）" class="headerlink" title="5. 归并排序（Merge Sort）"></a>5. 归并排序（Merge Sort）</h2><p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。</p><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 </p><h3 id="算法描述-4"><a href="#算法描述-4" class="headerlink" title="算法描述"></a>算法描述</h3><ol><li>把长度为n的输入序列分成两个长度为n/2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ol><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMzA1NTcwNDMtMzczNzUwMTAuZ2lm"></p><h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="java">/*** 归并排序** @param array* @return*/public static int[] MergeSort(int[] array) &#123;    if (array.length &lt; 2) return array;    int mid = array.length / 2;    int[] left = Arrays.copyOfRange(array, 0, mid);    int[] right = Arrays.copyOfRange(array, mid, array.length);    return merge(MergeSort(left), MergeSort(right));&#125;/*** 归并排序——将两段排序好的数组结合成一个排序数组** @param left* @param right* @return*/public static int[] merge(int[] left, int[] right) &#123;    int[] result = new int[left.length + right.length];    for (int index = 0, i = 0, j = 0; index &lt; result.length; index++) &#123;        if (i &gt;= left.length)            result[index] = right[j++];        else if (j &gt;= right.length)            result[index] = left[i++];        else if (left[i] &gt; right[j])            result[index] = right[j++];        else            result[index] = left[i++];    &#125;    return result;&#125;</code></pre><h3 id="算法分析-4"><a href="#算法分析-4" class="headerlink" title="算法分析"></a>算法分析</h3><p>最佳情况：T(n) = O(n)<br>最差情况：T(n) = O(n logn)<br>平均情况：T(n) = O(n logn)</p><h2 id="6-快速排序（Quick-Sort）"><a href="#6-快速排序（Quick-Sort）" class="headerlink" title="6. 快速排序（Quick Sort）"></a>6. 快速排序（Quick Sort）</h2><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><h3 id="算法描述-5"><a href="#算法描述-5" class="headerlink" title="算法描述"></a>算法描述</h3><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p><ol><li>从数列中挑出一个元素，称为 “基准”（pivot）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ol><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMzA5MzYzNzEtMTQxMzUyMzQxMi5naWY"></p><h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="java">/*** 快速排序方法* @param array* @param start* @param end* @return*/public static int[] QuickSort(int[] array, int start, int end) &#123;    if (array.length &lt; 1 || start &lt; 0 || end &gt;= array.length || start &gt; end) return null;    int smallIndex = partition(array, start, end);    if (smallIndex &gt; start)        QuickSort(array, start, smallIndex - 1);    if (smallIndex &lt; end)        QuickSort(array, smallIndex + 1, end);    return array;&#125;/*** 快速排序算法——partition* @param array* @param start* @param end* @return*/public static int partition(int[] array, int start, int end) &#123;    int pivot = (int) (start + Math.random() * (end - start + 1));    int smallIndex = start - 1;    swap(array, pivot, end);    for (int i = start; i &lt;= end; i++)        if (array[i] &lt;= array[end]) &#123;            smallIndex++;            if (i &gt; smallIndex)                swap(array, i, smallIndex);        &#125;    return smallIndex;&#125;/*** 交换数组内两个元素* @param array* @param i* @param j*/public static void swap(int[] array, int i, int j) &#123;    int temp = array[i];    array[i] = array[j];    array[j] = temp;&#125;</code></pre><h3 id="算法分析-5"><a href="#算法分析-5" class="headerlink" title="算法分析"></a>算法分析</h3><p>最佳情况：T(n) = O(nlogn)<br>最差情况：T(n) = O(n2)<br>平均情况：T(n) = O(nlogn)　</p><h2 id="7-堆排序（Heap-Sort）"><a href="#7-堆排序（Heap-Sort）" class="headerlink" title="7. 堆排序（Heap Sort）"></a>7. 堆排序（Heap Sort）</h2><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><h3 id="算法描述-6"><a href="#算法描述-6" class="headerlink" title="算法描述"></a>算法描述</h3><ol><li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li><li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li><li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li></ol><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMzEzMDg2OTktMzU2MTM0MjM3LmdpZg"></p><h3 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="java">//声明全局变量，用于记录数组array的长度；static int len;/*** 堆排序算法** @param array* @return*/public static int[] HeapSort(int[] array) &#123;    len = array.length;    if (len &lt; 1) return array;    //1.构建一个最大堆    buildMaxHeap(array);    //2.循环将堆首位（最大值）与末位交换，然后在重新调整最大堆    while (len &gt; 0) &#123;        swap(array, 0, len - 1);        len--;        adjustHeap(array, 0);    &#125;    return array;&#125;/*** 建立最大堆** @param array*/public static void buildMaxHeap(int[] array) &#123;    //从最后一个非叶子节点开始向上构造最大堆    for (int i = (len/2 - 1); i &gt;= 0; i--) &#123; //感谢 @让我发会呆 网友的提醒，此处应该为 i = (len/2 - 1)         adjustHeap(array, i);    &#125;&#125;/*** 调整使之成为最大堆** @param array* @param i*/public static void adjustHeap(int[] array, int i) &#123;    int maxIndex = i;    //如果有左子树，且左子树大于父节点，则将最大指针指向左子树    if (i * 2 &lt; len &amp;&amp; array[i * 2] &gt; array[maxIndex])        maxIndex = i * 2;    //如果有右子树，且右子树大于父节点，则将最大指针指向右子树    if (i * 2 + 1 &lt; len &amp;&amp; array[i * 2 + 1] &gt; array[maxIndex])        maxIndex = i * 2 + 1;    //如果父节点不是最大值，则将父节点与最大值交换，并且递归调整与父节点交换的位置。    if (maxIndex != i) &#123;        swap(array, maxIndex, i);        adjustHeap(array, maxIndex);    &#125;&#125;</code></pre><h3 id="算法分析-6"><a href="#算法分析-6" class="headerlink" title="算法分析"></a>算法分析</h3><p>最佳情况：T(n) = O(nlogn)<br>最差情况：T(n) = O(nlogn)<br>平均情况：T(n) = O(nlogn)</p><h2 id="8-计数排序（Counting-Sort）"><a href="#8-计数排序（Counting-Sort）" class="headerlink" title="8. 计数排序（Counting Sort）"></a>8. 计数排序（Counting Sort）</h2><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><p>计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。</p><h3 id="算法描述-7"><a href="#算法描述-7" class="headerlink" title="算法描述"></a>算法描述</h3><ol><li>找出待排序的数组中最大和最小的元素；</li><li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li><li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li><li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li></ol><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMzE3NDA4NDAtNjk2ODE4MS5naWY"></p><h3 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="java">/*** 计数排序** @param array* @return*/public static int[] CountingSort(int[] array) &#123;    if (array.length == 0) return array;    int bias, min = array[0], max = array[0];    for (int i = 1; i &lt; array.length; i++) &#123;        if (array[i] &gt; max)            max = array[i];        if (array[i] &lt; min)            min = array[i];    &#125;    bias = 0 - min;    int[] bucket = new int[max - min + 1];    Arrays.fill(bucket, 0);    for (int i = 0; i &lt; array.length; i++) &#123;        bucket[array[i] + bias]++;    &#125;    int index = 0, i = 0;    while (index &lt; array.length) &#123;        if (bucket[i] != 0) &#123;            array[index] = i - bias;            bucket[i]--;            index++;        &#125; else            i++;    &#125;    return array;&#125;</code></pre><h3 id="算法分析-7"><a href="#算法分析-7" class="headerlink" title="算法分析"></a>算法分析</h3><p>当输入的元素是n 个0到k之间的整数时，它的运行时间是 O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。</p><p>最佳情况：T(n) = O(n+k)<br>最差情况：T(n) = O(n+k)<br>平均情况：T(n) = O(n+k)</p><h2 id="9-桶排序（Bucket-Sort）"><a href="#9-桶排序（Bucket-Sort）" class="headerlink" title="9. 桶排序（Bucket Sort）"></a>9. 桶排序（Bucket Sort）</h2><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。</p><p>桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排</p><h3 id="算法描述-8"><a href="#算法描述-8" class="headerlink" title="算法描述"></a>算法描述</h3><ol><li>人为设置一个BucketSize，作为每个桶所能放置多少个不同数值（例如当BucketSize==5时，该桶可以存放｛1,2,3,4,5｝这几种数字，但是容量不限，即可以存放100个3）；</li><li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li><li>对每个不是空的桶进行排序，可以使用其它排序方法，也可以递归使用桶排序；</li><li>从不是空的桶里把排好序的数据拼接起来。 </li></ol><p>注意，如果递归使用桶排序为各个桶排序，则当桶数量为1时要手动减小BucketSize增加下一循环桶的数量，否则会陷入死循环，导致内存溢出。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMzIxMDcwOTAtMTkyMDcwMjAxMS5wbmc?x-oss-process=image/format,png"></p><h3 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="java">/*** 桶排序* * @param array* @param bucketSize* @return*/public static ArrayList&lt;Integer&gt; BucketSort(ArrayList&lt;Integer&gt; array, int bucketSize) &#123;    if (array == null || array.size() &lt; 2)        return array;    int max = array.get(0), min = array.get(0);    // 找到最大值最小值    for (int i = 0; i &lt; array.size(); i++) &#123;        if (array.get(i) &gt; max)            max = array.get(i);        if (array.get(i) &lt; min)            min = array.get(i);    &#125;    int bucketCount = (max - min) / bucketSize + 1;    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = new ArrayList&lt;&gt;(bucketCount);    ArrayList&lt;Integer&gt; resultArr = new ArrayList&lt;&gt;();    for (int i = 0; i &lt; bucketCount; i++) &#123;        bucketArr.add(new ArrayList&lt;Integer&gt;());    &#125;    for (int i = 0; i &lt; array.size(); i++) &#123;        bucketArr.get((array.get(i) - min) / bucketSize).add(array.get(i));    &#125;    for (int i = 0; i &lt; bucketCount; i++) &#123;        if (bucketSize == 1) &#123; // 如果带排序数组中有重复数字时  感谢 @见风任然是风 朋友指出错误            for (int j = 0; j &lt; bucketArr.get(i).size(); j++)                resultArr.add(bucketArr.get(i).get(j));        &#125; else &#123;            if (bucketCount == 1)                bucketSize--;            ArrayList&lt;Integer&gt; temp = BucketSort(bucketArr.get(i), bucketSize);            for (int j = 0; j &lt; temp.size(); j++)                resultArr.add(temp.get(j));        &#125;    &#125;    return resultArr;&#125;</code></pre><h3 id="算法分析-8"><a href="#算法分析-8" class="headerlink" title="算法分析"></a>算法分析</h3><p>桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。 </p><p>最佳情况：T(n) = O(n+k)<br>最差情况：T(n) = O(n+k)<br>平均情况：T(n) = O(n2)　　</p><h2 id="10-基数排序（Radix-Sort）"><a href="#10-基数排序（Radix-Sort）" class="headerlink" title="10. 基数排序（Radix Sort）"></a>10. 基数排序（Radix Sort）</h2><p>基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数；</p><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。</p><h3 id="算法描述-9"><a href="#算法描述-9" class="headerlink" title="算法描述"></a>算法描述</h3><ol><li>取得数组中的最大数，并取得位数；</li><li>arr为原始数组，从最低位开始取每个位组成radix数组；</li><li>对 radix 进行计数排序（利用计数排序适用于小范围数的特点）。</li></ol><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMzI0NTM2NjgtMTM5NzY2MjUyNy5naWY"></p><h3 id="代码实现-9"><a href="#代码实现-9" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="java">/*** 基数排序* @param array* @return*/public static int[] RadixSort(int[] array) &#123;    if (array == null || array.length &lt; 2)        return array;    // 1.先算出最大数的位数；    int max = array[0];    for (int i = 1; i &lt; array.length; i++) &#123;        max = Math.max(max, array[i]);    &#125;    int maxDigit = 0;    while (max != 0) &#123;        max /= 10;        maxDigit++;    &#125;    int mod = 10, div = 1;    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketList = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();    for (int i = 0; i &lt; 10; i++)        bucketList.add(new ArrayList&lt;Integer&gt;());    for (int i = 0; i &lt; maxDigit; i++, mod *= 10, div *= 10) &#123;        for (int j = 0; j &lt; array.length; j++) &#123;            int num = (array[j] % mod) / div;            bucketList.get(num).add(array[j]);        &#125;        int index = 0;        for (int j = 0; j &lt; bucketList.size(); j++) &#123;            for (int k = 0; k &lt; bucketList.get(j).size(); k++)                array[index++] = bucketList.get(j).get(k);            bucketList.get(j).clear();        &#125;    &#125;    return array;&#125;</code></pre><h3 id="算法分析-9"><a href="#算法分析-9" class="headerlink" title="算法分析"></a>算法分析</h3><p>最佳情况：T(n) = O(n * k)<br>最差情况：T(n) = O(n * k)<br>平均情况：T(n) = O(n * k)</p><p>基数排序有两种方法：</p><ul><li>MSD 从高位开始进行排序 </li><li>LSD 从低位开始进行排序 </li></ul><h3 id="基数排序-vs-计数排序-vs-桶排序"><a href="#基数排序-vs-计数排序-vs-桶排序" class="headerlink" title="基数排序 vs 计数排序 vs 桶排序"></a>基数排序 vs 计数排序 vs 桶排序</h3><p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p><ul><li>基数排序：根据键值的每位数字来分配桶</li><li>计数排序：每个桶只存储单一键值</li><li>桶排序：每个桶存储一定范围的数值</li></ul>]]></content>
      
      
      <categories>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 生活技能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 虚拟机面试题</title>
      <link href="/2019-12-11/java-vm-interview/"/>
      <url>/2019-12-11/java-vm-interview/</url>
      
        <content type="html"><![CDATA[<h2 id="Java虚拟机面试题-（⭐⭐⭐）"><a href="#Java虚拟机面试题-（⭐⭐⭐）" class="headerlink" title="Java虚拟机面试题 （⭐⭐⭐）"></a>Java虚拟机面试题 （⭐⭐⭐）</h2><span id="more"></span><h4 id="1、JVM内存区域。"><a href="#1、JVM内存区域。" class="headerlink" title="1、JVM内存区域。"></a>1、JVM内存区域。</h4><p>JVM基本构成<img src="https://user-gold-cdn.xitu.io/2017/11/21/15fdc4cfaf97ca63?imageslim" alt="image"></p><p>从上图可知，JVM主要包括四个部分：</p><p>1.类加载器（ClassLoader）:在JVM启动时或者在类运行将需要的class加载到JVM中。（下图表示了从java源文件到JVM的整个过程，可配合理解。</p><p><img src="https://user-gold-cdn.xitu.io/2017/11/21/15fdc4cfb0e97353?imageslimo" alt="image"></p><p>2.执行引擎：负责执行class文件中包含的字节码指令；</p><p>3.内存区（也叫运行时数据区）：是在JVM运行的时候操作所分配的内存区。运行时内存区主要可以划分为5个区域，如图：</p><p><img src="https://user-gold-cdn.xitu.io/2017/11/21/15fdc4cfaf3c52a9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><p>方法区(MethodArea)：用于存储类结构信息的地方，包括常量池、静态常量、构造函数等。虽然JVM规范把方法区描述为堆的一个辑部分， 但它却有个别名non-heap（非堆），所以大家不要搞混淆了。方法区还包含一个运行时常量池。</p><p>java堆(Heap)：存储java实例或者对象的地方。这块是GC的主要区域。从存储的内容我们可以很容易知道，方法和堆是被所有java线程共享的。</p><p>java栈(Stack)：java栈总是和线程关联在一起，每当创一个线程时，JVM就会为这个线程创建一个对应的java栈在这个java栈中,其中又会包含多个栈帧，每运行一个方法就建一个栈帧，用于存储局部变量表、操作栈、方法返回等。每一个方法从调用直至执行完成的过程，就对应一栈帧在java栈中入栈到出栈的过程。所以java栈是现成有的。</p><p>程序计数器(PCRegister)：用于保存当前线程执行的内存地址。由于JVM程序是多线程执行的（线程轮流切换），所以为了保证程切换回来后，还能恢复到原先状态，就需要一个独立计数器，记录之前中断的地方，可见程序计数器也是线程私有的。</p><p>本地方法栈(Native MethodStack)：和java栈的作用差不多，只不过是为JVM使用到native方法服务的。</p><p>4.本地方法接口：主要是调用C或C++实现的本地方法及回调结果。</p><h5 id="开线程影响哪块内存？"><a href="#开线程影响哪块内存？" class="headerlink" title="开线程影响哪块内存？"></a>开线程影响哪块内存？</h5><p>每当有线程被创建的时候，JVM就需要为其在内存中分配虚拟机栈和本地方法栈来记录调用方法的内容，分配程序计数器记录指令执行的位置，这样的内存消耗就是创建线程的内存代价。</p><h4 id="2、JVM的内存模型的理解？"><a href="#2、JVM的内存模型的理解？" class="headerlink" title="2、JVM的内存模型的理解？"></a>2、JVM的内存模型的理解？</h4><p>Java内存模型即Java Memory Model，简称JMM。JMM定义了Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式。JVM是整个计算机虚拟模型，所以JMM是隶属于JVM的。</p><p>Java线程之间的通信总是隐式进行，并且采用的是共享内存模型。这里提到的共享内存模型指的就是Java内存模型(简称JMM)，JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。</p><p>总之，JMM就是一组规则，这组规则意在解决在并发编程可能出现的线程安全问题，并提供了内置解决方案（happen-before原则）及其外部可使用的同步手段(synchronized/volatile等)，确保了程序执行在多线程环境中的应有的原子性，可视性及其有序性。</p><h5 id="需要更全面理解建议阅读以下文章："><a href="#需要更全面理解建议阅读以下文章：" class="headerlink" title="需要更全面理解建议阅读以下文章："></a>需要更全面理解建议阅读以下文章：</h5><p><a href="https://blog.csdn.net/javazejian/article/details/72772461#%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8Ejava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B">全面理解Java内存模型(JMM)及volatile关键字</a></p><p><a href="https://blog.csdn.net/suifeng3051/article/details/52611310">全面理解Java内存模型</a></p><h4 id="3、描述一下GC的原理和回收策略？"><a href="#3、描述一下GC的原理和回收策略？" class="headerlink" title="3、描述一下GC的原理和回收策略？"></a>3、描述一下GC的原理和回收策略？</h4><p>提到垃圾回收，我们可以先思考一下，如果我们去做垃圾回收需要解决哪些问题？ </p><p>一般说来，我们要解决三个问题：</p><p>1、回收哪些内存？</p><p>2、什么时候回收？</p><p>3、如何回收？</p><p>这些问题分别对应着引用管理和回收策略等方案。</p><p>提到引用，我们都知道Java中有四种引用类型：</p><ul><li>强引用：代码中普遍存在的，只要强引用还存在，垃圾收集器就不会回收掉被引用的对象。</li><li>软引用：SoftReference，用来描述还有用但是非必须的对象，当内存不足的时候会回收这类对象。</li><li>弱引用：WeakReference，用来描述非必须对象，弱引用的对象只能生存到下一次GC发生时，当GC发生时，无论内存是否足够，都会回收该对象。</li><li>虚引用：PhantomReference，一个对象是否有虚引用的存在，完全不会对其生存时间产生影响，也无法通过虚引用取得一个对象的引用，它存在的唯一目的是在这个对象被回收时可以收到一个系统通知。</li></ul><p>不同的引用类型，在做GC时会区别对待，我们平时生成的Java对象，默认都是强引用，也就是说只要强引用还在，GC就不会回收，那么如何判断强引用是否存在呢？</p><p>一个简单的思路就是：引用计数法，有对这个对象的引用就+1，不再引用就-1，但是这种方式看起来简单美好，但它却不能解决循环引用计数的问题。</p><p>因此可达性分析算法登上历史舞台，用它来判断对象的引用是否存在。</p><p>可达性分析算法通过一系列称为GCRoots的对象作为起始点，从这些节点从上向下搜索，所走过的路径称为引用链，当一个对象没有任何引用链与GCRoots连接时就说明此对象不可用，也就是对象不可达。</p><p>GC Roots对象通常包括：</p><ul><li>虚拟机栈中引用的对象（栈帧中的本地变量表）</li><li>方法中类的静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>Native方法引用的对象</li></ul><p>可达性分析算法整个流程如下所示：</p><p>第一次标记：对象在经过可达性分析后发现没有与GC Roots有引用链，则进行第一次标记并进行一次筛选，筛选条件是：该对象是否有必要执行finalize()方法。没有覆盖finalize()方法或者finalize()方法已经被执行过都会被认为没有必要执行。<br>如果有必要执行：则该对象会被放在一个F-Queue队列，并稍后在由虚拟机建立的低优先级Finalizer线程中触发该对象的finalize()方法，但不保证一定等待它执行结束，因为如果这个对象的finalize()方法发生了死循环或者执行时间较长的情况，会阻塞F-Queue队列里的其他对象，影响GC。</p><p>第二次标记：GC对F-Queue队列里的对象进行第二次标记，如果在第二次标记时该对象又成功被引用，则会被移除即将回收的集合，否则会被回收。</p><p>总之，JVM在做垃圾回收的时候，会检查堆中的所有对象否会被这些根集对象引用，不能够被引用的对象就会被圾收集器回收。一般回收算法也有如下几种：</p><p>1).标记-清除（Mark-sweep）</p><p>标记-清除算法采用从根集合进行扫描，对存活的对象进行标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收。标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片。</p><p>2).标记-整理（Mark-Compact）</p><p>标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。该垃圾回收算法适用于对象存活率高的场景（老年代）。</p><p>3).复制（Copying）</p><p>　复制算法将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这种算法适用于对象存活率低的场景，比如新生代。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况。</p><p>4).分代收集算法</p><p>不同的对象的生命周期(存活情况)是不一样的，而不同生命周期的对象位于堆中不同的区域，因此对堆内存不同区域采用不同的策略进行回收可以提高 JVM 的执行效率。当代商用虚拟机使用的都是分代收集算法：新生代对象存活率低，就采用复制算法；老年代存活率高，就用标记清除算法或者标记整理算法。Java堆内存一般可以分为新生代、老年代和永久代三个模块：</p><h5 id="新生代："><a href="#新生代：" class="headerlink" title="新生代："></a>新生代：</h5><p>1.所有新生成的对象首先都是放在新生代的。新生代的目标就是尽可能快速的收集掉那些生命周期短的对象。</p><p>2.新生代内存按照8:1:1的比例分为一个eden区和两个survivor(survivor0,survivor1)区。大部分对象在Eden区中生成。回收时先将eden区存活对象复制到一个survivor0区，然后清空eden区，当这个survivor0区也存放满了时，则将eden区和survivor0区存活对象复制到另一个survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后将survivor0区和survivor1区交换，即保持survivor1区为空， 如此往复。</p><p>3.当survivor1区不足以存放 eden和survivor0的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次Full GC，也就是新生代、老年代都进行回收。</p><p>4.新生代发生的GC也叫做Minor GC，MinorGC发生频率比较高(不一定等Eden区满了才触发)。</p><h5 id="老年代："><a href="#老年代：" class="headerlink" title="老年代："></a>老年代：</h5><p>1.在老年代中经历了N次垃圾回收后仍然存活的对象，就会被放到老年代中。因此，可以认为老年代中存放的都是一些生命周期较长的对象。</p><p>2.内存比新生代也大很多(大概比例是1:2)，当老年代内存满时触发Major GC，即Full GC。Full GC发生频率比较低，老年代对象存活时间比较长。</p><h5 id="永久代："><a href="#永久代：" class="headerlink" title="永久代："></a>永久代：</h5><p>永久代主要存放静态文件，如Java类、方法等。永久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如使用反射、动态代理、CGLib等bytecode框架时，在这种时候需要设置一个比较大的永久代空间来存放这些运行过程中新增的类。</p><h5 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h5><p>垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现：</p><ul><li><p>Serial收集器（复制算法): 新生代单线程收集器，标记和清理都是单线程，优点是简单高效；</p></li><li><p>Serial Old收集器 (标记-整理算法): 老年代单线程收集器，Serial收集器的老年代版本；</p></li><li><p>ParNew收集器 (复制算法): 新生代收并行集器，实际上是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现；</p></li><li><p>CMS(Concurrent Mark Sweep)收集器（标记-清除算法）： 老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间。</p></li><li><p>Parallel Old收集器 (标记-整理算法)： 老年代并行收集器，吞吐量优先，Parallel Scavenge收集器的老年代版本；</p></li><li><p>Parallel Scavenge收集器 (复制算法): 新生代并行收集器，追求高吞吐量，高效利用 CPU。吞吐量 = 用户线程时间/(用户线程时间+GC线程时间)，高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景；</p></li><li><p>G1(Garbage First)收集器 (标记-整理算法)： Java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代。</p></li></ul><h5 id="内存分配和回收策略"><a href="#内存分配和回收策略" class="headerlink" title="内存分配和回收策略"></a>内存分配和回收策略</h5><p>JAVA自动内存管理：给对象分配内存 以及 回收分配给对象的内存。</p><p>1、对象优先在Eden分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次MinorGC。</p><p>2、大对象直接进入老年代。如很长的字符串以及数组。很长的字符串以及数组。</p><p>3、长期存活的对象将进入老年代。当对象在新生代中经历过一定次数（默认为15）的Minor GC后，就会被晋升到老年代中。</p><p>4、动态对象年龄判定。为了更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</p><p><a href="https://blog.csdn.net/justloveyou_/article/details/71216049">需要更全面的理解请点击这里</a></p><h4 id="4、类的加载器，双亲机制，Android的类加载器。"><a href="#4、类的加载器，双亲机制，Android的类加载器。" class="headerlink" title="4、类的加载器，双亲机制，Android的类加载器。"></a>4、类的加载器，双亲机制，Android的类加载器。</h4><h5 id="类的加载器"><a href="#类的加载器" class="headerlink" title="类的加载器"></a>类的加载器</h5><p>大家都知道，一个Java程序都是由若干个.class文件组织而成的一个完整的Java应用程序，当程序在运行时，即会调用该程序的一个入口函数来调用系统的相关功能，而这些功能都被封装在不同的class文件当中，所以经常要从这个class文件中要调用另外一个class文件中的方法，如果另外一个文件不存在的话，则会引发系统异常。</p><p>而程序在启动的时候，并不会一次性加载程序所要用到的class文件，而是根据程序的需要，通过Java的类加载制（ClassLoader）来动态加载某个class文件到内存当的，从而只有class文件被载入到了内存之后，才能被其它class文件所引用。所以ClassLoader就是用来动态加载class件到内存当中用的。</p><h5 id="双亲机制"><a href="#双亲机制" class="headerlink" title="双亲机制"></a>双亲机制</h5><p>类的加载就是虚拟机通过一个类的全限定名来获取描述此类的二进制字节流，而完成这个加载动作的就是类加载器。</p><p>类和类加载器息息相关，判定两个类是否相等，只有在这两个类被同一个类加载器加载的情况下才有意义，否则即便是两个类来自同一个Class文件，被不同类加载器加载，它们也是不相等的。</p><p>注：这里的相等性保函Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果以及Instance关键字对对象所属关系的判定结果等。</p><p>类加载器可以分为三类：</p><ul><li><p>启动类加载器（Bootstrap ClassLoader）：负责加载<JAVA_HOME>\lib目录下或者被-Xbootclasspath参数所指定的路径的，并且是被虚拟机所识别的库到内存中。</p></li><li><p>扩展类加载器（Extension ClassLoader）：负责加载<JAVA_HOME>\lib\ext目录下或者被java.ext.dirs系统变量所指定的路径的所有类库到内存中。</p></li><li><p>应用类加载器（Application ClassLoader）：负责加载用户类路径上的指定类库，如果应用程序中没有实现自己的类加载器，一般就是这个类加载器去加载应用程序中的类库。</p></li></ul><p>1、原理介绍</p><p>ClassLoader使用的是双亲委托模型来搜索类的，每个ClassLoader实例都有一个父类加载器的引用（不是继承的关系，是一个包含的关系），虚拟机内置的类加载器（Bootstrap ClassLoader）本身没有父类加载器，但可以用作其它lassLoader实例的的父类加载器。</p><p>当一个ClassLoader实例需要加载某个类时，它会在试图搜索某个类之前，先把这个任务委托给它的父类加载器，这个过程是由上至下依次检查的，首先由最顶层的类加载器Bootstrap ClassLoader试图加载，如果没加载到，则把任务转交给Extension ClassLoader试图加载，如果也没加载到，则转交给App ClassLoader 进行加载，如果它也没有加载得到的话，则返回给委托的发起者，由它到指定的文件系统或网络等待URL中加载该类。</p><p>如果它们都没有加载到这个类时，则抛出ClassNotFoundException异常。否则将这个找到的类生成一个类的定义，将它加载到内存当中，最后返回这个类在内存中的Class实例对象。</p><p>类加载机制：</p><p>类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法去内，然后在堆区创建一个java.lang.Class对象，用来封装在方法区内的数据结构。类的加载最终是在堆区内的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。</p><p>类加载有三种方式：</p><p>1）命令行启动应用时候由JVM初始化加载</p><p>2）通过Class.forName（）方法动态加载</p><p>3）通过ClassLoader.loadClass（）方法动态加载</p><p>这么多类加载器，那么当类在加载的时候会使用哪个加载器呢？</p><p>这个时候就要提到类加载器的双亲委派模型，流程图如下所示：</p><p><img src="https://github.com/guoxiaoxing/android-open-source-project-analysis/raw/master/art/native/vm/classloader_model_structure.png" alt="image"></p><p>双亲委派模型的整个工作流程非常的简单，如下所示：</p><p>如果一个类加载器收到了加载类的请求，它不会自己立去加载类，它会先去请求父类加载器，每个层次的类加器都是如此。层层传递，直到传递到最高层的类加载器只有当 父类加载器反馈自己无法加载这个类，才会有当子类加载器去加载该类。</p><p>2、为什么要使用双亲委托这种模型呢？</p><p>因为这样可以避免重复加载，当父亲已经加载了该类的时候，就没有必要让子ClassLoader再加载一次。</p><p>考虑到安全因素，我们试想一下，如果不使用这种委托模式，那我们就可以随时使用自定义的String来动态替代java核心api中定义的类型，这样会存在非常大的安全隐患，而双亲委托的方式，就可以避免这种情况，因为String已经在启动时就被引导类加载器（BootstrcpClassLoader）加载，所以用户自定义的ClassLoader永远也无法加载一个自己写的String，除非你改变JDK中ClassLoader搜索类的默认算法。</p><p>3、但是JVM在搜索类的时候，又是如何判定两个class是相同的呢？</p><p>JVM在判定两个class是否相同时，不仅要判断两个类名否相同，而且要判断是否由同一个类加载器实例加载的。</p><p>只有两者同时满足的情况下，JVM才认为这两个class是相同的。就算两个class是同一份class字节码，如果被两个不同的ClassLoader实例所加载，JVM也会认为它们是两个不同class。</p><p>比如网络上的一个Java类org.classloader.simple.NetClassLoaderSimple，javac编译之后生成字节码文件NetClasLoaderSimple.class，ClassLoaderA和ClassLoaderB这个类加载器并读取了NetClassLoaderSimple.class文件并分别定义出了java.lang.Class实例来表示这个类，对JVM来说，它们是两个不同的实例对象，但它们确实是一份字节码文件，如果试图将这个Class实例生成具体的对象进行转换时，就会抛运行时异常java.lang.ClassCastException，提示这是两个不同的类型。</p><h4 id="Android类加载器"><a href="#Android类加载器" class="headerlink" title="Android类加载器"></a>Android类加载器</h4><p>对于Android而言，最终的apk文件包含的是dex类型的文件，dex文件是将class文件重新打包，打包的规则又不是简单地压缩，而是完全对class文件内部的各种函数表进行优化，产生一个新的文件，即dex文件。因此加载某种特殊的Class文件就需要特殊的类加载器DexClassLoader。</p><p>可以动态加载Jar通过URLClassLoader</p><p>1.ClassLoader 隔离问题：JVM识别一个类是由 ClassLoaderid + PackageName + ClassName。</p><p>2.加载不同Jar包中的公共类：</p><ul><li>让父ClassLoader加载公共的Jar，子ClassLoade加载包含公共Jar的Jar，此时子ClassLoader在加载Jar的时候会先去父ClassLoader中找。(只适用Java)</li><li>重写加载包含公共Jar的Jar的ClassLoader，在loClass中找到已经加载过公共Jar的ClassLoader，是把父ClassLoader替换掉。(只适用Java)</li><li>在生成包含公共Jar的Jar时候把公共Jar去掉。</li></ul><h4 id="5、JVM跟Art、Dalvik对比？"><a href="#5、JVM跟Art、Dalvik对比？" class="headerlink" title="5、JVM跟Art、Dalvik对比？"></a>5、<a href="https://www.jianshu.com/p/58f817d176b7">JVM跟Art、Dalvik对比</a>？</h4><p>　　</p><h4 id="6、GC收集器简介？以及它的内存划分怎么样的？"><a href="#6、GC收集器简介？以及它的内存划分怎么样的？" class="headerlink" title="6、GC收集器简介？以及它的内存划分怎么样的？"></a>6、GC收集器简介？以及它的内存划分怎么样的？</h4><p>（1）简介：</p><p>Garbage-First（G1，垃圾优先）收集器是服务类型的收集器，目标是多处理器机器、大内存机器。它高度符合垃圾收集暂停时间的目标，同时实现高吞吐量。Oracle JDK 7 update 4 以及更新发布版完全支持G1垃圾收集器</p><p>（2）G1的内存划分方式：</p><p>它是将堆内存被划分为多个大小相等的 heap 区,每个heap区都是逻辑上连续的一段内存(virtual memory). 其中一部分区域被当成老一代收集器相同的角色(eden, survivor, old), 但每个角色的区域个数都不是固定的。这在内存使用上提供了更多的灵活性</p><h4 id="7、Java的虚拟机JVM的两个内存：栈内存和堆内存的区别是什么？"><a href="#7、Java的虚拟机JVM的两个内存：栈内存和堆内存的区别是什么？" class="headerlink" title="7、Java的虚拟机JVM的两个内存：栈内存和堆内存的区别是什么？"></a>7、Java的虚拟机JVM的两个内存：栈内存和堆内存的区别是什么？</h4><p>Java把内存划分成两种：一种是栈内存，一种是堆内存。两者的区别是：</p><p>1）栈内存：在函数中定义的一些基本类型的变量和对象的引用变量都在函数的栈内存中分配。 当在一段代码块定义一个变量时，Java就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。</p><p>2）堆内存：堆内存用来存放由new创建的对象和数组。在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。</p><h4 id="8、JVM调优的常见命令行工具有哪些？JVM常见的调优参数有哪些？"><a href="#8、JVM调优的常见命令行工具有哪些？JVM常见的调优参数有哪些？" class="headerlink" title="8、JVM调优的常见命令行工具有哪些？JVM常见的调优参数有哪些？"></a>8、JVM调优的常见命令行工具有哪些？JVM常见的调优参数有哪些？</h4><p>（1）JVM调优的常见命令工具包括：</p><p>1）jps命令用于查询正在运行的JVM进程，</p><p>2）jstat可以实时显示本地或远程JVM进程中类装载、内存、垃圾收集、JIT编译等数据</p><p>3）jinfo用于查询当前运行这的JVM属性和参数的值。</p><p>4）jmap用于显示当前Java堆和永久代的详细信息</p><p>5）jhat用于分析使用jmap生成的dump文件，是JDK自带的工具</p><p>6）jstack用于生成当前JVM的所有线程快照，线程快照是虚拟机每一条线程正在执行的方法,目的是定位线程出现长时间停顿的原因。</p><p>（2）JVM常见的调优参数包括：</p><p>-Xmx</p><p>　　指定java程序的最大堆内存, 使用java -Xmx5000M -version判断当前系统能分配的最大堆内存</p><p>-Xms</p><p>　　指定最小堆内存, 通常设置成跟最大堆内存一样，减少GC</p><p>-Xmn</p><p>　　设置年轻代大小。整个堆大小=年轻代大小 + 年老代大小。所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。</p><p>-Xss</p><p>　　指定线程的最大栈空间, 此参数决定了java函数调用的深度, 值越大调用深度越深, 若值太小则容易出栈溢出错误(StackOverflowError)</p><p>-XX:PermSize</p><p>　　指定方法区(永久区)的初始值,默认是物理内存的1/64， 在Java8永久区移除, 代之的是元数据区， 由-XX:MetaspaceSize指定</p><p>-XX:MaxPermSize</p><p>　　指定方法区的最大值, 默认是物理内存的1/4， 在java8中由-XX:MaxMetaspaceSize指定元数据区的大小</p><p>-XX:NewRatio=n</p><p>　　年老代与年轻代的比值，-XX:NewRatio=2, 表示年老代与年轻代的比值为2:1</p><p>-XX:SurvivorRatio=n</p><p>　　Eden区与Survivor区的大小比值，-XX:SurvivorRatio=8表示Eden区与Survivor区的大小比值是8:1:1，因为Survivor区有两个(from, to)</p><h4 id="9、jstack-jmap-jutil分别的意义？如何线上排查JVM的相关问题？"><a href="#9、jstack-jmap-jutil分别的意义？如何线上排查JVM的相关问题？" class="headerlink" title="9、jstack,jmap,jutil分别的意义？如何线上排查JVM的相关问题？"></a>9、jstack,jmap,jutil分别的意义？如何线上排查JVM的相关问题？</h4><h4 id="10、JVM方法区存储内容-是否会动态扩展-是否会出现内存溢出-出现的原因有哪些。"><a href="#10、JVM方法区存储内容-是否会动态扩展-是否会出现内存溢出-出现的原因有哪些。" class="headerlink" title="10、JVM方法区存储内容 是否会动态扩展 是否会出现内存溢出 出现的原因有哪些。"></a>10、JVM方法区存储内容 是否会动态扩展 是否会出现内存溢出 出现的原因有哪些。</h4><h4 id="11、如何解决同时存在的对象创建和对象回收问题？"><a href="#11、如何解决同时存在的对象创建和对象回收问题？" class="headerlink" title="11、如何解决同时存在的对象创建和对象回收问题？"></a>11、如何解决同时存在的对象创建和对象回收问题？</h4><h4 id="12、JVM中最大堆大小有没有限制？"><a href="#12、JVM中最大堆大小有没有限制？" class="headerlink" title="12、JVM中最大堆大小有没有限制？"></a>12、JVM中最大堆大小有没有限制？</h4><h4 id="13、JVM方法区存储内容-是否会动态扩展-是否会出现内存溢出-出现的原因有哪些。"><a href="#13、JVM方法区存储内容-是否会动态扩展-是否会出现内存溢出-出现的原因有哪些。" class="headerlink" title="13、JVM方法区存储内容 是否会动态扩展 是否会出现内存溢出 出现的原因有哪些。"></a>13、JVM方法区存储内容 是否会动态扩展 是否会出现内存溢出 出现的原因有哪些。</h4><h4 id="14、如何理解Java的虚函数表？"><a href="#14、如何理解Java的虚函数表？" class="headerlink" title="14、如何理解Java的虚函数表？"></a>14、如何理解Java的虚函数表？</h4><h4 id="15、Java运行时数据区域，导致内存溢出的原因。"><a href="#15、Java运行时数据区域，导致内存溢出的原因。" class="headerlink" title="15、Java运行时数据区域，导致内存溢出的原因。"></a>15、Java运行时数据区域，导致内存溢出的原因。</h4><h4 id="16、对象创建、内存布局，访问定位等。"><a href="#16、对象创建、内存布局，访问定位等。" class="headerlink" title="16、对象创建、内存布局，访问定位等。"></a>16、对象创建、内存布局，访问定位等。</h4>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 职场 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统面试题</title>
      <link href="/2019-12-08/job-interview-os/"/>
      <url>/2019-12-08/job-interview-os/</url>
      
        <content type="html"><![CDATA[<p>集合了一些操作系统方面的面试题。</p><span id="more"></span><h2 id="操作系统面试题-（⭐⭐⭐）"><a href="#操作系统面试题-（⭐⭐⭐）" class="headerlink" title="操作系统面试题 （⭐⭐⭐）"></a>操作系统面试题 （⭐⭐⭐）</h2><h2 id="1、操作系统如何管理内存的？"><a href="#1、操作系统如何管理内存的？" class="headerlink" title="1、操作系统如何管理内存的？"></a>1、<a href="https://blog.csdn.net/hguisu/article/details/5713164">操作系统如何管理内存的？</a></h2><h2 id="2、进程调度"><a href="#2、进程调度" class="headerlink" title="2、进程调度"></a>2、<a href="https://www.cnblogs.com/wawlian/archive/2012/02/17/2356398.html">进程调度</a></h2><h2 id="3、说下Linux进程和线程的区别"><a href="#3、说下Linux进程和线程的区别" class="headerlink" title="3、说下Linux进程和线程的区别"></a>3、<a href="https://my.oschina.net/cnyinlinux/blog/422207">说下Linux进程和线程的区别</a></h2><p>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。<strong>进程有独立的地址空间</strong>，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。<strong>线程有自己的堆栈和局部变量</strong>，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</p><ol><li><p>简而言之，<strong>一个程序至少有一个进程，一个进程至少有一个线程</strong>。</p></li><li><p>线程的划分尺度小于进程，使得多线程程序的并发性高。</p></li><li><p>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</p></li><li><p>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</p></li><li><p>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配，这就是进程和线程的重要区别。</p></li></ol><h2 id="4、你能解释一下Linux的软链接和硬链接吗？"><a href="#4、你能解释一下Linux的软链接和硬链接吗？" class="headerlink" title="4、你能解释一下Linux的软链接和硬链接吗？"></a>4、你能解释一下Linux的软链接和硬链接吗？</h2><p>Linux链接分两种，一种被称为硬链接（Hard Link），另一种被称为符号链接（Symbolic Link）。默认情况下，ln命令产生硬链接。</p><h3 id="硬连接"><a href="#硬连接" class="headerlink" title="硬连接"></a>硬连接</h3><p>硬连接指通过索引节点来进行连接。在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在Linux中，多个文件名指向同一索引节点是存在的。一般这种连接就是硬连接。硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。</p><h3 id="软连接"><a href="#软连接" class="headerlink" title="软连接"></a>软连接</h3><p>另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于Windows的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。</p><h2 id="5、安卓权限管理，为何在清单中注册权限，安卓APP就可以使用，反之不可以？"><a href="#5、安卓权限管理，为何在清单中注册权限，安卓APP就可以使用，反之不可以？" class="headerlink" title="5、安卓权限管理，为何在清单中注册权限，安卓APP就可以使用，反之不可以？"></a>5、安卓权限管理，为何在清单中注册权限，安卓APP就可以使用，反之不可以？</h2><p>此题考查 Android 的权限管理在 Android 的安全架构中的作用。</p><p>Android 是一个权限分隔的操作系统，其中每个应用都有其独特的系统标识（Linux 用户 ID 和组 ID）。系统各部分也分隔为不同的标识。Linux 据此将不同的应用以及应用与系统分隔开来。</p><p>其他更详细的安全功能通过『权限』机制提供，此机制会限制特定进程可以执行的具体操作，并且根据 URI 权限授权临时访问特定的数据段。</p><p>Android 安全架构的中心设计点是：在默认情况下任何应用都没有权限执行对其他应用、操作系统或用户有不利影响的任何操作。这包括读取或写入用户的私有数据（例如联系人或电子邮件）、读取或写入其他应用程序的文件、执行网络访问、使设备保持唤醒状态等。</p><p>由于每个 Android 应用都是在进程沙盒中运行，因此应用必须显式共享资源和数据。它们的方法是声明需要哪些权限来获取基本沙盒未提供的额外功能。应用以静态方式声明它们需要的权限，然后 Android 系统提示用户同意。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库面试题</title>
      <link href="/2019-12-07/job-interview-db/"/>
      <url>/2019-12-07/job-interview-db/</url>
      
        <content type="html"><![CDATA[<p>集合了一些数据库系统方面的面试题。</p><span id="more"></span><h2 id="数据库面试题-（⭐）"><a href="#数据库面试题-（⭐）" class="headerlink" title="数据库面试题 （⭐）"></a>数据库面试题 （⭐）</h2><h3 id="1、事务的四大特征，数据库的隔离级别？"><a href="#1、事务的四大特征，数据库的隔离级别？" class="headerlink" title="1、事务的四大特征，数据库的隔离级别？"></a>1、事务的四大特征，数据库的隔离级别？</h3><p>事务（Transaction）是并发控制的基本单位。所谓的事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。例如，银行转账工作：从一个账号扣款并使另一个账号增款，这两个操作要么都执行，要么都不执行。所以，应该把它们看成一个事务。事务是数据库维护数据一致性的单位，在每个事务结束时，都能保持数据一致性。事务具有以下4个基本特征：</p><h4 id="事务的四大特征："><a href="#事务的四大特征：" class="headerlink" title="事务的四大特征："></a>事务的四大特征：</h4><ol><li><strong>原子性（Atomicity）。</strong> 原子性是指事务包含的所有操作<strong>要么全部成功，要么全部失败回滚</strong>。</li><li><strong>一致性（Consistency）。</strong> 一个事务<strong>执行之前和执行之后都必须处于一致性状态</strong>。</li><li><strong>隔离性（Isolation）。</strong> 隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，<strong>多个并发事务之间要相互隔离</strong>。</li><li><strong>持久性（Durability）。</strong> 持久性是指一个事务一旦被提交了，那么<strong>对数据库中的数据的改变就是永久性</strong>的。</li></ol><h4 id="数据库的隔离级别："><a href="#数据库的隔离级别：" class="headerlink" title="数据库的隔离级别："></a>数据库的隔离级别：</h4><ol><li>Serializable(串行化)：可避免脏读、不可重复读、幻读的发生。</li><li>Repeatable read (可重复读)：可避免脏读、不可重复读的发生。</li><li>Read committed (读已提交)：可避免脏读的发生。</li><li>Read uncommitted (读未提交)：最低级别，任何情况都无法保证。</li></ol><h3 id="2、数据库设计中常讲的三范式是指什么？"><a href="#2、数据库设计中常讲的三范式是指什么？" class="headerlink" title="2、数据库设计中常讲的三范式是指什么？"></a>2、数据库设计中常讲的三范式是指什么？</h3><ol><li>第一范式1NF（域的原子性)。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。</li><li>第二范式2NF(表中除主键外的字段都完全依赖主键)。第二范式是在第一范式基础上建立的。第二范式有两个重点:(1)表中必须有主键；(2)其他非主属性必须完全依赖主键，不能只依赖主键的一部分（主要针对联合主键而言）。</li><li>第三范式3NF（表中除主键外的字段都完全直接依赖，不能是传递依赖）。</li></ol><p>不能是传递依赖，即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。第二范式和第三范式区分的关键点：2NF：非主键列是否完全依赖于主键，还是依赖于主键的一部分；3NF：非主键列是直接依赖于主键，还是直接依赖于非主键列。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java 并发面试题</title>
      <link href="/2019-12-05/java-threading-interview/"/>
      <url>/2019-12-05/java-threading-interview/</url>
      
        <content type="html"><![CDATA[<h2 id="Java并发面试题"><a href="#Java并发面试题" class="headerlink" title="Java并发面试题"></a>Java并发面试题</h2><span id="more"></span><h3 id="一、线程池相关-（⭐⭐⭐）"><a href="#一、线程池相关-（⭐⭐⭐）" class="headerlink" title="一、线程池相关 （⭐⭐⭐）"></a>一、线程池相关 （⭐⭐⭐）</h3><h4 id="1、什么是线程池，如何使用？为什么要使用线程池？"><a href="#1、什么是线程池，如何使用？为什么要使用线程池？" class="headerlink" title="1、什么是线程池，如何使用？为什么要使用线程池？"></a>1、什么是线程池，如何使用？为什么要使用线程池？</h4><p>答：线程池就是事先将多个线程对象放到一个容器中，使用的时候就不用new线程而是直接去池中拿线程即可，节<br>省了开辟子线程的时间，提高了代码执行效率。</p><h4 id="2、Java中的线程池共有几种？"><a href="#2、Java中的线程池共有几种？" class="headerlink" title="2、Java中的线程池共有几种？"></a>2、Java中的线程池共有几种？</h4><p>Java有四种线程池：</p><p>第一种：newCachedThreadPool</p><p>不固定线程数量，且支持最大为Integer.MAX_VALUE的线程数量:</p><pre><code>public static ExecutorService newCachedThreadPool() &#123;    // 这个线程池corePoolSize为0，maximumPoolSize为Integer.MAX_VALUE    // 意思也就是说来一个任务就创建一个woker，回收时间是60s    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,                                60L, TimeUnit.SECONDS,                                new SynchronousQueue&lt;Runnable&gt;());&#125;</code></pre><p>可缓存线程池：</p><p>1、线程数无限制。<br>2、有空闲线程则复用空闲线程，若无空闲线程则新建线程。<br>3、一定程序减少频繁创建/销毁线程，减少系统开销。</p><p>第二种：newFixedThreadPool</p><p>一个固定线程数量的线程池:</p><pre><code>public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) &#123;    // corePoolSize跟maximumPoolSize值一样，同时传入一个无界阻塞队列    // 该线程池的线程会维持在指定线程数，不会进行回收    return new ThreadPoolExecutor(nThreads, nThreads,                                0L, TimeUnit.MILLISECONDS,                                new LinkedBlockingQueue&lt;Runnable&gt;(),                                threadFactory);&#125;</code></pre><p>定长线程池：</p><p>1、可控制线程最大并发数（同时执行的线程数）。<br>2、超出的线程会在队列中等待。</p><p>第三种：newSingleThreadExecutor</p><p>可以理解为线程数量为1的FixedThreadPool:</p><pre><code>public static ExecutorService newSingleThreadExecutor() &#123;    // 线程池中只有一个线程进行任务执行，其他的都放入阻塞队列    // 外面包装的FinalizableDelegatedExecutorService类实现了finalize方法，在JVM垃圾回收的时候会关闭线程池    return new FinalizableDelegatedExecutorService        (new ThreadPoolExecutor(1, 1,                                0L, TimeUnit.MILLISECONDS,                                new LinkedBlockingQueue&lt;Runnable&gt;()));&#125;</code></pre><p>单线程化的线程池：</p><p>1、有且仅有一个工作线程执行任务。<br>2、所有任务按照指定顺序执行，即遵循队列的入队出队规则。</p><p>第四种：newScheduledThreadPool。</p><p>支持定时以指定周期循环执行任务:</p><pre><code>public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123;    return new ScheduledThreadPoolExecutor(corePoolSize);&#125;</code></pre><p>注意：前三种线程池是ThreadPoolExecutor不同配置的实例，最后一种是ScheduledThreadPoolExecutor的实例。</p><h4 id="3、线程池原理？"><a href="#3、线程池原理？" class="headerlink" title="3、线程池原理？"></a>3、<a href="https://itimetraveler.github.io/2018/02/13/%E3%80%90Java%E3%80%91%E7%BA%BF%E7%A8%8B%E6%B1%A0ThreadPoolExecutor%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">线程池原理？</a></h4><p>从数据结构的角度来看，线程池主要使用了阻塞队列（BlockingQueue）和HashSet集合构成。<br>从任务提交的流程角度来看，对于使用线程池的外部来说，线程池的机制是这样的：</p><pre><code>1、如果正在运行的线程数 &lt; coreSize，马上创建核心线程执行该task，不排队等待；2、如果正在运行的线程数 &gt;= coreSize，把该task放入阻塞队列；3、如果队列已满 &amp;&amp; 正在运行的线程数 &lt; maximumPoolSize，创建新的非核心线程执行该task；4、如果队列已满 &amp;&amp; 正在运行的线程数 &gt;= maximumPoolSize，线程池调用handler的reject方法拒绝本次提交。</code></pre><p>理解记忆：1-2-3-4对应（核心线程-&gt;阻塞队列-&gt;非核心线程-&gt;handler拒绝提交）。</p><h5 id="线程池的线程复用："><a href="#线程池的线程复用：" class="headerlink" title="线程池的线程复用："></a>线程池的线程复用：</h5><p>这里就需要深入到源码addWorker()：它是创建新线程的关键，也是线程复用的关键入口。最终会执行到runWoker，它取任务有两个方式： </p><ul><li>firstTask：这是指定的第一个runnable可执行任务，它会在Woker这个工作线程中运行执行任务run。并且置空表示这个任务已经被执行。 </li><li>getTask()：这首先是一个死循环过程，工作线程循环直到能够取出Runnable对象或超时返回，这里的取的目标就是任务队列workQueue，对应刚才入队的操作，有入有出。</li></ul><p>其实就是任务在并不只执行创建时指定的firstTask第一任务，还会从任务队列的中通过getTask()方法自己主动去取任务执行，而且是有/无时间限定的阻塞等待，保证线程的存活。</p><h5 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h5><p>semaphore 可用于进程间同步也可用于同一个进程间的线程同步。</p><p>可以用来保证两个或多个关键代码段不被并发调用。在进入一个关键代码段之前，线程必须获取一个信号量；一旦该关键代码段完成了，那么该线程必须释放信号量。其它想进入该关键代码段的线程必须等待直到第一个线程释放信号量。</p><h4 id="4、线程池都有哪几种工作队列？"><a href="#4、线程池都有哪几种工作队列？" class="headerlink" title="4、线程池都有哪几种工作队列？"></a>4、线程池都有哪几种工作队列？</h4><p>1、ArrayBlockingQueue</p><p>是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。</p><p>2、LinkedBlockingQueue</p><p>一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()和Executors.newSingleThreadExecutor使用了这个队列。</p><p>3、SynchronousQueue</p><p>一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。</p><p>4、PriorityBlockingQueue</p><p>一个具有优先级的无限阻塞队列。</p><h4 id="5、怎么理解无界队列和有界队列？"><a href="#5、怎么理解无界队列和有界队列？" class="headerlink" title="5、怎么理解无界队列和有界队列？"></a>5、怎么理解无界队列和有界队列？</h4><h5 id="有界队列"><a href="#有界队列" class="headerlink" title="有界队列"></a>有界队列</h5><p>1.初始的poolSize &lt; corePoolSize，提交的runnable任务，会直接做为new一个Thread的参数，立马执行 。<br>2.当提交的任务数超过了corePoolSize，会将当前的runable提交到一个block queue中。<br>3.有界队列满了之后，如果poolSize &lt; maximumPoolsize时，会尝试new 一个Thread的进行救急处理，立马执行对应的runnable任务。<br>4.如果3中也无法处理了，就会走到第四步执行reject操作。</p><h5 id="无界队列"><a href="#无界队列" class="headerlink" title="无界队列"></a>无界队列</h5><p>与有界队列相比，除非系统资源耗尽，否则无界的任务队列不存在任务入队失败的情况。当有新的任务到来，系统的线程数小于corePoolSize时，则新建线程执行任务。当达到corePoolSize后，就不会继续增加，若后续仍有新的任务加入，而没有空闲的线程资源，则任务直接进入队列等待。若任务创建和处理的速度差异很大，无界队列会保持快速增长，直到耗尽系统内存。<br>当线程池的任务缓存队列已满并且线程池中的线程数目达到maximumPoolSize，如果还有任务到来就会采取任务拒绝策略。</p><h4 id="6、多线程中的安全队列一般通过什么实现？"><a href="#6、多线程中的安全队列一般通过什么实现？" class="headerlink" title="6、多线程中的安全队列一般通过什么实现？"></a>6、<a href="https://blog.csdn.net/bieleyang/article/details/78027032">多线程中的安全队列一般通过什么实现？</a></h4><p>Java提供的线程安全的Queue可以分为阻塞队列和非阻塞队列，其中阻塞队列的典型例子是BlockingQueue，非阻塞队列的典型例子是ConcurrentLinkedQueue.</p><p>对于BlockingQueue，想要实现阻塞功能，需要调用put(e) take() 方法。而ConcurrentLinkedQueue是基于链接节点的、无界的、线程安全的非阻塞队列。</p><h3 id="二、Synchronized、volatile、Lock-ReentrantLock-相关-（⭐⭐⭐）"><a href="#二、Synchronized、volatile、Lock-ReentrantLock-相关-（⭐⭐⭐）" class="headerlink" title="二、Synchronized、volatile、Lock(ReentrantLock)相关 （⭐⭐⭐）"></a>二、Synchronized、volatile、Lock(ReentrantLock)相关 （⭐⭐⭐）</h3><h4 id="1、synchronized的原理？"><a href="#1、synchronized的原理？" class="headerlink" title="1、synchronized的原理？"></a>1、synchronized的原理？</h4><p>synchronized 代码块是由一对儿 monitorenter/monitorexit 指令实现的，Monitor 对象是同步的基本实现，而 synchronized 同步方法使用了ACC_SYNCHRONIZED访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p><p>在 Java 6 之前，Monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作。</p><p>现代的（Oracle）JDK 中，JVM 对此进行了大刀阔斧地改进，提供了三种不同的 Monitor 实现，也就是常说的三种不同的锁：偏斜锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能。</p><p>所谓锁的升级、降级，就是 JVM 优化 synchronized 运行的机制，当 JVM 检测到不同的竞争状况时，会自动切换到适合的锁实现，这种切换就是锁的升级、降级。</p><p>当没有竞争出现时，默认会使用偏斜锁。JVM 会利用 CAS 操作，在对象头上的 Mark Word 部分设置线程 ID，以表示这个对象偏向于当前线程，所以并不涉及真正的互斥锁。这样做的假设是基于在很多应用场景中，大部分对象生命周期中最多会被一个线程锁定，使用偏斜锁可以降低无竞争开销。</p><p>如果有另外的线程试图锁定某个已经被偏斜过的对象，JVM 就需要撤销（revoke）偏斜锁，并切换到轻量级锁实现。轻量级锁依赖 CAS 操作 Mark Word 来试图获取锁，如果重试成功，就使用普通的轻量级锁；否则，进一步升级为重量级锁（可能会先进行自旋锁升级，如果失败再尝试重量级锁升级）。</p><p>我注意到有的观点认为 Java 不会进行锁降级。实际上据我所知，锁降级确实是会发生的，当 JVM 进入安全点（SafePoint）的时候，会检查是否有闲置的 Monitor，然后试图进行降级。</p><h4 id="2、Synchronized优化后的锁机制简单介绍一下，包括自旋锁、偏向锁、轻量级锁、重量级锁？"><a href="#2、Synchronized优化后的锁机制简单介绍一下，包括自旋锁、偏向锁、轻量级锁、重量级锁？" class="headerlink" title="2、Synchronized优化后的锁机制简单介绍一下，包括自旋锁、偏向锁、轻量级锁、重量级锁？"></a>2、Synchronized优化后的锁机制简单介绍一下，包括自旋锁、偏向锁、轻量级锁、重量级锁？</h4><p>自旋锁：</p><p>线程自旋说白了就是让cpu在做无用功，比如：可以执行几次for循环，可以执行几条空的汇编指令，目的是占着CPU不放，等待获取锁的机会。如果旋的时间过长会影响整体性能，时间过短又达不到延迟阻塞的目的。</p><p>偏向锁</p><p>偏向锁就是一旦线程第一次获得了监视对象，之后让监视对象“偏向”这个线程，之后的多次调用则可以避免CAS操作，说白了就是置个变量，如果发现为true则无需再走各种加锁/解锁流程。</p><p>轻量级锁：</p><p>轻量级锁是由偏向所升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁竞争用的时候，偏向锁就会升级为轻量级锁；</p><p>重量级锁</p><p>重量锁在JVM中又叫对象监视器（Monitor），它很像C中的Mutex，除了具备Mutex(0|1)互斥的功能，它还负责实现了Semaphore(信号量)的功能，也就是说它至少包含一个竞争锁的队列，和一个信号阻塞队列（wait队列），前者负责做互斥，后一个用于做线程同步。</p><h4 id="3、谈谈对Synchronized关键字涉及到的类锁，方法锁，重入锁的理解？"><a href="#3、谈谈对Synchronized关键字涉及到的类锁，方法锁，重入锁的理解？" class="headerlink" title="3、谈谈对Synchronized关键字涉及到的类锁，方法锁，重入锁的理解？"></a>3、谈谈对Synchronized关键字涉及到的类锁，方法锁，重入锁的理解？</h4><p>synchronized修饰静态方法获取的是类锁(类的字节码文件对象)。</p><p>synchronized修饰普通方法或代码块获取的是对象锁。这种机制确保了同一时刻对于每一个类实例，其所有声明为 synchronized 的成员函数中至多只有一个处于可执行状态，从而有效避免了类成员变量的访问冲突。</p><p>它俩是不冲突的，也就是说：获取了类锁的线程和获取了对象锁的线程是不冲突的！</p><pre><code>public class Widget &#123;    // 锁住了    public synchronized void doSomething() &#123;        ...    &#125;&#125;public class LoggingWidget extends Widget &#123;    // 锁住了    public synchronized void doSomething() &#123;        System.out.println(toString() + &quot;: calling doSomething&quot;);        super.doSomething();    &#125;&#125;</code></pre><p>因为锁的持有者是“线程”，而不是“调用”。</p><p>线程A已经是有了LoggingWidget实例对象的锁了，当再需要的时候可以继续<strong>“开锁”</strong>进去的！</p><p>这就是内置锁的可重入性。</p><h4 id="4、wait、sleep的区别和notify运行过程。"><a href="#4、wait、sleep的区别和notify运行过程。" class="headerlink" title="4、wait、sleep的区别和notify运行过程。"></a>4、wait、sleep的区别和notify运行过程。</h4><h5 id="wait、sleep的区别"><a href="#wait、sleep的区别" class="headerlink" title="wait、sleep的区别"></a>wait、sleep的区别</h5><p>最大的不同是在等待时 wait 会释放锁，而 sleep 一直持有锁。wait 通常被用于线程间交互，sleep 通常被用于暂停执行。    </p><ul><li>首先，要记住这个差别，“sleep是Thread类的方法,wait是Object类中定义的方法”。尽管这两个方法都会影响线程的执行行为，但是本质上是有区别的。</li><li>Thread.sleep不会导致锁行为的改变，如果当前线程是拥有锁的，那么Thread.sleep不会让线程释放锁。如果能够帮助你记忆的话，可以简单认为和锁相关的方法都定义在Object类中，因此调用Thread.sleep是不会影响锁的相关行为。</li><li>Thread.sleep和Object.wait都会暂停当前的线程，对于CPU资源来说，不管是哪种方式暂停的线程，都表示它暂时不再需要CPU的执行时间。OS会将执行时间分配给其它线程。区别是，调用wait后，需要别的线程执行notify/notifyAll才能够重新获得CPU执行时间。</li><li>线程的状态参考 Thread.State的定义。新创建的但是没有执行（还没有调用start())的线程处于“就绪”，或者说Thread.State.NEW状态。</li><li>Thread.State.BLOCKED（阻塞）表示线程正在获取锁时，因为锁不能获取到而被迫暂停执行下面的指令，一直等到这个锁被别的线程释放。BLOCKED状态下线程，OS调度机制需要决定下一个能够获取锁的线程是哪个，这种情况下，就是产生锁的争用，无论如何这都是很耗时的操作。</li></ul><h5 id="notify运行过程"><a href="#notify运行过程" class="headerlink" title="notify运行过程"></a>notify运行过程</h5><p>当线程A（消费者）调用wait()方法后，线程A让出锁，自己进入等待状态，同时加入锁对象的等待队列。<br>线程B（生产者）获取锁后，调用notify方法通知锁对象的等待队列，使得线程A从等待队列进入阻塞队列。<br>线程A进入阻塞队列后，直至线程B释放锁后，线程A竞争得到锁继续从wait()方法后执行。</p><h4 id="5、synchronized关键字和Lock的区别你知道吗？为什么Lock的性能好一些？"><a href="#5、synchronized关键字和Lock的区别你知道吗？为什么Lock的性能好一些？" class="headerlink" title="5、synchronized关键字和Lock的区别你知道吗？为什么Lock的性能好一些？"></a>5、synchronized关键字和Lock的区别你知道吗？为什么Lock的性能好一些？</h4><table><thead><tr><th>类别</th><th>synchronized</th><th>Lock（底层实现主要是Volatile + CAS）</th></tr></thead><tbody><tr><td>存在层次</td><td>Java的关键字，在jvm层面上</td><td>是一个类</td></tr><tr><td>锁的释放</td><td>1、已获取锁的线程执行完同步代码，释放锁          2、线程执行发生异常，jvm会让线程释放锁。</td><td>在finally中必须释放锁，不然容易造成线程死锁。</td></tr><tr><td>锁的获取</td><td>假设A线程获得锁，B线程等待。如果A线程阻塞，B线程会一直等待。</td><td>分情况而定，Lock有多个锁获取的方式，大致就是可以尝试获得锁，线程可以不用一直等待</td></tr><tr><td>锁状态</td><td>无法判断</td><td>可以判断</td></tr><tr><td>锁类型</td><td>可重入 不可中断 非公平</td><td>可重入 可判断 可公平（两者皆可）</td></tr><tr><td>性能</td><td>少量同步</td><td>大量同步</td></tr><tr><td></td><td></td><td></td></tr><tr><td>Lock（ReentrantLock）的底层实现主要是Volatile + CAS（乐观锁），而Synchronized是一种悲观锁，比较耗性能。但是在JDK1.6以后对Synchronized的锁机制进行了优化，加入了偏向锁、轻量级锁、自旋锁、重量级锁，在并发量不大的情况下，性能可能优于Lock机制。所以建议一般请求并发量不大的情况下使用synchronized关键字。</td><td></td><td></td></tr></tbody></table><h4 id="6、volatile原理。"><a href="#6、volatile原理。" class="headerlink" title="6、volatile原理。"></a>6、volatile原理。</h4><p>在《Java并发编程：核心理论》一文中，我们已经提到可见性、有序性及原子性问题，通常情况下我们可以通过Synchronized关键字来解决这些个问题，不过如果对Synchonized原理有了解的话，应该知道Synchronized是一个较重量级的操作，对系统的性能有比较大的影响，所以如果有其他解决方案，我们通常都避免使用Synchronized来解决问题。</p><p>而volatile关键字就是Java中提供的另一种解决可见性有序性问题的方案。对于原子性，需要强调一点，也是大家容易误解的一点：对volatile变量的单次读/写操作可保证原子性的，如long和double类型变量，但是并不能保证i++这种操作的原子性，因为本质上i++是读、写两次操作。</p><p>volatile也是互斥同步的一种实现，不过它非常的轻量级。</p><h5 id="volatile-的意义？"><a href="#volatile-的意义？" class="headerlink" title="volatile 的意义？"></a>volatile 的意义？</h5><ul><li>防止CPU指令重排序</li></ul><p>volatile有两条关键的语义：</p><p>保证被volatile修饰的变量对所有线程都是可见的</p><p>禁止进行指令重排序</p><p>要理解volatile关键字，我们得先从Java的线程模型开始说起。如图所示：</p><p><img src="https://github.com/guoxiaoxing/android-open-source-project-analysis/raw/master/art/native/process/java_memory_model.png" alt="image"></p><p>Java内存模型规定了所有字段（这些字段包括实例字段、静态字段等，不包括局部变量、方法参数等，因为这些是线程私有的，并不存在竞争）都存在主内存中，每个线程会 有自己的工作内存，工作内存里保存了线程所使用到的变量在主内存里的副本拷贝，线程对变量的操作只能在工作内存里进行，而不能直接读写主内存，当然不同内存之间也 无法直接访问对方的工作内存，也就是说主内存是线程传值的媒介。</p><p>我们来理解第一句话：</p><pre><code>保证被volatile修饰的变量对所有线程都是可见的</code></pre><p>如何保证可见性？</p><p>被volatile修饰的变量在工作内存修改后会被强制写回主内存，其他线程在使用时也会强制从主内存刷新，这样就保证了一致性。</p><p>关于“保证被volatile修饰的变量对所有线程都是可见的”，有种常见的错误理解：</p><ul><li>由于volatile修饰的变量在各个线程里都是一致的，所以基于volatile变量的运算在多线程并发的情况下是安全的。</li></ul><p>这句话的前半部分是对的，后半部分却错了，因此它忘记考虑变量的操作是否具有原子性这一问题。</p><p>举个例子：</p><pre><code>private volatile int start = 0;private void volatile Keyword() &#123;    Runnable runnable = new Runnable() &#123;        @Override        public void run() &#123;            for (int i = 0; i &lt; 10; i++) &#123;                start++;            &#125;        &#125;    &#125;;    for (int i = 0; i &lt; 10; i++) &#123;        Thread thread = new Thread(runnable);        thread.start();    &#125;    Log.d(TAG, &quot;start = &quot; + start);&#125;</code></pre><p><img src="https://github.com/guoxiaoxing/android-open-source-project-analysis/raw/master/art/native/process/volatile_thread_safe.png" alt="image"></p><p>这段代码启动了10个线程，每次10次自增，按道理最终结果应该是100，但是结果并非如此。</p><p>为什么会这样？</p><p>仔细看一下start++，它其实并非一个原子操作，简单来看，它有两步：</p><p>1、取出start的值，因为有volatile的修饰，这时候的值是正确的。</p><p>2、自增，但是自增的时候，别的线程可能已经把start加大了，这种情况下就有可能把较小的start写回主内存中。<br>所以volatile只能保证可见性，在不符合以下场景下我们依然需要通过加锁来保证原子性：</p><ul><li>运算结果并不依赖变量当前的值，或者只有单一线程修改变量的值。（要么结果不依赖当前值，要么操作是原子性的，要么只要一个线程修改变量的值）</li><li>变量不需要与其他状态变量共同参与不变约束<br>比方说我们会在线程里加个boolean变量，来判断线程是否停止，这种情况就非常适合使用volatile。</li></ul><p>我们再来理解第二句话。</p><p>禁止进行指令重排序</p><p>什么是指令重排序？</p><ul><li><p>指令重排序是指指令乱序执行，即在条件允许的情况下直接运行当前有能力立即执行的后续指令，避开为获取一条指令所需数据而造成的等待，通过乱序执行的技术提供执行效率。</p></li><li><p>指令重排序会在被volatile修饰的变量的赋值操作前，添加一个内存屏障，指令重排序时不能把后面的指令重排序移到内存屏障之前的位置。</p></li></ul><h4 id="7、synchronized-和-volatile-关键字的作用和区别。"><a href="#7、synchronized-和-volatile-关键字的作用和区别。" class="headerlink" title="7、synchronized 和 volatile 关键字的作用和区别。"></a>7、synchronized 和 volatile 关键字的作用和区别。</h4><h5 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h5><p>1）保证了不同线程对这个变量进行操作时的可见性即一个线程修改了某个变量的值，这新值对其他线程来是立即可见的。</p><p>2）禁止进行指令重排序。</p><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p>volatile 本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需从主存中读取；synchronized则是锁定当前变量，只有当前线程可以访问该变量，其它线程被阻塞住。</p><h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><p>1.volatile 仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。</p><p>2.volatile 仅能实现变量的修改可见性，并不能保证原子性；synchronized 则可以保证变量的修改可见性和原子性。</p><p>3.volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。</p><p>4.volatile 标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。</p><h4 id="8、ReentrantLock的内部实现。"><a href="#8、ReentrantLock的内部实现。" class="headerlink" title="8、ReentrantLock的内部实现。"></a>8、<a href="https://www.cnblogs.com/chengxiao/p/7255941.html">ReentrantLock的内部实现</a>。</h4><p>ReentrantLock实现的前提就是AbstractQueuedSynchronizer，简称AQS，是java.util.concurrent的核心，CountDownLatch、FutureTask、Semaphore、ReentrantLock等都有一个内部类是这个抽象类的子类。由于AQS是基于FIFO队列的实现，因此必然存在一个个节点，Node就是一个节点，Node有两种模式：共享模式和独占模式。ReentrantLock是基于AQS的，AQS是Java并发包中众多同步组件的构建基础，它通过一个int类型的状态变量state和一个FIFO队列来完成共享资源的获取，线程的排队等待等。AQS是个底层框架，采用模板方法模式，它定义了通用的较为复杂的逻辑骨架，比如线程的排队，阻塞，唤醒等，将这些复杂但实质通用的部分抽取出来，这些都是需要构建同步组件的使用者无需关心的，使用者仅需重写一些简单的指定的方法即可（其实就是对于共享变量state的一些简单的获取释放的操作）。AQS的子类一般只需要重写tryAcquire(int arg)和tryRelease(int arg)两个方法即可。</p><h5 id="ReentrantLock的处理逻辑："><a href="#ReentrantLock的处理逻辑：" class="headerlink" title="ReentrantLock的处理逻辑："></a>ReentrantLock的处理逻辑：</h5><p>其内部定义了三个重要的静态内部类，Sync，NonFairSync，FairSync。Sync作为ReentrantLock中公用的同步组件，继承了AQS（要利用AQS复杂的顶层逻辑嘛，线程排队，阻塞，唤醒等等）；NonFairSync和FairSync则都继承Sync，调用Sync的公用逻辑，然后再在各自内部完成自己特定的逻辑（公平或非公平）。</p><p>接着说下这两者的lock()方法实现原理：</p><h5 id="NonFairSync（非公平可重入锁）"><a href="#NonFairSync（非公平可重入锁）" class="headerlink" title="NonFairSync（非公平可重入锁）"></a>NonFairSync（非公平可重入锁）</h5><p>1.先获取state值，若为0，意味着此时没有线程获取到资源，CAS将其设置为1，设置成功则代表获取到排他锁了；</p><p>2.若state大于0，肯定有线程已经抢占到资源了，此时再去判断是否就是自己抢占的，是的话，state累加，返回true，重入成功，state的值即是线程重入的次数；</p><p>3.其他情况，则获取锁失败。</p><h5 id="FairSync（公平可重入锁）"><a href="#FairSync（公平可重入锁）" class="headerlink" title="FairSync（公平可重入锁）"></a>FairSync（公平可重入锁）</h5><p>可以看到，公平锁的大致逻辑与非公平锁是一致的，不同的地方在于有了!hasQueuedPredecessors()这个判断逻辑，即便state为0，也不能贸然直接去获取，要先去看有没有还在排队的线程，若没有，才能尝试去获取，做后面的处理。反之，返回false，获取失败。</p><p>最后，说下ReentrantLock的tryRelease()方法实现原理：</p><p>若state值为0，表示当前线程已完全释放干净，返回true，上层的AQS会意识到资源已空出。若不为0，则表示线程还占有资源，只不过将此次重入的资源的释放了而已，返回false。</p><p>ReentrantLock是一种可重入的，可实现公平性的互斥锁，它的设计基于AQS框架，可重入和公平性的实现逻辑都不难理解，每重入一次，state就加1，当然在释放的时候，也得一层一层释放。至于公平性，在尝试获取锁的时候多了一个判断：是否有比自己申请早的线程在同步队列中等待，若有，去等待；若没有，才允许去抢占。　　</p><h4 id="9、ReentrantLock-、synchronized-和-volatile-比较？"><a href="#9、ReentrantLock-、synchronized-和-volatile-比较？" class="headerlink" title="9、ReentrantLock 、synchronized 和 volatile 比较？"></a>9、ReentrantLock 、synchronized 和 volatile 比较？</h4><p>synchronized是互斥同步的一种实现。</p><p>synchronized：当某个线程访问被synchronized标记的方法或代码块时，这个线程便获得了该对象的锁，其他线暂时无法访问这个方法，只有等待这个方法执行完毕或代码块执行完毕，这个线程才会释放该对象的锁，其他线程才能执行这个方法代码块。</p><p>前面我们已经说了volatile关键字，这里我们举个例子来综合分析volatile与synchronized关键字的使用。</p><p>举个例子：</p><pre><code>public class Singleton &#123;    // volatile保证了：1 instance在多线程并发的可见性 2 禁止instance在操作是的指令重排序    private volatile static Singleton instance;    private Singleton()&#123;&#125;    public static Singleton getInstance() &#123;        // 第一次判空，保证不必要的同步        if (instance == null) &#123;            // synchronized对Singleton加全局锁，保证每次只要一个线程创建实例            synchronized (Singleton.class) &#123;                // 第二次判空时为了在null的情况下创建实例                if (instance == null) &#123;                    instance = new Singleton();                &#125;            &#125;        &#125;        return instance;    &#125;&#125;</code></pre><p>这是一个经典的DCL单例。</p><p>它的字节码如下：</p><p><img src="https://github.com/guoxiaoxing/android-open-source-project-analysis/raw/master/art/native/process/synchronized_bytecode.png" alt="image"></p><p>可以看到被synchronized同步的代码块，会在前后分别加上monitorenter和monitorexit，这两个字节码都需要指定加锁和解锁的对象。</p><p>关于加锁和解锁的对象：</p><p>synchronized代码块 ：同步代码块，作用范围是整个代码块，作用对象是调用这个代码块的对象。</p><p>synchronized方法 ：同步方法，作用范围是整个方法，作用对象是调用这个方法的对象。</p><p>synchronized静态方法 ：同步静态方法，作用范围是整个静态方法，作用对象是调用这个类的所有对象。</p><p>synchronized(this)：作用范围是该对象中所有被synchronized标记的变量、方法或代码块，作用对象是对象本身。</p><p>synchronized(ClassName.class) ：作用范围是静态的方法或者静态变量，作用对象是Class对象。</p><p>synchronized(this)添加的是对象锁，synchronized(ClassName.class)添加的是类锁，它们的区别如下：</p><ul><li><p>对象锁：Java的所有对象都含有1个互斥锁，这个锁由JVM自动获取和释放。线程进入synchronized方法的时候获取该对象的锁，当然如果已经有线程获取了这个对象的锁那么当前线程会等待；synchronized方法正常返回或者抛异常而终止，JVM会自动释放对象锁。这里也体现了用synchronized来加锁的好处，方法抛异常的时候，锁仍然可以由JVM来自动释放。</p></li><li><p>类锁：对象锁是用来控制实例方法之间的同步，类锁是来控制静态方法（或静态变量互斥体）之间的同步。其实类锁只是一个概念上的东西，并不是真实存在的，它只用来帮助我们理解锁定实例方法和静态方法的区别的。我们都知道，java类可能会有很多个对象，但是只有1个Class对象，也就说类的不同实例之间共享该类的Class对象。Class对象其实也仅仅是1个java对象，只不过有点特殊而已。由于每个java对象都有个互斥锁，而类的静态方法是需要Class对象。所以所谓类锁，不过是Class对象的锁而已。获取类的Class对象有好几种，最简单的就是MyClass.class的方式。类锁和对象锁不是同一个东西，一个是类的Class对象的锁，一个是类的实例的锁。也就是说：一个线程访问静态sychronized的时候，允许另一个线程访问对象的实例synchronized方法。反过来也是成立的，为他们需要的锁是不同的。</p></li></ul><h3 id="三、其它-（⭐⭐⭐）"><a href="#三、其它-（⭐⭐⭐）" class="headerlink" title="三、其它 （⭐⭐⭐）"></a>三、其它 （⭐⭐⭐）</h3><h4 id="1、多线程的使用场景？"><a href="#1、多线程的使用场景？" class="headerlink" title="1、多线程的使用场景？"></a>1、多线程的使用场景？</h4><p>使用多线程就一定效率高吗？有时候使用多线程并不是为了提高效率，而是使得CPU能同时处理多个事件。</p><ul><li><p>为了不阻塞主线程,启动其他线程来做事情,比如APP中的耗时操作都不在UI线程中做。</p></li><li><p>实现更快的应用程序,即主线程专门监听用户请求,子线程用来处理用户请求,以获得大的吞吐量.感觉这种情况，多线程的效率未必高。这种情况下的多线程是为了不必等待，可以并行处理多条数据。比如JavaWeb的就是主线程专门监听用户的HTTP请求，然启动子线程去处理用户的HTTP请求。</p></li><li><p>某种虽然优先级很低的服务，但是却要不定时去做。比如Jvm的垃圾回收。</p></li><li><p>某种任务，虽然耗时，但是不消耗CPU的操作时间，开启个线程，效率会有显著提高。比如读取文件，然后处理。磁盘IO是个很耗费时间，但是不耗CPU计算的工作。所以可以一个线程读取数据，一个线程处理数据。肯定比一个线程读取数据，然后处理效率高。因为两个线程的时候充分利用了CPU等待磁盘IO的空闲时间。</p></li></ul><h4 id="2、CopyOnWriteArrayList的了解。"><a href="#2、CopyOnWriteArrayList的了解。" class="headerlink" title="2、CopyOnWriteArrayList的了解。"></a>2、CopyOnWriteArrayList的了解。</h4><h5 id="Copy-On-Write-是什么？"><a href="#Copy-On-Write-是什么？" class="headerlink" title="Copy-On-Write 是什么？"></a>Copy-On-Write 是什么？</h5><p>在计算机中就是当你想要对一块内存进行修改时，我们不在原有内存块中进行写操作，而是将内存拷贝一份，在新的内存中进行写操作，写完之后呢，就将指向原来内存指针指向新的内存，原来的内存就可以被回收掉。</p><h5 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h5><p>CopyOnWriteArrayList这是一个ArrayList的线程安全的变体，CopyOnWriteArrayList 底层实现添加的原理是先copy出一个容器(可以简称副本)，再往新的容器里添加这个新的数据，最后把新的容器的引用地址赋值给了之前那个旧的的容器地址，但是在添加这个数据的期间，其他线程如果要去读取数据，仍然是读取到旧的容器里的数据。</p><h5 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点:"></a>优点和缺点:</h5><p>优点:</p><p>1.据一致性完整，为什么？因为加锁了，并发数据不会乱。</p><p>2.解决了像ArrayList、Vector这种集合多线程遍历迭代问题，记住，Vector虽然线程安全，只不过是加了synchronized关键字，迭代问题完全没有解决！</p><p>缺点:</p><p>1.内存占有问题:很明显，两个数组同时驻扎在内存中，如果实际应用中，数据比较多，而且比较大的情况下，占用内存会比较大，针对这个其实可以用ConcurrentHashMap来代替。</p><p>2.数据一致性:CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。</p><h5 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h5><p>1、读多写少（白名单，黑名单，商品类目的访问和更新场景），为什么？因为写的时候会复制新集合。</p><p>2、集合不大，为什么？因为写的时候会复制新集合。</p><p>3、实时性要求不高，为什么，因为有可能会读取到旧的集合数据。</p><h4 id="3、ConcurrentHashMap加锁机制是什么，详细说一下？"><a href="#3、ConcurrentHashMap加锁机制是什么，详细说一下？" class="headerlink" title="3、ConcurrentHashMap加锁机制是什么，详细说一下？"></a>3、ConcurrentHashMap加锁机制是什么，详细说一下？</h4><h5 id="Java7-ConcurrentHashMap"><a href="#Java7-ConcurrentHashMap" class="headerlink" title="Java7 ConcurrentHashMap"></a>Java7 ConcurrentHashMap</h5><p>ConcurrentHashMap作为一种线程安全且高效的哈希表的解决方案，尤其其中的”分段锁”的方案，相比HashTable的表锁在性能上的提升非常之大。HashTable容器在竞争激烈的并发环境下表现出效率低下的原因，是因为所有访问HashTable的线程都必须竞争同一把锁，那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p><p>ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承 ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。</p><p>concurrencyLevel：并行级别、并发数、Segment 数。默认是 16，也就是说 ConcurrentHashMap 有 16 个 Segments，所以理论上，这个时候，最多可以同时支持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。这个值可以在初始化的时候设置为其他值，但是一旦初始化以后，它是不可以扩容的。其中的每个 Segment 很像 HashMap，不过它要保证线程安全，所以处理起来要麻烦些。</p><p>初始化槽: ensureSegment</p><p>ConcurrentHashMap 初始化的时候会初始化第一个槽 segment[0]，对于其他槽来说，在插入第一个值的时候进行初始化。对于并发操作使用 CAS 进行控制。</p><h5 id="Java8-ConcurrentHashMap"><a href="#Java8-ConcurrentHashMap" class="headerlink" title="Java8 ConcurrentHashMap"></a>Java8 ConcurrentHashMap</h5><p>抛弃了原有的 Segment 分段锁，而采用了 CAS + synchronized 来保证并发安全性。结构上和 Java8 的 HashMap（数组+链表+红黑树） 基本上一样，不过它要保证线程安全性，所以在源码上确实要复杂一些。1.8 在 1.7 的数据结构上做了大的改动，采用红黑树之后可以保证查询效率（O(logn)），甚至取消了 ReentrantLock 改为了 synchronized，这样可以看出在新版的 JDK 中对 synchronized 优化是很到位的。</p><h4 id="4、线程死锁的4个条件？"><a href="#4、线程死锁的4个条件？" class="headerlink" title="4、线程死锁的4个条件？"></a>4、线程死锁的4个条件？</h4><p>死锁是如何发生的，如何避免死锁？</p><p>当线程A持有独占锁a，并尝试去获取独占锁b的同时，线程B持有独占锁b，并尝试获取独占锁a的情况下，就会发生AB两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。</p><pre><code>public class DeadLockDemo &#123;    public static void main(String[] args) &#123;        // 线程a        Thread td1 = new Thread(new Runnable() &#123;            public void run() &#123;                DeadLockDemo.method1();            &#125;        &#125;);        // 线程b        Thread td2 = new Thread(new Runnable() &#123;            public void run() &#123;                DeadLockDemo.method2();            &#125;        &#125;);        td1.start();        td2.start();    &#125;    public static void method1() &#123;        synchronized (String.class) &#123;            try &#123;                Thread.sleep(2000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(&quot;线程a尝试获取integer.class&quot;);            synchronized (Integer.class) &#123;            &#125;        &#125;    &#125;    public static void method2() &#123;        synchronized (Integer.class) &#123;            try &#123;                Thread.sleep(2000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(&quot;线程b尝试获取String.class&quot;);            synchronized (String.class) &#123;            &#125;        &#125;    &#125;&#125;</code></pre><p>造成死锁的四个条件：</p><ul><li>互斥条件：一个资源每次只能被一个线程使用。</li><li>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件：线程已获得的资源，在未使用完之前，不能强行剥夺。</li><li>循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。</li></ul><p>在并发程序中，避免了逻辑中出现数个线程互相持有对方线程所需要的独占锁的的情况，就可以避免死锁，如下所示：</p><pre><code>public class BreakDeadLockDemo &#123;    public static void main(String[] args) &#123;        // 线程a        Thread td1 = new Thread(new Runnable() &#123;            public void run() &#123;                DeadLockDemo2.method1();            &#125;        &#125;);        // 线程b        Thread td2 = new Thread(new Runnable() &#123;            public void run() &#123;                DeadLockDemo2.method2();            &#125;        &#125;);        td1.start();        td2.start();    &#125;    public static void method1() &#123;        synchronized (String.class) &#123;            try &#123;                Thread.sleep(2000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(&quot;线程a尝试获取integer.class&quot;);            synchronized (Integer.class) &#123;                System.out.println(&quot;线程a获取到integer.class&quot;);            &#125;        &#125;    &#125;    public static void method2() &#123;        // 不再获取线程a需要的Integer.class锁。        synchronized (String.class) &#123;            try &#123;                Thread.sleep(2000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(&quot;线程b尝试获取Integer.class&quot;);            synchronized (Integer.class) &#123;                System.out.println(&quot;线程b获取到Integer.class&quot;);            &#125;        &#125;    &#125;&#125;</code></pre><h4 id="5、CAS介绍？"><a href="#5、CAS介绍？" class="headerlink" title="5、CAS介绍？"></a>5、CAS介绍？</h4><h5 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h5><p>Unsafe是CAS的核心类。因为Java无法直接访问底层操作系统，而是通过本地（native）方法来访问。不过尽管如此，JVM还是开了一个后门，JDK中有一个类Unsafe，它提供了硬件级别的原子操作。</p><h5 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h5><p>CAS，Compare and Swap即比较并交换，设计并发算法时常用到的一种技术，java.util.concurrent包全完建立在CAS之上，没有CAS也就没有此包，可见CAS的重要性。当前的处理器基本都支持CAS，只不过不同的厂家的实现不一样罢了。并且CAS也是通过Unsafe实现的，由于CAS都是硬件级别的操作，因此效率会比普通加锁高一些。</p><h5 id="CAS的缺点"><a href="#CAS的缺点" class="headerlink" title="CAS的缺点"></a>CAS的缺点</h5><p>CAS看起来很美，但这种操作显然无法涵盖并发下的所有场景，并且CAS从语义上来说也不是完美的，存在这样一个逻辑漏洞：如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？如果在这段期间它的值曾经被改成了B，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个漏洞称为CAS操作的”ABA”问题。java.util.concurrent包为了解决这个问题，提供了一个带有标记的原子引用类”AtomicStampedReference”，它可以通过控制变量值的版本来保证CAS的正确性。不过目前来说这个类比较”鸡肋”，大部分情况下ABA问题并不会影响程序并发的正确性，如果需要解决ABA问题，使用传统的互斥同步可能回避原子类更加高效。</p><h4 id="6、进程和线程的区别？"><a href="#6、进程和线程的区别？" class="headerlink" title="6、进程和线程的区别？"></a>6、进程和线程的区别？</h4><p>简而言之,一个程序至少有一个进程,一个进程至少有一个线程。</p><ul><li><p>1、线程的划分尺度小于进程，使得多线程程序的并发性高。</p></li><li><p>2、进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</p></li><li><p>3、线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</p></li><li><p>4、从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</p></li><li><p>5、进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</p></li><li><p>6、一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行。</p></li><li><p>7、进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。</p></li></ul><h4 id="7、什么导致线程阻塞？"><a href="#7、什么导致线程阻塞？" class="headerlink" title="7、什么导致线程阻塞？"></a>7、什么导致线程阻塞？</h4><p>线程的阻塞</p><p>为了解决对共享存储区的访问冲突，Java 引入了同步机制，现在让我们来考察多个线程对共享资源的访问，显然同步机制已经不够了，因为在任意时刻所要求的资源不一定已经准备好了被访问，反过来，同一时刻准备好了的资源也可能不止一个。为了解决这种情况下的访问控制问题，Java 引入了对阻塞机制的支持.</p><p>阻塞指的是暂停一个线程的执行以等待某个条件发生（如某资源就绪），学过操作系统的同学对它一定已经很熟悉了。Java 提供了大量方法来支持阻塞，下面让我们逐一分析。</p><p>sleep() 方法：sleep() 允许 指定以毫秒为单位的一段时间作为参数，它使得线程在指定的时间内进入阻塞状态，不能得到CPU 时间，指定的时间一过，线程重新进入可执行状态。 典型地，sleep() 被用在等待某个资源就绪的情形：测试发现条件不满足后，让线程阻塞一段时间后重新测试，直到条件满足为止。</p><p>suspend() 和 resume() 方法：两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的resume() 被调用，才能使得线程重新进入可执行状态。典型地，suspend() 和 resume() 被用在等待另一个线程产生的结果的情形：测试发现结果还没有产生后，让线程阻塞，另一个线程产生了结果后，调用 resume() 使其恢复。</p><p>yield() 方法：yield() 使得线程放弃当前分得的 CPU 时间，但是不使线程阻塞，即线程仍处于可执行状态，随时可能再次分得 CPU 时间。调用 yield() 的效果等价于调度程序认为该线程已执行了足够的时间从而转到另一个线程。</p><p>wait() 和 notify() 方法：两个方法配套使用，wait() 使得线程进入阻塞状态，它有两种形式，一种允许指定以毫秒为单位的一段时间作为参数，另一种没有参数，前者当对应的 notify() 被调用或者超出指定时间时线程重新进入可执行状态，后者则必须对应的 notify() 被调用。初看起来它们与 suspend() 和 resume() 方法对没有什么分别，但是事实上它们是截然不同的。区别的核心在于，前面叙述的所有方法，阻塞时都不会释放占用的锁（如果占用了的话），而这一对方法则相反。</p><p>上述的核心区别导致了一系列的细节上的区别。</p><p>首先，前面叙述的所有方法都隶属于 Thread 类，但是这一对却直接隶属于 Object 类，也就是说，所有对象都拥有这一对方法。初看起来这十分不可思议，但是实际上却是很自然的，因为这一对方法阻塞时要释放占用的锁，而锁是任何对象都具有的，调用任意对象的 wait() 方法导致线程阻塞，并且该对象上的锁被释放。而调用 任意对象的notify()方法则导致因调用该对象的 wait() 方法而阻塞的线程中随机选择的一个解除阻塞（但要等到获得锁后才真正可执行）。</p><p>其次，前面叙述的所有方法都可在任何位置调用，但是这一对方法却必须在 synchronized 方法或块中调用，理由也很简单，只有在synchronized 方法或块中当前线程才占有锁，才有锁可以释放。同样的道理，调用这一对方法的对象上的锁必须为当前线程所拥有，这样才有锁可以释放。因此，这一对方法调用必须放置在这样的 synchronized 方法或块中，该方法或块的上锁对象就是调用这一对方法的对象。若不满足这一条件，则程序虽然仍能编译，但在运行时会出现IllegalMonitorStateException 异常。</p><p>wait() 和 notify() 方法的上述特性决定了它们经常和synchronized 方法或块一起使用，将它们和操作系统的进程间通信机制作一个比较就会发现它们的相似性：synchronized方法或块提供了类似于操作系统原语的功能，它们的执行不会受到多线程机制的干扰，而这一对方法则相当于 block 和wakeup 原语（这一对方法均声明为 synchronized）。它们的结合使得我们可以实现操作系统上一系列精妙的进程间通信的算法（如信号量算法），并用于解决各种复杂的线程间通信问题。（此外，线程间通信的方式还有多个线程通过synchronized关键字这种方式来实现线程间的通信、while轮询、使用java.io.PipedInputStream 和 java.io.PipedOutputStream进行通信的管道通信）。</p><p>关于 wait() 和 notify() 方法最后再说明两点：</p><p>第一：调用 notify() 方法导致解除阻塞的线程是从调用该对象的 wait() 方法而阻塞的线程中随机选取的，我们无法预料哪一个线程将会被选择，所以编程时要特别小心，避免因这种不确定性而产生问题。</p><p>第二：除了 notify()，还有一个方法 notifyAll() 也可起到类似作用，唯一的区别在于，调用 notifyAll() 方法将把因调用该对象的 wait() 方法而阻塞的所有线程一次性全部解除阻塞。当然，只有获得锁的那一个线程才能进入可执行状态。</p><p>谈到阻塞，就不能不谈一谈死锁，略一分析就能发现，suspend() 方法和不指定超时期限的 wait() 方法的调用都可能产生死锁。遗憾的是，Java 并不在语言级别上支持死锁的避免，我们在编程中必须小心地避免死锁。</p><p>以上我们对 Java 中实现线程阻塞的各种方法作了一番分析，我们重点分析了 wait() 和 notify() 方法，因为它们的功能最强大，使用也最灵活，但是这也导致了它们的效率较低，较容易出错。实际使用中我们应该灵活使用各种方法，以便更好地达到我们的目的。</p><h4 id="8、线程的生命周期"><a href="#8、线程的生命周期" class="headerlink" title="8、线程的生命周期"></a>8、线程的生命周期</h4><p>线程状态流程图</p><p><img src="https://github.com/guoxiaoxing/android-open-source-project-analysis/raw/master/art/native/process/java_thread_state.png" alt="image"></p><ul><li>NEW：创建状态，线程创建之后，但是还未启动。</li><li>RUNNABLE：运行状态，处于运行状态的线程，但有可能处于等待状态，例如等待CPU、IO等。</li><li>WAITING：等待状态，一般是调用了wait()、join()、LockSupport.spark()等方法。</li><li>TIMED_WAITING：超时等待状态，也就是带时间的等待状态。一般是调用了wait(time)、join(time)、LockSupport.sparkNanos()、LockSupport.sparkUnit()等方法。</li><li>BLOCKED：阻塞状态，等待锁的释放，例如调用了synchronized增加了锁。</li><li>TERMINATED：终止状态，一般是线程完成任务后退出或者异常终止。</li></ul><p>NEW、WAITING、TIMED_WAITING都比较好理解，我们重点说一说RUNNABLE运行态和BLOCKED阻塞态。</p><p>线程进入RUNNABLE运行态一般分为五种情况：</p><ul><li>线程调用sleep(time)后结束了休眠时间</li><li>线程调用的阻塞IO已经返回，阻塞方法执行完毕</li><li>线程成功的获取了资源锁</li><li>线程正在等待某个通知，成功的获得了其他线程发出的通知</li><li>线程处于挂起状态，然后调用了resume()恢复方法，解除了挂起。</li></ul><p>线程进入BLOCKED阻塞态一般也分为五种情况：</p><ul><li>线程调用sleep()方法主动放弃占有的资源</li><li>线程调用了阻塞式IO的方法，在该方法返回前，该线程被阻塞。</li><li>线程视图获得一个资源锁，但是该资源锁正被其他线程锁持有。</li><li>线程正在等待某个通知</li><li>线程调度器调用suspend()方法将该线程挂起</li></ul><p>我们再来看看和线程状态相关的一些方法。</p><ul><li><p>sleep()方法让当前正在执行的线程在指定时间内暂停执行，正在执行的线程可以通过Thread.currentThread()方法获取。</p></li><li><p>yield()方法放弃线程持有的CPU资源，将其让给其他任务去占用CPU执行时间。但放弃的时间不确定，有可能刚刚放弃，马上又获得CPU时间片。</p></li><li><p>wait()方法是当前执行代码的线程进行等待，将当前线程放入预执行队列，并在wait()所在的代码处停止执行，直到接到通知或者被中断为止。该方法可以使得调用该方法的线程释放共享资源的锁， 然后从运行状态退出，进入等待队列，直到再次被唤醒。该方法只能在同步代码块里调用，否则会抛出IllegalMonitorStateException异常。wait(long millis)方法等待某一段时间内是否有线程对锁进行唤醒，如果超过了这个时间则自动唤醒。</p></li><li><p>notify()方法用来通知那些可能等待该对象的对象锁的其他线程，该方法可以随机唤醒等待队列中等同一共享资源的一个线程，并使该线程退出等待队列，进入可运行状态。</p></li><li><p>notifyAll()方法可以使所有正在等待队列中等待同一共享资源的全部线程从等待状态退出，进入可运行状态，一般会是优先级高的线程先执行，但是根据虚拟机的实现不同，也有可能是随机执行。</p></li><li><p>join()方法可以让调用它的线程正常执行完成后，再去执行该线程后面的代码，它具有让线程排队的作用。</p></li></ul><h4 id="9、乐观锁与悲观锁。"><a href="#9、乐观锁与悲观锁。" class="headerlink" title="9、乐观锁与悲观锁。"></a>9、<a href="https://juejin.im/post/5b4977ae5188251b146b2fc8">乐观锁与悲观锁</a>。</h4><h5 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h5><p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。</p><h5 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h5><p>总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。</p><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><p>乐观锁适用于写比较少的情况下（多读场景），而一般多写的场景下用悲观锁就比较合适。</p><h5 id="乐观锁常见的两种实现方式"><a href="#乐观锁常见的两种实现方式" class="headerlink" title="乐观锁常见的两种实现方式"></a>乐观锁常见的两种实现方式</h5><p>1、版本号机制</p><p>一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加1。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。</p><p>2、CAS算法</p><p>即compare and swap（比较与交换），是一种有名的无锁算法。CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。 一般情况下是一个自旋操作，即不断的重试。</p><h5 id="乐观锁的缺点"><a href="#乐观锁的缺点" class="headerlink" title="乐观锁的缺点"></a>乐观锁的缺点</h5><p>1、ABA 问题</p><p>如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 “ABA”问题。</p><p>JDK 1.5 以后的 AtomicStampedReference 类一定程度上解决了这个问题，其中的 compareAndSet 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p><p>2、自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。</p><p>3、CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5开始，提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用AtomicReference类把多个共享变量合并成一个共享变量来操作。</p><h4 id="10、run-和start-方法区别？"><a href="#10、run-和start-方法区别？" class="headerlink" title="10、run()和start()方法区别？"></a>10、run()和start()方法区别？</h4><p>1.start()方法来启动线程，真正实现了多线程运行，这时无需等待run方法体代码执行完毕而直接继续执行下面的代码：</p><p>通过调用Thread类的start()方法来启动一个线程，<br>这时此线程是处于就绪状态，<br>并没有运行。<br>然后通过此Thread类调用方法run()来完成其运行操作的，<br>这里方法run()称为线程体，<br>它包含了要执行的这个线程的内容，<br>Run方法运行结束，<br>此线程终止，<br>而CPU再运行其它线程，在Android中一般是主线程。</p><p>2.run()方法当作普通方法的方式调用，程序还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码：</p><p>而如果直接用Run方法，<br>这只是调用一个方法而已，<br>程序中依然只有主线程–这一个线程，<br>其程序执行路径还是只有一条，<br>这样就没有达到写线程的目的。</p><h4 id="11、多线程断点续传原理。"><a href="#11、多线程断点续传原理。" class="headerlink" title="11、多线程断点续传原理。"></a>11、多线程断点续传原理。</h4><p>在本地下载过程中要使用数据库实时存储到底存储到文件的哪个位置了，这样点击开始继续传递时，才能通过HTTP的GET请求中的setRequestProperty(“Range”,”bytes=startIndex-endIndex”);方法可以告诉服务器，数据从哪里开始，到哪里结束。同时在本地的文件写入时，RandomAccessFile的seek()方法也支持在文件中的任意位置进行写入操作。同时通过广播或事件总线机制将子线程的进度告诉Activity的进度条。关于断线续传的HTTP状态码是206，即HttpStatus.SC_PARTIAL_CONTENT。</p><h4 id="12、怎么安全停止一个线程任务？原理是什么？线程池里有类似机制吗？"><a href="#12、怎么安全停止一个线程任务？原理是什么？线程池里有类似机制吗？" class="headerlink" title="12、怎么安全停止一个线程任务？原理是什么？线程池里有类似机制吗？"></a>12、怎么安全停止一个线程任务？原理是什么？线程池里有类似机制吗？</h4><h5 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h5><p>1、使用violate boolean变量退出标志，使线程正常退出，也就是当run方法完成后线程终止。（推荐）</p><p>2、使用interrupt()方法中断线程，但是线程不一定会终止。</p><p>3、使用stop方法强行终止线程。不安全主要是：thread.stop()调用之后，创建子线程的线程就会抛出ThreadDeatherror的错误，并且会释放子线程所持有的所有锁。</p><h5 id="终止线程池"><a href="#终止线程池" class="headerlink" title="终止线程池"></a>终止线程池</h5><p>ExecutorService线程池就提供了shutdown和shutdownNow这样的生命周期方法来关闭线程池自身以及它拥有的所有线程。</p><p>1、shutdown关闭线程池</p><p>线程池不会立刻退出，直到添加到线程池中的任务都已经处理完成，才会退出。 </p><p>2、shutdownNow关闭线程池并中断任务</p><p>终止等待执行的线程，并返回它们的列表。试图停止所有正在执行的线程，试图终止的方法是调用Thread.interrupt()，但是大家知道，如果线程中没有sleep 、wait、Condition、定时锁等应用, interrupt()方法是无法中断当前的线程的。所以，ShutdownNow()并不代表线程池就一定立即就能退出，它可能必须要等待所有正在执行的任务都执行完成了才能退出。</p><h4 id="13、堆内存，栈内存理解，栈如何转换成堆？"><a href="#13、堆内存，栈内存理解，栈如何转换成堆？" class="headerlink" title="13、堆内存，栈内存理解，栈如何转换成堆？"></a>13、堆内存，栈内存理解，栈如何转换成堆？</h4><ul><li>在函数中定义的一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配。</li><li>堆内存用于存放由new创建的对象和数组。JVM里的“堆”（heap）特指用于存放Java对象的内存区域。所以根据这个定义，Java对象全部都在堆上。JVM的堆被同一个JVM实例中的所有Java线程共享。它通常由某种自动内存管理机制所管理，这种机制通常叫做“垃圾回收”（garbage collection，GC）。</li><li>堆主要用来存放对象的，栈主要是用来执行程序的。</li><li>实际上，栈中的变量指向堆内存中的变量，这就是 Java 中的指针!</li></ul><h4 id="14、如何控制某个方法允许并发访问线程的个数；"><a href="#14、如何控制某个方法允许并发访问线程的个数；" class="headerlink" title="14、如何控制某个方法允许并发访问线程的个数；"></a>14、如何控制某个方法允许并发访问线程的个数；</h4><h4 id="15、多进程开发以及多进程应用场景；"><a href="#15、多进程开发以及多进程应用场景；" class="headerlink" title="15、多进程开发以及多进程应用场景；"></a>15、多进程开发以及多进程应用场景；</h4><h4 id="16、Java的线程模型；"><a href="#16、Java的线程模型；" class="headerlink" title="16、Java的线程模型；"></a>16、Java的线程模型；</h4><h4 id="17、死锁的概念，怎么避免死锁？"><a href="#17、死锁的概念，怎么避免死锁？" class="headerlink" title="17、死锁的概念，怎么避免死锁？"></a>17、死锁的概念，怎么避免死锁？</h4><h4 id="18、如何保证多线程读写文件的安全？"><a href="#18、如何保证多线程读写文件的安全？" class="headerlink" title="18、如何保证多线程读写文件的安全？"></a>18、如何保证多线程读写文件的安全？</h4><h4 id="19、线程如何关闭，以及如何防止线程的内存泄漏？"><a href="#19、线程如何关闭，以及如何防止线程的内存泄漏？" class="headerlink" title="19、线程如何关闭，以及如何防止线程的内存泄漏？"></a>19、线程如何关闭，以及如何防止线程的内存泄漏？</h4><h4 id="20、为什么要有线程，而不是仅仅用进程？"><a href="#20、为什么要有线程，而不是仅仅用进程？" class="headerlink" title="20、为什么要有线程，而不是仅仅用进程？"></a>20、为什么要有线程，而不是仅仅用进程？</h4><h4 id="21、多个线程如何同时请求，返回的结果如何等待所有线程数据完成后合成一个数据？"><a href="#21、多个线程如何同时请求，返回的结果如何等待所有线程数据完成后合成一个数据？" class="headerlink" title="21、多个线程如何同时请求，返回的结果如何等待所有线程数据完成后合成一个数据？"></a>21、多个线程如何同时请求，返回的结果如何等待所有线程数据完成后合成一个数据？</h4><h4 id="22、线程如何关闭？"><a href="#22、线程如何关闭？" class="headerlink" title="22、线程如何关闭？"></a>22、线程如何关闭？</h4><h4 id="23、数据一致性如何保证？"><a href="#23、数据一致性如何保证？" class="headerlink" title="23、数据一致性如何保证？"></a>23、数据一致性如何保证？</h4><h4 id="24、两个进程同时要求写或者读，能不能实现？如何防止进程的同步？"><a href="#24、两个进程同时要求写或者读，能不能实现？如何防止进程的同步？" class="headerlink" title="24、两个进程同时要求写或者读，能不能实现？如何防止进程的同步？"></a>24、两个进程同时要求写或者读，能不能实现？如何防止进程的同步？</h4><h4 id="25、谈谈对多线程的理解并举例说明"><a href="#25、谈谈对多线程的理解并举例说明" class="headerlink" title="25、谈谈对多线程的理解并举例说明"></a>25、谈谈对多线程的理解并举例说明</h4><h4 id="26、线程的状态和优先级。"><a href="#26、线程的状态和优先级。" class="headerlink" title="26、线程的状态和优先级。"></a>26、线程的状态和优先级。</h4><h4 id="27、ThreadLocal的使用"><a href="#27、ThreadLocal的使用" class="headerlink" title="27、ThreadLocal的使用"></a>27、ThreadLocal的使用</h4><h4 id="28、Java中的并发工具（CountDownLatch，CyclicBarrier等）"><a href="#28、Java中的并发工具（CountDownLatch，CyclicBarrier等）" class="headerlink" title="28、Java中的并发工具（CountDownLatch，CyclicBarrier等）"></a>28、Java中的并发工具（CountDownLatch，CyclicBarrier等）</h4><h4 id="29、进程线程在操作系统中的实现"><a href="#29、进程线程在操作系统中的实现" class="headerlink" title="29、进程线程在操作系统中的实现"></a>29、进程线程在操作系统中的实现</h4><h4 id="30、双线程通过线程同步的方式打印12121212……"><a href="#30、双线程通过线程同步的方式打印12121212……" class="headerlink" title="30、双线程通过线程同步的方式打印12121212……."></a>30、双线程通过线程同步的方式打印12121212…….</h4><h4 id="31、java线程，场景实现，多个线程如何同时请求，返回的结果如何等待所有线程数据完成后合成一个数据"><a href="#31、java线程，场景实现，多个线程如何同时请求，返回的结果如何等待所有线程数据完成后合成一个数据" class="headerlink" title="31、java线程，场景实现，多个线程如何同时请求，返回的结果如何等待所有线程数据完成后合成一个数据"></a>31、java线程，场景实现，多个线程如何同时请求，返回的结果如何等待所有线程数据完成后合成一个数据</h4><h4 id="32、服务器只提供数据接收接口，在多线程或多进程条件下，如何保证数据的有序到达？"><a href="#32、服务器只提供数据接收接口，在多线程或多进程条件下，如何保证数据的有序到达？" class="headerlink" title="32、服务器只提供数据接收接口，在多线程或多进程条件下，如何保证数据的有序到达？"></a>32、服务器只提供数据接收接口，在多线程或多进程条件下，如何保证数据的有序到达？</h4><h4 id="33、单机上一个线程池正在处理服务，如果忽然断电了怎么办（正在处理和阻塞队列里的请求怎么处理）？"><a href="#33、单机上一个线程池正在处理服务，如果忽然断电了怎么办（正在处理和阻塞队列里的请求怎么处理）？" class="headerlink" title="33、单机上一个线程池正在处理服务，如果忽然断电了怎么办（正在处理和阻塞队列里的请求怎么处理）？"></a>33、单机上一个线程池正在处理服务，如果忽然断电了怎么办（正在处理和阻塞队列里的请求怎么处理）？</h4>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 职场 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java动态代理机制</title>
      <link href="/2019-11-30/dynamic-proxy/"/>
      <url>/2019-11-30/dynamic-proxy/</url>
      
        <content type="html"><![CDATA[<p>Java 动态代理是一种代理机制，它允许我们动态地、在不修改原代码的基础上，让代码完成它本来无法完成的工作。</p><span id="more"></span><h2 id="静态代理是什么"><a href="#静态代理是什么" class="headerlink" title="静态代理是什么"></a>静态代理是什么</h2><p>哎哎？标题不是在讲动态代理吗？</p><p>要想知道动态代理，必须先知道静态代理。</p><p>静态代理模式可以在<strong>不修改被代理对象</strong>的基础上，通过扩展代理类，进行一些功能的附加与增强。值得注意的是，代理类和被代理类应该共同实现一个接口，或者是共同继承某个类。它的类型是事先预定好的，在编译时<strong>会被编译进 .class 文件</strong>中。</p><p>举个例子。</p><p>比如我电影院要放电影，放电影之前要放广告吧，但是电影本身是不能进行修改的，我们就可以用代理的方法，在电影的前、后都加入广告的播放功能。</p><p>首先我们设计一个接口，有了通用接口，才有了代理模式实现的基础。</p><pre><code class="java">package com.debugLife.proxyTest;public interface Movie &#123;    public void play();&#125;</code></pre><p>接下来我们来一部电影（被代理类）：</p><pre><code class="java">public com.debugLife.proxyTest;public class AMovie implements Movie &#123;    @Override    public void play() &#123;        System.out.println(&quot;正在播放电影 -《指环王》&quot;);    &#125;&#125;</code></pre><p>它实现了 Movie 接口，当调用<code>play()</code>方法时，电影就开始播放了。</p><p>接下来是电影院（代理类）：</p><pre><code class="java">public com.debugLife.proxyTest;public class Cinema implements Movie &#123;    AMovie aMovie;    public Cinema(AMovie aMovie) &#123;        super();        this.aMovie = aMovie;    &#125;    @Override    public void play() &#123;        playAds();        aMovie.play();        playAds();    &#125;    private void playAds() &#123;        System.out.println(&quot;得了痔疮怎么办？大铁棍子医院找捅主任！&quot;);    &#125;&#125;</code></pre><p>此时的 Cinema 已经是代理对象了，它有一个<code>play()</code>方法，里面有它自己的一些小九九。</p><p>而影院开始运营时，就是这样了：</p><pre><code class="java">package com.debugLife.proxyTest;public class WandaCinema &#123;    public static void main(String[] args) &#123;        AMovie aMovie = new AMovie();        Movie movie = new Cinema(aMovie);        movie.play();    &#125;&#125;</code></pre><p>结果不必多想，肯定如下：</p><pre><code>得了痔疮怎么办？大铁棍子医院找捅主任！正在播放电影 -《指环王》得了痔疮怎么办？大铁棍子医院找捅主任！</code></pre><p>静态代理的缺点是什么呢？</p><p>它通常<strong>只能代理一个类</strong>，这对于日益增长的需求来看，100个类，就几乎要写100个代理方法，这显然是不合实际的。</p><p>那么，能否不写代理类，而直接得到代理 Class 对象，然后根据它创建代理实例（反射）呢？为了解决这种问题，出现了动态代理。</p><h2 id="动态代理是什么"><a href="#动态代理是什么" class="headerlink" title="动态代理是什么"></a>动态代理是什么</h2><p>Java 的动态代理机制可谓是『狸猫换太子』的典范了。为了<strong>不暴露内部的接口</strong>，采取了为其他对象<strong>提供一个代理</strong>以控制对某个对象的访问。代理类主要负责为委托类（真实对象）预处理消息、过滤消息、传递消息给委托类，代理类不现实具体服务，而是利用委托类来完成服务，并将执行结果封装处理。</p><p>JDK 提供了<code>java.lang.reflect.InvocationHandler</code>接口和<code>java.lang.reflect.Proxy</code>类，这两个类相互配合，入口是 Proxy，所以我们先聊它。</p><p>Proxy有个静态方法：<code>getProxyClass(ClassLoader, interfaces)</code>，只要你给它传入类加载器和一组接口，它就给你返回代理 Class 对象。</p><p>用通俗的话说，<code>getProxyClass()</code>这个方法，会从你传入的接口 Class 中，『拷贝』类结构信息到一个新的 Class 对象中，但新的 Class 对象带有构造器，是可以创建对象的。打个比方，一个大内太监（接口Class），空有一身武艺（类信息），但是无法传给后人。现在江湖上有个妙手神医（Proxy类），发明了克隆大法（getProxyClass），不仅能克隆太监的一身武艺，还保留了小DD（构造器）。</p><p>所以，一旦我们明确接口，完全可以通过接口的Class对象，创建一个代理Class，通过代理Class即可创建代理对象。</p><p>大体思路如下：</p><div class="center-img"><p><img src="/img/java-proxy-1588601750.png"></p></div><p>其中静态代理的机制如下：</p><div class="center-img"><p><img src="/img/java-proxy-1588602762.png"></p></div><p>动态代理的机制如下：</p><div class="center-img"><p><img src="/img/java-proxy-1588603762.png"></p></div><p>所以，<code>Proxy.getProxyClass()</code>这个方法的本质就是：<strong>用 Class 来制造 Class</strong></p><p>但在实际开发中，一般都会使用<code>Proxy.newProxyInstance()</code>直接返回代理实例，中间的过程全部隐藏。</p><p>还是来看刚才电影院的例子。使用动态代理的话，应该是下面这种方式：</p><pre><code class="java">Movie proxyMovie = (Movie)Proxy.newProxyInstance(        Movie.class.getClassLoader(),        new Class&lt;?&gt;[] &#123; Movie.class &#125; ,        new InvocationHandler() &#123;            @Override            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;                System.out.println(&quot;得了痔疮怎么办？大铁棍子医院找捅主任！&quot;);                Movie movie = new AMovie();                method.invoke(movie, args);                System.out.println(&quot;得了痔疮怎么办？大铁棍子医院找捅主任！&quot;);                return null;            &#125;        &#125;);proxyMovie.play();</code></pre><p>可以看出，我们已经不再需要静态代理类『Cinema』了，可以直接想怎么玩就怎么玩了，甚至我可以不调用<code>method.invoke()</code>方法，让<code>proxyMovie.play()</code>时，不再调用<code>AMovie.play()</code>方法，直接全程广告！</p><pre><code class="java">Movie proxyMovie = (Movie)Proxy.newProxyInstance(        Movie.class.getClassLoader(),        new Class&lt;?&gt;[] &#123; Movie.class &#125; ,        new InvocationHandler() &#123;            @Override            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;                System.out.println(&quot;得了痔疮怎么办？大铁棍子医院找捅主任！&quot;);                // Movie movie = new AMovie();                // method.invoke(movie, args);                System.out.println(&quot;得了痔疮怎么办？大铁棍子医院找捅主任！&quot;);                return null;            &#125;        &#125;);proxyMovie.play();</code></pre><p>输入结果就如下：</p><pre><code>得了痔疮怎么办？大铁棍子医院找捅主任！得了痔疮怎么办？大铁棍子医院找捅主任！</code></pre><p>真是干(sang)得(xin)漂(bing)亮(kuang)。有了动态代理机制，可以在原有接口和被代理类的基础上<strong>做出任何拓展</strong>，而<strong>不会影响到原有接口和被代理类</strong>。而且还省掉了一个代理类。</p><p>如果新添加了一部电影（被代理类）叫BMovie，那么我就得改<code>invoke()</code>方法了，这种方法忒差劲，我们可以改进一下：</p><pre><code class="java">public static void main(String[] args) throws Exception &#123;    Movie aMovie = (Movie)getProxy(new AMovie());    Movie bMovie = (Movie)getProxy(new BMovie());    aMovie.play();    bMovie.play();&#125;private static Object getProxy(final Object target) throws Exception &#123;    return Proxy.newProxyInstance(target.getClass().getClassLoader(),            target.getClass().getInterfaces(),            new InvocationHandler() &#123;                @Override                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;                    System.out.println(&quot;得了痔疮怎么办？大铁棍子医院找捅主任！&quot;);                    method.invoke(target, args);                    System.out.println(&quot;得了痔疮怎么办？大铁棍子医院找捅主任！&quot;);                    return null;                &#125;            &#125;);&#125;</code></pre><p>就可以输出下面的结果：</p><pre><code>得了痔疮怎么办？大铁棍子医院找捅主任！正在播放电影 -《指环王》得了痔疮怎么办？大铁棍子医院找捅主任！得了痔疮怎么办？大铁棍子医院找捅主任！正在播放电影 -《断背山》得了痔疮怎么办？大铁棍子医院找捅主任！</code></pre><h2 id="为何要使用动态代理机制"><a href="#为何要使用动态代理机制" class="headerlink" title="为何要使用动态代理机制"></a>为何要使用动态代理机制</h2><ol><li>设计模式中有一个设计原则是<strong>开闭原则</strong>，是说对修改关闭，对扩展开放。我们在工作中有时会接手很多前人的代码，里面代码逻辑让人摸不着头脑，这时就很难去下手修改代码，那么这时我们就可以通过代理对类进行增强。</li><li>实现无侵入式的代码扩展，也就是<strong>方法的增强</strong>。同时让你可以在不用修改源码的情况下，增强一些方法，甚至在方法的前后你可以做你任何想做的事情（甚至不去执行这个方法都可以）。</li><li>采用动态代理的机制可以实现面向切面编程。</li></ol><h2 id="动态代理的实现原理"><a href="#动态代理的实现原理" class="headerlink" title="动态代理的实现原理"></a>动态代理的实现原理</h2><p>上面的例子中，我们是通过<code>Proxy.newInstance()</code>来创建的代理对象，我们来看看它是如何实现的：</p><pre><code class="java">// java.lang.reflect.Proxy.javapublic static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)        throws IllegalArgumentException &#123;    Objects.requireNonNull(h);    final Class&lt;?&gt;[] intfs = interfaces.clone();    // Android 中会移除下面几行代码：SecurityManager 相关    final SecurityManager sm = System.getSecurityManager();    if (sm != null) &#123;        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);    &#125;    // 查找或者生成指定的代理类    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);    // 使用指定的调用者调用它的构造函数    try &#123;        if (sm != null) &#123;            checkNewProxyPermission(Reflection.getCallerClass(), cl);        &#125;        final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);        final InvocationHandler ih = h;        if (!Modifier.isPublic(cl.getModifiers())) &#123;            AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;                public Void run() &#123;                    cons.setAccessible(true);                    return null;                &#125;            &#125;);        &#125;        return cons.newInstance(new Object[]&#123;h&#125;);    &#125; catch (IllegalAccessException|InstantiationException e) &#123;        throw new InternalError(e.toString(), e);    &#125; catch (InvocationTargetException e) &#123;        Throwable t = e.getCause();        if (t instanceof RuntimeException) &#123;            throw (RuntimeException) t;        &#125; else &#123;            throw new InternalError(t.toString(), t);        &#125;    &#125; catch (NoSuchMethodException e) &#123;        throw new InternalError(e.toString(), e);    &#125;&#125;</code></pre><p>上方代码中，<code>getProxyClass0()</code>方法如下：</p><pre><code class="java">// java.lang.reflect.Proxy.java// 生成代理类。在调用这里之前，必须要先调用 checkProxyAccess() 方法private static Class&lt;?&gt; getProxyClass0(ClassLoader loader,                                        Class&lt;?&gt;... interfaces) &#123;    if (interfaces.length &gt; 65535) &#123;        throw new IllegalArgumentException(&quot;interface limit exceeded&quot;);    &#125;    // 如果指定接口的代理类已经存在于缓存 proxyClassCache 中，直接从缓存中取了返回即可；    // 如果缓存中没有指定代理对象，则通过 ProxyClassFactory 来创建一个代理类。    return proxyClassCache.get(loader, interfaces);&#125;</code></pre><p>继续看 ProxyClassFactory 是怎样创建代理类的：</p><pre><code class="java">// java.lang.reflect.Proxy.java/** * 一个工厂方法，给定 ClassLoader 和 interface 的列表之后，可以创建、定义并返回代理类 */private static final class ProxyClassFactory    implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;&#123;    // 所有的代理类名前缀给它搞成 &quot;$Proxy&quot;    private static final String proxyClassNamePrefix = &quot;$Proxy&quot;;    // 每个代理类名生成时再来个数字编号    private static final AtomicLong nextUniqueNumber = new AtomicLong();    @Override    public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;        Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = new IdentityHashMap&lt;&gt;(interfaces.length);        for (Class&lt;?&gt; intf : interfaces) &#123;            Class&lt;?&gt; interfaceClass = null;            try &#123;                // 用Class.forName 查找一下给定的接口是否存在                interfaceClass = Class.forName(intf.getName(), false, loader);            &#125; catch (ClassNotFoundException e) &#123;            &#125;            // 然后对比 apply 中传入的 class 是否与 ClassLoader 中找到的 class 是否相同            if (interfaceClass != intf) &#123;                throw new IllegalArgumentException(                    intf + &quot; is not visible from class loader&quot;);            &#125;            // 验证这个 class 是不是接口            if (!interfaceClass.isInterface()) &#123;                throw new IllegalArgumentException(                    interfaceClass.getName() + &quot; is not an interface&quot;);            &#125;            // 验证这个 class 的唯一性            if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) &#123;                throw new IllegalArgumentException(                    &quot;repeated interface: &quot; + interfaceClass.getName());            &#125;        &#125;        String proxyPkg = null;     // 要生成的代理类的包名        int accessFlags = Modifier.PUBLIC | Modifier.FINAL;        // 记录下一个非 public 的 class 的包名，代理类也将会被定义在这个包里。        // 同时验证所有的非 public 的 class 都在这个包里。        for (Class&lt;?&gt; intf : interfaces) &#123;            int flags = intf.getModifiers();            if (!Modifier.isPublic(flags)) &#123;                accessFlags = Modifier.FINAL;                String name = intf.getName();                int n = name.lastIndexOf(&#39;.&#39;);                String pkg = ((n == -1) ? &quot;&quot; : name.substring(0, n + 1));                if (proxyPkg == null) &#123;                    proxyPkg = pkg;                &#125; else if (!pkg.equals(proxyPkg)) &#123;                    throw new IllegalArgumentException(                        &quot;non-public interfaces from different packages&quot;);                &#125;            &#125;        &#125;        // 如果没有非 public 的 class，就使用 com.sun.proxy 包        if (proxyPkg == null) &#123;            proxyPkg = ReflectUtil.PROXY_PACKAGE + &quot;.&quot;;        &#125;        // 搞个名字给这个代理类        long num = nextUniqueNumber.getAndIncrement();        String proxyName = proxyPkg + proxyClassNamePrefix + num;        // 生成这个代理类的字节码        byte[] proxyClassFile = ProxyGenerator.generateProxyClass(            proxyName, interfaces, accessFlags);        try &#123;            // 调用 native 方法            // private static native Class&lt;?&gt; defineClass0(ClassLoader loader, String name,            //                                   byte[] b, int off, int len);            return defineClass0(loader, proxyName,                                proxyClassFile, 0, proxyClassFile.length);        &#125; catch (ClassFormatError e) &#123;            /*                * A ClassFormatError here means that (barring bugs in the                * proxy class generation code) there was some other                * invalid aspect of the arguments supplied to the proxy                * class creation (such as virtual machine limitations                * exceeded).                */            throw new IllegalArgumentException(e.toString());        &#125;    &#125;&#125;</code></pre><p>看来主要生成 class 的过程在<code>ProxyGenerator.generateProxyClass()</code>中，继续跟踪：</p><pre><code class="java">// sun.misc.ProxyGenerator.java// 此处是 Java 的一个系统变量，是否要保存生成的文件private static final boolean saveGeneratedFiles = (Boolean)AccessController.doPrivileged(new GetBooleanAction(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;));public static byte[] generateProxyClass(final String var0, Class&lt;?&gt;[] var1, int var2) &#123;    ProxyGenerator var3 = new ProxyGenerator(var0, var1, var2);    // 生成字节码文件    final byte[] var4 = var3.generateClassFile();    if (saveGeneratedFiles) &#123;        AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;            public Void run() &#123;                try &#123;                    int var1 = var0.lastIndexOf(46);                    Path var2;                    if (var1 &gt; 0) &#123;                        Path var3 = Paths.get(var0.substring(0, var1).replace(&#39;.&#39;, File.separatorChar));                        Files.createDirectories(var3);                        var2 = var3.resolve(var0.substring(var1 + 1, var0.length()) + &quot;.class&quot;);                    &#125; else &#123;                        var2 = Paths.get(var0 + &quot;.class&quot;);                    &#125;                    Files.write(var2, var4, new OpenOption[0]);                    return null;                &#125; catch (IOException var4x) &#123;                    throw new InternalError(&quot;I/O exception saving generated file: &quot; + var4x);                &#125;            &#125;        &#125;);    &#125;    return var4;&#125;// 生成 class 文件private byte[] generateClassFile() &#123;    // 将 Object 中的一些方法添加到代理类中    this.addProxyMethod(hashCodeMethod, Object.class);    this.addProxyMethod(equalsMethod, Object.class);    this.addProxyMethod(toStringMethod, Object.class);    Class[] var1 = this.interfaces;    int var2 = var1.length;    int var3;    Class var4;    for(var3 = 0; var3 &lt; var2; ++var3) &#123;        var4 = var1[var3];        Method[] var5 = var4.getMethods();        int var6 = var5.length;        // 将 interface 中的方法添加到代理类中        for(int var7 = 0; var7 &lt; var6; ++var7) &#123;            Method var8 = var5[var7];            this.addProxyMethod(var8, var4);        &#125;    &#125;    Iterator var11 = this.proxyMethods.values().iterator();    List var12;    while(var11.hasNext()) &#123;        var12 = (List)var11.next();        checkReturnTypes(var12);    &#125;    Iterator var15;    try &#123;        // 添加构造函数        this.methods.add(this.generateConstructor());        var11 = this.proxyMethods.values().iterator();        while(var11.hasNext()) &#123;            var12 = (List)var11.next();            var15 = var12.iterator();            while(var15.hasNext()) &#123;                ProxyGenerator.ProxyMethod var16 = (ProxyGenerator.ProxyMethod)var15.next();                this.fields.add(new ProxyGenerator.FieldInfo(var16.methodFieldName, &quot;Ljava/lang/reflect/Method;&quot;, 10));                this.methods.add(var16.generateMethod());            &#125;        &#125;        // 添加静态方法        this.methods.add(this.generateStaticInitializer());    &#125; catch (IOException var10) &#123;        throw new InternalError(&quot;unexpected I/O Exception&quot;, var10);    &#125;    if (this.methods.size() &gt; 65535) &#123;        throw new IllegalArgumentException(&quot;method limit exceeded&quot;);    &#125; else if (this.fields.size() &gt; 65535) &#123;        throw new IllegalArgumentException(&quot;field limit exceeded&quot;);    &#125; else &#123;        this.cp.getClass(dotToSlash(this.className));        this.cp.getClass(&quot;java/lang/reflect/Proxy&quot;);        var1 = this.interfaces;        var2 = var1.length;        for(var3 = 0; var3 &lt; var2; ++var3) &#123;            var4 = var1[var3];            this.cp.getClass(dotToSlash(var4.getName()));        &#125;        this.cp.setReadOnly();        ByteArrayOutputStream var13 = new ByteArrayOutputStream();        DataOutputStream var14 = new DataOutputStream(var13);        try &#123;            var14.writeInt(-889275714);            var14.writeShort(0);            var14.writeShort(49);            this.cp.write(var14);            var14.writeShort(this.accessFlags);            var14.writeShort(this.cp.getClass(dotToSlash(this.className)));            var14.writeShort(this.cp.getClass(&quot;java/lang/reflect/Proxy&quot;));            var14.writeShort(this.interfaces.length);            Class[] var17 = this.interfaces;            int var18 = var17.length;            for(int var19 = 0; var19 &lt; var18; ++var19) &#123;                Class var22 = var17[var19];                var14.writeShort(this.cp.getClass(dotToSlash(var22.getName())));            &#125;            var14.writeShort(this.fields.size());            var15 = this.fields.iterator();            while(var15.hasNext()) &#123;                ProxyGenerator.FieldInfo var20 = (ProxyGenerator.FieldInfo)var15.next();                var20.write(var14);            &#125;            var14.writeShort(this.methods.size());            var15 = this.methods.iterator();            while(var15.hasNext()) &#123;                ProxyGenerator.MethodInfo var21 = (ProxyGenerator.MethodInfo)var15.next();                var21.write(var14);            &#125;            var14.writeShort(0);            return var13.toByteArray();        &#125; catch (IOException var9) &#123;            throw new InternalError(&quot;unexpected I/O Exception&quot;, var9);        &#125;    &#125;&#125;private void addProxyMethod(Method var1, Class&lt;?&gt; var2) &#123;    String var3 = var1.getName();    Class[] var4 = var1.getParameterTypes();    Class var5 = var1.getReturnType();    Class[] var6 = var1.getExceptionTypes();    String var7 = var3 + getParameterDescriptors(var4);    Object var8 = (List)this.proxyMethods.get(var7);    if (var8 != null) &#123;        Iterator var9 = ((List)var8).iterator();        while(var9.hasNext()) &#123;            ProxyGenerator.ProxyMethod var10 = (ProxyGenerator.ProxyMethod)var9.next();            if (var5 == var10.returnType) &#123;                ArrayList var11 = new ArrayList();                collectCompatibleTypes(var6, var10.exceptionTypes, var11);                collectCompatibleTypes(var10.exceptionTypes, var6, var11);                var10.exceptionTypes = new Class[var11.size()];                var10.exceptionTypes = (Class[])var11.toArray(var10.exceptionTypes);                return;            &#125;        &#125;    &#125; else &#123;        var8 = new ArrayList(3);        this.proxyMethods.put(var7, var8);    &#125;    ((List)var8).add(new ProxyGenerator.ProxyMethod(var3, var4, var5, var6, var2));&#125;</code></pre><p>字节码生成之后，调用 native 方法<code>defineClass0()</code>来解析字节码，生成了代理类。</p><p>native 层的具体实现<a href="https://stackoverflow.com/questions/40217559/how-to-find-the-native-method-from-the-jvm-source-code">看这个链接</a></p><p>用一个流程图来总结一下：</p><div style="width: 100%; text-align:center;"><p><img src="/img/29.png"></p></div>]]></content>
      
      
      <categories>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> Java </tag>
            
            <tag> 动态代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 基础面试题</title>
      <link href="/2019-11-30/java-junior-interview/"/>
      <url>/2019-11-30/java-junior-interview/</url>
      
        <content type="html"><![CDATA[<p>集合了一些 Java 的基础面试题。</p><span id="more"></span><h2 id="一、面向对象-（⭐⭐⭐）"><a href="#一、面向对象-（⭐⭐⭐）" class="headerlink" title="一、面向对象 （⭐⭐⭐）"></a>一、面向对象 （⭐⭐⭐）</h2><h3 id="1、谈谈对java多态的理解？"><a href="#1、谈谈对java多态的理解？" class="headerlink" title="1、谈谈对java多态的理解？"></a>1、谈谈对java多态的理解？</h3><p>多态是指父类的某个方法被子类重写时，可以产生自己的功能行为，同一个操作作用于不同对象，可以有不同的解释，产生不同的执行结果。</p><p>多态的三个必要条件：</p><ul><li>继承父类。</li><li>重写父类的方法。</li><li>父类的引用指向子类对象。</li></ul><p>什么是多态</p><p><strong>面向对象的三大特性：封装、继承、多态。</strong> 从一定角度来看，封装和继承几乎都是为多态而准备的。这是我们最后一个概念，也是最重要的知识点。</p><p><strong>多态的定义：</strong> 指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式（发送消息就是指函数调用）。</p><p><strong>实现多态的技术称为：</strong> 动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。</p><p><strong>多态的作用：</strong> 消除类型之间的耦合关系。</p><p>现实中，关于多态的例子不胜枚举。比方说按下 F1 键这个动作，如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档；如果当前在 Word 下弹出的就是 Word 帮助；在 Windows 下弹出的就是 Windows 帮助和支持。同一个事件发生在不同的对象上会产生不同的结果。</p><p>多态的好处：</p><p>1.可替换性（substitutability）。多态对已存在代码具有可替换性。例如，多态对圆Circle类工作，对其他任何圆形几何体，如圆环，也同样工作。</p><p>2.可扩充性（extensibility）。多态对代码具有可扩充性。增加新的子类不影响已存在类的多态性、继承性，以及其他特性的运行和操作。实际上新加子类更容易获得多态功能。例如，在实现了圆锥、半圆锥以及半球体的多态基础上，很容易增添球体类的多态性。</p><p>3.接口性（interface-ability）。多态是超类通过方法签名，向子类提供了一个共同接口，由子类来完善或者覆盖它而实现的。</p><p>4.灵活性（flexibility）。它在应用中体现了灵活多样的操作，提高了使用效率。</p><p>5.简化性（simplicity）。多态简化对应用软件的代码编写和修改过程，尤其在处理大量对象的运算和操作时，这个特点尤为突出和重要。</p><p>Java中多态的实现方式：接口实现，继承父类进行方法重写，同一个类中进行方法重载。</p><h3 id="2、你所知道的设计模式有哪些？"><a href="#2、你所知道的设计模式有哪些？" class="headerlink" title="2、你所知道的设计模式有哪些？"></a>2、你所知道的设计模式有哪些？</h3><p>答：Java 中一般认为有23种设计模式，我们不需要所有的都会，但是其中常用的种设计模式应该去掌握。下面列出了所有的设计模式。要掌握的设计模式我单独列出来了，当然能掌握的越多越好。</p><p>总体来说设计模式分为三大类：</p><p><strong>创建型模式</strong>，共五种：</p><ol><li>工厂方法模式</li><li>抽象工厂模式</li><li>单例模式</li><li>建造者模式</li><li>原型模式</li></ol><p><strong>结构型模式</strong>，共七种：</p><ol><li>适配器模式</li><li>装饰器模式</li><li>代理模式</li><li>外观模式</li><li>桥接模式</li><li>组合模式</li><li>享元模式</li></ol><p><strong>行为型模式</strong>，共十一种：</p><ol><li>策略模式</li><li>模板方法模式</li><li>观者模式</li><li>迭代子模式</li><li>责任链模式</li><li>命令模式</li><li>备忘录模式</li><li>状态模式</li><li>访问者模式</li><li>中介者模式</li><li>解释器模式</li></ol><p><a href="/design-pattern-must/">具体可见我的设计模式总结笔记</a></p><h3 id="3、通过静态内部类实现单例模式有哪些优点？"><a href="#3、通过静态内部类实现单例模式有哪些优点？" class="headerlink" title="3、通过静态内部类实现单例模式有哪些优点？"></a>3、通过静态内部类实现单例模式有哪些优点？</h3><ol><li>不用<code>synchronized</code>，节省时间。 </li><li>调用<code>getInstance()</code>的时候才会创建对象，不调用不创建，节省空间，这有点像懒汉式。</li></ol><h3 id="4、静态代理和动态代理的区别，什么场景使用？"><a href="#4、静态代理和动态代理的区别，什么场景使用？" class="headerlink" title="4、静态代理和动态代理的区别，什么场景使用？"></a>4、静态代理和动态代理的区别，什么场景使用？</h3><p>静态代理与动态代理的区别在于代理类生成的时间不同，即根据程序运行前代理类是否已经存在，可以将代理分为静态代理和动态代理。如果需要对多个类进行代理，并且代理的功能都是一样的，用静态代理重复编写代理类就非常的麻烦，可以用动态代理动态的生成代理类。</p><pre><code class="java">// 为目标对象生成代理对象public Object getProxyInstance() &#123;    return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(),            new InvocationHandler() &#123;                @Override                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;                    System.out.println(&quot;开启事务&quot;);                    // 执行目标对象方法                    Object returnValue = method.invoke(target, args);                    System.out.println(&quot;提交事务&quot;);                    return null;                &#125;            &#125;);&#125;</code></pre><ul><li>静态代理使用场景：四大组件同AIDL与AMS进行跨进程通信</li><li>动态代理使用场景：Retrofit使用了动态代理极大地提升了扩展性和可维护性。</li></ul><h3 id="5、简单工厂、工厂方法、抽象工厂、Builder模式的区别？"><a href="#5、简单工厂、工厂方法、抽象工厂、Builder模式的区别？" class="headerlink" title="5、简单工厂、工厂方法、抽象工厂、Builder模式的区别？"></a>5、简单工厂、工厂方法、抽象工厂、Builder模式的区别？</h3><ul><li>简单工厂模式：一个工厂方法创建不同类型的对象。</li><li>工厂方法模式：一个具体的工厂类负责创建一个具体对象类型。</li><li>抽象工厂模式：一个具体的工厂类负责创建一系列相关的对象。</li><li>Builder模式：对象的构建与表示分离，它更注重对象的创建过程。</li></ul><h3 id="6、装饰模式和代理模式有哪些区别-？与桥接模式相比呢？"><a href="#6、装饰模式和代理模式有哪些区别-？与桥接模式相比呢？" class="headerlink" title="6、装饰模式和代理模式有哪些区别 ？与桥接模式相比呢？"></a>6、装饰模式和代理模式有哪些区别 ？与桥接模式相比呢？</h3><ol><li>装饰模式是以客户端透明的方式扩展对象的功能，是继承关系的一个替代方案；而代理模式则是给一个对象提供一个代理对象，并由代理对象来控制对原有对象的引用。</li><li>装饰模式应该为所装饰的对象增强功能；代理模式对代理的对象施加控制，但不对对象本身的功能进行增加。</li><li>桥接模式的作用于代理、装饰截然不同，它主要是为了应对某个类族有多个变化维度导致子类类型急剧增多的场景。通过桥接模式将多个变化维度隔离开，使得它们可以独立地变化，最后通过组合使它们应对多维变化，减少子类的数量和复杂度。</li></ol><h3 id="7、外观模式和中介模式的区别？"><a href="#7、外观模式和中介模式的区别？" class="headerlink" title="7、外观模式和中介模式的区别？"></a>7、外观模式和中介模式的区别？</h3><p>外观模式重点是对外封装统一的高层接口，便于用户使用；而中介模式则是避免多个互相协作的对象直接引用，它们之间的交互通过一个中介对象进行，从而使得它们耦合松散，能够易于应对变化。</p><h3 id="8、策略模式和状态模式的区别？"><a href="#8、策略模式和状态模式的区别？" class="headerlink" title="8、策略模式和状态模式的区别？"></a>8、策略模式和状态模式的区别？</h3><p>虽然两者的类型结构是一致的，但是它们的本质却是不一样的。策略模式重在整个算法的替换，也就是策略的替换，而状态模式则是通过状态来改变行为。</p><h3 id="9、适配器模式，装饰者模式，外观模式的异同？"><a href="#9、适配器模式，装饰者模式，外观模式的异同？" class="headerlink" title="9、适配器模式，装饰者模式，外观模式的异同？"></a>9、适配器模式，装饰者模式，外观模式的异同？</h3><p>这三个模式的相同之处是，它们都作用于用户与真实被使用的类或系统之间，作一个中间层，起到了让用户间接地调用真实的类的作用。它们的不同之外在于，如上所述的应用场合不同和本质的思想不同。</p><p>代理与外观的主要区别在于，代理对象代表一个单一对象，而外观对象代表一个子系统，代理的客户对象无法直接访问对象，由代理提供单独的目标对象的访问，而通常外观对象提供对子系统各元件功能的简化的共同层次的调用接口。代理是一种原来对象的代表，其它需要与这个对象打交道的操作都是和这个代表交涉的。而适配器则不需要虚构出一个代表者，只需要为应付特定使用目的，将原来的类进行一些组合。</p><p>外观与适配器都是对现存系统的封装。外观定义的新的接口，而适配器则是复用一个原有的接口，适配器是使两个已有的接口协同工作，而外观则是为现存系统提供一个更为方便的访问接口。如果硬要说外观是适配，那么适配器有用来适配对象的，而外观是用来适配整个子系统的。也就是说，外观所针对的对象的粒度更大。</p><p>代理模式提供与真实的类一致的接口，意在用代理类来处理真实的类，实现一些特定的服务或真实类的部分功能，Facade（外观）模式注重简化接口，Adapter（适配器）模式注重转换接口。</p><h3 id="10、代码的坏味道："><a href="#10、代码的坏味道：" class="headerlink" title="10、代码的坏味道："></a>10、代码的坏味道：</h3><ol><li><strong>代码重复。</strong> 代码重复几乎是最常见的异味了。他也是Refactoring 的主要目标之一。代码重复往往来自于copy-and-paste 的编程风格。</li><li><strong>方法过长。</strong> 一个方法应当具有自我独立的意图，不要把几个意图放在一起。</li><li><strong>类提供的功能太多。</strong> 把太多的责任交给了一个类，一个类应该仅提供一个单一的功能。</li><li><strong>数据泥团。</strong> 某些数据通常像孩子一样成群玩耍：一起出现在很多类的成员变量中，一起出现在许多方法的参数中…..，这些数据或许应该自己独立形成对象。 比如以单例的形式对外提供自己的实例。</li><li><strong>冗赘类。</strong> 一个干活不多的类。类的维护需要额外的开销，如果一个类承担了太少的责任，应当消除它。 </li><li><strong>需要太多注释。</strong> 经常觉得要写很多注释表示你的代码难以理解。如果这种感觉太多，表示你需要Refactoring。 </li></ol><h3 id="11、是否能从Android中举几个例子说说用到了什么设计模式-？"><a href="#11、是否能从Android中举几个例子说说用到了什么设计模式-？" class="headerlink" title="11、是否能从Android中举几个例子说说用到了什么设计模式 ？"></a>11、是否能从Android中举几个例子说说用到了什么设计模式 ？</h3><h4 id="AlertDialog、Notification源码中使用了Bulider（建造者）模式完成参数的初始化："><a href="#AlertDialog、Notification源码中使用了Bulider（建造者）模式完成参数的初始化：" class="headerlink" title="AlertDialog、Notification源码中使用了Bulider（建造者）模式完成参数的初始化："></a>AlertDialog、Notification源码中使用了Bulider（建造者）模式完成参数的初始化：</h4><p>在 AlertDialog 的 Builder 模式中并没有看到 Director 角色的出现，其实在很多场景中，Android 并没有完全按照 GOF 的经典设计模式来实现，而是做了一些修改，使得这个模式更易于使用。这个的 AlertDialog.Builder 同时扮演了上下文中提到的 builder、ConcreteBuilder、Director 的角色，简化了 Builder 模式的设计。当模块比较稳定，不存在一些变化时，可以在经典模式实现的基础上做出一些精简，而不是照搬 GOF 上的经典实现，更不要生搬硬套，使程序失去架构之美。</p><ul><li>定义：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。即将配置从目标类中隔离出来，避免过多的 setter 方法。</li><li>优点：<ol><li>良好的封装性，使用建造者模式可以使客户端不必知道产品内部组成的细节。</li><li>建造者独立，容易扩展。</li></ol></li><li>缺点：<br>会产生多余的 Builder 对象以及 Director 对象，消耗内存。</li></ul><h4 id="日常开发的-BaseActivity-抽象工厂模式："><a href="#日常开发的-BaseActivity-抽象工厂模式：" class="headerlink" title="日常开发的 BaseActivity 抽象工厂模式："></a>日常开发的 BaseActivity 抽象工厂模式：</h4><p>定义：为创建一组相关或者是相互依赖的对象提供一个接口，而不需要指定它们的具体类。</p><p>主题切换的应用：</p><p>比如我们的应用中有两套主题，分别为亮色主题LightTheme和暗色主题DarkTheme，这两种主题我们可以通过一个抽象的类或接口来定义，而在对应主题下我们又有各类不同的UI元素，比如Button、TextView、Dialog、ActionBar等，这些UI元素都会分别对应不同的主题，这些UI元素我们也可以通过抽象的类或接口定义，抽象的主题、具体的主题、抽象的UI元素和具体的UI元素之间的关系就是抽象工厂模式最好的体现。</p><p>优点：</p><ul><li>分离接口与实现，面向接口编程，使其从具体的产品实现中解耦，同时基于接口与实现的分离，使抽象该工厂方法模式在切换产品类时更加灵活、容易。</li></ul><p>缺点：</p><ul><li>类文件的爆炸性增加。</li><li>新的产品类不易扩展。</li></ul><h4 id="Okhttp内部使用了责任链模式来完成每个Interceptor拦截器的调用："><a href="#Okhttp内部使用了责任链模式来完成每个Interceptor拦截器的调用：" class="headerlink" title="Okhttp内部使用了责任链模式来完成每个Interceptor拦截器的调用："></a>Okhttp内部使用了责任链模式来完成每个Interceptor拦截器的调用：</h4><p>定义：使多个对象都有机会处理请求，从而避免了请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。</p><p>ViewGroup事件传递的递归调用就类似一条责任链，一旦其寻找到责任者，那么将由责任者持有并消费掉该次事件，具体体现在View的onTouchEvent方法中返回值的设置，如果onTouchEvent返回false，那么意味着当前View不会是该次事件的责任人，将不会对其持有；如果为true则相反，此时View会持有该事件并不再向下传递。</p><p>优点：</p><p>将请求者和处理者关系解耦，提供代码的灵活性。</p><p>缺点：</p><p>对链中请求处理者的遍历中，如果处理者太多，那么遍历必定会影响性能，特别是在一些递归调用中，要慎重。</p><h4 id="RxJava的观察者模式："><a href="#RxJava的观察者模式：" class="headerlink" title="RxJava的观察者模式："></a>RxJava的观察者模式：</h4><p>定义：定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。</p><p>ListView/RecyclerView的Adapter的notifyDataSetChanged方法、广播、事件总线机制。</p><p>观察者模式主要的作用就是对象解耦，将观察者与被观察者完全隔离，只依赖于Observer和Observable抽象。</p><p>优点：</p><ul><li>观察者和被观察者之间是抽象耦合，应对业务变化。</li><li>增强系统灵活性、可扩展性。</li></ul><p>缺点：</p><ul><li>在Java中消息的通知默认是顺序执行，一个观察者卡顿，会影响整体的执行效率，在这种情况下，一般考虑采用异步的方式。</li></ul><h4 id="AIDL代理模式："><a href="#AIDL代理模式：" class="headerlink" title="AIDL代理模式："></a>AIDL代理模式：</h4><p>定义：为其他对象提供一种代理以控制对这个对象的访问。</p><p>静态代理：代码运行前代理类的class编译文件就已经存在。</p><p>动态代理：通过反射动态地生成代理者的对象。代理谁将会在执行阶段决定。将原来代理类所做的工作由InvocationHandler来处理。</p><p>使用场景：</p><ul><li>当无法或不想直接访问某个对象或访问某个对象存在困难时可以通过一个代理对象来间接访问，为了保证客户端使用的透明性，委托对象与代理对象需要实现相同的接口。</li></ul><p>缺点：</p><ul><li>对类的增加。</li></ul><h4 id="ListView-RecyclerView-GridView的适配器模式："><a href="#ListView-RecyclerView-GridView的适配器模式：" class="headerlink" title="ListView/RecyclerView/GridView的适配器模式："></a>ListView/RecyclerView/GridView的适配器模式：</h4><p>适配器模式把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。</p><p>使用场景：</p><ul><li>接口不兼容。</li><li>想要建立一个可以重复使用的类。</li><li>需要一个统一的输出接口，而输入端的类型不可预知。</li></ul><p>优点：</p><ul><li>更好的复用性：复用现有的功能。</li><li>更好的扩展性：扩展现有的功能。</li></ul><p>缺点：</p><ul><li>过多地使用适配器，会让系统非常零乱，不易于整体把握。例如，明明看到调用的是A接口，其实内部被适配成了B接口的实现，一个系统如果出现太多这种情况，无异于一场灾难。</li></ul><h4 id="Context-ContextImpl外观模式："><a href="#Context-ContextImpl外观模式：" class="headerlink" title="Context/ContextImpl外观模式："></a>Context/ContextImpl外观模式：</h4><p>要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行，门面模式提供一个高层次的接口，使得子系统更易于使用。</p><p>使用场景：</p><ul><li>为一个复杂子系统提供一个简单接口。</li></ul><p>优点：</p><ul><li>对客户程序隐藏子系统细节，因而减少了客户对于子系统的耦合，能够拥抱变化。</li><li>外观类对子系统的接口封装，使得系统更易用使用。</li></ul><p>缺点：</p><ul><li>外观类接口膨胀。</li><li>外观类没有遵循开闭原则，当业务出现变更时，可能需要直接修改外观类。</li></ul><h2 id="二、集合框架-（⭐⭐⭐）"><a href="#二、集合框架-（⭐⭐⭐）" class="headerlink" title="二、集合框架 （⭐⭐⭐）"></a>二、集合框架 （⭐⭐⭐）</h2><h3 id="1、集合框架，list，map，set都有哪些具体的实现类，区别都是什么"><a href="#1、集合框架，list，map，set都有哪些具体的实现类，区别都是什么" class="headerlink" title="1、集合框架，list，map，set都有哪些具体的实现类，区别都是什么?"></a>1、集合框架，list，map，set都有哪些具体的实现类，区别都是什么?</h3><p>Java集合里使用接口来定义功能，是一套完善的继承体系。Iterator 是所有集合的总接口，其他所有接口都继承于它，该接口定义了集合的遍历操作，Collection 接口继承于 Iterator，是集合的次级接口（Map 独立存在），定义了集合的一些通用操作。</p><h4 id="Java集合的类结构图如下所示："><a href="#Java集合的类结构图如下所示：" class="headerlink" title="Java集合的类结构图如下所示："></a>Java集合的类结构图如下所示：</h4><p><img src="http://blog.cigis-cloud.com/aaji-1591348465.png" alt="Java 集合类"></p><ul><li>List：有序、可重复；索引查询速度快；插入、删除伴随数据移动，速度慢；</li><li>Set：无序，不可重复；</li><li>Map：键值对，键唯一，值多个；</li></ul><ol><li>List、Set 都是继承自 Collection 接口，Map 则不是;</li><li>List 特点：元素<strong>有放入顺序</strong>，元素可<strong>重复</strong>;</li><li>Set 特点：元素<strong>无放入顺序</strong>，元素<strong>不可重复</strong>，重复元素会盖掉。（注意：元素虽然无放入顺序，但是元素在 Set 中位置是由该元素的 HashCode 决定的，其位置其实是固定，加入 Set 的Object必须定义equals()方法；另外 List 支持<code>for</code>循环，也就是通过下标来遍历，也可以使用迭代器，但是 Set 只能用迭代，因为他无序，无法用下标取得想要的值）。</li><li>Set 和 List 对比：<br>Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。<br>List：和数组类似，List 可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变。</li><li>Map适合储存键值对的数据。</li><li>线程安全集合类与非线程安全集合类（如下表）<table><thead><tr><th>线程不安全</th><th>线程安全</th></tr></thead><tbody><tr><td>LinkedList</td><td>Vector</td></tr><tr><td>ArrayList</td><td>HashTable</td></tr><tr><td>HashSet</td><td></td></tr><tr><td>HashMap</td><td>ConcurrentHashMap</td></tr></tbody></table></li></ol><h4 id="下面是这些类具体的使用介绍："><a href="#下面是这些类具体的使用介绍：" class="headerlink" title="下面是这些类具体的使用介绍："></a>下面是这些类具体的使用介绍：</h4><h4 id="ArrayList-与-LinkedList-的区别和适用场景"><a href="#ArrayList-与-LinkedList-的区别和适用场景" class="headerlink" title="ArrayList 与 LinkedList 的区别和适用场景"></a>ArrayList 与 LinkedList 的区别和适用场景</h4><ul><li><p>Arraylist：<br><strong>优点：</strong> ArrayList是实现了基于动态数组的数据结构,因地址连续，一旦数据存储好了，查询操作效率会比较高（在内存里是连着放的）。<br><strong>缺点：</strong> 因为地址连续，ArrayList要移动数据,所以插入和删除操作效率比较低。</p></li><li><p>LinkedList：<br><strong>优点：</strong> LinkedList 基于链表的数据结构，地址是任意的，其在开辟内存空间的时候不需要等一个连续的地址，对新增和删除操作<code>add</code>和<code>remove</code>，LinedList 比较占优势。LikedList 适用于要头尾操作或插入指定位置的场景。<br><strong>缺点：</strong> 因为 LinkedList 要移动指针,所以查询操作性能比较低。</p></li><li><p>适用场景分析：<br>当需要对数据进行对此访问的情况下选用 ArrayList，当要对数据进行多次增加删除修改时采用 LinkedList。</p></li></ul><h4 id="ArrayList-和-LinkedList-的扩容机制"><a href="#ArrayList-和-LinkedList-的扩容机制" class="headerlink" title="ArrayList 和 LinkedList 的扩容机制"></a>ArrayList 和 LinkedList 的扩容机制</h4><ul><li><p>ArrayList:<br>ArrayList 初始化大小是 10。（如果你知道你的 ArrayList 会达到多少容量，可以在初始化的时候就指定，能节省扩容的性能开支）扩容的规则是，新增的时候发现容量不够用了，就去扩容。扩容大小规则是，<code>newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)</code>。例如：原始大小是 10 ，扩容后的大小就是 10 + 5 = 15）</p></li><li><p>LinkedList:<br>LinkedList 是一个双向链表，没有初始化大小，也没有扩容的机制，就是一直在前面或者后面新增就好。</p></li></ul><h4 id="ArrayList-与-Vector-的区别和适用场景"><a href="#ArrayList-与-Vector-的区别和适用场景" class="headerlink" title="ArrayList 与 Vector 的区别和适用场景"></a>ArrayList 与 Vector 的区别和适用场景</h4><p>ArrayList有三个构造方法：</p><pre><code class="java">public ArrayList(int intinitialCapacity) // 构造一个具有指定初始容量的空列表public ArrayList() // 构造一个初始容量为10的空列表。public ArrayList(Collection&lt;? extends E&gt; c) // 构造一个包含指定 collection 的元素的列表</code></pre><p>Vector有四个构造方法：</p><pre><code class="java">public Vector() // 使用指定的初始容量和等于零的容量增量构造一个空向量public Vector(int initialCapacity) // 构造一个空向量，使其内部数据数组的大小，其标准容量增量为零public Vector(Collection&lt;? extends E&gt; c) // 构造一个包含指定 collection 中的元素的向量public Vector(int initialCapacity, int capacityIncrement) // 使用指定的初始容量和容量增量构造一个空的向量</code></pre><p>ArrayList和Vector都是用数组实现的，主要有这么四个区别：</p><p>1)Vector是多线程安全的，线程安全就是说多线程访问代码，不会产生不确定的结果。而ArrayList不是，这可以从源码中看出，Vector类中的方法很多有synchronied进行修饰，这样就导致了Vector在效率上无法与ArrayLst相比；</p><p>2)两个都是采用的线性连续空间存储元素，但是当空间充足的时候，两个类的增加方式是不同。</p><p>3)Vector可以设置增长因子，而ArrayList不可以。</p><p>4)Vector是一种老的动态数组，是线程同步的，效率很低，一般不赞成使用。</p><p>适用场景：</p><p>1.Vector是线程同步的，所以它也是线程安全的，而ArraList是线程异步的，是不安全的。如果不考虑到线程的安全因素，一般用ArrayList效率比较高。</p><p>2.如果集合中的元素的数目大于目前集合数组的长度时，在集合中使用数据量比较大的数据，用Vector有一定的优势。</p><h4 id="HashSet与TreeSet的区别和适用场景"><a href="#HashSet与TreeSet的区别和适用场景" class="headerlink" title="HashSet与TreeSet的区别和适用场景"></a>HashSet与TreeSet的区别和适用场景</h4><p>1.TreeSet 是二叉树（红黑树的树据结构）实现的，Treest中的数据是自动排好序的，不允许放入null值。</p><p>2.HashSet 是哈希表实现的，HashSet中的数据是无序的可以放入null，但只能放入一个null，两者中的值都不重复，就如数据库中唯一约束。</p><p>3.HashSet要求放入的对象必须实现HashCode()方法，放的对象，是以hashcode码作为标识的，而具有相同内容的String对象，hashcode是一样，所以放入的内容不能重复但是同一个类的对象可以放入不同的实例。</p><p>适用场景分析:</p><p>HashSet是基于Hash算法实现的，其性能通常都优于TreeSet。为快速查找而设计的Set，我们通常都应该使用HashSet，在我们需要排序的功能时，我们才使用TreeSet。</p><h4 id="HashMap与TreeMap、HashTable的区别及适用场景"><a href="#HashMap与TreeMap、HashTable的区别及适用场景" class="headerlink" title="HashMap与TreeMap、HashTable的区别及适用场景"></a>HashMap与TreeMap、HashTable的区别及适用场景</h4><p>HashMap 非线程安全  </p><p>HashMap：基于哈希表(散列表)实现。使用HashMap要求的键类明确定义了hashCode()和equals()[可以重写hasCode()和equals()]，为了优化HashMap空间的使用，您可以调优初始容量和负载因子。其中散列表的冲突处理主分两种，一种是开放定址法，另一种是链表法。HashMap实现中采用的是链表法。</p><p>TreeMap：非线程安全基于红黑树实现。TreeMap没有调优选项，因为该树总处于平衡状态。</p><p>适用场景分析：</p><p>HashMap和HashTable:HashMap去掉了HashTable的contain方法，但是加上了containsValue()和containsKey()方法。HashTable是同步的，而HashMap是非同步的，效率上比HashTable要高。HashMap允许空键值，而HashTable不允许。</p><p>HashMap：适用于Map中插入、删除和定位元素。</p><p>Treemap：适用于按自然顺序或自定义顺序遍历键(key)。<br>(ps:其实我们工作的过程中对集合的使用是很频繁的,稍注意并总结积累一下,在面试的时候应该会回答的很轻松)</p><h3 id="2、set集合从原理上如何保证不重复？"><a href="#2、set集合从原理上如何保证不重复？" class="headerlink" title="2、set集合从原理上如何保证不重复？"></a>2、set集合从原理上如何保证不重复？</h3><p>1）在往set中添加元素时，如果指定元素不存在，则添加成功。</p><p>2）具体来讲：当向HashSet中添加元素的时候，首先计算元素的hashcode值，然后用这个（元素的hashcode）%（HashMap集合的大小）+1计算出这个元素的存储位置，如果这个位置为空，就将元素添加进去；如果不为空，则用equals方法比较元素是否相等，相等就不添加，否则找一个空位添加。</p><h3 id="3、HashMap和HashTable的主要区别是什么？，两者底层实现的数据结构是什么？"><a href="#3、HashMap和HashTable的主要区别是什么？，两者底层实现的数据结构是什么？" class="headerlink" title="3、HashMap和HashTable的主要区别是什么？，两者底层实现的数据结构是什么？"></a>3、HashMap和HashTable的主要区别是什么？，两者底层实现的数据结构是什么？</h3><p>HashMap和HashTable的区别：</p><p>二者都实现了Map 接口，是将唯一的键映射到特定的值上，主要区别在于：</p><p>1)HashMap 没有排序，允许一个null 键和多个null 值,而Hashtable 不允许；</p><p>2)HashMap 把Hashtable 的contains 方法去掉了，改成containsvalue 和containsKey, 因为contains 方法容易让人引起误解；</p><p>3)Hashtable 继承自Dictionary 类，HashMap 是Java1.2 引进的Map 接口的实现；</p><p>4)Hashtable 的方法是Synchronized 的，而HashMap 不是，在多个线程访问Hashtable 时，不需要自己为它的方法实现同步，而HashMap 就必须为之提供额外的同步。Hashtable 和HashMap 采用的hash/rehash 算法大致一样，所以性能不会有很大的差异。</p><p>HashMap和HashTable的底层实现数据结构：</p><p>HashMap和Hashtable的底层实现都是数组 + 链表结构实现的（jdk8以前）</p><h3 id="4、HashMap、ConcurrentHashMap、hash-相关原理解析？"><a href="#4、HashMap、ConcurrentHashMap、hash-相关原理解析？" class="headerlink" title="4、HashMap、ConcurrentHashMap、hash()相关原理解析？"></a>4、HashMap、ConcurrentHashMap、hash()相关原理解析？</h3><h4 id="HashMap-1-7的原理："><a href="#HashMap-1-7的原理：" class="headerlink" title="HashMap 1.7的原理："></a>HashMap 1.7的原理：</h4><p>HashMap 底层是基于 数组 + 链表 组成的，不过在 jdk1.7 和 1.8 中具体实现稍有不同。</p><p>负载因子：</p><ul><li>给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</li><li>因此通常建议能提前预估 HashMap 的大小最好，尽量的减少扩容带来的性能损耗。</li></ul><p>其实真正存放数据的是 Entry&lt;K,V&gt;[] table，Entry 是 HashMap 中的一个静态内部类，它有key、value、next、hash（key的hashcode）成员变量。</p><p>put 方法：</p><ul><li>判断当前数组是否需要初始化。</li><li>如果 key 为空，则 put 一个空值进去。</li><li>根据 key 计算出 hashcode。</li><li>根据计算出的 hashcode 定位出所在桶。</li><li>如果桶是一个链表则需要遍历判断里面的 hashcode、key 是否和传入 key 相等，如果相等则进行覆盖，并返回原来的值。</li><li>如果桶是空的，说明当前位置没有数据存入，新增一个 Entry 对象写入当前位置。（当调用 addEntry 写入 Entry 时需要判断是否需要扩容。如果需要就进行两倍扩充，并将当前的 key 重新 hash 并定位。而在 createEntry 中会将当前位置的桶传入到新建的桶中，如果当前桶有值就会在位置形成链表。）</li></ul><p>get 方法：</p><ul><li>首先也是根据 key 计算出 hashcode，然后定位到具体的桶中。</li><li>判断该位置是否为链表。</li><li>不是链表就根据 key、key 的 hashcode 是否相等来返回值。</li><li>为链表则需要遍历直到 key 及 hashcode 相等时候就返回值。</li><li>啥都没取到就直接返回 null 。</li></ul><h4 id="HashMap-1-8的原理："><a href="#HashMap-1-8的原理：" class="headerlink" title="HashMap 1.8的原理："></a>HashMap 1.8的原理：</h4><p>当 Hash 冲突严重时，在桶上形成的链表会变的越来越长，这样在查询时的效率就会越来越低；时间复杂度为 O(N)，因此 1.8 中重点优化了这个查询效率。</p><p>TREEIFY_THRESHOLD 用于判断是否需要将链表转换为红黑树的阈值。</p><p>HashEntry 修改为 Node。</p><p>put 方法：</p><ul><li>判断当前桶是否为空，空的就需要初始化（在resize方法 中会判断是否进行初始化）。</li><li>根据当前 key 的 hashcode 定位到具体的桶中并判断是否为空，为空表明没有 Hash 冲突就直接在当前位置创建一个新桶即可。</li><li>如果当前桶有值（ Hash 冲突），那么就要比较当前桶中的 key、key 的 hashcode 与写入的 key 是否相等，相等就赋值给 e,在第 8 步的时候会统一进行赋值及返回。</li><li>如果当前桶为红黑树，那就要按照红黑树的方式写入数据。</li><li>如果是个链表，就需要将当前的 key、value 封装成一个新节点写入到当前桶的后面（形成链表）。</li><li>接着判断当前链表的大小是否大于预设的阈值，大于时就要转换为红黑树。</li><li>如果在遍历过程中找到 key 相同时直接退出遍历。</li><li>如果 e != null 就相当于存在相同的 key,那就需要将值覆盖。</li><li>最后判断是否需要进行扩容。</li></ul><p>get 方法：</p><ul><li>首先将 key hash 之后取得所定位的桶。</li><li>如果桶为空则直接返回 null 。</li><li>否则判断桶的第一个位置(有可能是链表、红黑树)的 key 是否为查询的 key，是就直接返回 value。</li><li>如果第一个不匹配，则判断它的下一个是红黑树还是链表。</li><li>红黑树就按照树的查找方式返回值。</li><li>不然就按照链表的方式遍历匹配返回值。</li></ul><p>修改为红黑树之后查询效率直接提高到了 O(logn)。但是 HashMap 原有的问题也都存在，比如在并发场景下使用时容易出现死循环：</p><ul><li>在 HashMap 扩容的时候会调用 resize() 方法，就是这里的并发操作容易在一个桶上形成环形链表；这样当获取一个不存在的 key 时，计算出的 index 正好是环形链表的下标就会出现死循环：在 1.7 中 hash 冲突采用的头插法形成的链表，在并发条件下会形成循环链表，一旦有查询落到了这个链表上，当获取不到值时就会死循环。</li></ul><h4 id="ConcurrentHashMap-1-7原理："><a href="#ConcurrentHashMap-1-7原理：" class="headerlink" title="ConcurrentHashMap 1.7原理："></a>ConcurrentHashMap 1.7原理：</h4><p>ConcurrentHashMap 采用了分段锁技术，其中 Segment 继承于 ReentrantLock。不会像 HashTable 那样不管是 put 还是 get 操作都需要做同步处理，理论上 ConcurrentHashMap 支持 CurrencyLevel (Segment 数组数量)的线程并发。每当一个线程占用锁访问一个 Segment 时，不会影响到其他的 Segment。</p><p>put 方法:</p><p>首先是通过 key 定位到 Segment，之后在对应的 Segment 中进行具体的 put。</p><ul><li>虽然 HashEntry 中的 value 是用 volatile 关键词修饰的，但是并不能保证并发的原子性，所以 put 操作时仍然需要加锁处理。</li><li>首先第一步的时候会尝试获取锁，如果获取失败肯定就有其他线程存在竞争，则利用 scanAndLockForPut() 自旋获取锁:</li></ul><pre><code>尝试自旋获取锁。如果重试的次数达到了 MAX_SCAN_RETRIES 则改为阻塞锁获取，保证能获取成功。</code></pre><ul><li>将当前 Segment 中的 table 通过 key 的 hashcode 定位到 HashEntry。</li><li>遍历该 HashEntry，如果不为空则判断传入的 key 和当前遍历的 key 是否相等，相等则覆盖旧的 value。</li><li>为空则需要新建一个 HashEntry 并加入到 Segment 中，同时会先判断是否需要扩容。</li><li>最后会使用unlock()解除当前 Segment 的锁。</li></ul><p>get 方法：</p><ul><li>只需要将 Key 通过 Hash 之后定位到具体的 Segment ，再通过一次 Hash 定位到具体的元素上。</li><li>由于 HashEntry 中的 value 属性是用 volatile 关键词修饰的，保证了内存可见性，所以每次获取时都是最新值。</li><li>ConcurrentHashMap 的 get 方法是非常高效的，因为整个过程都不需要加锁。</li></ul><h4 id="ConcurrentHashMap-1-8原理："><a href="#ConcurrentHashMap-1-8原理：" class="headerlink" title="ConcurrentHashMap 1.8原理："></a>ConcurrentHashMap 1.8原理：</h4><p>1.7 已经解决了并发问题，并且能支持 N 个 Segment 这么多次数的并发，但依然存在 HashMap 在 1.7 版本中的问题：那就是查询遍历链表效率太低。和 1.8 HashMap 结构类似：其中抛弃了原有的 Segment 分段锁，而采用了 CAS + synchronized 来保证并发安全性。</p><p>CAS：</p><p>如果obj内的value和expect相等，就证明没有其他线程改变过这个变量，那么就更新它为update，如果这一步的CAS没有成功，那就采用自旋的方式继续进行CAS操作。</p><p>问题：</p><ul><li>目前在JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</li><li>如果CAS不成功，则会原地自旋，如果长时间自旋会给CPU带来非常大的执行开销。</li></ul><p>put 方法：</p><ul><li>根据 key 计算出 hashcode 。</li><li>判断是否需要进行初始化。</li><li>如果当前 key 定位出的 Node为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</li><li>如果当前位置的 hashcode == MOVED == -1,则需要进行扩容。</li><li>如果都不满足，则利用 synchronized 锁写入数据。</li><li>最后，如果数量大于 TREEIFY_THRESHOLD 则要转换为红黑树。</li></ul><p>get 方法：</p><ul><li>根据计算出来的 hashcode 寻址，如果就在桶上那么直接返回值。</li><li>如果是红黑树那就按照树的方式获取值。</li><li>就不满足那就按照链表的方式遍历获取值。</li></ul><p>1.8 在 1.7 的数据结构上做了大的改动，采用红黑树之后可以保证查询效率（O(logn)），甚至取消了 ReentrantLock 改为了 synchronized，这样可以看出在新版的 JDK 中对 synchronized 优化是很到位的。</p><p><a href="https://crossoverjie.top/2018/07/23/java-senior/ConcurrentHashMap/">HashMap、ConcurrentHashMap 1.7/1.8实现原理</a></p><p><a href="https://www.hollischuang.com/archives/2091">hash()算法全解析</a></p><h4 id="HashMap何时扩容："><a href="#HashMap何时扩容：" class="headerlink" title="HashMap何时扩容："></a>HashMap何时扩容：</h4><p>当向容器添加元素的时候，会判断当前容器的元素个数，如果大于等于阈值—即大于当前数组的长度乘以加载因子的值的时候，就要自动扩容。</p><h4 id="扩容的算法是什么："><a href="#扩容的算法是什么：" class="headerlink" title="扩容的算法是什么："></a>扩容的算法是什么：</h4><p>扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组。</p><h4 id="Hashmap如何解决散列碰撞（必问）？"><a href="#Hashmap如何解决散列碰撞（必问）？" class="headerlink" title="Hashmap如何解决散列碰撞（必问）？"></a>Hashmap如何解决散列碰撞（必问）？</h4><p>Java中HashMap是利用“拉链法”处理HashCode的碰撞问题。在调用HashMap的put方法或get方法时，都会首先调用hashcode方法，去查找相关的key，当有冲突时，再调用equals方法。hashMap基于hasing原理，我们通过put和get方法存取对象。当我们将键值对传递给put方法时，他调用键对象的hashCode()方法来计算hashCode，然后找到bucket（哈希桶）位置来存储对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当碰撞发生了，对象将会存储在链表的下一个节点中。hashMap在每个链表节点存储键值对对象。当两个不同的键却有相同的hashCode时，他们会存储在同一个bucket位置的链表中。键对象的equals()来找到键值对。</p><h4 id="Hashmap底层为什么是线程不安全的？"><a href="#Hashmap底层为什么是线程不安全的？" class="headerlink" title="Hashmap底层为什么是线程不安全的？"></a>Hashmap底层为什么是线程不安全的？</h4><ul><li>并发场景下使用时容易出现死循环，在 HashMap 扩容的时候会调用 resize() 方法，就是这里的并发操作容易在一个桶上形成环形链表；这样当获取一个不存在的 key 时，计算出的 index 正好是环形链表的下标就会出现死循环；</li><li>在 1.7 中 hash 冲突采用的头插法形成的链表，在并发条件下会形成循环链表，一旦有查询落到了这个链表上，当获取不到值时就会死循环。</li></ul><h3 id="5、ArrayMap跟SparseArray在HashMap上面的改进？"><a href="#5、ArrayMap跟SparseArray在HashMap上面的改进？" class="headerlink" title="5、ArrayMap跟SparseArray在HashMap上面的改进？"></a>5、ArrayMap跟SparseArray在HashMap上面的改进？</h3><p>HashMap要存储完这些数据将要不断的扩容，而且在此过程中也需要不断的做hash运算，这将对我们的内存空间造成很大消耗和浪费。</p><h4 id="SparseArray"><a href="#SparseArray" class="headerlink" title="SparseArray:"></a>SparseArray:</h4><p>SparseArray比HashMap更省内存，在某些条件下性能更好，主要是因为它避免了对key的自动装箱（int转为Integer类型），它内部则是通过两个数组来进行数据存储的，一个存储key，另外一个存储value，为了优化性能，它内部对数据还采取了压缩的方式来表示稀疏数组的数据，从而节约内存空间，我们从源码中可以看到key和value分别是用数组表示：</p><pre><code>private int[] mKeys;private Object[] mValues;</code></pre><p>同时，SparseArray在存储和读取数据时候，使用的是二分查找法。也就是在put添加数据的时候，会使用二分查找法和之前的key比较当前我们添加的元素的key的大小，然后按照从小到大的顺序排列好，所以，SparseArray存储的元素都是按元素的key值从小到大排列好的。<br>而在获取数据的时候，也是使用二分查找法判断元素的位置，所以，在获取数据的时候非常快，比HashMap快的多。</p><h4 id="ArrayMap"><a href="#ArrayMap" class="headerlink" title="ArrayMap:"></a>ArrayMap:</h4><p>ArrayMap利用两个数组，mHashes用来保存每一个key的hash值，mArrray大小为mHashes的2倍，依次保存key和value。</p><pre><code>mHashes[index] = hash;mArray[index&lt;&lt;1] = key;mArray[(index&lt;&lt;1)+1] = value;</code></pre><p>当插入时，根据key的hashcode()方法得到hash值，计算出在mArrays的index位置，然后利用二分查找找到对应的位置进行插入，当出现哈希冲突时，会在index的相邻位置插入。</p><h4 id="假设数据量都在千级以内的情况下："><a href="#假设数据量都在千级以内的情况下：" class="headerlink" title="假设数据量都在千级以内的情况下："></a>假设数据量都在千级以内的情况下：</h4><p>1、如果key的类型已经确定为int类型，那么使用SparseArray，因为它避免了自动装箱的过程，如果key为long类型，它还提供了一个LongSparseArray来确保key为long类型时的使用</p><p>2、如果key类型为其它的类型，则使用ArrayMap。</p><h2 id="三、反射-（⭐⭐⭐）"><a href="#三、反射-（⭐⭐⭐）" class="headerlink" title="三、反射 （⭐⭐⭐）"></a>三、反射 （⭐⭐⭐）</h2><h3 id="1、说说你对Java反射的理解？"><a href="#1、说说你对Java反射的理解？" class="headerlink" title="1、说说你对Java反射的理解？"></a>1、说说你对Java反射的理解？</h3><p>答：Java 中的反射首先是能够获取到Java中要反射类的字节码， 获取字节码有三种方法：</p><p>1.Class.forName(className)</p><p>2.类名.class</p><p>3.this.getClass()。</p><p>然后将字节码中的方法，变量，构造函数等映射成相应的Method、Filed、Constructor等类，这些类提供了丰富的方法可以被我们所使用。</p><p><a href="https://www.sczyh30.com/posts/Java/java-reflection-1/">深入解析Java反射（1） - 基础</a></p><p><a href="https://blog.csdn.net/sinat_38259539/article/details/71799078">Java基础之—反射（非常重要）</a></p><h2 id="四、泛型-（⭐⭐）"><a href="#四、泛型-（⭐⭐）" class="headerlink" title="四、泛型 （⭐⭐）"></a>四、泛型 （⭐⭐）</h2><h3 id="1、简单介绍一下java中的泛型，泛型擦除以及相关的概念，解析与分派？"><a href="#1、简单介绍一下java中的泛型，泛型擦除以及相关的概念，解析与分派？" class="headerlink" title="1、简单介绍一下java中的泛型，泛型擦除以及相关的概念，解析与分派？"></a>1、简单介绍一下java中的泛型，泛型擦除以及相关的概念，解析与分派？</h3><p>泛型是Java SE1.5的新特性，泛型的本质是参数化类型，也就是说所操的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口、泛型方法。 Java语言引入泛型的好处是安全简单。</p><p>在Java SE 1.5之前，没有泛型的情况的下，通过对类型Object的引用来实现参数的“任意化”，“任意化”带来的缺点是要做显式的强制类型转换，而这种转换是要求开发者实际参数类型可以预知的情况下进行的。对于强制类型换错误的情况，编译器可能不提示错误，在运行的时候出现异常，这是一个安全隐患。</p><p>泛型的好处是在编译的时候检查类型安全，并且所有的转换都是自动和隐式的，提高代码的重用率。</p><p>1、泛型的类型参数只能是类类型（包括自定义类），不是简单类型。</p><p>2、同一种泛型可以对应多个版本（因为参数类型是不确的），不同版本的泛型类实例是不兼容的。</p><p>3、泛型的类型参数可以有多个。</p><p>4、泛型的参数类型可以使用extends语句，例如<T extends superclass>。习惯上称为“有界类型”。</p><p>5、泛型的参数类型还可以是通配符类型。例如Class&lt;?&gt; classType = Class.forName(“java.lang.String”);</p><h4 id="泛型擦除以及相关的概念"><a href="#泛型擦除以及相关的概念" class="headerlink" title="泛型擦除以及相关的概念"></a>泛型擦除以及相关的概念</h4><p>泛型信息只存在代码编译阶段，在进入JVM之前，与泛型关的信息都会被擦除掉。</p><p>在类型擦除的时候，如果泛型类里的类型参数没有指定上限，则会被转成Object类型，如果指定了上限，则会被传转换成对应的类型上限。</p><p>Java中的泛型基本上都是在编译器这个层次来实现的。生成的Java字节码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会在编译器在编译的时候擦除掉。这个过程就称为类型擦除。</p><p>类型擦除引起的问题及解决方法：</p><p>1、先检查，在编译，以及检查编译的对象和引用传递的题</p><p>2、自动类型转换</p><p>3、类型擦除与多态的冲突和解决方法</p><p>4、泛型类型变量不能是基本数据类型</p><p>5、运行时类型查询</p><p>6、异常中使用泛型的问题</p><p>7、数组（这个不属于类型擦除引起的问题）</p><p>9、类型擦除后的冲突</p><p>10、泛型在静态方法和静态类中的问题</p><h2 id="五、注解-（⭐⭐）"><a href="#五、注解-（⭐⭐）" class="headerlink" title="五、注解 （⭐⭐）"></a>五、注解 （⭐⭐）</h2><h3 id="1、说说你对Java注解的理解？"><a href="#1、说说你对Java注解的理解？" class="headerlink" title="1、说说你对Java注解的理解？"></a>1、说说你对Java注解的理解？</h3><p>注解相当于一种标记，在程序中加了注解就等于为程序打上了某种标记。程序可以利用ava的反射机制来了解你的类及各种元素上有无何种标记，针对不同的标记，就去做相应的事件。标记可以加在包，类，字段，方法，方法的参数以及局部变量上。</p><h2 id="六、其它-（⭐⭐）"><a href="#六、其它-（⭐⭐）" class="headerlink" title="六、其它 （⭐⭐）"></a>六、其它 （⭐⭐）</h2><h3 id="1、Java的char是两个字节，是怎么存Utf-8的字符的？"><a href="#1、Java的char是两个字节，是怎么存Utf-8的字符的？" class="headerlink" title="1、Java的char是两个字节，是怎么存Utf-8的字符的？"></a>1、Java的char是两个字节，是怎么存Utf-8的字符的？</h3><h4 id="是否熟悉Java-char和字符串（初级）"><a href="#是否熟悉Java-char和字符串（初级）" class="headerlink" title="是否熟悉Java char和字符串（初级）"></a>是否熟悉Java char和字符串（初级）</h4><ul><li>char是2个字节，utf-8是1~3个字节。</li><li>字符集（字符集不是编码）：ASCII码与Unicode码。</li><li>字符 -&gt; 0xd83dde00(码点）。</li></ul><h4 id="是否了解字符的映射和存储细节（中级）"><a href="#是否了解字符的映射和存储细节（中级）" class="headerlink" title="是否了解字符的映射和存储细节（中级）"></a>是否了解字符的映射和存储细节（中级）</h4><p>人类认知：字符 =&gt; 字符集：0x4e2d(char) =&gt; 计算机存储(byte)：01001110:4e、00101101:2d</p><p>编码：UTF-16</p><p>“中”.getBytes(“utf-6”); -&gt; fe ff 4e 2d：4个字节，其中前面的fe ff只是字节序标志。</p><h4 id="是否能触类旁通，横向对比其他语言（高级）"><a href="#是否能触类旁通，横向对比其他语言（高级）" class="headerlink" title="是否能触类旁通，横向对比其他语言（高级）"></a>是否能触类旁通，横向对比其他语言（高级）</h4><p>Python2的字符串：</p><ul><li>byteString = “中”</li><li>unicodeString = u”中”</li></ul><p>令人迷惑的字符串长度</p><pre><code>emoij = u&quot;表情&quot;print(len(emoji)</code></pre><p>Java与python 3.2及以下：2字节<br>python &gt;= 3.3：1字节</p><p><strong>注意：Java 9对latin字符的存储空间做了优化，但字符串长度还是!= 字符数。</strong></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>Java char不存UTF-8的字节，而是UTF-16。</li><li>Unicode通用字符集占两个字节，例如“中”。</li><li>Unicode扩展字符集需要用一对char来表示，例如“表情”。</li><li>Unicode是字符集，不是编码，作用类似于ASCII码。</li><li>Java String的length不是字符数。</li></ul><h3 id="2、Java-String可以有多长？"><a href="#2、Java-String可以有多长？" class="headerlink" title="2、Java String可以有多长？"></a>2、Java String可以有多长？</h3><h4 id="是否对字符串编解码有深入了解（中级）"><a href="#是否对字符串编解码有深入了解（中级）" class="headerlink" title="是否对字符串编解码有深入了解（中级）"></a>是否对字符串编解码有深入了解（中级）</h4><p>分配到栈：</p><pre><code>String longString = &quot;aaa...aaa&quot;;</code></pre><p>分配到堆：</p><pre><code>byte[] bytes = loadFromFile(new File(&quot;superLongText.txt&quot;);String superLongString = new String(bytes);</code></pre><h4 id="是否对字符串在内存当中的存储形式有深入了解（高级）"><a href="#是否对字符串在内存当中的存储形式有深入了解（高级）" class="headerlink" title="是否对字符串在内存当中的存储形式有深入了解（高级）"></a>是否对字符串在内存当中的存储形式有深入了解（高级）</h4><h4 id="是否对Java虚拟机字节码有足够的了解（高级）"><a href="#是否对Java虚拟机字节码有足够的了解（高级）" class="headerlink" title="是否对Java虚拟机字节码有足够的了解（高级）"></a>是否对Java虚拟机字节码有足够的了解（高级）</h4><p>源文件：*.java</p><pre><code>String longString = &quot;aaa...aaa&quot;;字节数 &lt;= 65535</code></pre><p>字节码：*.class</p><pre><code>CONSTANT_Utf8_info &#123;     u1 tag;     u2 length;    (0~65535) u1 bytes[length];     最多65535个字节 &#125;</code></pre><p>javac的编译器有问题，&lt; 65535应该改为&lt; = 65535。</p><p><strong>Java String 栈分配</strong></p><ul><li>受字节码限制，字符串最终的MUTF-8字节数不超过65535。</li><li>Latin字符，受Javac代码限制，最多65534个。</li><li>非Latin字符最终对应字节个数差异较大，最多字节个数是65535。</li><li>如果运行时方法区设置较小，也会受到方法区大小的限制。</li></ul><h4 id="是否对java虚拟机指令有一定的认识（高级）"><a href="#是否对java虚拟机指令有一定的认识（高级）" class="headerlink" title="是否对java虚拟机指令有一定的认识（高级）"></a>是否对java虚拟机指令有一定的认识（高级）</h4><p>new String(bytes)内部是采用了一个字符数组，其对应的虚拟机指令是newarray [int] ，数组理论最大个数为Integer.MAX_VALUE，有些虚拟机需要一些头部信息，所以MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8。</p><p><strong>Java String 堆分配</strong></p><ul><li>受虚拟机指令限制，字符数理论上限为Integer.MAX_VALUE。</li><li>受虚拟机实现限制，实际上限可能会小于Integer.MAX_VALUE。</li><li>如果堆内存较小，也会受到堆内存的限制。</li></ul><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p><strong>Java String字面量形式</strong></p><ul><li>字节码中CONSTANT_Utf8_info的限制</li><li>Javac源码逻辑的限制</li><li>方法区大小的限制</li></ul><p><strong>Java String运行时创建在堆上的形式</strong></p><ul><li>Java虚拟机指令newarray的限制</li><li>Java虚拟机堆内存大小的限制</li></ul><h3 id="3、Java的匿名内部类有哪些限制？"><a href="#3、Java的匿名内部类有哪些限制？" class="headerlink" title="3、Java的匿名内部类有哪些限制？"></a>3、Java的匿名内部类有哪些限制？</h3><h4 id="考察匿名内部类的概念和用法（初级）"><a href="#考察匿名内部类的概念和用法（初级）" class="headerlink" title="考察匿名内部类的概念和用法（初级）"></a>考察匿名内部类的概念和用法（初级）</h4><ul><li>匿名内部类的名字：没有人类认知意义上的名字</li><li>只能继承一个父类或实现一个接口</li><li>包名.OuterClass$1，表示定位的第一个匿名内部类。外部类加$N，N是匿名内部类的顺序。</li></ul><h4 id="考察语言规范以及语言的横向对比等（中级）"><a href="#考察语言规范以及语言的横向对比等（中级）" class="headerlink" title="考察语言规范以及语言的横向对比等（中级）"></a>考察语言规范以及语言的横向对比等（中级）</h4><p>匿名内部类的继承结构：Java中的匿名内部类不可以继承，只有内部类才可以有实现继承、实现接口的特性。而Kotlin是的匿名内部类是支持继承的，如</p><pre><code>val runnableFoo = object: Foo(),Runnable &#123;         override fun run() &#123;                 &#125; &#125;</code></pre><h4 id="作为考察内存泄漏的切入点（高级）"><a href="#作为考察内存泄漏的切入点（高级）" class="headerlink" title="作为考察内存泄漏的切入点（高级）"></a>作为考察内存泄漏的切入点（高级）</h4><p>匿名内部类的构造方法（深入源码字节码探索语言本质的能力）：</p><ul><li>匿名内部类会默认持有外部类的引用，可能会导致内存泄漏。</li><li>由编译器生成的。</li></ul><p>其参数列表包括</p><ul><li>外部对象（定义在非静态域内）</li><li>父类的外部对象（父类非静态）</li><li>父类的构造方法参数（父类有构造方法且参数列表不为空）</li><li>外部捕获的变量（方法体内有引用外部final变量）</li></ul><p>Lambda转换(SAM类型，仅支持单一接口类型）：</p><p>如果CallBack是一个interface，不是抽象类，则可以转换为Lambda表达式。</p><pre><code>CallBack callBack = () -&gt; &#123;         ... &#125;;</code></pre><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><ul><li>没有人类认知意义上的名字。</li><li>只能继承一个父类或实现一个接口。</li><li>父类是非静态的类型，则需父类外部实例来初始化。</li><li>如果定义在非静态作用域内，会引用外部类实例。</li><li>只能捕获外部作用域内的final变量。</li><li>创建时只有单一方法的接口可以用Lambda转换。</li></ul><h4 id="技巧点拨"><a href="#技巧点拨" class="headerlink" title="技巧点拨"></a>技巧点拨</h4><p>关注语言版本的变化：</p><ul><li>体现对技术的热情</li><li>体现好学的品质</li><li>显得专业</li></ul><h3 id="4、Java中对异常是如何进行分类的？"><a href="#4、Java中对异常是如何进行分类的？" class="headerlink" title="4、Java中对异常是如何进行分类的？"></a>4、Java中对异常是如何进行分类的？</h3><h4 id="异常整体分类："><a href="#异常整体分类：" class="headerlink" title="异常整体分类："></a>异常整体分类：</h4><p>Java异常结构中定义有Throwable类。 Exception和Error为其子类。</p><p>Error是程序无法处理的错误，比如OutOfMemoryError、StackOverflowError。这些异常发生时， Java虚拟机（JVM）一般会选择线程终止。</p><p>Exception是程序本身可以处理的异常，这种异常分两大类运行时异常和非运行时异常，程序中应当尽可能去处理这些异常。</p><p>运行时异常都是RuntimeException类及其子类异常，如NullPointerException、IndexOutOfBoundsException等， 这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的， 程序应该从逻辑角度尽可能避免这类异常的发生。</p><h4 id="异常处理的两个基本原则"><a href="#异常处理的两个基本原则" class="headerlink" title="异常处理的两个基本原则:"></a>异常处理的两个基本原则:</h4><p>1、尽量不要捕获类似 Exception 这样的通用异常，而是应该捕获特定异常。</p><p>2、不要生吞异常。</p><h4 id="NoClassDefFoundError-和-ClassNotFoundException-有什么区别？"><a href="#NoClassDefFoundError-和-ClassNotFoundException-有什么区别？" class="headerlink" title="NoClassDefFoundError 和 ClassNotFoundException 有什么区别？"></a>NoClassDefFoundError 和 ClassNotFoundException 有什么区别？</h4><p>ClassNotFoundException的产生原因主要是：<br>Java支持使用反射方式在运行时动态加载类，例如使用Class.forName方法来动态地加载类时，可以将类名作为参数传递给上述方法从而将指定类加载到JVM内存中，如果这个类在类路径中没有被找到，那么此时就会在运行时抛出ClassNotFoundException异常。<br>解决该问题需要确保所需的类连同它依赖的包存在于类路径中，常见问题在于类名书写错误。<br>另外还有一个导致ClassNotFoundException的原因就是：当一个类已经某个类加载器加载到内存中了，此时另一个类加载器又尝试着动态地从同一个包中加载这个类。通过控制动态类加载过程，可以避免上述情况发生。</p><p>NoClassDefFoundError产生的原因在于：<br>如果JVM或者ClassLoader实例尝试加载（可以通过正常的方法调用，也可能是使用new来创建新的对象）类的时候却找不到类的定义。要查找的类在编译的时候是存在的，运行的时候却找不到了。这个时候就会导致NoClassDefFoundError.<br>造成该问题的原因可能是打包过程漏掉了部分类，或者jar包出现损坏或者篡改。解决这个问题的办法是查找那些在开发期间存在于类路径下但在运行期间却不在类路径下的类。</p><h3 id="5、String-为什么要设计成不可变的？"><a href="#5、String-为什么要设计成不可变的？" class="headerlink" title="5、String 为什么要设计成不可变的？"></a>5、String 为什么要设计成不可变的？</h3><p>String是不可变的（修改String时，不会在原有的内存地址修改，而是重新指向一个新对象），String用final修饰，不可继承，String本质上是个final的char[]数组，所以char[]数组的内存地址不会被修改，而且String 也没有对外暴露修改char[]数组的方法。不可变性可以保证线程安全以及字符串串常量池的实现。</p><h3 id="6、Java里的幂等性了解吗？"><a href="#6、Java里的幂等性了解吗？" class="headerlink" title="6、Java里的幂等性了解吗？"></a>6、Java里的幂等性了解吗？</h3><p>幂等性原本是数学上的一个概念，即：f(x) = f(f(x))，对同一个系统，使用同样的条件，一次请求和重复的多次请求对系统资源的影响是一致的。</p><p>幂等性最为常见的应用就是电商的客户付款，试想一下如果你在付款的时候因为网络等各种问题失败了，然后去重复的付了一次，是一种多么糟糕的体验。幂等性就是为了解决这样的问题。</p><p>实现幂等性可以使用Token机制。</p><p>核心思想是为每一次操作生成一个唯一性的凭证，也就是token。一个token在操作的每一个阶段只有一次执行权，一旦执行成功则保存执行结果。对重复的请求，返回同一个结果。</p><p>例如：电商平台上的订单id就是最适合的token。当用户下单时，会经历多个环节，比如生成订单，减库存，减优惠券等等。每一个环节执行时都先检测一下该订单id是否已经执行过这一步骤，对未执行的请求，执行操作并缓存结果，而对已经执行过的id，则直接返回之前的执行结果，不做任何操<br>作。这样可以在最大程度上避免操作的重复执行问题，缓存起来的执行结果也能用于事务的控制等。</p><h3 id="7、为什么Java里的匿名内部类只能访问final修饰的外部变量？"><a href="#7、为什么Java里的匿名内部类只能访问final修饰的外部变量？" class="headerlink" title="7、为什么Java里的匿名内部类只能访问final修饰的外部变量？"></a>7、为什么Java里的匿名内部类只能访问final修饰的外部变量？</h3><p>匿名内部类用法：</p><pre><code>public class TryUsingAnonymousClass &#123;    public void useMyInterface() &#123;        final Integer number = 123;        System.out.println(number);        MyInterface myInterface = new MyInterface() &#123;            @Override            public void doSomething() &#123;                System.out.println(number);            &#125;        &#125;;        myInterface.doSomething();        System.out.println(number);    &#125;&#125;</code></pre><p>编译后的结果</p><pre><code>class TryUsingAnonymousClass$1        implements MyInterface &#123;    private final TryUsingAnonymousClass this$0;    private final Integer paramInteger;    TryUsingAnonymousClass$1(TryUsingAnonymousClass this$0, Integer paramInteger) &#123;        this.this$0 = this$0;        this.paramInteger = paramInteger;    &#125;    public void doSomething() &#123;        System.out.println(this.paramInteger);    &#125;&#125;</code></pre><p>因为匿名内部类最终会编译成一个单独的类，而被该类使用的变量会以构造函数参数的形式传递给该类，例如：Integer paramInteger，如果变量不定义成final的，paramInteger在匿名内部类被可以被修改，进而造成和外部的paramInteger不一致的问题，为了避免这种不一致的情况，因次Java规定匿名内部类只能访问final修饰的外部变量。</p><h3 id="8、讲一下Java的编码方式？"><a href="#8、讲一下Java的编码方式？" class="headerlink" title="8、讲一下Java的编码方式？"></a>8、讲一下Java的编码方式？</h3><p>为什么需要编码</p><p>计算机存储信息的最小单元是一个字节即8bit，所以能示的范围是0~255，这个范围无法保存所有的字符，所以要一个新的数据结构char来表示这些字符，从char到byte需要编码。</p><p>常见的编码方式有以下几种：</p><p>ASCII：总共有 128 个，用一个字节的低 7 位表示，031 是控制字符如换行回车删除等；32126 是打印字符，可以通过键盘输入并且能够显示出来。</p><p>GBK：码范围是 8140~FEFE（去掉 XX7F）总共有 23940 个码位，它能表示 21003 个汉字，它的编码是和 GB2312 兼容的，也就是说用 GB2312 编码的汉字可以用 GBK 来解码，并且不会有乱码。</p><p>UTF-16：UTF-16 具体定义了 Unicode 字符在计算机中存取方法。UTF-16 用两个字节来表示 Unicode 转化格式，这个是定长的表示方法，不论什么字符都可以用两个字节表示，两个字节是 16 个 bit，所以叫 UTF-16。UTF-16 表示字符非常方便，每两个字节表示一个字符，这个在字符串操作时就大大简化了操作，这也是 Java 以 UTF-16 作为内存的字符存储格式的一个很重要的原因。</p><p>UTF-8：统一采用两个字节表示一个字符，虽然在表示上非常简单方便，但是也有其缺点，有很大一部分字符用一个字节就可以表示的现在要两个字节表示，存储空间放大了一倍，在现在的网络带宽还非常有限的今天，这样会增大网络传输的流量，而且也没必要。而 UTF-8 采用了一种变长技术，每个编码区域有不同的字码长度。不同类型的字符可以是由 1~6 个字节组成。</p><p>Java中需要编码的地方一般都在字符到字节的转换上，这个一般包括磁盘IO和网络IO。</p><p>Reader 类是 Java 的 I/O 中读字符的父类，而InputStream 类是读字节的父类，InputStreamReader类就是关联字节到字符的桥梁，它负责在 I/O 过程中处理读取字节到字符的转换，而具体字节到字符解码实现由 StreamDecoder 去实现，在 StreamDecoder 解码过程中必须由用户指定 Charset 编码格式。</p><h3 id="9、String，StringBuffer，StringBuilder有哪些不同？"><a href="#9、String，StringBuffer，StringBuilder有哪些不同？" class="headerlink" title="9、String，StringBuffer，StringBuilder有哪些不同？"></a>9、String，StringBuffer，StringBuilder有哪些不同？</h3><p>三者在执行速度方面的比较：StringBuilder &gt;  StringBuffer  &gt;  String</p><p>String每次变化一个值就会开辟一个新的内存空间</p><p>StringBuilder：线程非安全的</p><p>StringBuffer：线程安全的</p><p>对于三者使用的总结： </p><p>1.如果要操作少量的数据用 String。</p><p>2.单线程操作字符串缓冲区下操作大量数据用 StringBuilder。</p><p>3.多线程操作字符串缓冲区下操作大量数据用 StringBuffer。</p><p>String 是 Java 语言非常基础和重要的类，提供了构造和管理字符串的各种基本逻辑。它是典型的 Immutable 类，被声明成为 final class，所有属性也都是 final 的。也由于它的不可变性，类似拼接、裁剪字符串等动作，都会产生新的 String 对象。由于字符串操作的普遍性，所以相关操作的效率往往对应用性能有明显影响。</p><p>StringBuffer 是为解决上面提到拼接产生太多中间对象的问题而提供的一个类，我们可以用 append 或者 add 方法，把字符串添加到已有序列的末尾或者指定位置。StringBuffer 本质是一个线程安全的可修改字符序列，它保证了线程安全，也随之带来了额外的性能开销，所以除非有线程安全的需要，不然还是推荐使用它的后继者，也就是 StringBuilder。</p><p>StringBuilder 是 Java 1.5 中新增的，在能力上和 StringBuffer 没有本质区别，但是它去掉了线程安全的部分，有效减小了开销，是绝大部分情况下进行字符串拼接的首选。</p><h3 id="10、什么是内部类？内部类的作用。"><a href="#10、什么是内部类？内部类的作用。" class="headerlink" title="10、什么是内部类？内部类的作用。"></a>10、什么是内部类？内部类的作用。</h3><p>内部类可以有多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。</p><p>在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。</p><p>创建内部类对象并不依赖于外围类对象的创建。</p><p>内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。</p><p>内部类提供了更好的封装，除了该外围类，其他类都不能访问。。</p><h3 id="11、抽象类和接口区别？"><a href="#11、抽象类和接口区别？" class="headerlink" title="11、抽象类和接口区别？"></a>11、抽象类和接口区别？</h3><p>共同点</p><ul><li>是上层的抽象层。</li><li>都不能被实例化。</li><li>都能包含抽象的方法，这些抽象的方法用于描述类具备的功能，但是不提供具体的实现。</li></ul><p>区别：</p><ul><li>1、在抽象类中可以写非抽象的方法，从而避免在子类中重复书写他们，这样可以提高代码的复用性，这是抽象类的优势，接口中只能有抽象的方法。</li><li>2、多继承：一个类只能继承一个直接父类，这个父类可以是具体的类也可是抽象类，但是一个类可以实现多个接口。</li><li>3、抽象类可以有默认的方法实现，接口根本不存在方法的实现。</li><li>4、子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明方法的实现。子类使用关键字implements来实现接口。它需要提供接口中所有声明方法的实现。</li><li>5、构造器：抽象类可以有构造器，接口不能有构造器。</li><li>6、和普通Java类的区别：除了你不能实例化抽象类之外，抽象类和普通Java类没有任何区别，接口是完全不同的类型。</li><li>7、访问修饰符:抽象方法可以有public、protected和default修饰符，接口方法默认修饰符是public。你不可以使用其它修饰符。</li><li>8、main方法:抽象方法可以有main方法并且我们可以运行它接口没有main方法，因此我们不能运行它。</li><li>9、速度:抽象类比接口速度要快，接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。</li><li>10、添加新方法:如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。如果你往接口中添加方法，那么你必须改变实现该接口的类。</li></ul><h3 id="12、接口的意义？"><a href="#12、接口的意义？" class="headerlink" title="12、接口的意义？"></a>12、接口的意义？</h3><p>规范、扩展、回调。</p><h3 id="13、父类的静态方法能否被子类重写？"><a href="#13、父类的静态方法能否被子类重写？" class="headerlink" title="13、父类的静态方法能否被子类重写？"></a>13、父类的静态方法能否被子类重写？</h3><p>不能。子类继承父类后，用相同的静态方法和非静态方法，这时非静态方法覆盖父类中的方法（即方法重写），父类的该静态方法被隐藏（如果对象是父类则调用该隐藏的方法），另外子类可继承父类的静态与非静态方法，至于方法重载我觉得它其中一要素就是在同一类中，不能说父类中的什么方法与子类里的什么方法是方法重载的体现。</p><h3 id="14、抽象类的意义"><a href="#14、抽象类的意义" class="headerlink" title="14、抽象类的意义?"></a>14、抽象类的意义?</h3><p>为其子类提供一个公共的类型，封装子类中的重复内容，定义抽象方法，子类虽然有不同的实现 但是定义是一致的。</p><h3 id="15、静态内部类、非静态内部类的理解？"><a href="#15、静态内部类、非静态内部类的理解？" class="headerlink" title="15、静态内部类、非静态内部类的理解？"></a>15、静态内部类、非静态内部类的理解？</h3><p>静态内部类：只是为了降低包的深度，方便类的使用，静态内部类适用于包含在类当中，但又不依赖与外在的类，不用使用外在类的非静态属性和方法，只是为了方便管理类结构而定义。在创建静态内部类的时候，不需要外部类对象的引用。</p><p>非静态内部类：持有外部类的引用，可以自由使用外部类的所有变量和方法。</p><h3 id="16、为什么复写equals方法的同时需要复写hashcode方法，前者相同后者是否相同，反过来呢？为什么？"><a href="#16、为什么复写equals方法的同时需要复写hashcode方法，前者相同后者是否相同，反过来呢？为什么？" class="headerlink" title="16、为什么复写equals方法的同时需要复写hashcode方法，前者相同后者是否相同，反过来呢？为什么？"></a>16、为什么复写equals方法的同时需要复写hashcode方法，前者相同后者是否相同，反过来呢？为什么？</h3><p>要考虑到类似HashMap、HashTable、HashSet的这种散列的数据类型的运用，当我们重写equals时，是为了用自身的方式去判断两个自定义对象是否相等，然而如果此时刚好需要我们用自定义的对象去充当hashmap的键值使用时，就会出现我们认为的同一对象，却因为hash值不同而导致hashmap中存了两个对象，从而才需要进行hashcode方法的覆盖。</p><h3 id="17、equals-和-hashcode-的关系？"><a href="#17、equals-和-hashcode-的关系？" class="headerlink" title="17、equals 和 hashcode 的关系？"></a>17、equals 和 hashcode 的关系？</h3><p>hashcode和equals的约定关系如下：</p><ul><li><p>1、如果两个对象相等，那么他们一定有相同的哈希值（hashcode）。</p></li><li><p>2、如果两个对象的哈希值相等，那么这两个对象有可能相等也有可能不相等。（需要再通过equals来判断）</p></li></ul><h3 id="18、java为什么跨平台？"><a href="#18、java为什么跨平台？" class="headerlink" title="18、java为什么跨平台？"></a>18、java为什么跨平台？</h3><p>因为Java程序编译之后的代码不是能被硬件系统直接运行的代码，而是一种“中间码”——字节码。然后不同的硬件平台上安装有不同的Java虚拟机(JVM)，由JVM来把字节码再“翻译”成所对应的硬件平台能够执行的代码。因此对于Java编程者来说，不需要考虑硬件平台是什么。所以Java可以跨平台。</p><h3 id="19、浮点数的精准计算"><a href="#19、浮点数的精准计算" class="headerlink" title="19、浮点数的精准计算"></a>19、浮点数的精准计算</h3><p>BigDecimal类进行商业计算，Float和Double只能用来做科学计算或者是工程计算。</p><h3 id="20、final，finally，finalize的区别？"><a href="#20、final，finally，finalize的区别？" class="headerlink" title="20、final，finally，finalize的区别？"></a>20、final，finally，finalize的区别？</h3><p>final 可以用来修饰类、方法、变量，分别有不同的意义，final 修饰的 class 代表不可以继承扩展，final 的变量是不可以修改的，而 final 的方法也是不可以重写的（override）。</p><p>finally 则是 Java 保证重点代码一定要被执行的一种机制。我们可以使用 try-finally 或者 try-catch-finally 来进行类似关闭 JDBC 连接、保证 unlock 锁等动作。</p><p>finalize 是基础类 java.lang.Object 的一个方法，它的设计目的是保证对象在被垃圾收集前完成特定资源的回收。finalize 机制现在已经不推荐使用，并且在 JDK 9 开始被标记为 deprecated。Java 平台目前在逐步使用 java.lang.ref.Cleaner 来替换掉原有的 finalize 实现。Cleaner 的实现利用了幻象引用（PhantomReference），这是一种常见的所谓 post-mortem 清理机制。利用幻象引用和引用队列，我们可以保证对象被彻底销毁前做一些类似资源回收的工作，比如关闭文件描述符（操作系统有限的资源），它比 finalize 更加轻量、更加可靠。</p><h3 id="21、静态内部类的设计意图"><a href="#21、静态内部类的设计意图" class="headerlink" title="21、静态内部类的设计意图"></a>21、静态内部类的设计意图</h3><p>静态内部类与非静态内部类之间存在一个最大的区别：非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围内，但是静态内部类却没有。</p><p>没有这个引用就意味着：</p><p>它的创建是不需要依赖于外围类的。<br>它不能使用任何外围类的非static成员变量和方法。</p><h3 id="22、Java中对象的生命周期"><a href="#22、Java中对象的生命周期" class="headerlink" title="22、Java中对象的生命周期"></a>22、Java中对象的生命周期</h3><p>在Java中，对象的生命周期包括以下几个阶段：</p><p>1.创建阶段(Created)</p><p>JVM 加载类的class文件 此时所有的static变量和static代码块将被执行<br>加载完成后，对局部变量进行赋值（先父后子的顺序）<br>再执行new方法 调用构造函数<br>一旦对象被创建，并被分派给某些变量赋值，这个对象的状态就切换到了应用阶段。</p><p>2.应用阶段(In Use)</p><p>对象至少被一个强引用持有着。</p><p>3.不可见阶段(Invisible)</p><p>当一个对象处于不可见阶段时，说明程序本身不再持有该对象的任何强引用，虽然该这些引用仍然是存在着的。<br>简单说就是程序的执行已经超出了该对象的作用域了。</p><p>4.不可达阶段(Unreachable)</p><p>对象处于不可达阶段是指该对象不再被任何强引用所持有。<br>与“不可见阶段”相比，“不可见阶段”是指程序不再持有该对象的任何强引用，这种情况下，该对象仍可能被JVM等系统下的某些已装载的静态变量或线程或JNI等强引用持有着，这些特殊的强引用被称为”GC root”。存在着这些GC root会导致对象的内存泄露情况，无法被回收。</p><p>5.收集阶段(Collected)</p><p>当垃圾回收器发现该对象已经处于“不可达阶段”并且垃圾回收器已经对该对象的内存空间重新分配做好准备时，则对象进入了“收集阶段”。如果该对象已经重写了finalize()方法，则会去执行该方法的终端操作。</p><p>6.终结阶段(Finalized)</p><p>当对象执行完finalize()方法后仍然处于不可达状态时，则该对象进入终结阶段。在该阶段是等待垃圾回收器对该对象空间进行回收。</p><p>7.对象空间重分配阶段(De-allocated)</p><p>垃圾回收器对该对象的所占用的内存空间进行回收或者再分配了，则该对象彻底消失了，称之为“对象空间重新分配阶段。</p><h3 id="23、静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？"><a href="#23、静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？" class="headerlink" title="23、静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？"></a>23、静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？</h3><p>结论：java中静态属性和静态方法可以被继承，但是不可以被重写而是被隐藏。</p><p>原因：</p><p>1). 静态方法和属性是属于类的，调用的时候直接通过类名.方法名完成，不需要继承机制即可以调用。如果子类里面定义了静态方法和属性，那么这时候父类的静态方法或属性称之为”隐藏”。如果你想要调用父类的静态方法和属性，直接通过父类名.方法或变量名完成，至于是否继承一说，子类是有继承静态方法和属性，但是跟实例方法和属性不太一样，存在”隐藏”的这种情况。</p><p>2). 多态之所以能够实现依赖于继承、接口和重写、重载（继承和重写最为关键）。有了继承和重写就可以实现父类的引用指向不同子类的对象。重写的功能是：”重写”后子类的优先级要高于父类的优先级，但是“隐藏”是没有这个优先级之分的。</p><p>3). 静态属性、静态方法和非静态的属性都可以被继承和隐藏而不能被重写，因此不能实现多态，不能实现父类的引用可以指向不同子类的对象。非静态方法可以被继承和重写，因此可以实现多态。</p><h3 id="24、object类的equal-和hashcode-方法重写，为什么？"><a href="#24、object类的equal-和hashcode-方法重写，为什么？" class="headerlink" title="24、object类的equal 和hashcode 方法重写，为什么？"></a>24、object类的equal 和hashcode 方法重写，为什么？</h3><p>在Java API文档中关于hashCode方法有以下几点规定（原文来自java深入解析一书）：</p><p>1、在java应用程序执行期间，如果在equals方法比较中所用的信息没有被修改，那么在同一个对象上多次调用hashCode方法时必须一致地返回相同的整数。如果多次执行同一个应用时，不要求该整数必须相同。</p><p>2、如果两个对象通过调用equals方法是相等的，那么这两个对象调用hashCode方法必须返回相同的整数。</p><p>3、如果两个对象通过调用equals方法是不相等的，不要求这两个对象调用hashCode方法必须返回不同的整数。但是程序员应该意识到对不同的对象产生不同的hash值可以提供哈希表的性能。</p><h3 id="25、java中-和equals和hashCode的区别？"><a href="#25、java中-和equals和hashCode的区别？" class="headerlink" title="25、java中==和equals和hashCode的区别？"></a>25、java中==和equals和hashCode的区别？</h3><p>默认情况下也就是从超类Object继承而来的equals方法与‘==’是完全等价的，比较的都是对象的内存地址，但我们可以重写equals方法，使其按照我们的需求的方式进行比较，如String类重写了equals方法，使其比较的是字符的序列，而不再是内存地址。在java的集合中，判断两个对象是否相等的规则是：</p><pre><code>  1.判断两个对象的hashCode是否相等。  2.判断两个对象用equals运算是否相等。</code></pre><h3 id="26、Java的四种引用及使用场景？"><a href="#26、Java的四种引用及使用场景？" class="headerlink" title="26、Java的四种引用及使用场景？"></a>26、Java的四种引用及使用场景？</h3><ul><li>强引用（FinalReference）：在内存不足时不会被回收。平常用的最多的对象，如新创建的对象。</li><li>软引用（SoftReference）：在内存不足时会被回收。用于实现内存敏感的高速缓存。</li><li>弱引用（WeakReferenc）：只要GC回收器发现了它，就会将之回收。用于Map数据结构中，引用占用内存空间较大的对象。</li><li>虚引用（PhantomReference）：在回收之前，会被放入ReferenceQueue，JVM不会自动将该referent字段值设置成null。其它引用被JVM回收之后才会被放入ReferenceQueue中。用于实现一个对象被回收之前做一些清理工作。</li></ul><h3 id="27、类的加载过程，Person-person-new-Person-为例进行说明。"><a href="#27、类的加载过程，Person-person-new-Person-为例进行说明。" class="headerlink" title="27、类的加载过程，Person person = new Person();为例进行说明。"></a>27、类的加载过程，Person person = new Person();为例进行说明。</h3><p>1).因为new用到了Person.class，所以会先找到Person.class文件，并加载到内存中;</p><p>2).执行该类中的static代码块，如果有的话，给Person.class类进行初始化;</p><p>3).在堆内存中开辟空间分配内存地址;</p><p>4).在堆内存中建立对象的特有属性，并进行默认初始化;</p><p>5).对属性进行显示初始化;</p><p>6).对对象进行构造代码块初始化;</p><p>7).对对象进行与之对应的构造函数进行初始化;</p><p>8).将内存地址付给栈内存中的p变量。</p><h3 id="28、JAVA常量池"><a href="#28、JAVA常量池" class="headerlink" title="28、JAVA常量池"></a>28、JAVA常量池</h3><p>Interger中的128(-128~127)</p><p>a.当数值范围为-128~127时：如果两个new出来的Integer对象，即使值相同，通过“==”比较结果为false，但两个对直接赋值，则通过“==”比较结果为“true，这一点与String非常相似。</p><p>b.当数值不在-128~127时，无论通过哪种方式，即使两对象的值相等，通过“==”比较，其结果为false；</p><p>c.当一个Integer对象直接与一个int基本数据类型通过“==”比较，其结果与第一点相同；</p><p>d.Integer对象的hash值为数值本身；</p><p>为什么是-128-127?</p><p>在Integer类中有一个静态内部类IntegerCache，在IntegrCache类中有一个Integer数组，用以缓存当前数值范围为-128~127时的Integer对象。</p><h3 id="29、在重写equals方法时，需要遵循哪些约定，具体介绍一下？"><a href="#29、在重写equals方法时，需要遵循哪些约定，具体介绍一下？" class="headerlink" title="29、在重写equals方法时，需要遵循哪些约定，具体介绍一下？"></a>29、在重写equals方法时，需要遵循哪些约定，具体介绍一下？</h3><p>重写equals方法时需要遵循通用约定：自反性、对称性、传递性、一致性、非空性</p><p>1）自反性</p><p>对于任何非null的引用值x,x.equals(x)必须返回true。—这一点基本上不会有啥问题</p><p>2）对称性</p><p>对于任何非null的引用值x和y，当且仅当x.equals(y)为true时，y.equals(x)也为true。</p><p>3）传递性</p><p>对于任何非null的引用值x、y、z。如果x.equals(y)==true,y.equals(z)==true,那么x.equals(z)==true。</p><p>4） 一致性</p><p>对于任何非null的引用值x和y，只要equals的比较操作在对象所用的信息没有被修改，那么多次调用x.equals(y)就会一致性地返回true,或者一致性的返回false。</p><p>5）非空性</p><p>所有比较的对象都不能为空。</p><h3 id="30、深拷贝和浅拷贝的区别"><a href="#30、深拷贝和浅拷贝的区别" class="headerlink" title="30、深拷贝和浅拷贝的区别"></a>30、<a href="http://www.cnblogs.com/chenssy/p/3308489.html">深拷贝和浅拷贝的区别</a></h3><h3 id="31、Integer类对int的优化"><a href="#31、Integer类对int的优化" class="headerlink" title="31、Integer类对int的优化"></a>31、<a href="http://denverj.iteye.com/blog/745422">Integer类对int的优化</a></h3>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 职场 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP 与 HTTPS</title>
      <link href="/2019-10-23/http-and-https/"/>
      <url>/2019-10-23/http-and-https/</url>
      
        <content type="html"><![CDATA[<p>作为开发者，必须要对 HTTP 与 HTTPS 的概念、区别和优缺点有所了解，在出现问题的时候才能对症下药。</p><span id="more"></span><p><a href="https://www.jianshu.com/p/14cd2c9d2cd2">这个</a></p><ul><li>HTTP: HTTP 协议（HyperText Transfer Protocol，超文本传输协议）：是客户端浏览器或其他程序与Web服务器之间的应用层通信协议 。</li><li>HTTPS: HTTPS 协议（HyperText Transfer Protocol over Secure Socket Layer）：可以理解为HTTP+SSL/TLS， 即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL，用于安全的 HTTP 数据传输。</li></ul><p>如下图所示：</p><p><img src="https://pic2.zhimg.com/80/v2-54ff04e1b0cc698f08f76d6356f59fac_1440w.png" alt="HTTP 与 HTTPS"></p><h2 id="HTTP-请求过程"><a href="#HTTP-请求过程" class="headerlink" title="HTTP 请求过程"></a>HTTP 请求过程</h2><p>如下图所示，为 HTTP 的请求过程：</p><p><img src="https://picb.zhimg.com/80/v2-e367a5e3bc28fb7fd083ddc201e7e693_1440w.png" alt="HTTP 请求过程"></p><p>HTTP 请求过程中，客户端与服务器之间没有任何身份确认的过程，数据全部明文传输，『裸奔』在互联网上，所以很容易遭到黑客的攻击，如下：</p><p><img src="https://pic1.zhimg.com/80/v2-831635f04f3732e866af0ec6ce1040e7_1440w.png" alt="HTTP 黑客攻击"></p><p>可以看到，客户端发出的请求很容易被黑客截获，如果此时黑客冒充服务器，则其可返回任意信息给客户端，而不被客户端察觉，所以我们经常会听到一词“劫持”，现象如下：</p><p>下面两图中，浏览器中填入的是相同的URL，左边是正确响应，而右边则是被劫持后的响应</p><p><img src="https://pic3.zhimg.com/80/v2-299b4a71f9b005fa15fbcd4cabfd841b_1440w.png" alt="劫持效果"></p><p>所以 HTTP 传输面临的风险有：</p><ol><li>窃听风险：黑客可以获知通信内容。</li><li>篡改风险：黑客可以修改通信内容。</li><li>冒充风险：黑客可以冒充他人身份参与通信。</li></ol><h2 id="HTTP-向-HTTPS-演化的过程"><a href="#HTTP-向-HTTPS-演化的过程" class="headerlink" title="HTTP 向 HTTPS 演化的过程"></a>HTTP 向 HTTPS 演化的过程</h2><p>第一步：为了防止上述现象的发生，人们想到一个办法：对传输的信息加密（即使黑客截获，也无法破解）</p><p><img src="https://pic1.zhimg.com/80/v2-8d8138e883455e4d316d644c79a89314_1440w.png"></p><p>如上图所示，此种方式属于对称加密，双方拥有相同的密钥，信息得到安全传输，但此种方式的缺点是：</p><ol><li>不同的客户端、服务器数量庞大，所以双方都需要维护大量的密钥，维护成本很高</li><li>因每个客户端、服务器的安全级别不同，密钥极易泄露</li></ol><p>第二步：既然使用对称加密时，密钥维护这么繁琐，那我们就用非对称加密试试</p><p><img src="https://pic1.zhimg.com/80/v2-660bec42419281a9ec47c029089a77c9_1440w.png"></p><p>如上图所示，客户端用公钥对请求内容加密，服务器使用私钥对内容解密，反之亦然，但上述过程也存在缺点：</p><p>公钥是公开的（也就是黑客也会有公钥），所以第 ④ 步私钥加密的信息，如果被黑客截获，其可以使用公钥进行解密，获取其中的内容</p><p>第三步：非对称加密既然也有缺陷，那我们就将对称加密，非对称加密两者结合起来，取其精华、去其糟粕，发挥两者的各自的优势</p><p><img src="https://picb.zhimg.com/80/v2-22570e3e422de7951ce7c5c3e8435312_1440w.png"></p><ol><li>第 ③ 步时，客户端说：（咱们后续回话采用对称加密吧，这是对称加密的算法和对称密钥）这段话用公钥进行加密，然后传给服务器；</li><li>服务器收到信息后，用私钥解密，提取出对称加密算法和对称密钥后，服务器说：（好的）对称密钥加密；</li><li>后续两者之间信息的传输就可以使用对称加密的方式了。</li></ol><p>遇到的问题：</p><ol><li>客户端如何获得公钥？</li><li>如何确认服务器是真实的而不是黑客？</li></ol><p>第四步：获取公钥与确认服务器身份</p><p><img src="https://pic2.zhimg.com/80/v2-f2ac6567fa1a3c10e73eba59eab3823a_1440w.png"></p><ol><li>获取公钥<ol><li>提供一个下载公钥的地址，回话前让客户端去下载。（缺点：下载地址有可能是假的；客户端每次在回话前都先去下载公钥也很麻烦）</li><li>会话开始时，服务器把公钥发给客户端（缺点：黑客冒充服务器，发送给客户端假的公钥）</li></ol></li><li>有木有一种方式既可以安全的获取公钥，又能防止黑客冒充呢？ 那就需要用到终极武器了：<strong>SSL 证书</strong></li></ol><p><img src="https://pic3.zhimg.com/80/v2-5e2241fae8b593ff7f3b3a308ef81c10_1440w.png" alt="使用 SSL 证书"></p><p>如上图所示，在第 ② 步时服务器发送了一个SSL证书给客户端，SSL 证书中包含的具体内容有：</p><ul><li>证书的发布机构CA</li><li>证书的有效期</li><li>公钥</li><li>证书所有者</li><li>签名</li><li>其它</li></ul><ol start="3"><li>客户端在接受到服务端发来的SSL证书时，会对证书的真伪进行校验，以浏览器为例说明如下：</li></ol><p>（1）首先浏览器读取证书中的证书所有者、有效期等信息进行一一校验</p><p>（2）浏览器开始查找操作系统中已内置的受信任的证书发布机构CA，与服务器发来的证书中的颁发者CA比对，用于校验证书是否为合法机构颁发</p><p>（3）如果找不到，浏览器就会报错，说明服务器发来的证书是不可信任的。</p><p>（4）如果找到，那么浏览器就会从操作系统中取出 颁发者CA 的公钥，然后对服务器发来的证书里面的签名进行解密</p><p>（5）浏览器使用相同的hash算法计算出服务器发来的证书的hash值，将这个计算的hash值与证书中签名做对比</p><p>（6）对比结果一致，则证明服务器发来的证书合法，没有被冒充</p><p>（7）此时浏览器就可以读取证书中的公钥，用于后续加密了</p><ol start="4"><li>所以通过发送SSL证书的形式，既解决了公钥获取问题，又解决了黑客冒充问题，一箭双雕，HTTPS加密过程也就此形成</li></ol><p>所以相比HTTP，HTTPS 传输更加安全</p><p>（1） 所有信息都是加密传播，黑客无法窃听。</p><p>（2） 具有校验机制，一旦被篡改，通信双方会立刻发现。</p><p>（3） 配备身份证书，防止身份被冒充。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上所述，相比 HTTP 协议，HTTPS 协议增加了很多握手、加密解密等流程，虽然过程很复杂，但其可以保证数据传输的安全。所以在这个互联网膨胀的时代，其中隐藏着各种看不见的危机，为了保证数据的安全，维护网络稳定，建议大家多多推广HTTPS。</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的2015</title>
      <link href="/2015-12-31/my-2015/"/>
      <url>/2015-12-31/my-2015/</url>
      
        <content type="html"><![CDATA[<p>又到一年尾声时，我也该好好总结这一年了。<br>域名换了，变成了<a href="http://serious-think.me/">serious-think.me</a>。这个域名也是想了一段时间，原来的英文+数字不方便输入，而且显得不够严肃。<br>这个域名呢，<strong>serious</strong>是我的英文名，也是认真、严肃的意思，<strong>think</strong>是想、思考，也算是双关吧。</p><p>还是延续以前的老传统，让我们用四大味觉来总结这365天。</p><span id="more"></span><h2 style="text-align: center;">  <span style="color:#ffa500;">酸</span></h2><p>要说这酸啊，今年算下来，无非就是这钱的事。</p><p>因为在14年的5月份，哥荣升房奴的角色。在老家买了一套大房纸。各种问题接踵而至。首当其冲的就是钱的问题。车位、地下室、各种押金各种费用，把我们俩弄得疲惫不堪，也因为这件事情吵了几次架。我妈也四处借钱，总算是把我们的钱凑齐，把房子给搞定了。</p><p>但是呢，也是因为钱不够，买房时只交了15%的首付，另外15%需要在交房的时候交，也算是减轻了一点压力，不用在有限的时间内凑那么多钱。</p><p>即便是这样，也着实因为凑钱、借钱，拌了几次嘴。</p><p>好歹一路走来，再看看之前遇到的难题，都是笑话。</p><p>再联想到现在我们80后这一代人，心里真是酸溜溜的，委屈却又无处可诉，让人心里憋屈得很。</p><p>但是转念一想，我俩奋斗才有几年时光，居然就有了自己的房子，心里上总算是有了“家”的感觉吧。我们两个人聊天，偶尔也会感慨，花了钱，就是特么的不一样。</p><h2 style="text-align: center;">  <span style="color:#0000ff;">甜</span></h2><p>甜的事情，那可真有得说了。今年高兴的事儿真不少。</p><p>首先，我荣升奶爸了！今年6月份的时候开始准备造人，准备了几个月，媳妇的肚子毫无动静，我俩也快被逼疯了，后来实在不行，到医院一问，人家大夫震惊得要命：你俩这才几个月啊？！就来问？！两年都要不上再来找我！</p><p>没成想，回去之后的这个月，马上就有动静了！看到两道杠的那个早上，那真叫一个兴奋啊。</p><p>最近就开始认真照顾媳妇了。认真照顾媳妇也是一件令人开心的事情，她开心，我也跟着开心，宝宝也跟着开心，何乐而不为呢？</p><p>另一件事是哥荣升管理层（大雾）啦！虽然经验比较少，但是来这家公司一年之后，发现自己的水平有那么一点点的长进，可以带一两个小弟了。于是领导找到我，说准备给我招两个帮手。听到这席话，首先感觉是领导对我的肯定，其次才感觉到自己也算是有了一点进步吧。</p><p>于是很快招到了两个新同事，也没有啥上下级的关系，互帮互助，而且我这人也没啥架子，自己会的东西都会倾囊相授，之前孤军奋战的日子也终于算是结束了。</p><p>再一件事是我向公司申请了一台MacBook Pro，本以为可能没戏，没想到领导非常爽快地批准了。终于可以不用再倒腾代码了。。本来就有回家再工作一会儿的习惯，现在可以带着本子回家干活了，还真是相当开心的一件事。</p><p>第三件事啊，是哥也当了一回优秀员工。是人事的同事告诉我的，哥当时强装镇定，其实心里早就乐开了花。不过也是，看看这一年，我也是有点进步的，这也充分说明了上面对我的认可，多令人开心！</p><h2 style="text-align: center;">  <span style="color:#008000;">苦</span></h2><p>苦，无非是工作上的事情。</p>]]></content>
      
      
      <categories>
          
          <category> 口水 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 口水 </tag>
            
            <tag> 年终总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何设置SSH使用公钥认证登录主机</title>
      <link href="/2015-07-24/ssh-using-public-key/"/>
      <url>/2015-07-24/ssh-using-public-key/</url>
      
        <content type="html"><![CDATA[<div id="menu"></div><p><a href="#Overview">总览</a></p><p><a href="#Linux">在Linux或OS X上设置SSH使用公钥</a></p><p><a href="#Windows">在Windows上使用PuTTY设置SSH使用公钥</a></p><span id="more"></span><p>###总览</p><p>在使用SSH时，利用公钥来进行认证后的链接，是比只利用密码来进行验证要安全得多的。SSH公钥认证是基于非对称加密算法的，这种加密算法会生成一对key，一个“私有”key，也就是私钥，和一个“公有”key，即公钥。你在你的电脑上只保存一个私钥，用来进行远程连接。同时你也可以把公钥分享给任何人（不要给他私钥哟），或者存储在远程主机的某个目录上，比如 <code>.ssh/autorized_keys</code>。</p><p>使用SSH公钥认证：</p><p>远程主机必须要安装了SSH（任意版本）。本文假设远程主机使用了OpenSSH（对，就是上一篇文说的印第安那大学的UTIS中心系统使用的那个）。如果远程主机正在使用一个奇怪的SSH版本（比如Tectia SSH），下文即将使用的方法可能不正确。</p><p>你的电脑也必须安装某种版本的SSH工具。本文假设你在Linux或Mac OS X下使用命令行中的SSH，在Windows下使用PuTTY。</p><p>还有个前提是你能够把公钥想办法传输到远程主机上。使用用户名密码登录到远程主机或者有网络管理员来帮你做这件事。</p><p>公钥可以存储到 <code>~/.ssh/authorized_keys</code>目录下。</p><p><a href="#menu">Back to top</a></p><div id="Linux"></div><p>###在Linux或OS X上设置SSH使用公钥</p><ol><li>使用命令行的SSH创建一对Key，加密算法可以是DSA或者RSA：</li></ol><ul><li>创建DSA Key，在命令行中输入：</li></ul><pre><code class="bash">ssh-keygen -t dsa</code></pre><ul><li>创建RSA Key，在命令行中输入：</li></ul><pre><code class="bash">ssh-keygen -t rsa</code></pre><ol start="2"><li><p>接下来ssh-keygen会提醒你提供一个文件名来储存key文件，同时提供一个密码来保护你的私钥。</p><ul><li><p>文件名：如果你要使用默认的文件名（和路径）的话，直接回车就好了。如果你想指定文件名（和路径）的话，就输入路径并回车。<br>  但是很多远程主机设置为只接受使用默认路径和默认文件名的私钥，在这种情况下，如果要使用其他文件名的私钥，就要做一点点设置了，下文会有介绍。</p></li><li><p>密码：输入不少于5个字符的密码，然后回车。如果不想使用密码，则可以直接回车。<br>  <em>UITS强烈建议使用密码来保护你的私钥。如果不使用密码的话，任何能访问你电脑的人都可以使用这个私钥来进行远程主机的登录。</em></p></li></ul><p> 你的私钥按照你的输入保存在相应的位置（<code>~/.ssh/id_rsa</code>或者 <code>~/.ssh/my_ssh_key</code>）。<br> 而相对应的公钥也会保存在与私钥相同的位置，并且会在私钥的文件名后面加一个.pub的后缀（<code>~/.ssh/id_rsa.pub</code>或者 <code>~/.ssh/my_ssh_key.pub</code>）。</p></li><li><p>使用SFTP或者SCP将公钥拷贝到远程主机上。例如：</p><pre><code class="bash">scp ~/.ssh/id_rsa.pub serious@cy198706.com:  // 不要忘记后面这个&quot;`:`&quot;</code></pre><p> 接着输入你在该远程主机上的用户密码，认证通过之后，公钥就会被拷贝到远程主机你的home目录下。</p></li><li><p>使用用户名密码登录远程主机。<br> <em>如果你没有权限登录远程主机，那么你需要联系网络管理员来帮你创建</em><code>~/.ssh/authorized_keys</code><em>文件。</em></p></li><li><p>如果你的远程主机中没有<code>~/.ssh/authorized_keys</code>文件，则需要手动创建一个：</p><pre><code class="bash">mkdir -p ~/.ssh  touch ~/.ssh/authorized_keys</code></pre><p> <em>如果已有这个文件，则上面的命令并没有什么卵用</em></p></li><li><p>将步骤3中拷贝过来的公钥文件（<code>~/id_rsa.pub</code>）的内容写入 <code>~/.ssh/authorized_keys</code>文件中。</p><pre><code class="bash">cat ~/id_rsa.pub &gt; ~/.ssh/authorized_keys</code></pre><p> 然后检查一下是否写入成功：</p><pre><code class="bash">cat ~/.ssh/authorized_keys | more</code></pre></li><li><p>现在可以安全地删除公钥文件了：</p><pre><code class="bash">rm ~/id_rsa.pub</code></pre></li><li><p>你可以在其他的主机上也添加这个公钥，只需要重复3-7步骤就可以啦。</p></li><li><p>现在你应该可以使用SSH登录到远程主机了。登录的主机是<a href="http://cy198706.com/">cy198706.com</a>，登录时的用户名是serious，登录所用的电脑就是存有你刚才创建的私钥的这台电脑。</p><p> 如果你刚才创建私钥时使用密码保护了，那么远程主机会要求你在SSH时输入密码（该密码并不会被传输到远程主机，只做本地验证）：</p><pre><code class="bash">[serious@desktop ~]$ ssh serious@cy198706.comEnter passphrase for key &#39;~/.ssh/id_dsa&#39;: Last login: Fri Jul 24 09:23:17 2015 from serious.somewhere.org</code></pre><p> 如果你刚才在创建私钥时没有使用默认的文件名（或路径），则你需要用以下两种方法来进行SSH：</p><ul><li>在命令行中加入-i参数，并指定私钥的路径。例如你刚才把私钥存在了<code>~/.ssh/mykeys/my_host</code>，并要使用这个私钥来进行SSH的话：</li></ul><pre><code class="bash">  ssh -i ~/.ssh/mykeys/myhost serious@cy198706.com</code></pre><ul><li>修改配置文件。<br>SSH会依次从以下几处读取配置信息：<ol><li>命令行参数</li><li>~/.ssh/config（也许不存在）</li><li>/etc/ssh/ssh_config两个文件中读取配置信息</li></ol></li></ul><p> SSH配置文件是一个包含关键词和参数的文本文件。要指定连接某台远程主机时要使用哪个私钥，只需要使用文件编辑器添加一条记录即可。</p><p> 例如，要连接到<a href="http://cy198706.com/">cy198706.com</a>，同时使用<code>~/.ssh/mykeys/cy_host</code>这个私钥，则需要在 <code>~/.ssh/config</code>（如果没有自行创建）文件中添加如下两行：</p><pre><code class="bash">Host cy198706.com IdentityFile ~/.ssh/mykeys/cy_host</code></pre><p> 保存文件之后，SSH就会利用这个规则来访问指定的主机。</p><p> 你也可以添加多条规则：</p><pre><code class="bash">   Host host1.cy198706.comIdentityFile ~/.ssh/mykeys/cy_host1  Host host2.cy198706.comIdentityFile ~/.ssh/mykeys/cy_host2  Host host3.cy198706.comIdentityFile ~/.ssh/mykeys/cy_host3</code></pre><p> 甚至可以使用通配符<code>*</code>来指定规则：</p><pre><code class="bash">  Host *.cy198706.comIdentityFile ~/.ssh/mykeys/cy_host</code></pre><p> 要想得知更多关于SSH配置文件的用法，查看<a href="https://kb.iu.edu/d/afjm">帮助页面</a>，或者<code>man ssh_config</code>。</p></li></ol><p><a href="#menu">Back to top</a></p><div id="Windows"></div><p>###在Windows上使用PuTTY设置SSH使用公钥</p><p><em>PuTTY命令行客户端，还有用来生成key的PuTTYgen工具，以及Pageant SSH认证代理工具，还有PuTTY SCP，Putty SFTP工具都是打包在一起下载的。打包版可以在<a href="http://the.earth.li/~sgtatham/putty/latest/x86/putty.zip">这儿</a>下载到。安装版可以在<a href="http://the.earth.li/~sgtatham/putty/latest/x86/putty-0.64-installer.exe">这儿</a>下载到。</em></p><p><em>墙内的同学你们有福了，该网站已被墙得体无完肤，我上传到了<a href="http://pan.baidu.com/s/1eQpmNAE">度娘网盘</a>提供下载。</em></p><p><em>下载完成后都有这些文件：</em></p><figure>  <img src="/images/putty1.png" alt="PuTTY"></figure><ol><li><p>打开PuTTYgen，如图所示</p><figure><img src="/images/putty2.png" alt="PuTTY"></figure></li><li><p>在下方的<code>Parameters</code>区域，可以选择<code>SSH-2 RSA</code>或者<code>SSH-2 DSA</code>加密方式。<code>Number of bits in a generated key</code>参数使用默认值就可以。</p></li><li><p>点击<code>Generate</code>，上方会出现一个进度条，并且提示你在空白区域移动鼠标（别移出去了！눈_눈），它就会随机生成一对key。然后公钥就会显示在上方的框里。如图所示。</p><figure><img src="/images/putty3.png" alt="PuTTY"></figure></li><li><p>在<code>Key passphrase</code>和<code>Confirm passphrase</code>输入框中，输入一个密码来保护你的私钥。当然你也可以不输入。</p></li></ol><p><em>UITS强烈建议使用密码来保护你的私钥。如果不使用密码的话，任何能访问你电脑的人都可以使用这个私钥来进行远程主机的登录。</em></p><ol start="5"><li><p>点击下方<code>Save public key</code>，指定公钥的名称，保存公钥。</p></li><li><p>点击下方<code>Save private key</code>，指定私钥的名称，保存私钥。<br> <em>如果你没有使用密码保护私钥的话，这时PuTTYgen会提醒你是否确定不使用密码保护。</em></p></li><li><p>使用用户名密码登录远程主机。<br> <em>如果你没有权限登录远程主机，那么你需要联系网络管理员来帮你创建</em><code>~/.ssh/authorized_keys</code><em>文件。</em></p></li><li><p>如果你的远程主机中没有<code>~/.ssh/authorized_keys</code>文件，则需要手动创建一个：</p><pre><code class="bash">mkdir -p ~/.ssh  touch ~/.ssh/authorized_keys</code></pre><p> <em>如果已有这个文件，则上面的命令并没有什么卵用</em></p></li><li><p>在你的电脑上，在PuTTYgen中，将公钥的内容拷贝一下，然后，在远程主机中把内容复制到<code>~/.ssh/authorized_keys</code>文件中。</p></li><li><p>打开Pageant SSH认证代理工具。这玩意会在后台运行，你只能在系统托盘区域看到它。右击托盘区域中的图标，选择Add Key，然后找到你刚才保存的私钥，选择之。</p><p>如果你在创建私钥时使用了密码保护，Pageant会询问你的密码是什么。</p></li><li><p>现在Pageant会把私钥保存在内存中，当你使用PuTTY访问远程主机时，该私钥就会起作用。</p></li><li><p>打开PuTTY客户端。如图。</p><figure><img src="/images/putty4.png" alt="PuTTY"></figure><ul><li><p><code>Session</code>页面的<code>Host Name (or IP address)</code>输入框中，输入远程主机的用户名和地址，例如<code>serious@cy198706.com</code>。</p></li><li><p>在<code>Connection type</code>中，选择SSH</p></li><li><p>在左侧列表的<code>Category</code>中，找到<code>Auth</code>页面（<code>Connection &gt; SSH &gt; Auth</code>）。在<code>Auth</code>页面的<code>Authentication methods</code>区域中，勾选<code>Attempt authentication using Pageant</code>。</p><figure><img src="/images/putty5.png" alt="PuTTY"></figure></li><li><p>返回<code>Session</code>页面，在<code>Saved Sessions</code>区域中输入一个名称用来保存这套配置，然后点击保存。</p></li><li><p>点击<code>Open</code>连接到远程主机。当Pageant在后台运行时，PuTTY将会自动获得私钥并使用，在登录到远程主机的过程中不会再次询问私钥的保护密码之类的信息。</p></li></ul><p><em>到这儿配置基本完成。需要注意的是，每次在开机之后，如果要使用Pageant，就必须手动启动它，添加私钥，再使用PuTTY。当然也有快捷的办法，下文将会继续介绍。</em></p></li><li><p>打开“启动”文件夹：</p><ul><li><p>Windows 8下，按Windows+R，输入<code>shell:startup</code>后回车就打开了。</p></li><li><p>Windows 7下，从开始菜单，点击所有程序，找到启动菜单，右击打开。</p></li><li><p>或者直接导航到“启动”文件夹：</p><pre><code class="bash">C:\Users\your_name\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</code></pre></li></ul></li><li><p>在文件夹中右键新建一个快捷方式。然后在弹出的对话框的输入框中输入你Pageant.exe的路径，也可以使用浏览找到它。接着在该路径的后面加一个空格，输入私钥的位置。例如：</p><pre><code class="bash">&quot;C:\Program Files (x86)\PuTTY\pageant.exe&quot; &quot;C:\Users\your_name\ssh_key\putty_private.ppk&quot;</code></pre><p>在下一步中，给快捷方式取个名字，点击完成。</p><p>这样在以后电脑开机之后，就会自动加载该私钥到Pageant中，省去了手动启动的麻烦。</p></li></ol><p><a href="#menu">Back to top</a></p>]]></content>
      
      
      <categories>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSH 与 SSH2</title>
      <link href="/2015-07-23/ssh-and-ssh2/"/>
      <url>/2015-07-23/ssh-and-ssh2/</url>
      
        <content type="html"><![CDATA[<p>什么是SSH和SSH2？看完这篇你就懂啦。</p><span id="more"></span><ul><li><p>SSH(Secure Shell)在你通过网络登录到另一台计算机、远程执行命令或者传输文件时，为你提供一个加密的通道。SSH提供一个强有力的主机对主机、主机对用户的认证，就如同网络上的加密通信一样。</p></li><li><p>SSH2是一个更加安全、有效，移植性强的SSH版本，它包含SFTP功能。SFTP与FTP功能相同，但SFTP是加密的。在印弟安那大学，UITS(<a href="https://uits.iu.edu/">University Information Technology Services</a>)已将其中心系统升级到了SSH2（通常都使用OpenSSH），并且提倡用户都使用SSH2来进行网络加密通讯。</p></li></ul><p>Mac OS X 集成了OpenSSH。在Windows下，则需要下载一个第三方的SSH客户端，比如SecureCRT和Putty。</p><p>当第一次连接到某台主机时，SSH将给你提供主机的指纹，并且询问你是否要将这个新的指纹和主机的路径存储到本地数据库中。在同意之前，你应该好好比对一下这个指纹是否与你之前得知的指纹（谁管你怎么得知的，打电话呗）相同，以避免连接到一个江湖骗子的主机上。输入<code>yes</code>之后，这条消息就不会再出现了。</p><p>比验证密码更好的，SSH2能使用公用密钥来进行主机的认证。例如，如果你想连接到某台远程主机，名称为host.cy198706.com （当然正在使用SSH2），SSH2会使用这套机制来验证这台主机是否可登录。如果你愿意的话，你可以在登录主机时，设置SSH2使用公钥来进行认证，而不是通过密码认证。如何设置，请看<a href="/ssh-using-public-key/">如何设置SSH使用公钥认证登录主机</a>。</p>]]></content>
      
      
      <categories>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在ant中使用exec更新版本号</title>
      <link href="/2015-07-17/ant-with-exec/"/>
      <url>/2015-07-17/ant-with-exec/</url>
      
        <content type="html"><![CDATA[<p>最近在Android中用Ant自动打包的过程中，有个要求，是从Git获取版本提交的总次数，加上最初版本的版本号，做为最新版本的版本号。</p><p>起初是写了一个shell脚本来做这件事。</p><pre><code class="sh">#!/bin/bashcd /home/serious/Workspace/client/count=`git rev-list origin/master --count`result=2.0.$countecho $resultsed -i &quot;s/android:versionName=\&quot;2.0.*\&quot;/android:versionName=\&quot;$&#123;result&#125;\&quot;/g&quot; AndroidManifest.xml</code></pre><p>但是这么一来，打包之前就会多一个步骤。我这么懒的人，怎么能允许这种事情发生？怎么能坐以待毙？</p><p>于是就翻看了ant的文档，找到解决方案。</p><span id="more"></span><p>在build.xml中，加入这么一段：</p><pre><code class="xml">&lt;target name=&quot;versioncode&quot;&gt;    &lt;exec executable=&quot;sh&quot;&gt;        &lt;arg value=&quot;update_vercode.sh&quot; /&gt;    &lt;/exec&gt;&lt;/target&gt;</code></pre><p>搞定。</p><p>但是，这样还多了个sh文件啊。我作为一个并不是处女座的洁癖，怎么能允许这种事情发生？怎么能坐以待毙？</p><p>于是找到了下面的解决方案：</p><pre><code class="xml">&lt;target name=&quot;versioncode&quot;&gt;        &lt;exec executable=&quot;sh&quot; outputproperty=&quot;v_name&quot;&gt;            &lt;arg value=&quot;-c&quot; /&gt;            &lt;arg value=&quot;git rev-list origin/master --count&quot; /&gt;        &lt;/exec&gt;        &lt;echo&gt;Revision (app): $&#123;v_name&#125;&lt;/echo&gt;        &lt;replaceregexp file=&quot;AndroidManifest.xml&quot; match=&#39;android:versionName=&quot;2.0.*&quot;&#39; replace=&#39;android:versionName=&quot;2.0.$&#123;v_name&#125;&quot;&#39; /&gt;&lt;/target&gt;</code></pre><p>Ant中执行系统命令时（比如上文的git命令和sh命令），在Windows下和在Linux下的方式是不同的。</p><ul><li>Windows</li></ul><pre><code class="xml">&lt;target name=&quot;help&quot;&gt;  &lt;exec executable=&quot;cmd&quot;&gt;    &lt;arg value=&quot;/c&quot;/&gt;    &lt;arg value=&quot;ant.bat&quot;/&gt;    &lt;arg value=&quot;-p&quot;/&gt;  &lt;/exec&gt;&lt;/target&gt;</code></pre><ul><li>Linux</li></ul><pre><code class="xml">&lt;target name=&quot;help&quot;&gt;  &lt;exec executable=&quot;sh&quot;&gt;    &lt;arg value=&quot;-c&quot;/&gt;    &lt;arg value=&quot;ant.sh&quot;/&gt;    &lt;arg value=&quot;-p&quot;/&gt;  &lt;/exec&gt;&lt;/target&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>弱者只会抱怨，强者总会改变</title>
      <link href="//gabby/%25e5%25bc%25b1%25e8%2580%2585%25e5%258f%25aa%25e4%25bc%259a%25e6%258a%25b1%25e6%2580%25a8%25ef%25bc%258c%25e5%25bc%25ba%25e8%2580%2585%25e6%2580%25bb%25e4%25bc%259a%25e6%2594%25b9%25e5%258f%2598/"/>
      <url>//gabby/%25e5%25bc%25b1%25e8%2580%2585%25e5%258f%25aa%25e4%25bc%259a%25e6%258a%25b1%25e6%2580%25a8%25ef%25bc%258c%25e5%25bc%25ba%25e8%2580%2585%25e6%2580%25bb%25e4%25bc%259a%25e6%2594%25b9%25e5%258f%2598/</url>
      
        <content type="html"><![CDATA[<p>现在，每天中午，吃饭的时候，我跟三个同事是在一起的。而噩梦也就开始了。</p><p>我们四个人，我是山东的，两个湖北的，一个湖南的。湖北的两个暂且命名为<strong>J</strong>君和<strong>H</strong>君，湖南的命名为<strong>L</strong>君。<span id="more"></span></p><img alt="" src="http://wenwen.soso.com/p/20100404/20100404173452-1536354237.jpg" style="width: 500px; height: 375px;" /><p><strong>J</strong>君是比较正常的那种人，农村出身，有四个姐姐。对各种事情都有自己的见解，不随大流，喜欢各种各样的汽车，而且极其清楚每种配置的价格，喜好军事，喜好经济，口齿有点不清楚，脸上的青春痘也无视这家伙已经23了，噌噌地往外长。总之，是个很好相处的人。</p><p><strong>L</strong>君是个特别喜欢秀下限的人。标准90后，自从他加入了我们，我们都感觉，我们小组的平均智商被拉到了一个肉眼不可见的水平。平时我们仨都喜欢调戏他，从他身上的围巾，到他深不可测的智商。我感觉，每一个四人组里，总需要这么一个人，也总会有这么一个人，这样在路上，不至于冷场。</p><p><img src="http://www.xlabc.com/upfiles/allimg/090624/1431250.jpg" style="margin-left: 10px; float: right;" /><strong>H</strong>君是个让我特别有感触的人，看到他，我就知道，我以后不能做哪些事了。并不是说他多么多么不像样，而是，在外人面前，像这样表现，只能被别人无视，并且在心里骂一句&ldquo;傻逼&rdquo;。</p><p>他的技能就是&ldquo;抱怨&rdquo;，对任何一点小事都能抱怨个没完没了，厕所没纸了，昨天又加班了，发票报了没给钱，现在结婚真TM早，电梯真够慢的等等等等，每天都会听到他的抱怨。<br>他的另一个技能是&ldquo;孤僻&rdquo;，当大家都聊天的时候，他就独自装酷，甚至聊了一会，发现他居然不见了。回来问&ldquo;去哪了&rdquo;，也不吱声，看起来像个怨妇，在怨我们把他抛弃了。<br>第三个技能是&ldquo;口刁&rdquo;，无论中午吃什么，绝对能听到他说&ldquo;什么东西，难吃死了&rdquo;，然后吃得干干净净。或者在自己的菜比较单一时，夹别人一筷子，然后眉头紧皱，说&ldquo;这种东西你也吃得下&rdquo;，搞得别人全无胃口。</p><p>但因为我是后来人，算是&ldquo;新人&rdquo;，虽然年龄是最大的（一个90后，一个一脚踏在90门槛上，一个89年的），但也没资格说别人什么。其实我也不想对他说什么，没必要啊。</p><p>以前我也是个很能抱怨的人，大事小事都要抱怨一番，可能也烦到了我的一些朋友，他们可能也有跟我现在一样的想法。不过后来发现，抱怨其实什么也改变不了，安安心心吃你的饭，成功消化，成功排泄，这就算是功德圆满了，抱怨有什么用呢。</p><p>忘记在哪看到这句话了，&ldquo;弱者抱怨命运的无情,强者扼住命运的咽喉&rdquo;。的确是这样，抱怨不是不可以，偶尔抱怨一下并不会表示你这个人是个废物，因为没有哪个人的心性是完美的。但是天天抱怨，当抱怨成为一种习惯，就会被命运抛弃。</p><p>有时，抱怨的感觉挺不错，因为我们总喜欢做&ldquo;对&rdquo;的一方。我们总是为自己辩解：&ldquo;是这个人侵犯了我&rdquo;、&ldquo;是那个家伙的错&rdquo;，殊不知我们正一步步滑入抱怨的泥潭，止步不前。其实我们可以选择：是陷入自以为是的泥潭，还是放下抱怨继续上路？别忘了自己活得滋润才是对他人最好的报复。</p><p>说真的，埋怨世界可以上瘾。但只要你愿意，你就能停止抱怨的游戏。有时我们没法改掉习惯，因为我们惧怕改变。但请相信只要你抛弃埋怨的习惯，一个崭新的你便诞生了。答案和方向就在你拨开云雾的那一刹那便可以清楚看到。</p><p>现在社会各种竞争激烈严酷、各种恐惧的蔓延纠结，让我们变得如刺猬般&ldquo;剑气十足&rdquo;：对周遭的一切抱怨不止，却极少静下心来反省自己。当然，这并不是说就应将一切责任都揽给自己，而是应该接受现实，从经历中成长，原谅自己，从失败中重新振作，并制定下一步的计划。不管怎样，时间不等人。</p><p>国外都有专家研究出，听多了抱怨，会损伤我们英明神武的大脑的。所以，让我们远离抱怨吧。</p><p>有一则古老的寓言，或许可以给我们一些启示。</p><blockquote><p>有一个年轻的农夫，划着小船，给另一个村子的居民运送自家的农产品。那天的天气酷热难耐，农夫汗流浃背，苦不堪言。他心急火燎地划着小船，希望赶紧完成运送任务，以便在天黑之前能返回家中。突然，农夫发现，前面另外一只小船，沿河而下，迎面向自己快速驶来。眼见着两只船就要撞上了，但那只船并没有丝毫避让的意思，似乎是有意要撞翻农夫的小船。</p><p>&ldquo;让开，快点让开！你这个白痴！&rdquo;农夫大声地向对面的船吼叫道。&ldquo;再不让开你就要撞上我了！&rdquo;但农夫的吼叫完全没用，尽管农夫手忙脚乱地企图让开水道，但为时已晚，那只船还是重重地撞上了他。农夫被激怒了，他厉声斥责道：&ldquo;你会不会驾船，这么宽的河面，你竟然撞到了我的船上？！&rdquo;当农夫怒目审视对方小船时，他吃惊地发现，小船上空无一人。听他大呼小叫，厉言斥骂的只是一只挣脱了绳索、顺河漂流的空船。</p></blockquote><p>好久没码字了，语竭词穷了。</p>]]></content>
      
      
      <categories>
          
          <category> 口水 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 口水 </tag>
            
            <tag> 人生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的2012</title>
      <link href="//gabby/%25e6%2588%2591%25e7%259a%25842012/"/>
      <url>//gabby/%25e6%2588%2591%25e7%259a%25842012/</url>
      
        <content type="html"><![CDATA[<div>  &nbsp; &nbsp; &nbsp; &nbsp; 2012年，有惊无险地过来了。</div><div>  &nbsp;</div><div>  &nbsp; &nbsp; &nbsp; &nbsp; 回顾这一年，酸甜苦辣都有，算是让我在这一年体会到了人生的多姿多彩。</div><div>  &nbsp;</div><div>  &nbsp; &nbsp; &nbsp; &nbsp; 之前在我的脑海里，印象最深的一年是1993年，其实我也不知道为什么印象最深刻，但是如果别人问起来，肯定就是1993年，可能跟纽约世贸中心发生爆炸有关系？（笑）</div><div>  &nbsp;</div><div>  &nbsp; &nbsp; &nbsp; &nbsp; 现在来说，印象最深刻的肯定就是2012年了。</div><div>  &nbsp;</div><div>  &nbsp; &nbsp; &nbsp; &nbsp; 2012年注定是不平凡的一年，25岁，算是正式度过了人生的1/4&#8211;或许是1/3更好些。这一年世界上发生的事情太多，跟我有关系的倒是不多。或许世界末日跟我有点关系吧，但是这一天是跟最爱的人一起度过的，蛮有意义。</div><div>  <span id="more"></span></div><h2 style="text-align: center;">  <span style="color:#ffa500;">酸</span></h2><p style="text-align: center;">  <strong>&#8212; 酸是种催化剂</strong></p><div>  &nbsp; &nbsp; &nbsp; &nbsp; 2010年我来到北京，到2012年7月整两年。<br /> &nbsp;</div><div>  &nbsp; &nbsp; &nbsp; &nbsp; 北京给我的第一印象很不错，交错盘杂的立交桥，哪哪都是人的景点，干净的街道，满目的高楼大厦，穿得很有质量的行人。</div><div>  &nbsp; &nbsp; &nbsp; &nbsp; 深入了解北京后，才感觉不是那么回事。北京表面看起来很光鲜亮丽，内里的污浊是深到骨髓里的。碍于天朝制度，我不能在这里说一朝之都的坏话，否则被跨省了就不好了。毕竟我也是天朝的一分子。<br /> &nbsp;</div><div>  &nbsp; &nbsp; &nbsp; &nbsp; 现在的京城给我的感觉很差。混浊的空气，每天要瘫痪几次的交通（地铁很方便），鱼龙混杂的人，高明的骗子，昂贵的生活。</div><div>  &nbsp; &nbsp; &nbsp; &nbsp; 了解了京城，却又不得不在这种大环境下随波逐流，真的是很无奈，谁让咱是为了生活呢。<br /> &nbsp;</div><div>  &nbsp; &nbsp; &nbsp; &nbsp; 2011年底，在合肥度过了一段灰暗的时光，在2012年年初又转战陕西，1个月不长不短，但却将我的信心和耐心磨得一干二净。索性离开陕西，独自一人踏上回北京的路，心中的酸涩无人可诉。</div><div>  &nbsp; &nbsp; &nbsp; &nbsp; 接下来在找工作的过程中，又被打击得体无完肤。总想着自己已经可以独当一面了，到头来还是什么都不会，被面试的人说得面红耳赤。<br /> &nbsp;</div><div>  &nbsp; &nbsp; &nbsp; &nbsp; 最后来到这家公司，自己所在的部门只有自己一个人，在别人看起来&ldquo;哇，你既是部门经理又是技术总监又是员工哎！&rdquo;，却无法了解其中的难受之处。</div><div>  &nbsp; &nbsp; &nbsp; &nbsp; 因为前期被打击，工资没敢要太高，以致现在手头还是紧张得要命。我又不会存钱，几乎每个月都向月光群体靠拢，总是感觉钱不够。说实话我对金钱的欲望并不强烈，但有时在街上走，风啊雨啊的吹过来，还是很羡慕那些坐在车里暖暖和和舒舒服服的人的。<br /> &nbsp;</div><div>  &nbsp; &nbsp; &nbsp; &nbsp; 换了工作，也换了个新的住所。也许是我涉世未深，也许是我真的没什么脑子，对人没什么防备之心，居然就被骗着住了个很暗很暗的隔断间。当时正是春夏交际时，温度和湿度都适宜，但到了夏天就有想死的心了。这都不是重点，大不了多洗澡，多开会风扇，重点是同住的人是有多奇葩。</div><div>  &nbsp; &nbsp; &nbsp; &nbsp; 隔壁是四个白痴，其中一个从来不上班，因为我随时都能听到他的大嗓门，在喊&ldquo;艹！加血啊！艹，会不会打！&rdquo;；第二个拉完屎从来不冲，终于在一个晚上隔壁的隔壁的女人忍不住了，跟这白痴大吵了一通，这白痴还TM穿着红裤衩，站在走廊里，跟个暴露狂一样；第三个会弹吉他，曾经的记录是连续唱了两个星期的《你的背包》，这也就罢了，关键是他唱歌的调调实在让人不敢直视，真教人欲死不欲生；第四个每天都要抱怨生活的不公平，每天回到家都要长叹一口气，然后开始诉苦，说真没意思，拿这两千块钱的工资，还每天累得跟孙子一样。</div><div>  &nbsp; &nbsp; &nbsp; &nbsp; 隔壁的隔壁的女人其实也是个奇葩。她跟另一个女人住在一起，洗澡时一定是两个人一起，时间特别特别长，至少要两个小时，这让我们喝多了水憋着的人情何以堪。</div><div>  &nbsp; &nbsp; &nbsp; &nbsp; 还有偷肥皂的，出门从来不关门的，洗了袜子内裤随便往别人衣服上搭的，在满是蟑螂的厨房里做饭的，在洗衣机里洗鞋的，在冰箱里放避孕套的。。人生真的很神奇，可以遇见各种各样的人。<br /> &nbsp;</div><h2 style="text-align: center;">  <span style="color:#0000ff;">甜</span></h2><p style="text-align: center;">  <strong>&#8212; 最幸福的就是甜</strong></p><div>  &nbsp; &nbsp; &nbsp; &nbsp; 2012年2月2日，这个日子很普通，我认识了她。当时我人在合肥，一腔苦闷无人能解，也是她帮我排解，跟我一起嬉笑怒骂，给我指明方向。<br /> &nbsp;</div><div>  &nbsp; &nbsp; &nbsp; &nbsp; 茫茫人海中两人从相遇，相识，相知，相亲相爱，这就是缘分吧。当我发现两人的手机号竟然只差一位数时，心里有种异样的感觉，我觉得，就是她了。<br /> &nbsp;</div><div>  &nbsp; &nbsp; &nbsp; &nbsp; 她说她脾气很暴躁，总是动不动就发火，这点我领教到了。不过，爱她，就可以包容她的缺点，况且我的脾气好，也算是互补吧。</div><div>  &nbsp; &nbsp; &nbsp; &nbsp; 可是她也温柔似水啊，我就完全抗拒不了这一点。<br /> &nbsp;</div><div>  &nbsp; &nbsp; &nbsp; &nbsp; 4月7号我就向她表白了。还算是顺利吧，虽然她后来老向我抱怨我没正式地追过她。。<br /> &nbsp;</div><div>  &nbsp; &nbsp; &nbsp; &nbsp; 马上又要2月2号了，一年过得真快。在这一年里，我们一起毫无形象地大笑，一起为伤心的事情抱头痛哭，为了一点小屁事吵架，为了一点不公平合伙怒骂，这都是最美好的回忆。</div><div>  &nbsp; &nbsp; &nbsp; &nbsp; 我们一起出去旅行，一起为未来做打算，一起做饭，一起学跳舞，一起减肥（呃某人看到不要揍我），许许多多的故事，都是我们的财富。<br /> &nbsp;</div><div>  &nbsp; &nbsp; &nbsp; &nbsp; 我曾经在她上课的时候突然出现在她的身后，在儿童节的时候带着兔斯基去驾校接她，在七夕的时候给她送花，在圣诞夜的时候给她定情的戒指&#8211;好吧，我承认这些都不浪漫，我并不是个会制造浪漫的人，她也老说&ldquo;咱俩就像老夫老妻似的，有木有&rdquo;。<br /> &nbsp;</div><div>  &nbsp; &nbsp; &nbsp; &nbsp; 今年生过两场大病，都把她吓坏了。第一场是无缘故地拉肚子，持续了快一个周，整个人都虚脱了，发烧，没力气动。她半夜两点跑出去买退烧药，我在床上感动得死去活来的。第二场是非常严重的感冒，我从来没有感冒到这种程度，从一开始的嗓子疼，咳嗽，到后来呕吐，发烧，拉肚子，流鼻涕。。后来逢人我就说，这次可算是彻底感冒了一次。她请假在家照顾我，我很愧疚，在她做饭的时候，挪到厨房去看她，她说&ldquo;来这干什么，赶紧回去，别冻着。&rdquo;我向她表达我的歉疚之情，她很平淡地说&ldquo;这不应该的么。&rdquo;人生得此女，无所求也。<br /> &nbsp;</div><div>  &nbsp; &nbsp; &nbsp; &nbsp; 2012年12月9号，我们订婚了。10个月相处的时间，我觉得这就是我的人生伴侣了，可以将自己交付予她，她也可以把自己的未来交给我。我相信，未来在我们自己的手上！<br /> &nbsp;</div><h2 style="text-align: center;">  <span style="color:#008000;">苦</span></h2><p style="text-align: center;">  <strong>&#8212; 人间正道是沧桑</strong></p><div>  &nbsp; &nbsp; &nbsp; &nbsp; 佛说：人有八苦，生苦，老苦，病苦，死苦，怨憎会苦，爱别离苦，求不得苦，五蕴炽盛苦。唯有身心放空，方能人离难，难离身，一切灾殃化为尘。<br /> &nbsp;</div><div>  &nbsp; &nbsp; &nbsp; &nbsp; 我这个人，没什么太大耐心，要说吃苦，真吃不了。可是有些苦，却是能捱过来的。<br /> &nbsp;</div><div>  &nbsp; &nbsp; &nbsp; &nbsp; 从去年四月份进入这家公司，就开始了一种和以前截然不同的生活。每天上班要挤公交，挤完公交挤地铁，每天上班下班都要浪费掉两个小时，让人感叹北京人怎么这么多的同时，也暗暗叫苦。我有轻度强迫症，讨厌在车上被不认识的人碰，所以挤车的时候是个很痛苦的过程。常常很好的心情，就因为挤了个公交或者地铁，马上就乌云密布了。</div><div>  &nbsp; &nbsp; &nbsp; &nbsp; 但看看周围的人，哪个又不是这样，还有很多通州的人，大老早就坐车，到国贸上班。所以，这点苦，又算得了什么，我也没资格抱怨什么，年轻人，吃点苦怕什么，等到年纪大了，才能懂得，这些操蛋的经验才叫人生。</div><div>  &nbsp;</div><h2 style="text-align: center;">  <span style="color:#b22222;">辣</span></h2><p style="text-align: center;">  <strong>&#8212; 瞧我这爆脾气</strong></p><div>  &nbsp; &nbsp; &nbsp; &nbsp; 小的时候还蛮能吃辣的，长大了越发不行了。就好像我小时候被骂没什么关系，脸皮厚，长大了脸皮薄，被骂了就挂不住了。<br /> &nbsp;</div><div>  &nbsp; &nbsp; &nbsp; &nbsp; 这一年被很多不同的人骂过。有的是善意的，有的是恶意的。恶意的我从来都不放在身上，因为我是不会去咬马路上对着我狂吠的狗的。善意的骂每次都会难过，但过后都会想明白，我被骂也是应该的。<br /> &nbsp;</div><div>  &nbsp; &nbsp; &nbsp; &nbsp; 大抵是在1月份，当时在合肥，跟老外一起共事。有一次出了点问题，我没有跟他商量就擅自做了决定，当时我想，这个决定并不会对我们造成什么影响。没想到老外知道之后雷霆震怒，大声地斥责我，说为什么不告诉他，为什么不通知其他的领导让他们来拿主意。我的爆脾气也瞬间燃了，跟他对呛起来，场面一时失控。后来他抛下一句&ldquo;你自己想想吧&rdquo;就回办公室了。怒火过后，我静下心来，想当时的确不应该自己拿决定，毕竟不是一块钱两块钱的事，是每天上千万的交易，如果有了差错，事情只能落在我的头上，因为这个决定是我做的，我担当不起。事后跟老外道歉，他接受了，也没再说什么，所幸也没发生什么事情。<br /> &nbsp;</div><div>  &nbsp; &nbsp; &nbsp; &nbsp; 后来有一次。那一段时间我无所事事，上面交给我的事情我都不做，因为他们都远在陕西。每天都是&ldquo;放羊混日子&rdquo;的状态，上班看小说，下班玩游戏，不亦乐乎。期间有个其他的领导会指使我做一些跑腿的事情，我碍于上下级的关系，就会帮他做些事情。后来我的直属领导专程打电话过来，劈头盖脸骂我一通，说&ldquo;我才是你的领导，别的领导指使我的员工，我的员工可以不干！下次再让我知道你替他跑腿，你就干脆去他那边得了！程序员不是用来跑腿买烟的！&rdquo;我心里很委屈，却也只能反思自己的不是。领导也是有逆鳞的，他的逆鳞大概就是这样吧。<br /> &nbsp;</div><div>  &nbsp; &nbsp; &nbsp; &nbsp; 因为订婚，就牵扯到买房，结婚，生子。我心里压力骤增。80后都是悲摧的一代，他们生活的年代，拿着什么都买不起的工资，过着什么都买不起的日子。但是对我来说，压力是阻碍，也是动力，只想着靠死工资每天好吃懒作，什么时候是个头。爸妈肯定也希望我以后能有个好生活，不是么。</div><div>  &nbsp;</div><h2 style="text-align: center;">  续</h2><p style="text-align: center;">  <strong>&#8212; 人生还要继续</strong></p><div>  &nbsp; &nbsp; &nbsp; &nbsp; 从半个月前就开始规划这篇文章，后来发现还是没有按照预想的路子码字。<br /> &nbsp;</div><div>  &nbsp; &nbsp; &nbsp; &nbsp; 酸甜苦辣写完，感觉又明白了很多东西。<br /> &nbsp;</div><div>  &nbsp; &nbsp; &nbsp; &nbsp; 上高中的时候，我写过一句话：人生就是个舞台，各种各样的剧都在上演着。如果没有剧目，那就没人看了。</div><div>  &nbsp; &nbsp; &nbsp; &nbsp; 很对，是不？嘿嘿。<br /> &nbsp;</div><div>  &nbsp; &nbsp; &nbsp; &nbsp; 路还要继续走，玛雅人说好的世界末日并没有如约而至，2013迈着轻松的脚步向我们走来。我们不能停下，更不能放弃，世界多么精彩。</div>]]></content>
      
      
      <categories>
          
          <category> 口水 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 口水 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FlipBoard &amp;#8211; 优秀的社交杂志</title>
      <link href="//just-try/flipboard/"/>
      <url>//just-try/flipboard/</url>
      
        <content type="html"><![CDATA[<p>我用社交网络客户端，比如新浪微博，比如Weico，比如四次元，但都做不到这一点。<br>我用新闻软件客户端，比如百度新闻App，比如Google Reader，比如网易Zaker，但都做不到这一点。<br>我用杂志客户端，比如Viva，比如掌媒，比如Google Currents，但都做不到这一点。</p><p>Flipboard可以做到。Flipboard可以完美地结合社交与新闻与杂志元素。</p><p>那么什么是 Flipboard？它做了一件非常简单的事情：把你的新浪微博和豆瓣和变成了一本杂志。</p><p>Flipboard 反馈出来的是一种优雅的态度，将阅读真正变成一种&ldquo;享受&rdquo;。它与众不同的地方就在于它的设计，大量的触摸操作让它变得非常迷人：</p><blockquote><ol><li>点击一篇文章，它就会&ldquo;放大&rdquo;去显示更多的 内容。  </li><li>点击一个视频，它就会在文章内播放。  </li><li>让所有的东西去适应你的设备，连照片都会从竖直转换到水平方向。  </li><li>点击长文里的&ldquo;获取更多网络内容&rdquo;将会重定向到该文的发布站点。  </li><li>当你导入自己某个社交网络里好友时，他们的照片、状态信息都会显示在布局精致的页面里。  </li><li>根据正在阅读的内容，你可以通过触摸来分享、收藏、表示喜好或者转发。</li></ol></blockquote><p>Flipboard分为&ldquo;通用版&rdquo;与&ldquo;天朝版&rdquo;，鉴于阅读这篇文章的人大部分是天朝人，我就以&ldquo;天朝版&rdquo;做为评测的主要内容。  </p><span id="more"></span><p>首次安装进入Flipboard时，会有一个欢迎界面，非常类似Twitter的欢迎界面。</p><div style="text-align: center;">  <a href="http://i1352.photobucket.com/albums/q645/cy198706/Android/Screenshot_2013-02-01-17-18-58.png"><img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/Android/Screenshot_2013-02-01-17-18-58.png" style="width: 480px; height: 854px;" /></a></div><p>页面的下部还会自动有一个向上&ldquo;翻&rdquo;的动作，提示你可以通过&ldquo;向上滑&rdquo;的手势进入下一个页面。我们来&ldquo;翻&rdquo;一下，进入登录界面。</p><div style="text-align: center;">  <a href="http://i1352.photobucket.com/albums/q645/cy198706/Android/Screenshot_2013-02-01-17-19-20.png"><img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/Android/Screenshot_2013-02-01-17-19-20.png" style="width: 480px; height: 854px;" /></a></div><p>我们可以选择是否要通过Flipboard账号来登录。不登录也可以，只不过在管理社交网络方面会有点不方便，之后也可以通过设置来进行登录。</p><p>我注册了一个Flipboard账号，并用其来登录。接下来就会跳转到另一个界面，选择要订阅的内容。</p><div style="text-align: center;">  <a href="http://i1352.photobucket.com/albums/q645/cy198706/Android/Screenshot_2013-02-01-17-19-41.png"><img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/Android/Screenshot_2013-02-01-17-19-41.png" style="width: 480px; height: 854px;" /></a></div><p>选择你喜欢的内容，可以通过&ldquo;翻&rdquo;的手势来看看下一页的可订阅内容。</p><div style="text-align: center;">  <a href="http://i1352.photobucket.com/albums/q645/cy198706/Android/Screenshot_2013-02-01-17-19-47.png"><img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/Android/Screenshot_2013-02-01-17-19-47.png" /></a></div><p>选择完成，点击右上角的&ldquo;完成&rdquo;按钮，就可以进入首页了。</p><div style="text-align: center;">  <a href="http://i1352.photobucket.com/albums/q645/cy198706/Android/Screenshot_2013-02-01-17-22-01.png"><img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/Android/Screenshot_2013-02-01-17-22-01.png" /></a></div><p>可以看到，&ldquo;封面故事&rdquo;与&ldquo;Flipboard精选&rdquo;、&ldquo;新闻&rdquo;三个版块以一大二小的方式排列在屏幕上。</p><p>点击&ldquo;封面故事&rdquo;，则整个页面会被&ldquo;封面故事&rdquo;所占据。</p><div style="text-align: center;">  <a href="http://i1352.photobucket.com/albums/q645/cy198706/Android/Screenshot_2013-02-01-17-22-44.png"><img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/Android/Screenshot_2013-02-01-17-22-44.png" /></a></div><p>在Flipboard中，最常用的手势就是&ldquo;点击&rdquo;&ldquo;向上滑&rdquo;&ldquo;向下滑&rdquo;和&ldquo;向右滑&rdquo;。</p><p>点击通常用于浏览详细内容和选中链接并查看，查看图片，查看视频等。比如在上一张图中点击，则会进入详细信息页面。</p><div style="text-align: center;">  <a href="http://i1352.photobucket.com/albums/q645/cy198706/Android/Screenshot_2013-02-04-11-25-46.png"><img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/Android/Screenshot_2013-02-04-11-25-46.png" style="width: 480px; height: 854px;" /></a></div><div style="text-align: center;">  <a href="http://i1352.photobucket.com/albums/q645/cy198706/Android/Screenshot_2013-02-01-17-31-33.png"><img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/Android/Screenshot_2013-02-01-17-31-33.png" /></a></div><p>向上滑通常用于继续浏览下面的内容。比如在刚才的&ldquo;封面故事&rdquo;向上滑，则会看到其他的封面故事项目。</p><div style="text-align: center;">  <a href="http://i1352.photobucket.com/albums/q645/cy198706/Android/Screenshot_2013-02-01-17-22-55.png"><img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/Android/Screenshot_2013-02-01-17-22-55.png" /></a></div><p>向下滑通常用于回顾上面的内容，和刷新整个页面的内容。</p><div style="text-align: center;">  <a href="http://i1352.photobucket.com/albums/q645/cy198706/Android/Screenshot_2013-02-01-17-30-41.png"><img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/Android/Screenshot_2013-02-01-17-30-41.png" /></a></div><p>向右滑一般用来返回上一个页面。</p><p>如果我想订阅其他频道和内容呢，很简单，随时随地点击右上角的小旗子，就可以进入快捷面板。</p><div style="text-align: center;">  <a href="http://i1352.photobucket.com/albums/q645/cy198706/Android/Screenshot_2013-02-01-17-23-26.png"><img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/Android/Screenshot_2013-02-01-17-23-26.png" style="width: 480px; height: 854px;" /></a></div><p>可以看到，右上角可以快速地发微博（当然前提是你通过账号登录绑定了微博或者人人等），下面的列表就是分类了。</p><div style="text-align: center;">  <img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/Android/Screenshot_2013-02-01-17-23-38.png" style="width: 480px; height: 854px;" /></div><div style="text-align: center;">  <img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/Android/Screenshot_2013-02-01-17-24-40.png" style="width: 480px; height: 854px;" /></div><div style="text-align: center;">  <img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/Android/Screenshot_2013-02-01-17-25-30.png" /></div><p>如果需要订阅，则直接点击项目右边的加号就可以了。</p><p>没有喜欢的内容？没关系，搜索来帮你。搜索不但会帮你找到相应的版块用于添加到订阅，也可以帮你找到含有些关键字的微博。</p><div style="text-align: center;">  <a href="http://i1352.photobucket.com/albums/q645/cy198706/Android/Screenshot_2013-02-01-17-27-02.png"><img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/Android/Screenshot_2013-02-01-17-27-02.png" style="width: 480px; height: 854px;" /></a></div><p>Flipboard&ldquo;通用版&rdquo;与&ldquo;天朝版&rdquo;有一个小区别，就是&ldquo;天朝版&rdquo;可以进行离线下载，以便在信号不好或者不想浪费流量时进行阅读。看来的确很有&ldquo;天朝特色&rdquo;，因为天朝的网络信号的确是太差了，走哪哪没网络，而且天朝的网是世界上最贵的，谁不想省点钱啊。。。</p><p>在阅读界面点击设备上的菜单按钮，就可以弹出一个小菜单。</p><div style="text-align: center;">  <a href="http://i1352.photobucket.com/albums/q645/cy198706/Android/Screenshot_2013-02-01-17-23-45.png"><img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/Android/Screenshot_2013-02-01-17-23-45.png" /></a></div><p>Flipboard的设置按钮藏得很妙，不仔细观瞧还真不好找。<br>在首页，向下翻一页，看见其他订阅内容的同时，也可以看到右下角有个小齿轮，这就是设置界面的入口了。</p><div style="text-align: center;">  <a href="http://i1352.photobucket.com/albums/q645/cy198706/Android/Screenshot_2013-02-01-17-30-56.png"><img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/Android/Screenshot_2013-02-01-17-30-56.png" /></a></div><p>顺道提一句，当这个页面上的内容有更新时，每一个小块块会像百页窗一样翻下来，效果很棒。</p><p>Flipboard的设置选项不多，其实没必要设置太多的东西，因为软件本身的设置已经很不错了。</p><div style="text-align: center;">  <a href="http://i1352.photobucket.com/albums/q645/cy198706/Android/Screenshot_2013-02-01-17-29-10.png"><img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/Android/Screenshot_2013-02-01-17-29-10.png" /></a></div><div style="text-align: center;">  <a href="http://i1352.photobucket.com/albums/q645/cy198706/Android/Screenshot_2013-02-04-12-28-30.png"><img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/Android/Screenshot_2013-02-04-12-28-30.png" style="width: 480px; height: 854px;" /></a></div><p>总的来说，Flipboard大胆地将社交元素集中在一起，并通过杂志的方式展示在用户面前，是一种很有创意的行为。<br>当然，它也是有一些不足的，比如在过滤&ldquo;无聊的内容&rdquo;方面，就做得不太好；上手过程稍显繁琐；无法选择&ldquo;只阅读文字&rdquo;（针对小水管用户）等等。</p><p>但优点足以盖过缺点，Flipboard在ios上的表现比Android上更好，但手边没有ios设备，遂作罢。</p>]]></content>
      
      
      <categories>
          
          <category> 折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android App </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用GAE+GoAgent科学上网</title>
      <link href="//just-try/gae-proxy-goagent/"/>
      <url>//just-try/gae-proxy-goagent/</url>
      
        <content type="html"><![CDATA[<p>终于要聊到这个话题了吗。。</p><p>因为我最近发现，Google老是屏蔽我，我搜索了一个完全不会触及任何底线的词，竟然就把我Ban掉了，导致全公司都上不了Google。。</p><p>之前折腾过GAE+GoAgent，也成功过，后来发现没什么大用，因为上班时又不能老挂着GoAgent，毕竟用内网的时候还是居多的。但这次实在是忍不了了，对不起了，伟大的GFW，我要跃过你丫的。  </p><span id="more"></span><p>废话不说，先去创建一个Google的账号，如果你没有账号的话，那还聊什么聊。<br>&nbsp;</p><h4 id="一、申请Google-Appid"><a href="#一、申请Google-Appid" class="headerlink" title="一、申请Google Appid"></a>一、申请Google Appid</h4><ol><li>进入<a href="https://appengine.google.com/">Google AppEngine</a>，点击&ldquo;Create Application&rdquo;，如果是第一次创建的话，应该会提示要输入手机号码进行验证，大胆地验证吧，Google不会坑你的。</li></ol><p>验证完成后，进入如下界面：<br><a href="http://i1352.photobucket.com/albums/q645/cy198706/mess-ups/QQ20130205112620.jpg" target="_blank"><img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/mess-ups/QQ20130205112620.jpg" /></a><br>如果是第一次创建应用的话，下方会提示同意谷歌的协议，勾选上&ldquo;I accept these terms.&rdquo;就可以了。</p><ol start="2"><li><p>填写你的Appid，记得检查一下可用性，因为Appid必须是唯一的。<br>然后填入应用的名称，随便起啦，比如myagent-byebyeGFW之类的。。但是要注意，名称是有规定的，&ldquo;只能在4-30个字符之间，字母、数字、引号、连字符、逗号和叹号为可用字符。&rdquo;习惯写C和Java的同学们要注意，不要加下划线上去。</p></li><li><p>点击&ldquo;Create Application&rdquo;。好哎，出现如下页面，表示你的App已经创建成功了！<br><a href="http://i1352.photobucket.com/albums/q645/cy198706/mess-ups/QQ20130205112538.jpg"><img src="http://i1352.photobucket.com/albums/q645/cy198706/mess-ups/QQ20130205112538.jpg"></a><br>网页上的操作完成，接下来是本地操作。</p></li><li><p>去<a href="https://code.google.com/p/goagent/">传送门</a>这儿下载GoAgent的程序包，如果下载不了的话（嗯，你被墙了），可以下载文章最后提供的附件。</p></li></ol><p>5.&nbsp;解压GoAgent到任意位置。进入Server文件夹，用文本编辑器打开python文件夹下的app.yaml文件，将第一行Application:your_appid后的your_appid更换为你刚才申请的appid。保存退出。</p><ol start="6"><li>以管理员身份运行Uploader.bat，提示输入Appid，输入邮箱（注册Google账号时的邮箱），输入密码，就自动开始上传了。<br><a href="http://i1352.photobucket.com/albums/q645/cy198706/mess-ups/QQ20130205113930.jpg"><img src="http://i1352.photobucket.com/albums/q645/cy198706/mess-ups/QQ20130205113930.jpg"></a></li></ol><p>到最后，出现这个东西，就表明成功鸟。<br><a href="http://i1352.photobucket.com/albums/q645/cy198706/mess-ups/QQ20130205122648.jpg"><img src="http://i1352.photobucket.com/albums/q645/cy198706/mess-ups/QQ20130205122648.jpg"></a><br>&nbsp;</p><h4 id="二、配置GoAgent客户端"><a href="#二、配置GoAgent客户端" class="headerlink" title="二、配置GoAgent客户端"></a>二、配置GoAgent客户端</h4><ol><li><p>进入local文件夹（与Server文件夹同级目录），打开proxy.ini，修改[gae]模块下的appid字段为你刚才申请的appid。保存退出。</p></li><li><p>以管理员身份运行goagent.exe，出现此窗口，这个窗口就开着，它就是你的&ldquo;门&rdquo;。<br><a href="http://i1352.photobucket.com/albums/q645/cy198706/mess-ups/QQ20130205122830.jpg"><img src="http://i1352.photobucket.com/albums/q645/cy198706/mess-ups/QQ20130205122830.jpg"></a><br>&nbsp;</p></li></ol><h4 id="三、安装浏览器插件"><a href="#三、安装浏览器插件" class="headerlink" title="三、安装浏览器插件"></a>三、安装浏览器插件</h4><ol><li>如果你使用的是chrome浏览器，去<a href="https://chrome.google.com/webstore/detail/proxy-switchysharp/dpplabbmogkhghncfbfdeeokoefdjegm">这儿</a>下载SwitchySharp插件，安装。然后打开SwitchySharp，如下图所示，点击&ldquo;从文件恢复&rdquo;导入一个备份文件，该文件在文章最后提供下载。<br><a href="http://i1352.photobucket.com/albums/q645/cy198706/mess-ups/QQ20130205123020.jpg"><img src="http://i1352.photobucket.com/albums/q645/cy198706/mess-ups/QQ20130205123020.jpg"></a></li></ol><p>如果你使用的是Firefox浏览器，去<a href="https://addons.mozilla.org/zh-cn/firefox/addon/foxyproxy-standard/">这儿</a>下载FoxyProxy插件，安装。然后打开SwitchySharp，点击&ldquo;新建代理服务器&rdquo;，接着在&ldquo;手动配置代理服务器&rdquo;项目中输入ip地址&ldquo;127.0.0.1&rdquo;，端口号8087。点击确定，会弹出一个提示，问你是不是在浏览所有的网址时都要使用代理，因为你没有添加白名单。点击是，就配置完成了。<br><a href="http://i1352.photobucket.com/albums/q645/cy198706/mess-ups/QQ20130205123725.jpg"><img src="http://i1352.photobucket.com/albums/q645/cy198706/mess-ups/QQ20130205123725.jpg"></a></p><ol start="2"><li>启用插件<br>Chrome中点击SwitchySharp按钮，选择&ldquo;GoAgent&rdquo;，记得我们刚才还开着的&ldquo;门&rdquo;吗？现在Chrome就从这道&ldquo;门&rdquo;里出去了。<br><a href="http://i1352.photobucket.com/albums/q645/cy198706/mess-ups/QQ20130205124528.jpg"><img src="http://i1352.photobucket.com/albums/q645/cy198706/mess-ups/QQ20130205124528.jpg"></a></li></ol><p>Firefox中右键点击FoxyProxy按钮，选择&ldquo;为全部URLs启用代理服务器:127.0.0.1:8087&rdquo;，就可以了。<br><a href="http://i1352.photobucket.com/albums/q645/cy198706/mess-ups/QQ20130205123825.jpg"><img src="http://i1352.photobucket.com/albums/q645/cy198706/mess-ups/QQ20130205123825.jpg"></a></p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>四、疑难杂症</p><p>有的时候在访问Twitter, Youtube时会提示&ldquo;该网站的安全证书不受信任&rdquo;，如图所示<br><a href="http://i1352.photobucket.com/albums/q645/cy198706/mess-ups/QQ20130205125036.jpg"><img src="http://i1352.photobucket.com/albums/q645/cy198706/mess-ups/QQ20130205125036.jpg"></a></p><p>原因是在使用GoAgent代理的时候，Twitter等网站是需要SSL加密的，GoAgent<br>GoAgent是个代理，好比就是个web服务器，你通过他浏览https的加密网页的时候，要做认证再转发给你的浏览器。如果不加证书，你的浏览器认为这个https网站是伪造的，不让你打开。特别是Chrome和Firefox，要求中转的代理网站浏览https网页是必须要证书，否则不能打开。这个是浏览器自身的防止钓鱼攻击的安全手段。</p><p>解决的办法，就是找到刚才下载的GoAgent，在local文件夹里，找到CA.crt文件，就是GoAgent的提供的证书文件（他们也是花钱买的哦），按照如下步骤导入到系统中。  </p><ol><li><p>双击打开CA.crt文件，出现证书导入向导。点击&ldquo;安装证书&rdquo;。<br><a href="http://i1352.photobucket.com/albums/q645/cy198706/mess-ups/QQ20130205125603.jpg"><img src="http://i1352.photobucket.com/albums/q645/cy198706/mess-ups/QQ20130205125603.jpg"></a></p></li><li><p>选择&ldquo;本地计算机&rdquo;（当然，选择&ldquo;当前用户&rdquo;也可以，只不过切换用户时就失效了），点击&ldquo;下一步&rdquo;。<br><a href="http://i1352.photobucket.com/albums/q645/cy198706/mess-ups/QQ20130205125618.jpg"><img src="http://i1352.photobucket.com/albums/q645/cy198706/mess-ups/QQ20130205125618.jpg"></a></p></li></ol><p>3.&nbsp;选择&ldquo;将所有的证书都放入下列存储&rdquo;，点击&ldquo;浏览&rdquo;。<br><a href="http://i1352.photobucket.com/albums/q645/cy198706/mess-ups/QQ20130205125626.jpg"><img src="http://i1352.photobucket.com/albums/q645/cy198706/mess-ups/QQ20130205125626.jpg"></a></p><p>4.&nbsp;选择&ldquo;受信任的根证书颁发机构&rdquo;，点击&ldquo;确定&rdquo;。<br><a href="http://i1352.photobucket.com/albums/q645/cy198706/mess-ups/QQ20130205125635.jpg"><img src="http://i1352.photobucket.com/albums/q645/cy198706/mess-ups/QQ20130205125635.jpg"></a></p><p>5.&nbsp;点击&ldquo;下一步&rdquo;，再点击&ldquo;完成&rdquo;，出现导入成功的窗口。<br><a href="http://i1352.photobucket.com/albums/q645/cy198706/mess-ups/QQ20130205125655.jpg"><img src="http://i1352.photobucket.com/albums/q645/cy198706/mess-ups/QQ20130205125655.jpg"></a></p><p>为什么要自己签名根证书呢？因为GAE平台限制，没法支持真正的SSL加密，GoAgent只能通过伪造证书的方式做到代理SSL加密的网站，这个证书就是用来欺骗浏览器的。<br>&nbsp;</p><h4 id="五、玩吧"><a href="#五、玩吧" class="headerlink" title="五、玩吧"></a>五、玩吧</h4><p><a href="http://i1352.photobucket.com/albums/q645/cy198706/mess-ups/QQ20130205133033.jpg"><img src="http://i1352.photobucket.com/albums/q645/cy198706/mess-ups/QQ20130205133033.jpg"></a></p><p><a href="http://i1352.photobucket.com/albums/q645/cy198706/mess-ups/QQ20130205132928.jpg"><img src="http://i1352.photobucket.com/albums/q645/cy198706/mess-ups/QQ20130205132928.jpg"></a></p><p><a class="readmore" href="http://pan.baidu.com/share/link?shareid=265965&uk=151049050" target="_blank"><img alt="" src="http://cy198706.com/blog/wp-content/uploads/2013/04/download.png" /></a><br>&nbsp;</p>]]></content>
      
      
      <categories>
          
          <category> 折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GAE </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>支持Windows8的一键备份还原工具 &amp;#8211; OneKey一键备份/还原</title>
      <link href="//just-try/onekey-ghost/"/>
      <url>//just-try/onekey-ghost/</url>
      
        <content type="html"><![CDATA[<p>其实我个人不太习惯使用一键备份/还原，因为我除了刚出新的操作系统时需要折腾一段时间外，平时几乎不重装系统。如果系统出现问题，也能自己重装。</p><p>但是凡事都有个万一。有的时候还是备份一下比较好，比如犯懒的时候，就可以使用一键还原来还原当时备份的完美无缺的系统状态。</p><p>过年回家时，帮老爸安装Windows8，他现在对操作系统要求不高，能玩个游戏（使命召唤啊、孤岛危机啊、潜行者啊之类的FPS游戏），能上个网，能跟远在帝都的我视频一下，就足够了。所以一旦出现致命的系统问题，就没法子了，只能求助于我。</p><p>索性给他安装个一键备份/还原，出现问题可以使用时光机回到过去。  </p><span id="more"></span><p>OneKey一键还原是一款轻量级的备份/还原工具，无需安装，只需要一个exe文件就能工作。设置选项也不复杂，自动性比较高，经测试有效，分享给大家。</p><p>上几张真相图。<br>&nbsp;</p><div style="text-align: center;">  <img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/mess-ups/20130217155619.jpg" style="width: 449px; height: 373px;" /></div><p>这是打开软件后的主界面，可以选择&ldquo;还原系统&rdquo;或者&ldquo;备份系统&rdquo;。当前正在活动的主分区会在下面使用粗体标识出来。<br>&nbsp;</p><div style="text-align: center;">  <img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/mess-ups/20130217155639.jpg" style="width: 449px; height: 373px;" /></div><p>高级菜单适合懂得一些电脑知识的人来操作。<br>&nbsp;</p><div style="text-align: center;">  <img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/mess-ups/20130217155649.jpg" style="width: 449px; height: 373px;" /></div><p>还可以将一键备份/还原加入系统启动项中，并可以自定义菜单的名称。对于一些以前习惯使用F11启动&ldquo;一键GHOST&rdquo;之类的软件的用户，还设置了&ldquo;热键启动&rdquo;功能。</p><p>安装完成后，在启动菜单可以看到多了一个启动项：</p><div style="text-align: center;">  <img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/mess-ups/20130217155712.jpg" /></div><p style="text-align: center;">  附上下载链接：<br /> <a class="readmore" href="http://pan.baidu.com/share/link?shareid=324988&uk=151049050"><img alt="" src="http://cy198706.com/blog/wp-content/uploads/2013/04/download.png" style="width: 126px; height: 128px;" /></a></p>]]></content>
      
      
      <categories>
          
          <category> 折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随手一拍</title>
      <link href="//pictures/%25e9%259a%258f%25e6%2589%258b%25e4%25b8%2580%25e6%258b%258d/"/>
      <url>//pictures/%25e9%259a%258f%25e6%2589%258b%25e4%25b8%2580%25e6%258b%258d/</url>
      
        <content type="html"><![CDATA[<p>随便一拍，没有什么技术含量。。<span id="more"></span></p><div style="text-align: center;">  <a href="http://cy198706.com/blog/wp-content/uploads/2013/02/IMG_1414.jpg"><img alt="" src="http://cy198706.com/blog/wp-content/uploads/2013/02/IMG_1414.jpg" style="height: 450px; width: 600px;" /></a></div>]]></content>
      
      
      <categories>
          
          <category> 视觉盛宴 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随手拍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分享壁纸 1920&amp;#215;1080</title>
      <link href="//pictures/wallpaper_1920x1080/"/>
      <url>//pictures/wallpaper_1920x1080/</url>
      
        <content type="html"><![CDATA[<p>分享一张壁纸吧，友人的站关闭了，现在找壁纸只能自力更生了。。<br>如果没猜错，应该是阿尔卑斯山的一张图片。<br>点击图片进入无水印版下载。 <a href="http://pan.baidu.com/share/link?shareid=370061&uk=151049050"><img src="http://i1352.photobucket.com/albums/q645/cy198706/mess-ups/the-alps_1920x1080.jpg" alt="wallpaper"></a></p>]]></content>
      
      
      <categories>
          
          <category> 视觉盛宴 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我为什么不用360 &amp;#8211; 谈谈用户隐私</title>
      <link href="//gabby/why-not-360-talk-about-users-privacy/"/>
      <url>//gabby/why-not-360-talk-about-users-privacy/</url>
      
        <content type="html"><![CDATA[<h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><p>奇虎360创立于2005年9月，主营以360安全卫士、360杀毒为代表的免费网络安全平台，同时拥有奇虎问答等独立业务。岂今奇虎360拥有360安全浏览器、360保险箱、360杀毒、360软件管家、360网页防火墙、360手机卫士、360极速浏览器、360搜索等系列产品。</p><p>现在360的东西已经占了大部分中国人的电脑了。其拳头产品360安全卫士在市场上占有的份额已经高达80%以上，在2011年6月底，已有2亿用户在使用360的产品，渗透率已经达到52.2%。</p><p>我在七八年之前，还是非常依赖360的。因为那时候我很懒，而且是个电脑白痴，总是会被莫名安装上一些个垃圾插件，首页总是被篡改，用了360之后，就可以轻松地将这些东西解决掉。<br>后来有一次被强制安装了360后，它就把我的系统搞崩溃了，而且连安全模式和PE都无法进入，只能重装系统，损失了不少数据。<br>第二次被强制安装后，这孙子又以迅雷不及掩耳盗铃之势杀死了我的电脑。</p><p>从此再也不用360，跟360有关的一切都讨厌，有段时间甚至看到黄跟绿的组合我就来气。</p><div style="text-align: center;">  <img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/mess-ups/360.png" /></div><p>后来360的流氓行径开始被世人所知，窃取用户隐私、强制安装360安全浏览器、悄悄卸载竞争对手的软件、偷偷上传不知名的数据包。。这几种行为在普通人看来可能没什么，&ldquo;只要不妨碍我用电脑就行呗&rdquo;，其实这就是为什么360的产品在各种风口浪尖下，依然能在中国继续生存下去的根本原因。即便它一直在违反行业规则。</p><p>2月26日的《每日经济新闻》刊登了一篇文章《<a href="http://epaper.nbd.com.cn/shtml/mrjjxw/20130226/118530.shtml">奇虎360黑匣子之谜：暗藏后门盗取用户隐私</a>》，狠狠地揭了把360的老底。  </p><span id="more"></span><h2 id="一、何为用户隐私"><a href="#一、何为用户隐私" class="headerlink" title="一、何为用户隐私"></a><span>一、何为用户隐私</span></h2><h6 style="text-align: right;">  <span><em>&#8211; 这是我的小秘密</em></span></h6><blockquote><p><span>隐私是一种与公共利益、群体利益无关，当事人不愿他人知道或他人不便知道的个人信息，当事人不愿他人干涉或他人不便干涉的个人私事，以及当事人不愿他人侵入或他人不便侵入的个人领域。</span></p></blockquote><p><span>很绕口。简单来说，隐私就是&ldquo;我不想让别人看到或者听到或者乱动的东西&rdquo;，最直接的例子就是个人日记。</p> </p><p>  那么放到互联网上，用户隐私基本包括：<br /> 1. 个人信息。包括身份信息、财产信息、家庭信息、地理位置信息等等。<br /> 2. 密码。登录网站、论坛需要密码；登录网银、网上支付交易需要密码；登录邮箱需要密码；玩网络游戏需要密码，密码也属于用户隐私。<br /> 3. 邮箱地址。在注册一些网站（现在几乎所有网站）时，都会要求输入邮箱地址，但如果选择不公开，网站一般会承诺不公开邮箱，只供用户忘记密码时发送重置链接使用。邮箱也是用户隐私。<br /> 4. 网络活动踪迹。包括IP地址、网站浏览历史、Cookies<a href="#comm1"><span style="color:#b22222;"><sup>注1</sup></span></a>、记录表单、用户输入的内容、用户在个人电脑上的一切动作等。</p><p>  可以看出，在网络上，要注意的东西更多，用户需要保密的，比在现实生活中要复杂的多。隔壁王老二在外面有个小三，同事今天早上踩香蕉皮滑倒掉了颗牙，XX明星跟XX明星双宿双飞，李大嘴真正的身份是国安局局长，昨天苍老师的片子很好看。。这些隐私的保护方式很简单&#8211;管好你的嘴。<br /> 但在网络上就不一样了，除非你拔掉网线一了百了，否则被威逼利诱的IT攻城狮们会用各种奇葩方式攻破你的防线，窃取你的隐私。从你的系统，你的硬盘，你的鼠标、键盘、摄像头、U盘，从任何地方窃取信息。</p><p>  互联网上有句名言：&ldquo;在网上，没人知道你是一条狗<a href="#comm2"><span style="color:#b22222;"><sup>注2</sup></span></a>&rdquo;，用以描述互联网的匿名特性。但是现在再说这句话，就真有点不负责任了。</span></p><p style="text-align: center;">  <span><img alt="在网上没人知道你是一条狗" src="http://upload.wikimedia.org/wikipedia/zh/f/f8/Internet_dog.jpg" style="width: 300px; height: 335px;" /></span></p><p style="text-align: center;">  <span><span style="font-family:arial,helvetica,sans-serif;"><cite><em>图片来自维基百科</em></cite></span></span></p><p>  <span>统计/广告商可以通过你浏览互联网的习惯，在几毫秒内推断出你的身份，并且精准地给你投放你可能会喜欢的广告。这些&ldquo;习惯&rdquo;是从Cookies或者是跟踪消息中获取的。假如名为Lucky的狗点击了三五个关于狗粮的网站的话，那么下次打开浏览器，弹出的会是关于狗粮和刷毛器的广告，而不是关于马桶的广告。现在主流浏览器都设有&ldquo;Do Not Track&rdquo;的功能或插件，可以阻止第三方统计/广告商获取你的浏览历史。但这样也会导致你在浏览有广告的网站时，第三方统计/广告商给你投放一些无厘头的广告，其实双方都不讨好。</p>     <p>    当然，这里讨论的用户隐私不仅限于个人电脑，手机里的隐私也同样重要。联系人、短信、日程安排、浏览器历史等等，也可以归划在用户隐私中。比较明显的例子是安卓手机用户在安装软件时，会提示该软件的权限，包括联网权限、读取SD卡、读取联系人等。如果你下载了一个推箱子游戏，但这个游戏却有着读取联系人、拨打电话、发送短信、更改系统文件等权限，你还会用吗？你根本不知道在游戏在后台做着什么，也许你在享受着推推乐的同时，你跟你MM的甜言蜜语已经被上传到一个不知名的服务器去了。这其实已经侵犯了用户的合法权益了。  </p>    <p>    如果上面这些还是&ldquo;小Case&rdquo;的话，下面的会让你手心冒汗的：<br /> 注册了一个社交网站，网站说&ldquo;我们只接受实名制的会员哟亲&rdquo;，你就告诉了他你的名字，你的身份证号，户口所在地，老家在哪里，有没有对象，有没有房子，有没有汽车，在哪里上学，在哪里上班；为了防止账号被盗，也方便参与活动时抽奖送奖品送现金，你又告诉了他你现在的住址，你的手机号，你的银行卡或者信用卡号；为了推荐你的朋友们也到这里来从而形成一个小圈子方便交流，你又上传了你的通讯录，给各种亲戚朋友发注册链接。。你的所有信息都交给了这个社交网站的数据库。如果这个网站遵守游戏规则的话，那还好，反之则不敢想像。  </p>    <p>    关键是，这一切都是你自愿的。什么？你说人家有&ldquo;隐私条款声明&rdquo;？我只能说&ldquo;说出去的话泼出去的水，收回来的也是脏水&rdquo;。  </p>    <p>    其实有关隐私的概念，是因人而异的。任何与你有关的内容，都可能是隐私，无非那些能直接关联到你身份信息的内容，更为重要而敏感。有些人不在乎隐私，那这些东西就无所谓了，破罐子破摔了；有些人特别在乎隐私，那么在保护隐私上就要多加注意一番。</span>  </p>    <h2>    <span>二、为什么要保护用户隐私</span>  </h2>    <h6 style="text-align: right;">    <span><em>&#8211; 用四字成语来说&ldquo;关你屁事&rdquo;</em></span>  </h6>    <p>    <span>有一天，A公司接手了你家小区的管理业务，并承诺所有安保和物业都是免费的，代价是把你所能看见的东西都换成A公司旗下的。停车场、自来水、暖气、花园，都是A公司的产品。你想了想，决定使用他们的安保套餐，就因为这一切都是免费的。</p>     <pre><code>&lt;p&gt;  这天晚上你大吃了一顿，但是不知肿么的，吃坏了肚子，当你急急忙忙冲到自家厕所，一通乱枪乱炮后，突然发现，有个人正在你旁边盯着你。毛骨悚然的同时，你不禁问道：你是谁，来这里干什么？那个人不紧不慢地说：我是A公司的，出于对你安全的考虑，我有权在这里监视你。当你羞愤难当的时候，你突然发现，你的厕所，你的厨房，你的屋子，你的床，甚至你的冰箱，衣架上都有摄像头，而且所有的摄像头都是为保护你的安全，才窃取你的隐私的。&lt;/p&gt;&lt;p&gt;  你所做的事情，天知，地知，你知，A公司知。&lt;/p&gt;&lt;p&gt;  突然有一天，天A公司的网络被某位高人入侵了，因为整个小区在一个局域网内，这位高人把你在家里干的所有事情，广播给了整个小区的人。&lt;/p&gt;&lt;p&gt;  于是，本来打算跟你约会你的3号楼的王美丽，突然说&amp;ldquo;呃今天有事不能去了对不起再见你是个好人&amp;rdquo;；邻居李二姐家出来遛狗，再也不允许它家的狗过来蹭你的腿；你的电话经常接到骚扰电话和短信；小区门口卖菜的卖给你的时候特别贵；你的WOW账号被扒得一干二净。。一切的一切，原因都是他们知道了你的隐私，即使你伪装得再好，又有什么用呢？&lt;/p&gt;&lt;p&gt;  你急急忙忙地退掉A公司的所有业务，但却发现，在你打算退业务的时候，A公司暗中做祟，千般阻挠万般骚扰，让你无法成功退掉它，并且它已经偷偷挤掉了别的物业公司，让你&amp;ldquo;不得不用&amp;rdquo;。&lt;/p&gt;&lt;p&gt;  于是你的生活陷入混乱。。&lt;/p&gt;&lt;p&gt;  诚然，这只是一个假想，但在用户隐私日益重要的今天，保护用户隐私已经成为了当务之急。&lt;/p&gt;&lt;p&gt;  平时我们接到的&amp;ldquo;推销保险&amp;rdquo;、&amp;ldquo;小姐你的房子卖不卖&amp;rdquo;、&amp;ldquo;调查问卷&amp;rdquo;等骚扰电话，是程度比较轻微的隐私泄露，他们知道的可能仅有你的少量信息。而且你不必惊讶他们是怎么获得这些信息的，我说过，&amp;ldquo;隐私保护条款&amp;rdquo;都是屁话，你最相信的银行也会为了钱出卖你。&lt;/p&gt;&lt;p&gt;  现在你知道保护隐私的重要性了吧。&lt;/p&gt;&lt;p&gt;  &lt;/span&gt;&lt;/p&gt;&lt;h2&gt;  三、如何保护用户隐私&lt;/h2&gt;&lt;h6 style=&quot;text-align: right;&quot;&gt;  &amp;#8211; 你妈叫你回家吃饭！&lt;/h6&gt;&lt;p&gt;  工信部在2011年年初发布了《互联网信息服务市场秩序监督管理暂行办法(征求意见稿)》（以下简称《征求意见稿》），在保护用户隐私方面提出明确要求: 互联网企业应尊重用户隐私, 维护个人信息安全, 规范个人信息处理行为。未经法律法规的明确授权或用户的明示同意, 互联网企业不得擅自收集和处理用户的个人信息。可以肯定的是,《征求意见稿》中对于保护用户隐私的要求将会对今后的践行产生震慑, 一场关乎网络隐私权的保卫战即将打响。&lt;/p&gt;&lt;p&gt;  做为普通网民，有法律武器并不表示就安全了，毕竟很多时候法律是够不到的，否则也就不会有那么多&amp;ldquo;擦边球&amp;rdquo;了。我们必须也采取适当的措施，保护自己的隐私。&lt;/p&gt;&lt;div style=&quot;text-align: center;&quot;&gt;  &lt;img alt=&quot;&quot; src=&quot;http://i1352.photobucket.com/albums/q645/cy198706/mess-ups/01300000329092127073620955652.jpg&quot; /&gt;&lt;/div&gt;&lt;p&gt;  上文提到过&amp;ldquo;Do Not Track&amp;rdquo;功能，&amp;ldquo;Do Not Track&amp;rdquo;标记会向网站发送一个信号，表示你不愿意别人在你浏览网站时收集你对该网站的访问信息用以跟踪你。该功能在IE9发布时被提出来。这个功能可以阻止第三方广告代理商通过Cookies获取用户信息。但这个功能默认是关闭的，需要用户自行开启，并添加TPL（&amp;ldquo;Tracking Protect List&amp;rdquo;）来正确运行。&lt;/p&gt;&lt;div style=&quot;text-align: center;&quot;&gt;  &lt;img alt=&quot;&quot; src=&quot;http://i1352.photobucket.com/albums/q645/cy198706/mess-ups/do_not_track_1.png&quot; style=&quot;width: 615px; height: 275px;&quot; /&gt;&lt;/div&gt;&lt;div&gt;  &lt;br /&gt; 像Chrome、Firefox浏览器也有此功能，但其实最方便的办法就是安装一个名为AdBlock Plus的插件，可以屏蔽网页上的广告，也就可以从根本上断了信息跟踪。&lt;/div&gt;&lt;div style=&quot;text-align: center;&quot;&gt;  &lt;img alt=&quot;&quot; src=&quot;http://i1352.photobucket.com/albums/q645/cy198706/mess-ups/do_not_track_3.png&quot; /&gt;&lt;/div&gt;&lt;p&gt;  不要使用360的东西。在互联网上，360完全可以扮演A公司的角色。想像一下，你今天看了什么片，处理了什么文档，上网看了什么，输入的网银密码，买的东西，360全都知道的清清楚楚。而且你根本不知道它是什么时候窃取你的隐私的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;  四、结语&lt;/h2&gt;&lt;p&gt;  有一个网站叫&amp;ldquo;&lt;a href=&quot;http://www.xliar.com&quot;&gt;中国谎言测评中心&lt;/a&gt;&amp;rdquo;，这里有个独立调查员为保护中国网民的用户隐私做了很多的贡献。其不畏强权的精神也得到了很多网民的赞赏。现实中需要这样的人，不仅需要他们勇于挑战权威，也需要他们来提醒我们，应该保护自己。&lt;/p&gt;&lt;blockquote&gt;  &lt;p&gt;    虽然，他们知道，他们的努力，就是堂吉诃德式的，但必须有人去做。  &lt;/p&gt;    &lt;p style=&quot;text-align: right;&quot;&gt;    &amp;#8211;《每日经济新闻》  &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;  资料：&lt;br /&gt; 1. &lt;a href=&quot;http://epaper.nbd.com.cn/shtml/mrjjxw/20130226/118530.shtml&quot;&gt;每日经济新闻 &amp;#8211;&amp;nbsp;奇虎360黑匣子之谜：暗藏后门盗取用户隐私&lt;/a&gt;&lt;br /&gt; 2. &lt;a href=&quot;http://baike.baidu.com/view/1458023.htm?fromId=815488&quot;&gt;百度百科 &amp;#8211; 奇虎360&lt;/a&gt;&lt;br /&gt; 3. &lt;a href=&quot;http://zh.wikipedia.org/wiki/%E5%9C%A8%E7%BD%91%E4%B8%8A%EF%BC%8C%E6%B2%A1%E6%9C%89%E4%BA%BA%E7%9F%A5%E9%81%93%E4%BD%A0%E6%98%AF%E4%B8%80%E6%9D%A1%E7%8B%97&quot;&gt;维基百科 &amp;#8211; 在互联网上，没人知道你是一条狗&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;div id=&quot;comm1&quot;&gt;  &lt;span style=&quot;color:#b22222;&quot;&gt;&lt;span style=&quot;font-size: 16px;&quot;&gt;&lt;span style=&quot;font-family: &#39;times new roman&#39;, times, serif;&quot;&gt;注1：Cookies是一种文本文件，里面存储着用户ID、密码、浏览过的网页、停留的时间等信息，是用户访问网站的时候，网站在用户电脑里植入的一个文件。通过Cookies，网站不仅能够知道该用户访问了哪些网站，停留了多长时间，浏览了哪些网页等信息。对于网站，特别是搜索引擎来说，具有极大的商业价值。基于Cookies里面存储的信息，网站可以了解到该用户的上网行为，并据此精准地向用户投放商业广告。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br /&gt; &amp;nbsp;&lt;/div&gt;&lt;div id=&quot;comm2&quot;&gt;  &lt;span style=&quot;color:#b22222;&quot;&gt;&lt;span style=&quot;font-size: 16px;&quot;&gt;&lt;span style=&quot;font-family: &#39;times new roman&#39;, times, serif;&quot;&gt;注2：&amp;ldquo;在互联网上，没人知道你是一条狗&amp;rdquo;（On the Internet, nobody knows you&#39;re a dog）是一句互联网上的常用语，因为作为《纽约客》1993年7月5日刊登的一则由彼得&amp;middot;施泰纳（Peter Steiner）创作的漫画的标题而变得流行。 这则漫画中有两只狗：一只坐在计算机前的一张椅子上，与坐在地板上的另一只狗说漫画的标题：&amp;ldquo;在互联网上，没人知道你是一条狗&amp;rdquo;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 口水 </category>
          
          <category> 折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 口水 </tag>
            
            <tag> 360 </tag>
            
            <tag> 互联网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小花的新家</title>
      <link href="//gabby/977/"/>
      <url>//gabby/977/</url>
      
        <content type="html"><![CDATA[<p>下午请了半天假，到社保中心换卡。</p><p>到了社保中心一问，下午两点上班，现在才一点。于是我往旁边一瞅，有一个小亭子，阳光还不错，正好手里有一份《周末画报》，我决定把这一个小时用在这儿。</p><p>坐了一会，起风了，一摸报纸，一手灰。把报纸收起来，一看旁边，一只黑白相间的小狗正信步向我走来。</p><p>我喜欢狗，于是我决定逗逗这条小狗。  </p><span id="more"></span><p>小东西应该是京巴跟蝴蝶的串，脸上的毛的花纹有点像史努比，混身脏兮兮的，一看就是流浪狗。但是眼睛炯炯有神，一点也不怕我。它过来蹭我的腿，我就摸摸它的脑袋，一会它就趴在我旁边准备打个盹了。狗狗做出这种动作，就表明它对你已经信任了，我很开心可以看到它这样做。</p><p>我手里没什么吃的，旁边似乎也没有什么店可以买点零食喂它，遂作罢。</p><p>过了一会，来了一个30岁左右的男人，唤了一声&ldquo;小花！&rdquo;，正在睡梦中的小花一下子就睁开了眼睛，欢快地向男人奔了过去。这一人一狗显然是互相认识的。看他俩亲密的样子，我不仅出口问道&ldquo;这是流浪狗吧？&rdquo;男人抬头看了我一眼，语气沉重地回答道：&ldquo;是啊，前一阵它妈丢了，它就自己一个人了。&rdquo;说完又摸了摸小花。我只能叹一声气表示抱歉，男人接着说，&ldquo;正犹豫要不要把它弄回家呢。&rdquo;我就有点惊讶了。流浪狗一般是不会招人待见的，即便是不去欺负它，给它点吃的就算不错了。而他竟然在想要把它弄回家。</p><p>我正准备问其他的问题，身后又有人叫道&ldquo;小花！&rdquo;，我回头一看，是4个女人，估计40岁左右的样子，其中有一个稍微小点，30岁出头吧（好吧，我其实不太会看女人的年龄=。=）。唤小花的是一个穿着打扮比较讲究的，是那种一看就是接受过良好的教育的人。&ldquo;小花！过来，看妈妈今天给你带了什么？&rdquo;小花又乐颠颠地跑过去蹭她的腿。</p><p>我心头一热。这时候男人出声了，&ldquo;呀，小花，今儿你有口福了，是大骨头哎。&rdquo;说罢五个人一起哈哈大笑。原来这五个人也互相认识啊。</p><p>只听比较讲究的女人说，&ldquo;中午去酒店吃饭，留下些骨头，我就都打包回来了。&rdquo;另外几个女人也插嘴，说道&ldquo;怪不得小花跟你最亲，你老给它好吃的，我们给的都是些火腿肠啥的，和你一比差远啦。&rdquo;五个人说笑了一阵，就开始转向同一个话题&#8211;今天把它带回谁家。原来他们早已商量好了这次的事情。</p><p>男人先表态了：&ldquo;我来吧。我挺喜欢小花的。&rdquo;<br>比较年轻的女人插嘴了：&ldquo;不行，你家已经有两条母狗了，把小花弄过去，不怕出事啊。&rdquo;哦，原来小花是男生。<br>讲究的女人说道：&ldquo;我来吧，小花听话，比亨利听话多了，我们家亨利也是公的，不怕。&rdquo;看来她家里也有一条调皮捣蛋的狗，名叫亨利。<br>一个有点富态的女人说：&ldquo;你们几家都有狗了，没必要再弄，之前就说小花我要了。&rdquo;<br>年轻的女人反驳：&ldquo;看到小花我就后悔了，不想让给你了，让它去我家吧。&rdquo;看来她还是反悔了。</p><p>这时小花正在默默地低头啃骨头，全然不知把它围起来的这几个人正在决定它的命运。</p><p>几个人互相争了一会，一直没说话的那个女人出声了：&ldquo;我觉得我们还是公平一点，让它自己选择吧。我们都唤它，看它去找谁，就表明谁跟它最有缘。&rdquo;</p><p>这个提议得到了大家的一致认同，虽然有点儿戏，不过看起来似乎是最好的解决方案。</p><p>几个人拉开距离，然后以各自的方式唤小花。男人是吹口哨；讲究的女人是拿装骨头的塑料袋子诱惑它&#8211;遭到了大家的反对后，她不得不扔掉了袋子；年轻的女人蹲下来拍手，像唤孩子那样，富态的女人站着拍手，同时叫小花的名字；比较沉默的女人只是很单调地叫小花。</p><p>小花迷茫地抬起头，看看这个，看看那个&#8211;甚至还回头望了我一眼&#8211;全然不知这几个老小孩为什么要这么做。几个人都眼巴巴地看着小花，小花也不知道自己要做什么。</p><p>过了大约1分钟的时间，小花似乎终于做了决定。它回头看了一眼自己的骨头，就奔向了比较讲究的女人。</p><p>情理之中。狗总是对那个给自己好吃的东西的人有独特的感情。</p><p>其他四个人叹了口气，站起身来，纷纷抱怨她用美食诱惑小花。讲究的女人喜笑颜开，还打击其他人：&ldquo;这叫个人魅力！&rdquo;</p><p>总之，小花的去向定了下来，五个人就轻松了不少。接下来要商量的是回家前的处理工作。</p><p>&ldquo;要先给它洗一下，把毛全给它剃了，让它重新长，这些毛没营养，不抗冻。&rdquo;&ldquo;剃毛之后要做做皮肤护理。&rdquo;&ldquo;要给它打针，免得得传染病。&rdquo;&ldquo;要不要洗洗胃，谁知道咱不在的时候它吃了什么东西。&rdquo;&ldquo;我看不如喂虫子药，洗胃太遭罪了。&rdquo;</p><p>大家你一言我一语地讨论着，我在旁边看得心里热乎乎的。小花似乎也知道了些什么，不停地在五个人中间蹭来蹭去。</p><p>后来年轻的女人说话了：&ldquo;那就这么定了，我先打电话给X哥，问问他那能不能弄。&rdquo;</p><p>&ldquo;喂？X哥啊，是我啊。是这样的，我这有条小狗，是条流浪狗，我打算把它带回家，您看您那能不能帮我处理一下。啊？不能啊，别啊，我们就给它洗一洗然后剃个毛就行。别啊，我们自己洗还不行么，您那不是有个小卫生间么，我们给它洗完了您就帮忙推一下毛就行。我们多给您点钱。啊？不行啊？&rdquo;<br>这时讲究的女人要电话，直接就说：&ldquo;X啊，我是你Y姐。对，你就帮我们个忙，其他的宠物店都太远了，我们过不去啊，就认识你一个，大家都街里街坊的&#8212;-不麻烦不麻烦，就剃个毛，不麻烦的。&rdquo;<br>男人不耐烦了，在旁边说道：&ldquo;咱就直接抱过去就完了，先抱过去，抱过去再说。&rdquo;</p><p>讲究的女人又努力了一会，似乎没有和X哥达成共识，郁闷地挂断了电话。</p><p>我在旁边也很着急，这个X哥怎么这么大面子啊，这么些人求他他都不出手。</p><p>&ldquo;估计是怕有病菌，毕竟他那个地方狗来狗往的。&rdquo;沉默的女人突然来了句冷笑话。</p><p>其他几人很明显没心情听冷笑话，都皱着眉头，不知道在想什么。</p><p>后来还是男人打破沉默：&ldquo;走，去我家洗，多大点事。&rdquo;讲究的女人一听不干了：&ldquo;那也得去我家洗。&rdquo;<br>几个人争论了一会，还是决定去男人家给小花洗澡。</p><p>这个时候小花似乎发现了什么有趣的东西，向相反的方向走去。讲究的女人追了过来，叫道：&ldquo;小花，别乱跑，回家了。&rdquo;</p><p>这时她已经到我身边了，问我：&ldquo;你也是这个小区的？&rdquo;我笑答：&ldquo;不是，我是去那儿办事的。&rdquo;我指了指旁边的社保中心，&ldquo;你们这的人真好，很团结，很有爱心。&rdquo;我由衷地赞叹。讲究的女人叹了一口气，说道：&ldquo;流浪狗多啊，我们看着也心疼，尽自己的微薄之力吧。这些小东西也挺不容易的，又听话，讨喜。&rdquo;</p><p>说完，其他几个人叫她了。她全然不顾小花身上的脏兮兮，抱起小花，向我道别。</p><p>看着他们的背影，心里突然明白了为什么小花在一开始的时候不怕我了，因为它知道，有这么一帮人，是它的家人。</p>]]></content>
      
      
      <categories>
          
          <category> 口水 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 口水 </tag>
            
            <tag> 狗狗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Any.Do &amp;#8211; 计划你的今天和明天</title>
      <link href="//just-try/any-do-a-plan-for-today-and-tomorrow/"/>
      <url>//just-try/any-do-a-plan-for-today-and-tomorrow/</url>
      
        <content type="html"><![CDATA[<p>上了年纪，脑子就不好用了。。<img alt="" height="24" src="http://cy198706.com/blog/wp-content/plugins/ck-and-syntaxhighlighter/ckeditor/plugins/smiley/images/35.gif" title="" width="24" /><br>有时候需要一个小东西来提醒一下自己今天要做什么。</p><p>其实计划任务是一个很好的习惯，并不是因为脑子有问题或者什么，而是一种生活态度，有计划地生活才不至于让生活一团糟。<br>而且昨天今天你做了什么，留个备份不是很好吗？</p><p>这次就来推荐一款精致的小App，虽然小，但在To-do App界可是赫赫有名的，名字叫做Any.Do。  </p><span id="more"></span><p>Any.Do的图标做得很讨喜，而且整个App的风格非常统一，操作手感很棒，还充分利用了滑动、摇晃等手势，以提高用户体验度。<br>Any.Do可以与谷歌账户同步，并且在ios、Android平台上都有对应的App，更棒的是，它在Chrome也有对应的插件，而且在安装插件后，使用Gmail都能看见它的身影。还有HTML5版本的Any.Do（要等待好久才能接到邀请函。。），真可谓是占据了所有的网络平台可能性。</p><p>不唠叨了，多图杀猫详细说明一下Any.Do的特性。自用Android4.1.2，比Android2.2/2.3的体验要好一些。<br><span style="color:#b22222;"><var><small>TIP:不要在意截图里的时间。。截图截得比较烂，没有按照时间顺序。。</small></var></span></p><div style="text-align: center;">  1. 图标设计得比较有趣，符合一个To-Do App的风格。</div><div style="text-align: center;">  <img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/Android/AnyDo1.png" style="width: 480px; height: 854px;" /><br /> &nbsp;</div><div style="text-align: center;">  2. 第一个界面。黑乎乎的，因为是可以通过Facebook进行登录的，所以我怀疑。。你懂的。如果你没有账号，可以点击上面的&ldquo;入门&rdquo;，进行账号的注册。如果你已经有账号了，那可以点击下面的&ldquo;已经是会员？&rdquo;<br /> <span style="color:#b22222;"><var><span style="font-size: 14px;">PS：那个&ldquo;已经是会员&rdquo;平时是看不到的，得点击一下才能出现。。</span></var></span></div><div style="text-align: center;">  &nbsp;<img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/Android/AnyDo2.png" style="width: 480px; height: 854px;" /><br /> &nbsp;</div><div style="text-align: center;">  3. 创建账户界面</div><div style="text-align: center;">  <img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/Android/AnyDo3.png" style="width: 480px; height: 854px;" /><br /> &nbsp;</div><div style="text-align: center;">  4. 登录界面</div><div style="text-align: center;">  <img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/Android/AnyDo4.png" style="width: 480px; height: 854px;" /><br /> &nbsp;</div><div style="text-align: center;">  5. 介就是通过账户进入之后的界面了。可以看到，默认是分组为今儿、明儿、即将发生的以及明天之后的事情。</div><div style="text-align: center;">  <img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/Android/AnyDo5.png" style="width: 480px; height: 854px;" /><br /> &nbsp;</div><div style="text-align: center;">  6. 点击今天分组，可以看到我已经添加的一些信息。（不要在意内容。。）划横线并灰化的表示之前已经完成的内容了，我没有清空，因为我有&ldquo;做好事留记录&rdquo;的习惯。</div><div style="text-align: center;">  <img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/Android/AnyDo6.png" style="width: 480px; height: 854px;" /><br /> &nbsp;</div><div style="text-align: center;">  7. 点击&ldquo;给良仔打电话&rdquo;，可以看到弹出的小工具栏，从左至右分别是&ldquo;这个很重要哦亲&rdquo;&ldquo;放到文件夹里&rdquo;&ldquo;提个醒呗&rdquo;&ldquo;备注一下&rdquo;和&ldquo;让我的亲戚朋友知道这件事&rdquo;。</div><div style="text-align: center;">  <img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/Android/AnyDo7.png" style="width: 480px; height: 854px;" /><br /> &nbsp;</div><div style="text-align: center;">  8. 这是&ldquo;这个很重要哦亲&rdquo;的效果，在事件的左边有一条红线。</div><div style="text-align: center;">  <img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/Android/AnyDo8.png" style="width: 480px; height: 854px;" /><br /> &nbsp;</div><div style="text-align: center;">  9. 这是&ldquo;放到文件夹里&rdquo;，目前我只有两个文件夹，常用的是&ldquo;个人&rdquo;文件夹。</div><div style="text-align: center;">  <img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/Android/AnyDo9.png" style="width: 480px; height: 854px;" /><br /> &nbsp;</div><div style="text-align: center;">  10. &ldquo;提个醒吧&rdquo;拥有非常人性化的界面，而且不会误操作，有很好的直观性。分钟部分是以5分做为间隔的，其实也是，你定个19:22分没什么意义。</div><div style="text-align: center;">  <img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/Android/AnyDo10.png" style="width: 480px; height: 854px;" /><br /> &nbsp;</div><div style="text-align: center;">  11. 如果要添加一条记录，在上面的框框里输入，然后点击右边的小加号就好了。</div><div style="text-align: center;">  <img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/Android/AnyDo11.png" style="width: 480px; height: 854px;" /><br /> &nbsp;</div><div style="text-align: center;">  12. 再看看菜单按钮。基本包括了一个To-Do App应该有的设置。</div><div style="text-align: center;">  <img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/Android/AnyDo12.png" style="width: 480px; height: 854px;" /><br /> &nbsp;</div><div style="text-align: center;">  13. 切换为&ldquo;文件夹&rdquo;视图。</div><div style="text-align: center;">  <img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/Android/AnyDo13.png" style="width: 480px; height: 854px;" /><br /> &nbsp;</div><div style="text-align: center;">  14. 菜单里的&ldquo;同步&rdquo;选项。可以与Chrome同步，还可以与Google Tasks同步。</div><div style="text-align: center;">  <img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/Android/AnyDo14.png" style="width: 480px; height: 980px;" /><br /> &nbsp;</div><div style="text-align: center;">  15. 选项菜单中的&ldquo;计划&rdquo;功能。以分步骤的方式来添加一个新的提醒任务。</div><div style="text-align: center;">  <img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/Android/AnyDo15.png" style="width: 480px; height: 854px;" /><br /> &nbsp;</div><div style="text-align: center;">  16. 如果我点击了&ldquo;就在&rdquo;，就会问你具体是几点。</div><div style="text-align: center;">  <img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/Android/AnyDo16.png" style="width: 480px; height: 854px;" /><br /> &nbsp;</div><div style="text-align: center;">  17. 如果我点击了&ldquo;以后&rdquo;，则会问你具体是哪一天。</div><div style="text-align: center;">  <img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/Android/AnyDo17.png" style="width: 480px; height: 854px;" /><br /> &nbsp;</div><div style="text-align: center;">  18. 这就是设置界面了。基本上平时会用到的选项都可以直接设置，不需要进入二级菜单。</div><div style="text-align: center;">  <img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/Android/AnyDo18.png" style="width: 480px; height: 1292px;" /><br /> &nbsp;</div><div style="text-align: center;">  19. And.Do时刻。细心的你肯定已经发现了，设置里是&ldquo;Any.Do时间&rdquo;，这儿是&ldquo;Any.Do时刻&rdquo;，是的，这是翻译人员的失误。</div><div style="text-align: center;">  这个功能很贴心，在你规定的时刻在桌面上弹出一个小框框，让你&ldquo;计划你的一天&rdquo;。如果点击下面的&ldquo;开始Any.Do时刻&rdquo;，则会进入上面的&ldquo;计划&rdquo;功能。</div><div style="text-align: center;">  <img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/Android/AnyDo19.png" style="width: 480px; height: 854px;" /><br /> &nbsp;</div><div style="text-align: center;">  20. 设置菜单中有个选项，是否在状态栏显示。这个功能仅支持Android4.0+的系统。</div><div style="text-align: center;">  <img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/Android/AnyDo20.png" style="width: 480px; height: 854px;" /><br /> &nbsp;</div><div style="text-align: center;">  21. 设置菜单中的&ldquo;礼物&rdquo;原来就是&ldquo;告诉偶的亲朋好友偶正在用Any.Do这个好东西&rdquo;。</div><div style="text-align: center;">  <span style="color:#b22222;"><var>PS：某人，看到你的名字了没。。@eugene</var></span></div><div style="text-align: center;">  <img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/Android/AnyDo21.png" style="width: 480px; height: 854px;" /><br /> &nbsp;</div><div style="text-align: center;">  22. &ldquo;帮助&rdquo;里的&ldquo;关于&rdquo;，很有爱的翻译。</div><div style="text-align: center;">  <img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/Android/AnyDo22.png" style="width: 480px; height: 854px;" /><br /> &nbsp;</div><div style="text-align: center;">  23. 很多人也会关心桌面插件的问题，因为Android就是用来折腾的，桌面就是用来放快捷方式和插件的。Any.Do提供了5种大小的插件，任你折腾。</div><div style="text-align: center;">  <img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/Android/AnyDo23.png" style="width: 480px; height: 854px;" />&nbsp;<img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/Android/AnyDo24.png" style="width: 480px; height: 854px;" /><br /> &nbsp;</div><div style="text-align: center;">  24. Chrome下的插件，界面也很简洁，很友好，并且会与移动设备的客户端进行同步。所以，在哪里也丢不了你的任务喽。</div><div style="text-align: center;">  <img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/Android/AnyDo25.png" style="width: 280px; height: 646px;" />&nbsp;<img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/Android/AnyDo26.png" style="width: 281px; height: 621px;" /></p>     <p>    27. 渗透到Gmail的Any.Do。<br /> <img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/Android/AnyDo27.png" /></div>     <pre><code>&lt;p&gt;  总的来说，Any.Do是一款比较简洁、人性化、交互性强的To-Do类App，在每天繁忙的工作和生活中，空出一点时间来，计划一下你的一天，你可以过得更条理，更优雅。&lt;/p&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分享壁纸</title>
      <link href="//pictures/%25e5%2588%2586%25e4%25ba%25ab%25e5%25a3%2581%25e7%25ba%25b8/"/>
      <url>//pictures/%25e5%2588%2586%25e4%25ba%25ab%25e5%25a3%2581%25e7%25ba%25b8/</url>
      
        <content type="html"><![CDATA[<div style="text-align: center;">  分享几张壁纸，都是自己网上搜罗的，分辨率基本都是1920X1080。</p>     <p>    点击任意一张进入大图下载。  </p>    <p>    预览图：  </p></div><div style="text-align: center;">  <a href="http://pan.baidu.com/share/link?shareid=403243&uk=151049050" target="_blank"><img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/mess-ups/wallpaper1.jpg" style="width: 600px; height: 338px;" /></a></div><span id="more"></span><div style="text-align: center;">  <a href="http://pan.baidu.com/share/link?shareid=403243&uk=151049050" target="_blank"><img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/mess-ups/wallpaper2.jpg" style="width: 600px; height: 338px;" /></a></div><div style="text-align: center;">  <a href="http://pan.baidu.com/share/link?shareid=403243&uk=151049050" target="_blank"><img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/mess-ups/wallpaper3.jpg" style="width: 600px; height: 338px;" /></a></div><div style="text-align: center;">  <a href="http://pan.baidu.com/share/link?shareid=403243&uk=151049050" target="_blank"><img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/mess-ups/wallpaper4.jpg" style="width: 600px; height: 338px;" /></a></div><div style="text-align: center;">  <a href="http://pan.baidu.com/share/link?shareid=403243&uk=151049050" target="_blank"><img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/mess-ups/wallpaper5.jpg" style="width: 600px; height: 338px;" /></a></div><div style="text-align: center;">  <a href="http://pan.baidu.com/share/link?shareid=403243&uk=151049050" target="_blank"><img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/mess-ups/wallpaper6.jpg" style="width: 600px; height: 338px;" /></a></div><div style="text-align: center;">  <a href="http://pan.baidu.com/share/link?shareid=403243&uk=151049050" target="_blank"><img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/mess-ups/wallpaper7.jpg" style="width: 600px; height: 338px;" /></a></div><div style="text-align: center;">  <a href="http://pan.baidu.com/share/link?shareid=403243&uk=151049050" target="_blank"><img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/mess-ups/wallpaper8.jpg" style="width: 600px; height: 338px;" /></a></div>]]></content>
      
      
      <categories>
          
          <category> 视觉盛宴 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周杰伦出道十年间所有专辑合集(112首歌) 将近两个小时哦</title>
      <link href="//pictures/jays-albums-in-10-years/"/>
      <url>//pictures/jays-albums-in-10-years/</url>
      
        <content type="html"><![CDATA[<div>  初次接触周杰伦，还是小学六年级的时候，在游戏机厅里，游戏机厅的老板有一个磁带机，老是单曲循环《简单爱》这首歌。我一边玩游戏，听了两三次就会唱了，然后就开始找他的歌听。</div><div>  <br /> 其实那个时候他已经出道两年了，《简单爱》是《范特西》专辑里的主打歌之一。</p>     <p>    后来我也买得起盗版磁带了，就缠着我妈给我买了一个随身听（嗯，那个年代是这么叫的），然后家里仅有的几盘磁带，就都是他的专辑了。  </p>    <p>    到后来初中、高中、大学，他的每一首歌我都会唱，每一首歌的歌词我都知道，大学宿舍里也有两三个杰伦迷，大家平时会一起听着他的歌，唱上两句。  </p>    <p>    不过我这人不追星，只喜欢他的歌，对他的人没啥兴趣，他演的电影也看过几部，演技。。嗯。  </p>    <p>    到现在，周杰伦的歌已经开始出现颓势了，越来越没有Jay范了，有一点那种快餐的意思。一方面是因为他也三十好几的人了，二是他现在已经不再是专心做音乐了，质量下降似乎也是必然的。  </p>    <p>    偶然一个机会，看到了这个视频，把他的从《Jay》到《跨时代》的所有曲目串烧了一遍。听完了很能让我想起以前的时光，心里还是蛮有感触的。<br /> <span id="more"></span>    <pre><code>&lt;br /&gt; 昨天下午又听了一遍，轻声哼着，哼了两个小时。。</code></pre>  </p>    <p>    不知道看我文字的人有没有喜欢他的歌的，有的话当然好，我们可以一起回忆回忆过去的日子。<br /> &nbsp;</div>     <pre><code>&lt;div style=&quot;text-align: center;&quot;&gt;&lt;/div&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 视觉盛宴 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 音乐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速 XX Windows8 商店下的付费应用</title>
      <link href="//just-try/xx-apps-in-windows-store/"/>
      <url>//just-try/xx-apps-in-windows-store/</url>
      
        <content type="html"><![CDATA[<p>本来不想涉及这种话题的，因为很可能会收到微软的律师函。。</p><p>但本着造福大众的目标，我还是将这枚好东西共享出来，独乐乐不如众乐乐嘛！</p><p><span style="color:#0000ff;">注：本软件只能XX可以试用的应用，即在商店里显示如下的：</span></p><p style="text-align: center;">  <img alt="" src="http://images.cy198706.com/Mess-Ups/trial.gif" /></p><p><span style="color:#0000ff;">付费才能下载的不可XX（因为根本就下不下来<del>。</del>）</span></p><p style="text-align: center;">  <img alt="" src="http://images.cy198706.com/Mess-Ups/pay.gif" /></p><p><span style="color:#0000ff;">所以，如果你是第一种选择，请继续看下去。</span></p><p><span style="color:#b22222;">警告：XX后应用无法更新，只能卸载后重新下载重新XX，如果对此感到不适，请无视此文。</span></p><span id="more"></span><p style="text-align: center;">  下载文章后的附件WSACOnekey，解压。</p><p style="text-align: center;">  可以看到有三个目录，如下：</p><p style="text-align: center;">  <img alt="" src="http://images.cy198706.com/Mess-Ups/QQ20130411142154.png" style="width: 119px; height: 63px;" /></p><p style="text-align: center;">  wscrack_xx代表你安装的Win8是xx位的。进入相应的目录，可以看到如下的文件：</p><p style="text-align: center;">  <img alt="" src="http://images.cy198706.com/Mess-Ups/QQ20130411142240.jpg" /></p><p style="text-align: center;">  右键，以管理员身份运行installer.exe。</p><p style="text-align: center;">  在打开的程序中，选择Install。稍候片刻，将会弹出成功安装的提示。</p><p style="text-align: center;">  <img alt="" src="http://images.cy198706.com/Mess-Ups/QQ20130411142546.png" /></p><p style="text-align: center;">  接下来进入wscrack_anycpu目录，运行TokensExtractor.exe。</p><p style="text-align: center;">  <img alt="" src="http://images.cy198706.com/Mess-Ups/QQ20130411142605.png" /></p><p style="text-align: center;">  打开之后，可以看到现在你的电脑里安装的所有商店应用。</p><p style="text-align: center;">  <img alt="" src="http://images.cy198706.com/Mess-Ups/QQ20130411142924.png" /></p><p style="text-align: center;">  xxx.xxxx(Full)表示已经被XX或者根本不用XX。xxx.xxxx(Trial)表示可以被XX。比如我这里这个Ilomilo，就是可以XX的。</p><p style="text-align: center;">  点击右边的CrackIt!，稍候片刻，就弹出Cracked！提示，此时已经完成了无痛XX。</p><p style="text-align: center;">  <img alt="" src="http://images.cy198706.com/Mess-Ups/QQ20130411142958.png" /></p><p style="text-align: center;">  再看应用的状态，已经变成xxx.xxx(Full)了。</p><p style="text-align: center;">  <img alt="" src="http://images.cy198706.com/Mess-Ups/QQ20130411143029.png" /></p><p style="text-align: center;">  上个水果忍者的图。可以看到，下方的&ldquo;购买&rdquo;已经不见了。</p><p style="text-align: center;">  <img alt="" src="http://images.cy198706.com/Mess-Ups/FruitNinja-cracked.png" /></p><p style="text-align: center;">  有能力的还是多多支持正版哈！做为一个程序猿，还是不喜欢别人XX自己的应用的。。由此可以看出，我不是个合格的程序猿。。</p><p style="text-align: center;">  附件：<a href="http://pan.baidu.com/share/link?shareid=445987&uk=151049050" target="_blank"><img alt="" src="http://cy198706.com/blog/wp-content/uploads/2013/04/download.png" /></a></p>]]></content>
      
      
      <categories>
          
          <category> 折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows Store App </tag>
            
            <tag> XX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哥又特么中奖啦！！</title>
      <link href="//gabby/big-prize/"/>
      <url>//gabby/big-prize/</url>
      
        <content type="html"><![CDATA[<p>今天早晨，打开屌丝必备的QQ邮箱，发现了一封神秘的油件，我心中突然有种预感，今天要有好事发生！</p><p>果不其然，当我打开邮件，就发现自己中奖啦！好多好多钱！</p><p>截图给你们看看，流口水去吧！</p><p style="text-align: center;">  <img alt="1" src="http://serious.qiniudn.com/QQ20130412092019.png" /></p><span id="more"></span><p>我怀着激动而又忐忑的心情，打开了这个非常标准的全英文一级域名。</p><p>咦？肿么是这样子呢？全是乱码？</p><p style="text-align: center;">  <img alt="2" src="http://serious.qiniudn.com/QQ20130412092316.png" /></p><p>没关系，谁让咱是程序猿呢！</p><p style="text-align: center;">  <img alt="3" src="http://serious.qiniudn.com/QQ20130412092703.jpg" /></p><p style="text-align: center;">  <img alt="4" src="http://serious.qiniudn.com/QQ20130412093435.png" /></p><p>看，好了！瞧瞧，多温馨的提示啊，让我们不要提交秘码啥的。</p><p>点击&ldquo;登录领取奖项&rdquo;，就进入了猩光大道的首页。</p><p style="text-align: center;">  <img alt="5" src="http://serious.qiniudn.com/QQ20130412093436.png" /></p><p>看！这页面做得多大气，多整洁，还有图有视频的。左边还在不断地滚动着那些幸运儿的名字和他们所获得的奖品。</p><p>一等奖居然是Camry小汽车一辆哎~ 咱怎么就没那个运气呢~</p><p>我颤抖着双手，又带着些许的遗憾，填上了我的验证码&#8211;5688。</p><p style="text-align: center;">  <img alt="6" src="http://serious.qiniudn.com/QQ20130412101537.png" /></p><p>验证过程虽然只有短短的几秒，我却感觉像是过了几个世纪，万一不是怎么办？万一是发错了号码怎么办？无数个念头从我心头闪过。</p><p style="text-align: center;">  <img alt="7" src="http://serious.qiniudn.com/QQ20130412101551.png" /></p><p>哈！我就知道，哥的运气从来就是这么棒！</p><p style="text-align: center;">  <img alt="8" src="http://serious.qiniudn.com/QQ20130412101617.png" /></p><p>瞧，哥的奖品已经在那等哥了！小水果，等着哟~</p><p>想到这儿，我准备先去看看他们的&ldquo;身份&rdquo;，于是我点开了&ldquo;查看活动证书&rdquo;。</p><p style="text-align: center;">  <img alt="9" src="http://serious.qiniudn.com/QQ20130412104604.png" /></p><p style="text-align: center;">  <img alt="10" src="http://serious.qiniudn.com/QQ20130412104725.png" /></p><p style="text-align: center;">  <img alt="" src="http://xgdd.lnbxjz.com/%E5%8C%97%E4%BA%AC%E5%B8%82%E4%BA%92%E8%81%94%E7%BD%91%E5%85%AC%E8%AF%81%E5%A4%84/images/z1.jpg" /></p><p>嗯，这下我就放心了，毫无PS痕迹啊有木有！！</p><p>进入&ldquo;领取偶的奖品&rdquo;，老毕无辜的老脸出现在屏幕上。</p><p style="text-align: center;">  <img alt="11" src="http://serious.qiniudn.com/QQ20130412101710.png" /></p><p>我还特意搜了一下下方的电话：</p><p style="text-align: center;">  <img alt="12" src="http://serious.qiniudn.com/QQ20130412101836.png" /></p><p>同意了对方的协议后，就进入了下一步，填写信息环节。</p><p style="text-align: center;">  <img alt="13" src="http://serious.qiniudn.com/QQ20130412102745.png" /></p><p>为了让我的隐私得到保护，我对这张图片进行了处理，让你们看不清楚我填写的东西，哈哈，我岂能那么轻易让你们跨省！</p><p style="text-align: center;">  <img alt="14" src="http://serious.qiniudn.com/QQ20130412102836.png" /></p><p>填写完后，就出现了提交过程。经过短暂而又漫长的等待，猩光大道给了我两个提示，这里可以看出栏目组是多么地严谨啊！</p><p style="text-align: center;">  <img alt="15" src="http://serious.qiniudn.com/QQ20130412102850.png" /> <img alt="16" src="http://serious.qiniudn.com/QQ20130412102908.png" /></p><p>接下来，就进入正式的领奖环节了。领奖的时候，贴心的栏目组为了保证奖品不在运输过程中损坏，还给我们上了保险，而且只需要交纳2200元，就可以立即拿到我的奖品了！</p><p style="text-align: center;">  <img alt="17" src="http://serious.qiniudn.com/QQ20130412103030.png" /></p><p>详细内容（些小字，看得我高强度钛合金狗眼都快瞎了）。</p><p style="text-align: center;">  <img alt="18" src="http://serious.qiniudn.com/QQ20130412103053.png" /></p><p>无辜的公证人。我记得在我之前中的一次奖时，左边这哥们叫张龙旺来着。。<img src="http://serious.qiniudn.com/QQ20130412105625.jpg">这才多长时间，连姓都改啦？现在的小年轻，真无法理解<img src="http://serious.qiniudn.com/QQ20130412105721.jpg" alt="no way"></p><p>我决定交钱，但是一摸兜里，12块5。完了。<img src="http://serious.qiniudn.com/QQ20130412110233.png" alt="holyshit"></p>]]></content>
      
      
      <categories>
          
          <category> 口水 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 口水 </tag>
            
            <tag> 中奖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新建聊天室，欢迎大家来玩～</title>
      <link href="//gabby/%25e6%2596%25b0%25e5%25bb%25ba%25e8%2581%258a%25e5%25a4%25a9%25e5%25ae%25a4%25ef%25bc%258c%25e6%25ac%25a2%25e8%25bf%258e%25e5%25a4%25a7%25e5%25ae%25b6%25e6%259d%25a5%25e7%258e%25a9%25ef%25bd%259e/"/>
      <url>//gabby/%25e6%2596%25b0%25e5%25bb%25ba%25e8%2581%258a%25e5%25a4%25a9%25e5%25ae%25a4%25ef%25bc%258c%25e6%25ac%25a2%25e8%25bf%258e%25e5%25a4%25a7%25e5%25ae%25b6%25e6%259d%25a5%25e7%258e%25a9%25ef%25bd%259e/</url>
      
        <content type="html"><![CDATA[<p>使用Moot.it建立了一个聊天室。</p><p>呃。。更准确的说，应该是个小论坛。</p><p>总之，欢迎大家来玩。</p><p>TIP：可以点击上面的&ldquo;来聊天吧&rdquo;，也可以点击<a href="http://chat.cy198706.com/">这个链接</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 口水 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 聊天 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>恐怖的中学校规，我肯定进门就被踹出来。</title>
      <link href="//gabby/%25e6%2581%2590%25e6%2580%2596%25e7%259a%2584%25e4%25b8%25ad%25e5%25ad%25a6%25e6%25a0%25a1%25e8%25a7%2584%25ef%25bc%258c%25e6%2588%2591%25e8%2582%25af%25e5%25ae%259a%25e8%25bf%259b%25e9%2597%25a8%25e5%25b0%25b1%25e8%25a2%25ab%25e8%25b8%25b9%25e5%2587%25ba%25e6%259d%25a5%25e3%2580%2582/"/>
      <url>//gabby/%25e6%2581%2590%25e6%2580%2596%25e7%259a%2584%25e4%25b8%25ad%25e5%25ad%25a6%25e6%25a0%25a1%25e8%25a7%2584%25ef%25bc%258c%25e6%2588%2591%25e8%2582%25af%25e5%25ae%259a%25e8%25bf%259b%25e9%2597%25a8%25e5%25b0%25b1%25e8%25a2%25ab%25e8%25b8%25b9%25e5%2587%25ba%25e6%259d%25a5%25e3%2580%2582/</url>
      
        <content type="html"><![CDATA[<p>没得写了，到处乱逛的时候，发现了这个。</p><p>真是感叹，幸亏我不做学生好多年。。</p><span id="more"></span><p>1.有下列行为之一者，给与发放违纪通知单的处理，扣班级行为量化分1分/人次</p><p>携带随身听，mp3，见到废弃物视而不见，穿怪异服装，穿短透露的服装，男生剃光头、留长发、染发（非黑色）、蓄胡须，女生化妆、戴首饰、穿高跟鞋、斜挎长包，在宿舍楼以外的地方穿拖鞋，旷课一节，不遵守公共秩序，言行不诚信，考试违纪，跑步去餐厅，打饭夹塞，合伙购饭，就餐时提前，用勺等占座，隔墙、隔门接物，上课（含自习课）期间无证到医务室就医，不叠被子，在教室、宿舍墙面乱贴乱画，不按时归还图书。</p><hr><p>2．有下列行为之一者，给予全校通报批评的处理，扣班级行为量化分2分/人次</p><p>在水房、阳台等处随地便溺，随地乱扔废弃物，损坏公物，旷课2-3节，在用电器挂东西，使用充电器，擅自动用学校电脑，说话污言秽语。</p><hr><p>3．有下列行为之一者，视情节轻重予警告或严重警告处分，回家自我反思，接受家长在教育1-2周的处理，并全校通报，扣班级行为量化分3分/人次</p><p>男女生非正常接触</p><p>&nbsp;&nbsp;&nbsp;&nbsp;①男女生互相陪护到医务室看病<br>&nbsp;&nbsp;&nbsp;&nbsp;②男女生互相追逐打闹，动手动脚<br>&nbsp;&nbsp;&nbsp;&nbsp;③一男一女在隐蔽角落单独接触<br>&nbsp;&nbsp;&nbsp;&nbsp;④男女生互相请客，互发短信，互赠礼物，互传纸条、书信<br>&nbsp;&nbsp;&nbsp;&nbsp;⑤互相以兄妹或其他昵称称呼<br>&nbsp;&nbsp;&nbsp;&nbsp;⑥男女生两人频繁交往<br>&nbsp;&nbsp;&nbsp;&nbsp;⑦男女生两人拉手搭肩等。</p><p>严重损坏公物，王宿舍内带火种，私拉电线，焚烧物品，隔窗泼水、投物，携带手机小灵通等通讯工具，违规吃带零食（祥见吃带零食的有关规定），考试作弊，旷课半天到两天，侮辱、谩骂老师或他人，擅自动用学校电脑并更改设置，携带传看不健康书刊，损坏树木，践踏草坪，擅自离校外出（含跳墙外出），在水房内**洗澡，第1-2项违纪行为屡教不改者，常规管理中的屡教不改的违纪者。</p><hr><p>4．有下列行为之一这是情节轻重给予记过，记大过，留校察看处分，回家自我反思，接受家长再教育2-4周的处理，并全校通报批评，扣班级行为量化分4分/人次</p><p>擅自离校外出，并在校外过夜，抽烟、喝酒、打麻将，逃避考试一次，携带管丨制刀具及与学习无关的刀具棍棒等，打人打架，在公共场所起哄，搞恶作剧，旷课3-6天</p><hr><p>5．有下列行为之一者，给予取消在校学习资格的处分并全校通报，扣除班级行为量化分6分/人次</p><p>打人打架情节严重，举重打架及幕后操纵打假?，屡犯偷窃或偷窃性质严重，男女见越轨行为，旷课7-10天，学期累计逃避考试两次，第三四项屡教不改者</p><hr><p>6．有下列行为之一者，给予开除学籍的处分，并全校通报，扣除班级行为量化分10分/人次</p><p>偷窃成瘾且偷窃数额巨大的，打人打架手段恶劣，性质严重，造成严重后果的，男女生越轨接触造成严重后果的，有流氓行为，在公共场所搞恶作剧造成严重后果的</p><hr><p>7．违纪行为若造成严重后果，超出学校纪律处理范围的，将依法移交司法部门处理</p><hr><p>8．不能涵盖的其他违纪行为由学校根据性质和情节另作相应的处理，以上条块解释权在教育处</p>]]></content>
      
      
      <categories>
          
          <category> 口水 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 口水 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>絮叨絮叨</title>
      <link href="//gabby/tick-tock/"/>
      <url>//gabby/tick-tock/</url>
      
        <content type="html"><![CDATA[<p>这两天又开始瞎忙，干不属于自己的工作。</p><p>周一我的直属上司把我叫到办公室，跟我说了些没营养的话之后，就告诉我：&ldquo;你现在正在做的那个东西，就别弄了，没用了。&rdquo;</p><p>这句话对我来说仿佛晴天霹雳，我自己忙活了一整年的东西，就被这一句话给杀了。</p><p>他好像看穿了我的想法，开始劝我：&ldquo;没事，你接下来就看看安卓吧，咱们接下来要开发安卓版的客户端了。咱们公司会招两个安卓的人进来，他们做完，你就维护他们的代码吧。&rdquo;说完又加了一句&ldquo;你这个岗位，还是要保留的。&rdquo;</p><p class="Code">  <img src="http://images.cy198706.com/Gabby/8f83d327c08f5460b1de05e5.jpg" style="margin-right: 10px; float: left;" /></p><p>我只能强装镇定，说了一堆&ldquo;没问题&rdquo;&ldquo;这都小意思&rdquo;&ldquo;我不怕困难&rdquo;&ldquo;有啥活来找我&rdquo;之类的，然后就悻悻地回到了自己的工位。</p><p>没过几分钟，他又来了，说&ldquo;那个，明天下午下班先别走，咱们跟前端的检测员一起吃个饭，听听他们对新版客户端的改进意见，你呢，就拿个本，拿个笔，记录一下。&rdquo;</p><p>于是第二天晚上就去当速记员了。接着第三天中午又去当速记员了。</p><p>晚上回去后一直闷闷不乐的，感觉自己在公司已经没有价值了。从一个程序员变成速记员，在别人看来没啥，还有可能会说&ldquo;这有啥啊，闲着没事还拿工资，多好哇&rdquo;，但对我来说是一种能力的否定。</p><p>于是现在坐在这里，就如坐针砧了。本来想5月底跳，现在更坚定我的想法了&#8212;-我不能做些随便一个人都能做的工作，否则我对不起这份工资。</p><p>其实在上一家公司，也出现过这样的情况，当时公司缺人手，我既搓代码，还得跑腿，又要记录，甚至还要做决定，这完全不是我的本职工作了。</p><p>胸中郁闷，就把情况跟媳妇说了。媳妇一听就笑了：&ldquo;我还以为啥事的，看你闷闷不乐的。你想啊，为什么不随便找个人来做呢？其他人有你了解这个客户端吗？其他人听得懂那些专有名词吗？其他人跟得上你们技术人员之间的谈话进度吗？&rdquo;四个问题就把我惊醒了。</p><p>是呢，无意之间，我又多了一份责任，就是把自己知道的东西交给别人，把检测员反馈的情况组成新的特色，这样才叫&ldquo;改进&rdquo;。这样一想，就舒服多了。</p><p>今天决定把技术类的文章逐步独立出去，因为写技术类的文章，好像大伙都看不懂，也没什么意思，就独立出去，当作新的分支了。</p><p>明天下午的火车，回家了，请两天年假，凑个七天的长假，这笔生意挺划算。</p>]]></content>
      
      
      <categories>
          
          <category> 口水 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 口水 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lenka &amp;#8211; Trouble is a Friend</title>
      <link href="//music/lenka-trouble-is-a-friend/"/>
      <url>//music/lenka-trouble-is-a-friend/</url>
      
        <content type="html"><![CDATA[<p>这一看半个月又没更新了。 还有朋友在催我更新博客，因为他们过来，发现还是那篇文章，连想留个脚印的地方都没有，这显得我实在是太没意思了。 正在酝酿一篇长文，打算写完之后再一起放上来。今儿就先推荐一首曲子吧&ldquo;Lenka &#8211; Trouble is a Friend&rdquo;。 这首歌第一次听是在上一家公司的司机送我去机场的路上听到的。曲子的节奏感比较强（不是Disco舞曲哦，我不喜欢Disco舞曲），Lenka的声线很张扬，略带点沙哑的嗓子神马的最让人喜爱了。</p><p>再加上最近最到的麻烦事比较多，又听了几遍这首歌，就把它推荐给大家，希望朋友们可以从这首歌中受到鼓励~</p><p>上曲。<strike>来自skydrive外链。（可能会有点慢。。正在研究中。。）</strike></p><p><strike><span style="color:#b22222;"><em>（请使用支持HTML5的浏览器，否则会看不见啊听不到。。）</em></span></strike></p><p>因为不可抗力因素，改成虾米了。。HTML5普及路漫漫啊。。</p><p>&nbsp;</p><div style="text-align:center">  <embed height="33" src="http://www.xiami.com/widget/0_3320604/singlePlayer.swf" type="application/x-shockwave-flash" width="257" wmode="transparent">  </embed></div><p>&nbsp;</p>]]></content>
      
      
      <categories>
          
          <category> 耳朵 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 音乐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你还有梦想吗？ &amp;#8211; 观《小儿难养》有感</title>
      <link href="//gabby/%25e4%25bd%25a0%25e8%25bf%2598%25e6%259c%2589%25e6%25a2%25a6%25e6%2583%25b3%25e5%2590%2597%25ef%25bc%259f-%25e8%25a7%2582%25e3%2580%258a%25e5%25b0%258f%25e5%2584%25bf%25e9%259a%25be%25e5%2585%25bb%25e3%2580%258b%25e6%259c%2589%25e6%2584%259f/"/>
      <url>//gabby/%25e4%25bd%25a0%25e8%25bf%2598%25e6%259c%2589%25e6%25a2%25a6%25e6%2583%25b3%25e5%2590%2597%25ef%25bc%259f-%25e8%25a7%2582%25e3%2580%258a%25e5%25b0%258f%25e5%2584%25bf%25e9%259a%25be%25e5%2585%25bb%25e3%2580%258b%25e6%259c%2589%25e6%2584%259f/</url>
      
        <content type="html"><![CDATA[<p style="text-align: center;">  构思这篇文章的时候，正在跟媳妇一起看《小儿难养》&#8211; 我大马桶台之前强推的一部戏。</p><p style="text-align: center;">  着手写此文的时候，恰好是看完这部剧的时候。35集，这部剧给我留下了很深的印象。</p><p style="text-align: center;">  <img alt="" src="http://images.cy198706.com/Gabby/QQ截图20130515122845.png" style="width: 651px; height: 443px;" /></p><p style="text-align: center;">  文章比较长（其实也不长，只是好久没码字了，感觉好像挺长（什么长不长的你想哪去了））。</p><span id="more"></span><p>&nbsp;</p><h2 id="关于剧（强剧透向，如果有正在看的或者是打算看的请斟酌）"><a href="#关于剧（强剧透向，如果有正在看的或者是打算看的请斟酌）" class="headerlink" title="关于剧（强剧透向，如果有正在看的或者是打算看的请斟酌）"></a>关于剧（强剧透向，如果有正在看的或者是打算看的请斟酌）</h2><p>这部电视剧剧如其名，主要是讲小孩的故事，以及围绕着这个孩儿，父母、养父母、老父老母的故事，顺带着牵出婆媳、爱情故事。</p><p>主线一：上海，一对夫妻，生活质量还可以，有车有房，但自从有了孩子，就全乱了。夫妻之间本来都以对方为最优对象，但现在都转向了孩子，每一个决定都为了孩子好但却处处都是矛盾，家里乱成一锅粥。为了照顾孩子不惜高价请月嫂，但却被省钱的婆婆和丈母娘赶走。为了改善每况愈下的家庭财政，接私活却被坑送进警察局。为了提高收入却引发了夫妻之间的猜疑。。主线一是主线中的主线。</p><p>主线二：一夜情产生的一个意外，让以解雇别人作为职业的高富帅生活陷入困境。在韩国的孩子的母亲把孩子硬塞了过来，让高富帅手足无措。因为这个孩子，工作受到牵制，生活受到影响，甚至连未婚妻也因此反目分手。但也因为这个小孩，他认识了一个特立独行的女孩，两人之间的爱恨纠葛更让人纠结。</p><p>主线三：主线一中的女人是个事业女强人，从小没输过人，但就这种气场，让一起长大的玩伴暗生恨嫉，在职场上处处刁难，明枪暗剑你来我往。主线一中的男人是个事业失败者，平时硬气但一与客户接触就结巴，小富即安的心理让他受了不少上司的责骂。</p><p>主线四：恋爱中的小两口。男生是标准的&ldquo;单反穷三代，摄影毁一生&rdquo;，没有稳定的工作，总是偷偷地用女友的信用卡买镜头，不喜欢负责任，不喜欢受拘束，不想结婚，不想要孩子，是一个典型的没长大的孩子。女生心思全在男生身上，可以容忍男生的一切，但受到主线一中夫妻的影响，想结婚，想要孩子，于是矛盾就出现了。</p><p>四个主线来回切换又互相影响，编剧很厉害。我在看剧的过程中，大约夸了四次&ldquo;次奥。。编剧真牛掰&rdquo;。场景切换得很也流畅，分镜手法运用得也很娴熟，有些场景的镜头摇晃让人从心底感到急躁，这点很赞。偶尔出现的旁白很讨巧。主线的矛盾特别突出，人物性格通过两三个镜头就能体现出来。虽然也有一些比较狗血的场景，一些配音重制，和一些比较明显的广告植入，但完全不会影响到这部片子的光华。</p><p>孩子的哭声几乎在剧的中后部每集都有。哭声代表了不安、悲伤，在吵架的时候孩子的哭声就是催化剂，让场景显得特别混乱，观众心理的焦躁、不安到达顶点，好几次听到孩子刺耳的哭声都有点看不下去了。</p><p>几乎跟其他的剧一样，总会有几个角色，让人见一次就想骂一次；也总会有一些剧情，让观众大骂&ldquo;次奥，难道就不能那样或者那样吗？非得这么做？&rdquo;。没办法，这部剧也不能脱俗。最后求婚的部分让人眼前一亮，魏晨的加入也让这部分增色不少。</p><p>剧的背景音乐一般，很多时候都是该入的时候没入，不该入的时候瞎入，但质量尚可。</p><p>年轻演员的表演都很出彩，嬉笑怒骂毫不做作，情感收放自如，再加上导演的手法不错，让几个主演大放异彩。年纪大点的演员稍显拘束，但是70多岁的姥姥是个例外，算是本剧的灵魂人物之一，是&ldquo;传道、授业、解惑&rdquo;的角色。</p><p>总的来说，抛掉少量的糟粕，满分5分，此剧可以给4分了。</p><p>&nbsp;</p><h2 id="关于感想"><a href="#关于感想" class="headerlink" title="关于感想"></a>关于感想</h2><p>其实总里总归，这部片子最大的矛盾就是&ldquo;理想与现实&rdquo;。</p><p>理想与现实，这个话题蛮沉重的。无论是搁到什么上，&ldquo;理想很丰满，现实很骨感&rdquo;这句话都能用得上。梦里自己的白马王子或者白雪公主正准备跟自己打啵呢，一睁眼，是自己的屋子，想到还是单身，这种对比就很让人难受了。刚一毕业，满怀理想准备到社会上大展宏图实现自己的人生价值，却处处碰壁，被捅刀子，只能随便找了份工作，却拿着永远不涨价的工资买分分钟在涨价的食物。以为找到了自己人生的另一半，准备共结连理同度余生，却发现没房没车没钱，想做什么都举步维艰。</p><p><em><strong>是不是很现实？</strong></em></p><p>剧中主线一里的小夫妻，在孩子还没生下来之前，对未来生活充满了希望，他们要住更大的房子，他们要让孩子上个好学校，他们要让生活质量更好。。但孩子一出生后，情况就跟他们的规划完全不一样了。因为孩子，女主丢了原来的职位，男主也险些被辞退，家庭财政入不敷出，两口子从婚前的甜甜蜜蜜，到生儿子后吵的天翻地覆，其中的落差可见一斑。</p><p>我不知道在现实生活中，这样的情况多不多，毕竟我的成长过程还是很顺利的，虽然家庭状况不太好，但我的童年还是很快乐的，都是美好的回忆。爸妈几乎没有因为财政，我上学啥的问题吵过架。</p><p>主线二中特立独行的女孩，从小就是家里头疼的对象，不好好上学，不听话，长大了也不听话，有着一段难忘的经历，或许还有一些不切实际的幻想，不相信任何人，自己开纹身店，用自己的钱照顾流浪猫，不想结婚，不想谈恋爱。最经典的台词就是&ldquo;我的人生理想，就是当我的客人百年之后，他们的亲人看着他们身上的我的纹身作品，怎么也舍不得把他们放进焚化炉，觉得就这么烧了，简直就是毁坏艺术珍品！&rdquo;这样一个女孩，却为了一个捡来的小孩倾尽自己所有的感情。当她与高富帅相处多了，也产生了感情（*<span style="font-size:14px;">我跟媳妇从开头就猜中了，是不是国产剧的悲哀？</span>*），但幻想美好爱情的时候，却被高富帅的母亲和&ldquo;前未婚妻&rdquo;将这个梦粉碎了。</p><p>我不认识这样的女生。之前的求学生涯中有一些比较man的女同学，或者她们也有着自己的理想，想只身度过一辈子，但后来还不是一个个都嫁人生子了。没办法，你不结婚你就是异类，你是异类家里人都没面子啦，连出去逛街都要忍受邻居异样的眼光，这让他们情何以堪呢。</p><p>主线一的女主一直向往着一种职场生活，就是努力就有回报。她的努力在生完孩子之后就化为了泡影。公司抛弃了她，她原来的下属骑到了她的头上耀武扬威。她忍了，对于原下属所有的恶劣行径。当然最后结果是圆满的，下属就是下属，如果只想通过玩手段上位，就永远只能是下属。编剧还是想通过这支主线来传递一些正能量的。片中有段女主跟下属的谈话，问&ldquo;你的梦想是什么？&rdquo;，下属毫不犹豫地说：&ldquo;超越你就是我的梦想。&rdquo;</p><p>职场很危险，凡是工作了的人都知道。我之前有一个同事，被另外的人捅过刀子，然后直接就被辞了。而且，刀子的主人平步青云，现在似乎已经上升到总经理的职位了。生活不是电视剧，职场里一旦有了竞争，并牵扯到利益，那么不是你死就是我死。我还没有经历过这种事情，可能是因为我在职场混的时间太短，不会动到别人的利益，也不会有人来跟我抢什么，或者有人捅了我一刀，我没感觉到，或者他捅偏了伤到自个了也不一定。</p><p>再说主线四的男生。这种男生感觉现实生活中应该有很多，为了自己的理想不顾一切，甚至伤害爱自己的人和自己爱的人。对于他来说，摄影就是他的一切，他在剧中也不只一次地强调过，他不喜欢被栓住的感觉，他要自由地生活，他不想让结婚和孩子和油盐酱醋毁了自己的梦想。可是呢，最后他还是悟了，现实就是现实，男人要成长，就必须要经历一些事情，比如结婚，比如生孩子。</p><p>片中几乎每一个主角都被问过一个同样的问题：你还有梦想吗？</p><p>我其实在看到这部剧的名字的时候，我是有点抵触的。我怕自己会因为&ldquo;小儿难养&rdquo;对自己所坚持的生活有所动摇。</p><p>但是，看完了，却又豁然开朗。男主的妈妈说了一句很让我受用的话，&ldquo;老话说小儿难养，这养，不是指的养活，而是你为人父母的那份责任。&rdquo;生活，就算质量再怎么高，有大的房子，有高档的汽车，但最重要的，还是一家人都在一起，不是吗？</p><p>看着看着，把媳妇的&ldquo;婚前恐惧症&rdquo;给勾出来了。其实。。到底是不是婚前恐惧症，我也不太清楚。。聊了一会，发现其实过日子就是这样，平平淡淡的才最真。问了问今年刚结婚的同事，有没有婚前恐惧症，他斩钉截铁地说：&ldquo;有哇！必须有哇！&rdquo;我问什么时候开始，他说&ldquo;大约结婚前一个月吧。结完婚就好了。&rdquo;</p><p>于是我跟媳妇说，咱以后别看这样的片子了，会对咱们有影响的。国产的电视剧，正面向的居多（或者应该是绝大部分），但是不扯婆媳、不扯生活、不扯婚姻的少。看多了，思维定式了，多多少少还是会受影响的。</p><p>毕竟，生活还是得咱自己来过。</p><p>&nbsp;</p><h2 id="关于理想"><a href="#关于理想" class="headerlink" title="关于理想"></a>关于理想</h2><p>理想这玩意差不多每个人都会有，而且在很小的时候就会有。因为很小的时候接触的东西都是积极向上的，很容易就让人有各种理想。问了问周遭的人，小时候的理想也是五花八门的，有想做老师的，有想做科学家的，有想当总统的，有想当飞行员的，有想当医生的，想当司机的，当演员当数学家当画家当生意人。。等等等等。但是，他们现在跟我坐在一起，变成了个码农。</p><p>我小时候，受我爸爸的影响，想的是长大了要当科学家。我跟我爸都喜欢高科技的玩意，他年轻的时候折腾过无线电，也有一些小成果，而且对机械原理无比精通，这两样看来我没怎么继承。。那时候感觉科学家就是神一般的存在，没有他们解决不了的问题。</p><p>后来，长大一点，受到网络影响，想做一名黑客，或者是技术尖端人才，我记得最震憾我的是当年的&ldquo;熊猫烧香&rdquo;，让我萌生此意。</p><p>现在。。可能我的理想就是平平安安的，跟媳妇安稳地过一辈子，赚足够的钱让娘儿俩、让我们爸妈都能过上好点的日子。</p><p>变化是不是相当大？</p><p>有人说了，人是会成长的嘛，思想是会变化的嘛。但是我要说的是，理想这个东西，不应该随着人的成长面变化，如果变化了，那这东西就不叫理想，充其量叫个目标。</p><p>关于理想的话，有很多想说的，但是到了键盘上却打不出来了。</p><p>&nbsp;</p><h2 id="关于课外作业"><a href="#关于课外作业" class="headerlink" title="关于课外作业"></a>关于课外作业</h2><p>你的理想是什么来着？</p>]]></content>
      
      
      <categories>
          
          <category> 口水 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回家，小舅子结婚~</title>
      <link href="//gabby/%25e5%259b%259e%25e5%25ae%25b6%25ef%25bc%258c%25e5%25b0%258f%25e8%2588%2585%25e5%25ad%2590%25e7%25bb%2593%25e5%25a9%259a/"/>
      <url>//gabby/%25e5%259b%259e%25e5%25ae%25b6%25ef%25bc%258c%25e5%25b0%258f%25e8%2588%2585%25e5%25ad%2590%25e7%25bb%2593%25e5%25a9%259a/</url>
      
        <content type="html"><![CDATA[<p style="text-align: center;">  会有五天和大家失去联系呢。。</p><p style="text-align: center;">  无论如何，偶可不是人间蒸发了，只是又暂时性离开网络。。</p><p style="text-align: center;">  会想你们的哟~</p><p style="text-align: center;">  <img alt="" src="http://images.cy198706.com/Gabby/leaving.jpg" /></p>]]></content>
      
      
      <categories>
          
          <category> 口水 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 口水 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>听说用Word也可以发布文章</title>
      <link href="//tech/%25e5%2590%25ac%25e8%25af%25b4%25e7%2594%25a8word%25e4%25b9%259f%25e5%258f%25af%25e4%25bb%25a5%25e5%258f%2591%25e5%25b8%2583%25e6%2596%2587%25e7%25ab%25a0/"/>
      <url>//tech/%25e5%2590%25ac%25e8%25af%25b4%25e7%2594%25a8word%25e4%25b9%259f%25e5%258f%25af%25e4%25bb%25a5%25e5%258f%2591%25e5%25b8%2583%25e6%2596%2587%25e7%25ab%25a0/</url>
      
        <content type="html"><![CDATA[<p><strike><span style="font-size:12pt">TableLayout: </span></strike></p><p><strike>android:stretchColumns=”0” 代表让第一行扩展到整行</strike></p><p>试试看。</p>]]></content>
      
      
      <categories>
          
          <category> 金刚钻 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>端午坝上草原行（高清无码多图，小水管慎入）</title>
      <link href="//gabby/%25e7%25ab%25af%25e5%258d%2588%25e5%259d%259d%25e4%25b8%258a%25e8%258d%2589%25e5%258e%259f%25e8%25a1%258c%25ef%25bc%2588%25e9%25ab%2598%25e6%25b8%2585%25e6%2597%25a0%25e7%25a0%2581%25e5%25a4%259a%25e5%259b%25be%25ef%25bc%258c%25e5%25b0%258f%25e6%25b0%25b4%25e7%25ae%25a1%25e6%2585%258e%25e5%2585%25a5%25ef%25bc%2589/"/>
      <url>//gabby/%25e7%25ab%25af%25e5%258d%2588%25e5%259d%259d%25e4%25b8%258a%25e8%258d%2589%25e5%258e%259f%25e8%25a1%258c%25ef%25bc%2588%25e9%25ab%2598%25e6%25b8%2585%25e6%2597%25a0%25e7%25a0%2581%25e5%25a4%259a%25e5%259b%25be%25ef%25bc%258c%25e5%25b0%258f%25e6%25b0%25b4%25e7%25ae%25a1%25e6%2585%258e%25e5%2585%25a5%25ef%25bc%2589/</url>
      
        <content type="html"><![CDATA[<p>又好久没有生产文章了。原因也很差强人意 &#8212; 最近比较忙。</p><p>前前后后差不多忙了半个月，还是在做自己不该做的东西。</p><p>趁着端午的3天小假，我们打算出去玩玩，网上找了一通，最后决定去从去年就想要去的丰宁坝上草原。</p><p>本来计划坐公交，后来媳妇同事说有车，于是我们5个人+2个小孩，就嗨嗨皮皮地上路了。</p><p>这次旅程中的心情，可以用一条线的词语来形容：兴奋 &#8211; 稀奇 &#8211; 震撼 &#8211; 感慨 &#8211; 失望 &#8211; 气愤 &#8211; 无奈。</p><p>情绪为啥会有这么大的变化呢，且行且看吧。</p><span id="more"></span><p>早上5：40起床，因为车程将近6小时，所以起得特早。这时候心情是相当兴奋（我会告诉你4点我就睡不着了么）。在车里，走到怀柔的时候，就已经看到旁边的山和绿油油的田地了。从这儿开始，就有脱离城市的感觉了。因为我从小在城市里长大，像这样的山啊、田啊之类的真没看过。所以一路上我是东张西望，每一个景都想收在脑海里。</p><p>&nbsp;</p><img alt="" src="http://images.cy198706.com/Travel/IMG_1812.JPG" style="width: 1024px; height: 768px;" /><p>**&uarr;**干净的马路。因为马路上不会有人下车，大家也很自觉地不往车窗外扔东西，所以马路特别干净。这是在一个小的停车点照的。</p><img alt="" src="http://images.cy198706.com/Travel/IMG_1824.JPG" style="width: 1024px; height: 768px;" /><p>**&uarr;**这片山叫做云蒙山。这个名字特别形象。山上飘着的也不知道是不是真的云彩。当前海拔不知道是多少。</p><p><img src="http://images.cy198706.com/Travel/IMG_1831.JPG"></p><p>**&uarr;**毫无PS痕迹的云。因为是在车上，所以拍得不真着。感觉云就像是从山的那边被&ldquo;泼&rdquo;上来的。</p><p><img src="http://images.cy198706.com/Travel/IMG_1839.JPG"></p><p>**&uarr;**河北界旁边的山。在河北界我们休息了10分钟，这山真是让人感到相当震撼。</p><p><img src="http://images.cy198706.com/Travel/IMG_1842.JPG"></p><p>**&uarr;**同上，因为景色太棒，所以多上几张。</p><p><img src="http://images.cy198706.com/Travel/IMG_1849.JPG"></p><p>**&uarr;**河北界牌子下方的公路。用这种角度拍得还是挺有feel的。</p><p>&nbsp;</p><p>在下午1点左右的时候，因为热乎乎，所以。。睡着了。。等再次醒来，就已经看到一些蒙古包，马，风车，和小片的草原了。温度大约在19度左右。刚下过雨，空气特别特别清新，真真正正能感觉到什么叫&ldquo;沁人心脾&rdquo;，和都市里那种污浊的空气差距简直太大了。我们最后一次停车就是离草原大约30分钟车程的地方了。这儿拍得都不怎么好，就不上图了。</p><p>在网上查到坝上有一个不错的度假村叫&ldquo;扎拉营&rdquo;，导航至此，恶心的部分也就开始了。</p><p><strong>首先是遍地的马粪。</strong>马一多，马粪也就多，可是100米的路要走3分钟，你信吗？真的要&ldquo;躲着走&rdquo;，因为一不小心，你可能就踩地雷了。</p><p><strong>垃圾满地。</strong>其实本来挺干净，可是没素质的人实在太多，导致琳琅满目的垃圾。真是一样米饲百样人，总会有人跳出来污染美好的环境。</p><p><strong>住宿条件特别差。</strong>好歹也是&ldquo;著名&rdquo;的度假村，难道不能把住宿条件搞好点吗？接待我们的时候，说&ldquo;有电视、有网络、24小时热水，哦，你那边是向阳的，所以会特别舒服。&rdquo;等到晚上回去后，发现电视没信号，网络就是所谓的GPRS信号，热水需要自己打开热水器，自己打就自己打吧，对不起，插座没电。</p><p><strong>宰客现象特别严重。</strong>骑马要60块一小时，草地摩托要120块一小时，土豆丝一盘28，黄瓜沾酱18。其实出来一趟就不在乎花多少钱了，但是花得值不值，还得另说。</p><p><strong>所谓的&ldquo;草原&rdquo;都不在度假村附近，想去草原，自己找去吧。</strong>在度假村附近的，都是小草场，大部分都无法进入（有铁丝网拦着），就算能进去的，也是遍地马粪。本来计划的搭帐篷野餐也因此搁浅了。</p><p>我不是个喜欢抱怨的人（参见<a href="http://cy198706.com/blog/gabby/%E5%BC%B1%E8%80%85%E5%8F%AA%E4%BC%9A%E6%8A%B1%E6%80%A8%EF%BC%8C%E5%BC%BA%E8%80%85%E6%80%BB%E4%BC%9A%E6%94%B9%E5%8F%98/">弱者只会抱怨，强者总会改变</a>），但跟期望值差距太大，就有点说不过去了。</p><p>下午我们漫无目的地瞎逛，还真让我们找到了一片不错的草原。也碰上了跟我们有同样目的的一家三口。</p><p><img src="http://images.cy198706.com/Travel/IMG_1866.JPG"></p><p>**&uarr;**有木有Windows XP的感脚？<img alt="cheeky" height="24" src="http://cy198706.com/blog/wp-content/plugins/ck-and-syntaxhighlighter/ckeditor/plugins/smiley/images/6.gif" title="cheeky" width="24" /></p><p><img src="http://images.cy198706.com/Travel/IMG_1868.JPG"></p><p>**&uarr;**一望无际的大草原呀~ 来到这儿，整个人都被净化了。心里任何杂念都没有，就想享受这片绿，与这片蓝。</p><p><img src="http://images.cy198706.com/Travel/IMG_1871.JPG"></p><p>**&uarr;**在爬一片山丘的时候，半路遇见的不知名野花。被花香吸引来的小虫子们正在上面忙碌着。</p><img alt="" src="http://images.cy198706.com/Travel/IMG_1877.JPG" style="width: 1024px; height: 768px;" /><p>**&uarr;**把刚学来的拍摄手法用上，拍一个，自我感觉良好。</p><p><img src="http://images.cy198706.com/Travel/IMG_1900.JPG"></p><p>**&uarr;**我跟媳妇。她穿着皮肤衣，还没啥问题，我直接一条短袖，一天下来，把脖子给晒伤了=。=</p><p>在草原上把午饭吃完，就继续漫无目的地游荡。</p><p>开着开着，发现路边的&ldquo;可汗行宫&rdquo;。出于好奇的心理，我们在可汗行宫遛了一圈。</p><p>可汗行宫分为两部分，一部分是行宫的参观，一部分是以草原为基础的游乐园。因为有小孩子，所以我们决定在这个看不到边的游乐园里度过下午。</p><p><img src="http://images.cy198706.com/Travel/IMG_1910.JPG"></p><p>**&uarr;**介个不是可汗，是一名普通的士兵。很威武。</p><p><img src="http://images.cy198706.com/Travel/IMG_1933.JPG"></p><p>**&uarr;**草原摩托。既然来了，就爽一把。看我媳妇，多霸气。</p><p><img src="http://images.cy198706.com/Travel/IMG_1938.JPG"></p><p>**&uarr;**我相对来说就比较弱了。。</p><p><img src="http://images.cy198706.com/Travel/IMG_1970.JPG"></p><p>**&uarr;**骑马的时候纠结了半天，媳妇跟她同事都不敢骑，我又特别想骑，但又不能两个人一起，我也不敢单独搂一小孩，所以最后就只有我上马了。</p><p>这马不听话，牵马人说你就扯缰绳，往左扯它就往左走，往右扯它就往右走，可是真上马了就是另一回事了。你往左扯一下，丫就直接回头了。你再往右扯，丫就直接开始扽缰绳，搞得我也胆小了，只能由着它的性子走。</p><p>最后不了了之。这玩意真想骑好，还是得练。</p><p><img src="http://images.cy198706.com/Travel/IMG_2004.JPG"></p><p>**&uarr;**小溪。其实水很脏。</p><p><img src="http://images.cy198706.com/Travel/IMG_2012.JPG"></p><p>**&uarr;**宁静的湖水。安静得让人大气不敢出。</p><p><img src="http://images.cy198706.com/Travel/IMG_2045.JPG"></p><p>**&uarr;**牵着媳妇的手，在草原的木桥上走。</p><p>晚上回去随便吃了点东西，农家院里有烤羊肉，烧烤，KTV啥的，累了一天，实在是没心情了。</p><p>第二天决定早起看日出。可是我们两个没方向感的白痴，加上一堆没方向感的白痴（不认识的游客），四点多爬起来，对着北方看了半小时，都没有太阳。后来掏出地图来一看，次奥，太阳要是能从这边出来，我就面壁去。</p><p><img src="http://images.cy198706.com/Travel/IMG_2058.JPG"></p><p>**&uarr;**马马虎虎拍了一张，清晨的北方。</p><p>&nbsp;</p><p>因为怕休息不够，再加上这种环境实在是让人闹心，所以第二天下午就决定返程了。</p><p>回到北京，下了一场暴雨。</p>]]></content>
      
      
      <categories>
          
          <category> 口水 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 旅行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分享壁纸</title>
      <link href="//pictures/%25e5%2588%2586%25e4%25ba%25ab%25e5%25a3%2581%25e7%25ba%25b8-2/"/>
      <url>//pictures/%25e5%2588%2586%25e4%25ba%25ab%25e5%25a3%2581%25e7%25ba%25b8-2/</url>
      
        <content type="html"><![CDATA[<p>好久不更，良心上过不去了。</p><p>但的确抽不出时间来更，只能先跟大家分享点好东西，最近也在酝酿一篇文，等码完了再放上来吧。</p><p>上几张壁纸来分享一下，有喜欢的，不用打招呼，直接带走。如果你想打包下载，请拖到最下方。</p><p><span style="color:#0000ff;">tip: 如果你是windows 7 / windows 8的话，把这些图片放到同一个文件夹内，然后全选，右键，设为壁纸，就能自动变换壁纸啦。</span></p><p>当然，如果你愿意桌面右键，个性化，桌面背景，然后再一起选择的话，我也没意见哦。</p><p style="text-align: center;">  <a href="http://images.cy198706.com/Mess-Ups/wallpaper-183872.jpg" target="_blank"><img alt="wallpaper-183872" src="http://images.cy198706.com/Mess-Ups/wallpaper-183872.jpg" style="width: 480px; height: 270px;" /></a></p><span id="more"></span><p style="text-align: center;">  <a href="http://images.cy198706.com/Mess-Ups/wallpaper-423394.jpg" target="_blank"><img alt="wallpaper-423394" src="http://images.cy198706.com/Mess-Ups/wallpaper-423394.jpg" style="width: 480px; height: 270px;" /></a></p><p style="text-align: center;">  <a href="http://images.cy198706.com/Mess-Ups/wallpaper-730201.jpg" target="_blank"><img alt="wallpaper-730201" src="http://images.cy198706.com/Mess-Ups/wallpaper-730201.jpg" style="width: 480px; height: 270px;" /></a></p><p style="text-align: center;">  <a href="http://images.cy198706.com/Mess-Ups/wallpaper-747480.jpg" target="_blank"><img alt="wallpaper-747480" src="http://images.cy198706.com/Mess-Ups/wallpaper-747480.jpg" style="width: 480px; height: 270px;" /></a></p><p style="text-align: center;">  <a href="http://images.cy198706.com/Mess-Ups/wallpaper-1066065.jpg" target="_blank"><img alt="wallpaper-1066065" src="http://images.cy198706.com/Mess-Ups/wallpaper-1066065.jpg" style="width: 480px; height: 270px;" /></a></p><p style="text-align: center;">  <a href="http://images.cy198706.com/Mess-Ups/wallpaper-1099271.jpg" target="_blank"><img alt="wallpaper-1099271" src="http://images.cy198706.com/Mess-Ups/wallpaper-1099271.jpg" style="width: 480px; height: 270px;" /></a></p><p style="text-align: center;">  <a href="http://images.cy198706.com/Mess-Ups/wallpaper-1104267.jpg" target="_blank"><img alt="wallpaper-1104267" src="http://images.cy198706.com/Mess-Ups/wallpaper-1104267.jpg" style="width: 480px; height: 270px;" /></a></p><p style="text-align: center;">  <a href="http://images.cy198706.com/Mess-Ups/wallpaper-1110754.jpg" target="_blank"><img alt="wallpaper-1110754" src="http://images.cy198706.com/Mess-Ups/wallpaper-1110754.jpg" style="width: 480px; height: 270px;" /></a></p><p style="text-align: center;">  <a href="http://images.cy198706.com/Mess-Ups/wallpaper-1111647.jpg" target="_blank"><img alt="wallpaper-1111647" src="http://images.cy198706.com/Mess-Ups/wallpaper-1111647.jpg" style="width: 480px; height: 270px;" /></a></p><p style="text-align: center;">  <a href="http://images.cy198706.com/Mess-Ups/wallpaper-1712661.jpg" target="_blank"><img alt="wallpaper-1712661" src="http://images.cy198706.com/Mess-Ups/wallpaper-1712661.jpg" style="width: 480px; height: 270px;" /></a></p><p style="text-align: center;">  <a href="http://images.cy198706.com/Mess-Ups/wallpaper-1878706.jpg" target="_blank"><img alt="wallpaper-1878706" src="http://images.cy198706.com/Mess-Ups/wallpaper-1878706.jpg" style="width: 480px; height: 270px;" /></a></p><p style="text-align: center;">  <a href="http://images.cy198706.com/Mess-Ups/wallpaper-2601560.jpg" target="_blank"><img alt="wallpaper-2601560" src="http://images.cy198706.com/Mess-Ups/wallpaper-2601560.jpg" style="width: 480px; height: 270px;" /></a></p><p style="text-align: center;">  <a href="http://images.cy198706.com/Mess-Ups/wallpaper-2610355.jpg" target="_blank"><img alt="wallpaper-2610355" src="http://images.cy198706.com/Mess-Ups/wallpaper-2610355.jpg" style="width: 480px; height: 270px;" /></a></p><p style="text-align: center;">  <a href="http://images.cy198706.com/Mess-Ups/wallpaper-2810681.jpg" target="_blank"><img alt="wallpaper-2810681" src="http://images.cy198706.com/Mess-Ups/wallpaper-2810681.jpg" style="width: 480px; height: 270px;" /></a></p><p style="text-align: center;">  <a href="http://images.cy198706.com/Mess-Ups/wallpaper-2811385.jpg" target="_blank"><img alt="wallpaper-2811385" src="http://images.cy198706.com/Mess-Ups/wallpaper-2811385.jpg" style="width: 480px; height: 270px;" /></a></p><p style="text-align: center;">  打包下载：<a href="http://pan.baidu.com/share/link?shareid=2180002455&uk=151049050"><img src="http://pan.baidu.com/res/static/images/yun_pan_logo.gif?@=-1" /></a></p>]]></content>
      
      
      <categories>
          
          <category> 视觉盛宴 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>帝都，你真的要赶我们走吗？</title>
      <link href="//gabby/%25e5%25b8%259d%25e9%2583%25bd%25ef%25bc%258c%25e4%25bd%25a0%25e7%259c%259f%25e7%259a%2584%25e8%25a6%2581%25e8%25b5%25b6%25e6%2588%2591%25e4%25bb%25ac%25e8%25b5%25b0%25e5%2590%2597%25ef%25bc%259f/"/>
      <url>//gabby/%25e5%25b8%259d%25e9%2583%25bd%25ef%25bc%258c%25e4%25bd%25a0%25e7%259c%259f%25e7%259a%2584%25e8%25a6%2581%25e8%25b5%25b6%25e6%2588%2591%25e4%25bb%25ac%25e8%25b5%25b0%25e5%2590%2597%25ef%25bc%259f/</url>
      
        <content type="html"><![CDATA[<p>这篇文章在发布之前，已经码了近千字，但是7月18号在网上看到一则消息，就删了好多，今儿又重新码了一些。</p><p>希望每个看这篇文章的朋友都读一下我写的东西，然后留下点见解。因为我迷茫了。</p><span id="more"></span><p>半个月之前吧，朋友打来电话，说他们在X松租的房子被派出所的警察给查了，然后就贴条说不允许再交房租。这就把他给愁坏了，现在找个便宜的能住的地方多不容易啊。</p><p>没想到18号居然就给曝光了。80平米的房子，住了25个人。我一直不知道我朋友住的地方有这么多人。只知道是上下铺，一个月700块。</p><p>他每个月的工资只有2000块多一点，交掉房租，还要交电费和水费和网费共150，也就是每月至少850块的固定支出，再加上吃饭和一些额外开支，每个月剩不了多少钱。</p><p>我也住过这种地方，但好歹大一点：140平米，24个人，平均每个人居然能分到将近6平米。每天早上排队洗漱、上厕所，就是一项工程。而且24个人真的是跟菜市场一样，难以入睡不说，到夏天的时候，屋子里的味道就跟厕所没什么两样。</p><p>现在帝都颁布一项规定：<a href="http://hb.people.com.cn/utf-8/n/2013/0719/c192237-19107665.html">传送门</a></p><blockquote><p>出租房屋人均居住面积不得低于5平方米，每个房间居住不能超过2人。不得将一间房间分割出租，不得按床位等方式变相分割出租。厨房、卫生间、阳台和地下储藏室不能让租房者居住。</p></blockquote><p>先不质疑面积和床位的问题，如果是一家三口的话，是不是就得拆开来住了？这是什么狗屁规定？</p><p>现在在帝都，一个普通单间至少要800 &ndash; 1000，而且各种费用也并不低，还有所谓的”中介费”，”管理费”，”保洁费”，这废那废的，如果月工资只有2000，那么每个月只能靠喝西北风过日子了，是真的喝西北风，不是开玩笑。</p><p>如果你能租到500块以下的单间，那我只能说，你那个肯定是地下室。</p><p>群租在帝都是常见得不能再常见的现象，是一种无奈，是一种被动，这种规定不仅没有人性，而且是典型的”站着说话不腰疼”。房价涨就涨吧，毕竟怎么涨咱买不起；房租涨就涨吧，毕竟也没涨太多；连租都不让租了，这是要赶我们走啊。</p><p style="text-align: center">  <img alt="" src="http://cy198706.com/blog/wp-content/uploads/2013/07/6812de56jw1e6qsild99rj20c808mgmz.jpg" /></p><p style="text-align: center">  <span style="font-size:10pt"><em>注：图片来源于互联网。互联网，自由、开放的，你的，我的，大家的。 </em></span></p><p>&nbsp;</p><p>码上面这段文字之前，我心里很纠结，因为我有那么几个瞬间，觉得帝都把外地人赶走是有道理的。</p><p>虽然我也是外地人，也知道这种想法特别遭恨，但亲身体验过一些事情，你也会有这种想法。</p><p>**我下面说的事情，不针对任何一个人，不针对任何一个地区，不针对任何一个国家。就事论事。 **</p><p>有个11路公交车，从国贸地铁站始发，是条比较火爆的线路。我有时候下班会去找媳妇，然后跟她一起从始发站坐车回家。在始发站，排队用的围栏就是个摆设，即便旁边有志愿者管理，也几乎没人排队。因为有一个人不排，就会有第二个人加入，有第三个人加入后，大家就都不排了。每次去坐车，我都会站在旁边，看他们挤破头，推来推去，各种辱骂，各种大打出手，就为了一个座。而且他们都不怕死，直接站在车道上拦车。</p><p>在地铁里，拥挤是家常便饭，因为拥挤发生口角甚至打架更是常有的事。车来了，就闷头往里挤，也不管车里有多少人要下车。大家都在排队，他直接就站在门口位置。</p><p>一人，拉着自己的宠物狗在外边遛，狗哪能跟人似的那么遵守规矩啊，一泡便便拉在马路中央，恰好被路人看见了。路人愤愤不平地让狗主把便便打扫掉，狗主反驳反正有小区保洁在，我哪有空弄这东西。于是两个人就开始吵。更多路人围观，散去，留下一泡便便，最后还是得保洁人员来清理。</p><p>当然，大多数很有素质，出门遛狗会带一个袋子，给狗打扫卫生，然后扔进垃圾箱。</p><p>到小区的花坛里仔细看看，你会发现，卫生纸、矿泉水瓶子、吃剩的饭、苹果核、穿旧的皮鞋、铁丝、租房小广告等各式各样的垃圾；路坑坑洼洼，只要下雨，就不敢走，怕一脚踩坑里；灰头土脸各式各样的人；夜晚在墙角随便撒尿的男人；地铁里乞讨的各种手段。。让人有点晕：确定这是帝都？确定这特么不是个三不管地带么？</p><p>我接触过一些帝都人，都很有素质，很遵守一些常识性的规定。甚至有些规定并不是规定，他们也会去方便别人。所处的环境不一样，人的成长历程不一样，就会导致素质的参差不齐。</p><p>现在，每天过得都得小心翼翼，太乱了，每天都在发生死人的事件。生怕碰见个疯子，在大悦城这种地方把你一刀捅死。无论什么地方，一旦天朝人多了，这地方就完了。联想起之前去坝上草原的经历，这种念头就更加肯定了。</p><p>&nbsp;</p><p>其实写到这儿，已经不是在说”应不应该赶走外地人”了，而是在说”你看看这些没素质的”。人各有志不能强求，天朝这么大，只要我是合法公民，我愿意待在哪就待在哪，凭什么赶我走。</p><p>眼下又要换房子了，因为我现在租的房子肯定还要涨。搬到哪去，是不是搬到类似的地方，真的不得而知。</p><p>有个人评论关于帝都禁止群租这种现象，说”吃得苦中苦方为人上人”，他说他以前住的地方是地下室，条件特别特别艰苦，这样才能锻炼自己的品格，磨炼自己的意志，blablabla。我现在想问你，如果连这种磨炼意志的机会都不给你了，请问你怎么办？</p>]]></content>
      
      
      <categories>
          
          <category> 口水 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 口水 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>唉，最近好累。</title>
      <link href="//gabby/%25e5%2594%2589%25ef%25bc%258c%25e6%259c%2580%25e8%25bf%2591%25e5%25a5%25bd%25e7%25b4%25af%25e3%2580%2582/"/>
      <url>//gabby/%25e5%2594%2589%25ef%25bc%258c%25e6%259c%2580%25e8%25bf%2591%25e5%25a5%25bd%25e7%25b4%25af%25e3%2580%2582/</url>
      
        <content type="html"><![CDATA[<p>嗯，没有内容。</p><img alt="" src="http://www.xylophonefilms.com/sites/default/files/tired-dog-wallpaper-free-picture_w520.jpg" style="width: 520px; height: 325px;" />]]></content>
      
      
      <categories>
          
          <category> 口水 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>看IT职员如何五年在北京买500万房子 &amp;#8211; 励志！</title>
      <link href="//gabby/%25e7%259c%258bit%25e8%2581%258c%25e5%2591%2598%25e5%25a6%2582%25e4%25bd%2595%25e4%25ba%2594%25e5%25b9%25b4%25e5%259c%25a8%25e5%258c%2597%25e4%25ba%25ac%25e4%25b9%25b0500%25e4%25b8%2587%25e6%2588%25bf%25e5%25ad%2590-%25e5%258a%25b1%25e5%25bf%2597%25ef%25bc%2581/"/>
      <url>//gabby/%25e7%259c%258bit%25e8%2581%258c%25e5%2591%2598%25e5%25a6%2582%25e4%25bd%2595%25e4%25ba%2594%25e5%25b9%25b4%25e5%259c%25a8%25e5%258c%2597%25e4%25ba%25ac%25e4%25b9%25b0500%25e4%25b8%2587%25e6%2588%25bf%25e5%25ad%2590-%25e5%258a%25b1%25e5%25bf%2597%25ef%25bc%2581/</url>
      
        <content type="html"><![CDATA[<div>  五年前，刚毕业的小柯，只有不知名大学的学历，求职时处处碰壁，最后在北京某间小IT公司上班担任小程序员。过了半年，小柯觉得这样下去不是办法，突然觉醒，决定订出一个五年买房计划，步步规划彻底执行！&nbsp;</div><div>  &nbsp;&nbsp;</div><div>  &ldquo;刚开始真的很痛苦，什么交际应酬与娱乐消费都不能做了&rdquo;小柯回忆道。但是回想起自己过去的人生，其实也这样浑浑噩噩，突然有一股声音在自己体内觉醒，&ldquo;我开始利用下班时间去上财务规划课程与程序课程，增加自己的实力。&rdquo;利用网络上大大小小免费的资源，小柯发现自己过去学生生涯实在浪费了很多时间。&nbsp;</div><div>  &nbsp;</div><div>  &ldquo;刚开始会觉得很懊悔自己过去到底在干嘛，所以现在有机会反而更努力，加强冲刺。&rdquo;就这样，小柯利用通过大大小小的IT技能检定考试，让公司逐年帮他加薪3%。&nbsp;</div><div>  &ldquo;除了薪水成长还不够，我还去报名了许多管理课程，认识许多业界杰出人士。&rdquo;透过这样的交流，小柯逐步建立起自己的人脉。&nbsp;</div><div>  &ldquo;光靠死薪水肯定是不行的，我还充分利用业余时间，打一些零工，让自己明白钱来之不易。&rdquo;通过打零工，小柯也逐渐有了一些其他行业的宝贵经验。 &nbsp;</div><span id="more"></span><div>  &nbsp;</div><div>  最后，靠着这五年来累积的五万，再加上父母给的495万，小柯买下人生第一栋房子，而且是在北京市三环区域。&nbsp;</div><div>  &ldquo;有梦最美，筑梦踏实。&rdquo;小柯眼神坚毅地说着。</div><div>  &nbsp;</div>]]></content>
      
      
      <categories>
          
          <category> 口水 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 口水 </tag>
            
            <tag> 人生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>今天是1024节。</title>
      <link href="//gabby/%25e4%25bb%258a%25e5%25a4%25a9%25e6%2598%25af1024%25e8%258a%2582%25e3%2580%2582/"/>
      <url>//gabby/%25e4%25bb%258a%25e5%25a4%25a9%25e6%2598%25af1024%25e8%258a%2582%25e3%2580%2582/</url>
      
        <content type="html"><![CDATA[<p>有好多人说今天是个节日，我第一反映是1024，程序员的节日嘛。</p><p>后来才恍然大悟，1024啊。。</p><p>怎么也得纪念下。</p><p>得忙到年底了，现在晚上回去撸代码，周六加班，周日在家猛睡，虽然感觉很充实，但是累得要命。</p><p>wp上的app暂停维护，博客长草，朋友们那儿也都好久没逛逛了。基本算是脱节了。。</p><p>&nbsp;</p><p>等忙完吧，忙完了就有时间折腾了。</p><p>&nbsp;</p><p>主题换回来，这个绿色的主题看着真心难受。</p>]]></content>
      
      
      <categories>
          
          <category> 口水 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>每日一图 &amp;#8211; 20140820</title>
      <link href="//pictures/%25e6%25af%258f%25e6%2597%25a5%25e4%25b8%2580%25e5%259b%25be-20140811/"/>
      <url>//pictures/%25e6%25af%258f%25e6%2597%25a5%25e4%25b8%2580%25e5%259b%25be-20140811/</url>
      
        <content type="html"><![CDATA[<p>呃，想了很久，还是打算搞这么一套。一来可以偷懒，二来可以练习拍照，三来可以保持更新。</p><p><img src="http://serious.qiniudn.com/WP_20140804_19_03_13_Pro.jpg"></p><p>&nbsp;</p><p>拍摄于北京四惠公交枢纽站天桥。Lumia920，稍有晃动，噪点略多，请无视。</p>]]></content>
      
      
      <categories>
          
          <category> 视觉盛宴 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一图 – 20140821</title>
      <link href="//pictures/%25e6%25af%258f%25e6%2597%25a5%25e4%25b8%2580%25e5%259b%25be-20140821/"/>
      <url>//pictures/%25e6%25af%258f%25e6%2597%25a5%25e4%25b8%2580%25e5%259b%25be-20140821/</url>
      
        <content type="html"><![CDATA[<img src="http://serious.qiniudn.com/@/pic-a-day/2014-8-21-1.JPG" width="1280" height="853" class="alignnone" /><p><em>Canon EOS 60D f/5.6 1/80 100</em></p><p>拍摄于慕峪关 &#8211; 梦石城</p>]]></content>
      
      
      <categories>
          
          <category> 视觉盛宴 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的2014</title>
      <link href="//gabby/my-2014/"/>
      <url>//gabby/my-2014/</url>
      
        <content type="html"><![CDATA[<p>博客很久很久没有更新了，之前想搞个每日一图，也没坚持下来。从2015年开始吧，任性一点，每周都来个图啥的，能自己拍就自己拍，不为别的，只为坚持。说为啥不是每天都来个图？哪有那么多好图发。。也是要筛选的嘛。<br>一件小事坚持下来，就是一件大事。</p><p>2014年发生了很多事情。至少在我身上发生了很多事情。</p><p>首先要恭喜我变成了房奴。结婚之后，这应该是第一件大事了。因为房子的事情，搞得我跟媳妇在计划生育的问题上十分重视，如果有了小陈，就意味着家中财政一定会吃紧。<br>然后恭喜我换了工作。LBE安全大师，很不错很不错的地方。我从很久之前就开始用了，也几乎是逢人必推，看起来也给公司增加了不少客户的说。。<br>最后恭喜我有了目标。我觉得现在的目标很简单了，好好挣钱，养家糊口。这在几年前我是说不出这种话的，现在看来，这个目标很现实，也很温馨。</p><p>2013年年终总结未写，让我来照着2012年年终总结的风格来码字吧～（其实2013年年底开始到现在都没几篇文章，我真厉（zuo）害（si））  </p><span id="more"></span><h2 style="text-align: center;">  <span style="color:#ffa500;">酸</span></h2><p style="text-align: center;">  <strong>&#8212; 倒牙</strong></p><p>说起来今年买房这事，心中五味杂沉。<br>想要买房是结婚前的事，我俩基本是裸婚的，也很心照不宣地没有在结婚前提买房子的事情。真正开始行动就是今年五一了。<br>我妈帮我看好了一个地段，很不错，现在看起来有些荒凉，但过几年就是核心地段，离我们区政府很近。想到以后的升值空间，我们俩去看了两次，也没啥犹豫，直接就签了认购书。好在我妈跟这房地产商的把兄弟是亲戚关系（绕吗？绕吗？），优惠政策也还是有的，至少在很多事情上，也放了一份心。<br>于是漫长的拉锯战就开始了。<br>利率的问题、银行的选择、国家的政策、市的政策、每家银行的政策。。每有点风吹艹动，我俩都如惊弓之鸟般地商量对策，不为别的，还不是为了省那俩钱。<br>房子还不只是房子，地下室是捆绑销售的，但尼玛要单独算钱，不能算在贷款里。车位是要单独买的，不买以后就涨钱，一涨就是几万软妹币。地上停车位不敢买，谁知道哪天就给你划坏了。贷款是必须要走担保公司的，20年算下来要近一万软妹币。维修基金、地税、契税。。。<br>我真的学到了不少东西，但回过头来，心里还是酸涩的。人生活在这个世界上，只想有个遮风避雨的港湾，但这港湾真是来之不易。再想想买房中间的诸事，又不知道国家拿走了我多少钱，不免有些倒牙。</p><h2 style="text-align: center;">  <span style="color:#0000ff;">甜</span></h2><p style="text-align: center;">  <strong>&#8212; 糖心的</strong></p><p>去年10月2号，我们结婚了。婚后生活虽然跟之前没有太大的区别，但是很幸福，很甜蜜。朋友们都祝福我们，家里人也都很开心，看好我们的未来。<br>今年我们努力地为打造自己的生活努力着，虽然很累，忍受了一些平日不能忍受之苦，但是心里很甜。想想我们为生活的投入，看着一点点的成绩，我们觉得是值得的。<br>好像也吵过几次架，都是些些鸡毛蒜皮的小事，夫妻哪有不吵架的嘛，床头吵架床尾合嘛。现在想想，觉得也是种回忆嘛。<br>年底之前，做了个大决定，准备换工作。这份工作要说起来，还真是巧合，也是个机会。<br>在群里看见LBE的招聘信息，我就跟HR聊了起来，发现工资比我现在的要多，离家也非常近（出门+坐车+到公司=30分钟），也是我敬仰的公司，还有什么理由不去呢？<br>于是一不做二不休就去面试了=。=<br>老张说我走得太早，有的人我说作死，有的人说赶紧走吧这机会不好找。。最后还是决定听从自己内心的选择，就跟原来的公司说再见了。<br>之前一直不了解，为什么总有高管之类的从巨头公司离职呢？现在看明白了，大公司是给别人看的，内部有多乱，只有身临其境的人才知道。<br>半个月了，我过得很开心。公司有很多大牛，可以从他们那儿学到东西，令我很期待。</p><h2 style="text-align: center;">  <span style="color:#008000;">苦</span></h2><p style="text-align: center;">  <strong>&#8212; 隐隐作痛</strong></p><p>大约8月份的时候，我妈瞒着我去做了个手术。肾囊肿+肾积水，貌似已经到了不动刀不行的地步了。起初我妈是想把我俩都瞒过去的，但纸包不住火，这事还是让我知道了。<br>我责备了她。儿子不在身边不能尽孝，发生这么大的事，居然还要瞒着我。但我也理解她，报喜不报忧，她怕我们担心。<br>媳妇也很着急，我们赶紧买了第二天早上的票赶回家，所幸已经没什么事情了。但是看到我妈憔悴的身形，心里非常难受。但还是要故作坚强。<br>最近病情似乎有些反复，准备过完年再去趟。<br>随着年龄的增加，想的事情越来复杂，但一个念头越来越坚定，就是希望家里人都健健康康的，我们在外面也能放心打拼，毕竟就算我什么都没有了，至少还有家。</p><h2 style="text-align: center;">  <span style="color:#b22222;">辣</span></h2><p style="text-align: center;">  <strong>&#8212; 任性</strong></p><p>我决定这个部分不写了。因为似乎没有什么事情能称得上辣的。</p><p>2015年要来了，日子也要继续下去，新年的愿望是顺顺利利地走下去。</p>]]></content>
      
      
      <categories>
          
          <category> 口水 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 口水 </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>真实事件</title>
      <link href="//gabby/%25e7%259c%259f%25e5%25ae%259e%25e4%25ba%258b%25e4%25bb%25b6/"/>
      <url>//gabby/%25e7%259c%259f%25e5%25ae%259e%25e4%25ba%258b%25e4%25bb%25b6/</url>
      
        <content type="html"><![CDATA[<p>早上，接到一个陌生来电。  </p><span id="more"></span><p>“您好，您好，我这里是XXX金融公司，专业理财，零风险，低投入，高回报。您好，请问您对理财有什么想法吗？”</p><p>“哦，理财啊，啥叫理财？”<br>“哦，先生您好，您是不知道理财的意思吗？”</p><p>“嗯，你给具体讲讲呗。”<br>“好的先生。您好，是这样的，通俗地讲，理财就是把您的钱给我们，然后过一段时间，就能给您更多的钱了。”</p><p>“哦，那为什么要给你们呢？你们是怎么变成更多的钱的呢？”<br>“先生您好，是这样的，这部分比较复杂，我可能跟您说了您也听不明白。”</p><p>“哦，没关系，你说说吧，我听听看，说不定弄明白了一有兴趣，我就理一个呢？”<br>“那您好先生，我给您举个栗子。您要是去银行存钱，是不是会有利息呢？”</p><p>“是么？我去银行存钱也没给我过利息啊？”<br>“哦您好先生，请问您存了多少钱呢？”</p><p>“200多？我忘记了。”<br>“。。。。。。哦，那您好先生，您存的是定期呢？还是活期呢？”</p><p>“不知道啊，什么是定期？什么是活期？你给讲讲呗？”<br>“您好先生，定期就是您跟银行约定好日期去取钱，活期就是您随时可以去取。”</p><p>“哦，那我不知道啊，我存上之后就没再动过那部分钱了。”<br>“您好先生，您没去银行看看吗？”</p><p>“哦，那不是我的卡。”<br>“。。。。。。您好先生，那卡的主人有没有去看过呢？”</p><p>“哦，他密码忘记了。”<br>“您好先生，密码忘记是可以重置的。”</p><p>“哦？还能重置？怎么重置？你给讲讲呗？”<br>“您好先生，只要带上您的身份证去银行柜台办理密码重置业务就行了。”</p><p>“哦？他的卡还能带我的身份证呢？”<br>“不是，您好先生，他的卡需要带他的身份证才行。”</p><p>“哦，那重置了之后呢？”<br>“您好先生，重置了之后就可以看余额了，就能知道您的利息有多少了。”</p><p>“哦，有什么用呢？”<br>“。。。。。。您好先生，这样您就知道存钱是会有的利息的了。”</p><p>“哦，有什么用呢？”<br>“您好先生，我们的理财原理跟银行利息相同。”</p><p>“哦，那我干嘛不把钱存银行呢？”<br>“。。。。。。您好先生，我们的理财利息要比银行高一些，一段时间之后您能得到更多的收益。”</p><p>“哦，多多少？”<br>“您好先生，这个不好给您计算，跟您要存入的金额有关。”</p><p>“哦，那我要存100，你们能给我多少钱？能到1万不？”<br>“您好先生，没有那么高的利息。而且我们——”</p><p>“哦，那我要存200呢？”<br>“您好先生，是这样的，我们的理财10万起存。”</p><p>“哦，10万啊，那还不错。怎么存啊？”<br>“您好，您好先生，是这样的，我们可以有多种途径存款，直接打款，支付宝，到我们公司的柜台办理都可以。您要存多少？”</p><p>“哦？支付宝也能打款？”<br>“是的，先生您好，支付宝是有转账功能的，我们会给您一个账号，您直接打钱过来就好了。”</p><p>“哦，怎么转账，你给讲讲呗？”<br>“您好先生，您有支付宝的账号吗？”</p><p>“没有。”<br>“您好先生，您需要先注册一个支付宝的账号。”</p><p>“怎么注册？你给讲讲呗？”<br>“。。。。。。您身边有电脑吗？”</p><p>“有电脑，但是开不了机了。”<br>“您身边没有其他电脑吗？”</p><p>“没有，就这一台。开机黑屏，上面有两行小字，我也看不懂，我给你念念，你帮我看看怎么回事呗？”<br>“您好先生，我对修电脑——”</p><p>“歪哦优啊空格塞哦挨姆屁——”<br>“您好先生，我——”</p><p>“优踢易啊——”<br>“先生，您好先生，我真的不会修电脑！”</p><p>“哦，你不会啊，那就没法注册支付宝账号了。”<br>“没关系，您好先生，您可以去银行打款给我们。”</p><p>“去银行？怎么打？您给讲讲呗？”<br>“您好先生，您可以去任意一家银行，存入10万或更多的现金，然后——”</p><p>“怎么弄那么多钱？你给讲讲呗？”<br>“嘟——嘟——嘟——”</p>]]></content>
      
      
      <categories>
          
          <category> 口水 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 口水 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>真实事件</title>
      <link href="/2015-03-25/a-call/"/>
      <url>/2015-03-25/a-call/</url>
      
        <content type="html"><![CDATA[<p>早上，接到一个陌生来电。  </p><span id="more"></span><p>“您好，您好，我这里是XXX金融公司，专业理财，零风险，低投入，高回报。您好，请问您对理财有什么想法吗？”</p><p>“哦，理财啊，啥叫理财？”<br>“哦，先生您好，您是不知道理财的意思吗？”</p><p>“嗯，你给具体讲讲呗。”<br>“好的先生。您好，是这样的，通俗地讲，理财就是把您的钱给我们，然后过一段时间，就能给您更多的钱了。”</p><p>“哦，那为什么要给你们呢？你们是怎么变成更多的钱的呢？”<br>“先生您好，是这样的，这部分比较复杂，我可能跟您说了您也听不明白。”</p><p>“哦，没关系，你说说吧，我听听看，说不定弄明白了一有兴趣，我就理一个呢？”<br>“那您好先生，我给您举个栗子。您要是去银行存钱，是不是会有利息呢？”</p><p>“是么？我去银行存钱也没给我过利息啊？”<br>“哦您好先生，请问您存了多少钱呢？”</p><p>“200多？我忘记了。”<br>“。。。。。。哦，那您好先生，您存的是定期呢？还是活期呢？”</p><p>“不知道啊，什么是定期？什么是活期？你给讲讲呗？”<br>“您好先生，定期就是您跟银行约定好日期去取钱，活期就是您随时可以去取。”</p><p>“哦，那我不知道啊，我存上之后就没再动过那部分钱了。”<br>“您好先生，您没去银行看看吗？”</p><p>“哦，那不是我的卡。”<br>“。。。。。。您好先生，那卡的主人有没有去看过呢？”</p><p>“哦，他密码忘记了。”<br>“您好先生，密码忘记是可以重置的。”</p><p>“哦？还能重置？怎么重置？你给讲讲呗？”<br>“您好先生，只要带上您的身份证去银行柜台办理密码重置业务就行了。”</p><p>“哦？他的卡还能带我的身份证呢？”<br>“不是，您好先生，他的卡需要带他的身份证才行。”</p><p>“哦，那重置了之后呢？”<br>“您好先生，重置了之后就可以看余额了，就能知道您的利息有多少了。”</p><p>“哦，有什么用呢？”<br>“。。。。。。您好先生，这样您就知道存钱是会有的利息的了。”</p><p>“哦，有什么用呢？”<br>“您好先生，我们的理财原理跟银行利息相同。”</p><p>“哦，那我干嘛不把钱存银行呢？”<br>“。。。。。。您好先生，我们的理财利息要比银行高一些，一段时间之后您能得到更多的收益。”</p><p>“哦，多多少？”<br>“您好先生，这个不好给您计算，跟您要存入的金额有关。”</p><p>“哦，那我要存100，你们能给我多少钱？能到1万不？”<br>“您好先生，没有那么高的利息。而且我们——”</p><p>“哦，那我要存200呢？”<br>“您好先生，是这样的，我们的理财10万起存。”</p><p>“哦，10万啊，那还不错。怎么存啊？”<br>“您好，您好先生，是这样的，我们可以有多种途径存款，直接打款，支付宝，到我们公司的柜台办理都可以。您要存多少？”</p><p>“哦？支付宝也能打款？”<br>“是的，先生您好，支付宝是有转账功能的，我们会给您一个账号，您直接打钱过来就好了。”</p><p>“哦，怎么转账，你给讲讲呗？”<br>“您好先生，您有支付宝的账号吗？”</p><p>“没有。”<br>“您好先生，您需要先注册一个支付宝的账号。”</p><p>“怎么注册？你给讲讲呗？”<br>“。。。。。。您身边有电脑吗？”</p><p>“有电脑，但是开不了机了。”<br>“您身边没有其他电脑吗？”</p><p>“没有，就这一台。开机黑屏，上面有两行小字，我也看不懂，我给你念念，你帮我看看怎么回事呗？”<br>“您好先生，我对修电脑——”</p><p>“歪哦优啊空格塞哦挨姆屁——”<br>“您好先生，我——”</p><p>“优踢易啊——”<br>“先生，您好先生，我真的不会修电脑！”</p><p>“哦，你不会啊，那就没法注册支付宝账号了。”<br>“没关系，您好先生，您可以去银行打款给我们。”</p><p>“去银行？怎么打？你给讲讲呗？”<br>“您好先生，您可以去任意一家银行，存入10万或更多的现金，然后——”</p><p>“怎么弄那么多钱？你给讲讲呗？”<br>“嘟——嘟——嘟——”</p>]]></content>
      
      
      <categories>
          
          <category> 口水 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 口水 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的2014</title>
      <link href="/2014-12-31/my-2014/"/>
      <url>/2014-12-31/my-2014/</url>
      
        <content type="html"><![CDATA[<p>博客很久很久没有更新了，之前想搞个每日一图，也没坚持下来。从2015年开始吧，任性一点，每周都来个图啥的，能自己拍就自己拍，不为别的，只为坚持。说为啥不是每天都来个图？哪有那么多好图发。。也是要筛选的嘛。<br>一件小事坚持下来，就是一件大事。</p><p>2014年发生了很多事情。至少在我身上发生了很多事情。</p><p>首先要恭喜我变成了房奴。结婚之后，这应该是第一件大事了。因为房子的事情，搞得我跟媳妇在计划生育的问题上十分重视，如果有了小陈，就意味着家中财政一定会吃紧。<br>然后恭喜我换了工作。LBE安全大师，很不错很不错的地方。我从很久之前就开始用了，也几乎是逢人必推，看起来也给公司增加了不少客户的说。。<br>最后恭喜我有了目标。我觉得现在的目标很简单了，好好挣钱，养家糊口。这在几年前我是说不出这种话的，现在看来，这个目标很现实，也很温馨。</p><p>2013年年终总结未写，让我来照着2012年年终总结的风格来码字吧～（其实2013年年底开始到现在都没几篇文章，我真厉（zuo）害（si））  </p><span id="more"></span><h2 style="text-align: center;">  <span style="color:#ffa500;">酸</span></h2><p style="text-align: center;">  <strong>&#8212; 倒牙</strong></p><p>说起来今年买房这事，心中五味杂沉。<br>想要买房是结婚前的事，我俩基本是裸婚的，也很心照不宣地没有在结婚前提买房子的事情。真正开始行动就是今年五一了。<br>我妈帮我看好了一个地段，很不错，现在看起来有些荒凉，但过几年就是核心地段，离我们区政府很近。想到以后的升值空间，我们俩去看了两次，也没啥犹豫，直接就签了认购书。好在我妈跟这房地产商的把兄弟是亲戚关系（绕吗？绕吗？），优惠政策也还是有的，至少在很多事情上，也放了一份心。<br>于是漫长的拉锯战就开始了。<br>利率的问题、银行的选择、国家的政策、市的政策、每家银行的政策。。每有点风吹艹动，我俩都如惊弓之鸟般地商量对策，不为别的，还不是为了省那俩钱。<br>房子还不只是房子，地下室是捆绑销售的，但尼玛要单独算钱，不能算在贷款里。车位是要单独买的，不买以后就涨钱，一涨就是几万软妹币。地上停车位不敢买，谁知道哪天就给你划坏了。贷款是必须要走担保公司的，20年算下来要近一万软妹币。维修基金、地税、契税。。。<br>我真的学到了不少东西，但回过头来，心里还是酸涩的。人生活在这个世界上，只想有个遮风避雨的港湾，但这港湾真是来之不易。再想想买房中间的诸事，又不知道国家拿走了我多少钱，不免有些倒牙。</p><h2 style="text-align: center;">  <span style="color:#0000ff;">甜</span></h2><p style="text-align: center;">  <strong>&#8212; 糖心的</strong></p><p>去年10月2号，我们结婚了。婚后生活虽然跟之前没有太大的区别，但是很幸福，很甜蜜。朋友们都祝福我们，家里人也都很开心，看好我们的未来。<br>今年我们努力地为打造自己的生活努力着，虽然很累，忍受了一些平日不能忍受之苦，但是心里很甜。想想我们为生活的投入，看着一点点的成绩，我们觉得是值得的。<br>好像也吵过几次架，都是些些鸡毛蒜皮的小事，夫妻哪有不吵架的嘛，床头吵架床尾合嘛。现在想想，觉得也是种回忆嘛。<br>年底之前，做了个大决定，准备换工作。这份工作要说起来，还真是巧合，也是个机会。<br>在群里看见LBE的招聘信息，我就跟HR聊了起来，发现工资比我现在的要多，离家也非常近（出门+坐车+到公司=30分钟），也是我敬仰的公司，还有什么理由不去呢？<br>于是一不做二不休就去面试了=。=<br>老张说我走得太早，有的人我说作死，有的人说赶紧走吧这机会不好找。。最后还是决定听从自己内心的选择，就跟原来的公司说再见了。<br>之前一直不了解，为什么总有高管之类的从巨头公司离职呢？现在看明白了，大公司是给别人看的，内部有多乱，只有身临其境的人才知道。<br>半个月了，我过得很开心。公司有很多大牛，可以从他们那儿学到东西，令我很期待。</p><h2 style="text-align: center;">  <span style="color:#008000;">苦</span></h2><p style="text-align: center;">  <strong>&#8212; 隐隐作痛</strong></p><p>大约8月份的时候，我妈瞒着我去做了个手术。肾囊肿+肾积水，貌似已经到了不动刀不行的地步了。起初我妈是想把我俩都瞒过去的，但纸包不住火，这事还是让我知道了。<br>我责备了她。儿子不在身边不能尽孝，发生这么大的事，居然还要瞒着我。但我也理解她，报喜不报忧，她怕我们担心。<br>媳妇也很着急，我们赶紧买了第二天早上的票赶回家，所幸已经没什么事情了。但是看到我妈憔悴的身形，心里非常难受。但还是要故作坚强。<br>最近病情似乎有些反复，准备过完年再去趟。<br>随着年龄的增加，想的事情越来复杂，但一个念头越来越坚定，就是希望家里人都健健康康的，我们在外面也能放心打拼，毕竟就算我什么都没有了，至少还有家。</p><h2 style="text-align: center;">  <span style="color:#b22222;">辣</span></h2><p style="text-align: center;">  <strong>&#8212; 任性</strong></p><p>我决定这个部分不写了。因为似乎没有什么事情能称得上辣的。</p><p>2015年要来了，日子也要继续下去，新年的愿望是顺顺利利地走下去。</p>]]></content>
      
      
      <categories>
          
          <category> 口水 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 口水 </tag>
            
            <tag> 年终总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用gdb调试程序</title>
      <link href="/2013-04-17/gdb-debugging/"/>
      <url>/2013-04-17/gdb-debugging/</url>
      
        <content type="html"><![CDATA[<p>这篇文章来讲讲Linux下强大的调试工具–gdb。</p><span id="more"></span><h3 id="一、gdb常用的命令："><a href="#一、gdb常用的命令：" class="headerlink" title="一、gdb常用的命令："></a>一、gdb常用的命令：</h3><p>跟在Windows下使用Visual Studio进行调试一样，gdb的调试功能与其大同小异。</p><div class="centered"><table border="1" cellpadding="1" cellspacing="1">    <tbody>        <tr>            <td>命令</td>            <td>功能</td>            <td>快捷方式</td>        </tr>        <tr>            <td>file</td>            <td>加载需要调试的可执行文件</td>            <td>file</td>        </tr>        <tr>            <td>kill</td>            <td>终止正在调试的程序</td>            <td>k</td>        </tr>        <tr>            <td>list</td>            <td>列出源代码的一部分</td>            <td>l</td>        </tr>        <tr>            <td>info</td>            <td>列出某个项目的信息</td>            <td>i</td>        </tr>        <tr>            <td>next</td>            <td>执行一行代码（不进入函数内部）</td>            <td>n</td>        </tr>        <tr>            <td>step</td>            <td>执行下一行代码</td>            <td>s</td>        </tr>        <tr>            <td>continue</td>            <td>继续运行程序，直到下一个断点</td>            <td>c</td>        </tr>        <tr>            <td>run</td>            <td>执行已经加载的程序</td>            <td>r</td>        </tr>        <tr>            <td>quit</td>            <td>终止gdb</td>            <td>q</td>        </tr>        <tr>            <td>watch</td>            <td>监视某个变量的值</td>            <td>w</td>        </tr>        <tr>            <td>examine</td>            <td>监视某个变量的值</td>            <td>x</td>        </tr>        <tr>            <td>break</td>            <td>设置断点</td>            <td>b</td>        </tr>        <tr>            <td>disable / enable</td>            <td>使断点无效/有效</td>            <td>disable/enable</td>        </tr>        <tr>            <td>delete</td>            <td>删除断点</td>            <td>d</td>        </tr>        <tr>            <td>make</td>            <td>在不退出gdb的情况下，重新生成可执行文件</td>            <td>make</td>        </tr>        <tr>            <td>shell</td>            <td>在不退出gdb的情况下，使用shell命令</td>            <td>shell</td>        </tr>    </tbody></table></div><p>这只是一部分哦。关于整个gdb调试可以写成一本书呢。</p><p>看到全称不要紧张，毕竟还是有些对英文不太感冒的同学，在gdb下按Tab，gdb也会帮你自动补全，避免误输入。而且按上下键也可以翻看历史命令。（这样不是个办法，还是好好学英语吧╮（╯＿╰）╭）</p><p>还有一个办法，是使用简化的命令。这个方法我还是相当喜欢的。不过还是建议初学者使用全称，因为只使用首字母有时候会产生歧义，比如<strong>disable</strong>和<strong>delete</strong>，gdb在你输入<strong>d</strong>时，会默认调用<strong>delete</strong>，如果你想禁用某个断点，却输入了<strong>d 5</strong>，那这个断点就会被删除了。</p><p>当然，熟悉了之后，还是使用快捷命令吧，会提高很多的效率。</p><h3 id="二、编写测试程序"><a href="#二、编写测试程序" class="headerlink" title="二、编写测试程序"></a>二、编写测试程序</h3><p>因为要调试，偶要写一个有点BUG的程序，以方便调试，希望同学们不要学习我这种自残的行为。 </p><pre><code class="c">[serious@localhost c]$ vim gdbtest.c[serious@localhost c]$ cat gdbtest.c #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;string.h&amp;gt; void reverse(char* string) &#123;     int nLength = strlen(string);     char* temp = (char*)malloc(nLength + 1);      for(int i = 0; i &lt; nLength; i++)     &#123;         temp[i] = string[nLength - i];     &#125;          strcpy(string, temp);         free(temp);&#125;      int main(int argc, char** argv) &#123;     char * str = malloc(20);     memset(str, 0, 20);     strcpy(str, &quot;hello world!&quot;);      reverse(str);      printf(&quot;%s\n&quot;, str);      free(str);    return 0; &#125;</code></pre><p>编译之：</p><pre><code class="bash">[serious@localhost c]$gcc -g -o gdbtest gdbtest.c -std=c99  //添加-g选项以产生调试信息 </code></pre><p>这个程序的用意是将一个字符串给逆序化。请无视渣算法，一切为了调试。</p><p>运行看看我们的程序：  </p><pre><code class="bash">[serious@localhost c]$ ./gdbtest[serious@localhost c]$  </code></pre><p>咦？为什么没有输出呢？<br>那就来调试一下。</p><h3 id="三、调试程序"><a href="#三、调试程序" class="headerlink" title="三、调试程序"></a>三、调试程序</h3><p>因为刚才我们在编译程序时，已经加上了-g选项，就可以直接使用gdb进行调试了。</p><pre><code class="bash">[serious@localhost c]$ gdb gdbtest GNU gdb (GDB) 7.5 Copyright (C) 2012 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt; This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot; and &quot;show warranty&quot; for details. This GDB was configured as &quot;x86_64-unknown-linux-gnu&quot;. For bug reporting instructions, please see: &lt;http://www.gnu.org/software/gdb/bugs/&gt;... Reading symbols from /home/serious/Desktop/c/gdbtest...done. (gdb) //这里就可以开始输入命令进行调试了</code></pre><p>首先列出程序的内容（当然，你也可以另开一个终端界面使用vim的set nu功能显示行号）</p><pre><code class="bash">(gdb) list 1 #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;string.h&amp;gt; void reverse(char* string) &#123;     int nLength = strlen(string);     char * temp = (char*)malloc(nLength);     for(int i = 0; i &lt; nLength; i++) </code></pre><p>list命令会一次性列出10行源代码，list后面加上1是确保可以从第一行开始显示源代码。</p><p>后面的就不列出了。我们在几个关键的位置加上断点：</p><pre><code class="bash">(gdb) break 7 Breakpoint 1 at 0x4006ac: file gdbtest.c, line 7. (gdb) break 12 Breakpoint 2 at 0x4006d5: file gdbtest.c, line 12. (gdb) b 15 Breakpoint 3 at 0x400707: file gdbtest.c, line 15. (gdb) b 27 Breakpoint 4 at 0x400777: file gdbtest.c, line 27. (gdb) b 29 Breakpoint 5 at 0x400783: file gdbtest.c, line 29. </code></pre><p>然后看看我们所设置的断点：</p><pre><code class="bash">(gdb) info break Num     Type           Disp Enb Address            What 1       breakpoint     keep y   0x00000000004006ac in reverse at gdbtest.c:7 2       breakpoint     keep y   0x00000000004006d5 in reverse at gdbtest.c:12 3       breakpoint     keep y   0x0000000000400707 in reverse at gdbtest.c:15 4       breakpoint     keep y   0x0000000000400777 in main at gdbtest.c:27 5       breakpoint     keep y   0x0000000000400783 in main at gdbtest.c:29 </code></pre><ul><li><p>Num代表断点的序号，如果我们想要禁用某个断点，可以使用<strong>disable n</strong>命令；如果想要删除，则使用<strong>delete n</strong>命令。如果要全部禁用（或删除），则不需要带n。</p></li><li><p>Type代表断点的类型。有<strong>breakpoint</strong>, <strong>watchpoint</strong>和<strong>catchpoint</strong>三种类型。</p><ul><li><p>breakpoint: 就是传说中的断点啦。</p></li><li><p>watchpoint: 监控变量（或表达式）</p></li><li><p>catchpoint: 监控事件。</p></li></ul></li><li><p>Disp代表当走到当前断点时，如果此断点已被禁用，是否要显示该信息。</p></li><li><p>Enb是断点当前是否是启用的。启用为y，禁用为n。</p></li><li><p>Address是断点的地址。每一个断点也是有分配相应的内存的。</p></li><li><p>What是断点的详细信息，包括所在的函数名及所在源代码行数。</p></li></ul><p>开始调试：</p><pre><code class="bash">(gdb) run             // 运行程序Starting program: /home/serious/Desktop/c/gdbtestBreakpoint 4, main (argc=1, argv=0x7fffffffe1a8) at gdbtest.c:27 27      reverse(str); (gdb) continue        // 继续运行程序直到下一个断点Continuing. Breakpoint 1, reverse (string=0x601010 &quot;hello world!&quot;) at gdbtest.c:7 7       int nLength = strlen(string); (gdb) next            // 执行一行代码8       char * temp = (char*)malloc(nLength); (gdb) print nLength   // 查看nLength的值$10 = 12              // 长度是正确的(gdb) next 10      for(int i = 0; i &lt; nLength; i++) (gdb) next Breakpoint 2, reverse (string=0x601010 &quot;hello world!&quot;) at gdbtest.c:12 12          temp[i] = string[nLength - i]; (gdb) next 10      for(int i = 0; i &lt; nLength; i++) (gdb) next Breakpoint 2, reverse (string=0x601010 &quot;hello world!&quot;) at gdbtest.c:12 12          temp[i] = string[nLength - i]; (gdb) print temp      // 查看temp的值$11 = 0x601030 &quot;&quot; (gdb) continueContinuing. Breakpoint 2, reverse (string=0x601010 &quot;hello world!&quot;) at gdbtest.c:12 12          temp[i] = string[nLength - i]; (gdb) print temp $12 = 0x601030 &quot;&quot;     // 已经发现问题了，连续赋值两次，temp却一直是&quot;&quot;(gdb)</code></pre><p>程序的BUG在于，string[nLength - i]的值是’\0’，如果赋给temp[0]，则字符串temp的确就变成了””。</p><p>我们可以使用<strong>examine</strong>命令查看一下temp所在的内存区域：</p><pre><code class="bash">(gdb) examine/12ub temp 0x601030:   0   33  100 0   0   0   0   0 0x601038:   0   0   0   0 </code></pre><p>解释一下命令：</p><p>12ub表示temp所在内存的显示方式，12u代表显示12个计量单位，b代表字节，所以此命令是显示以temp作为起始地址，向后显示12个字节的内容。可以看到，第一个字节是0，第二个字节是33，即’!’。</p><p>更多格式，请man gdb。</p><p>不需要退出程序，我们直接修改程序：</p><pre><code class="bash">(gdb) shell [serious@localhost c]$ vim gdbtest.c [serious@localhost c]$ gcc -g -o gdbtest gdbtest.c -std=c99 [serious@localhost c]$ exit exit (gdb) </code></pre><p>将源代码第12行修改为:</p><pre><code class="bash">temp[i] = string[nLength - i - 1];</code></pre><p>再次调试到给temp赋值的部分，看一下temp：</p><pre><code class="bash">(gdb) p temp $13 = 0x601030 &quot;!dlr&quot; </code></pre><p>有童鞋问了，老这样输出temp好烦啊，有什么其他办法吗？</p><p>当然有。使用<strong>watch</strong>命令。</p><p>在调试到第10行时，使用<strong>watch</strong>：</p><pre><code class="bash">(gdb) n 10        for(int i = 0; i &lt; nLength; i++)(gdb) watch temp[i] Hardware watchpoint 12: temp[i] (gdb) c Continuing. Hardware watchpoint 12: temp[i] Old value = 0 &#39;\000&#39; New value = 33 &#39;!&#39; reverse (string=0x601010 &quot;hello world!&quot;) at gdbtest.c:10 10      for(int i = 0; i &lt; nLength; i++) (gdb)</code></pre><p>可以看到，当temp[i]有变化时，gdb会提示你，值有变化，从’\000\变化到了’!’。</p><p>程序最后的运行结果：</p><pre><code class="bash">[serious@localhost c]$ ./gdbtest!dlrow olleh</code></pre><h3 id="四、容易出现的问题"><a href="#四、容易出现的问题" class="headerlink" title="四、容易出现的问题"></a>四、容易出现的问题</h3><p>1.在使用gdb时，有时会出现这样的问题：</p><pre><code class="bash">(gdb) nMissing separate debuginfos, use: debuginfo-install glibc-2.12-1.80.el6.x86_64(gdb) </code></pre><p>解决办法：编辑一下debuginfo的源，并使用debuginfo-install命令更新debuginfo库。</p><pre><code class="bash">[serius@localhost c]$ vim /etc/yum.repos.d/CentOS-Base-debuginfo.repo: // 添加如下源[base-debuginfo]name=CentOS-$releasever -DebugInfobaseurl=http://debuginfo.centos.org/$releasever/$basearch/gpgcheck=0enabled=0protect=1priority=1</code></pre><p>2.也有可能在调试你的程序时出现：</p><pre><code class="bash">(gdb) n Single stepping until exit from function yourfunc, which has no line number information. (gdb) </code></pre><p>yourfunc是你自己的函数，这表示着含有此函数的代码在编译时并没有加上-g选项。</p><p>还有一种可能，是你的gcc版本过高而gdb版本过低，比如我。CentOS6.4，4.8.0版本gcc，却是7.2.0版本的gdb，无奈先升级了gdb，才避免了这个错误。</p><p>3.在<strong>watch</strong>变量时出现：</p><pre><code class="bash">(gdb) watch varNo symbol &quot;var&quot; in current context. </code></pre><p>很明显了，gdb在当前的代码域内找不到var变量，就会报这种错误。</p><h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><p>总的来说，gdb是个强大的调试器，我在上面说的这一堆，也只是沧海一粟而已，gdb的官方pdf文档已经堆到了662页。。我也不可能在一篇文章里说清楚，所以，如果你想知道更多，就去下载文档阅读吧。</p><p><a href="http://sourceware.org/gdb/current/onlinedocs/gdb.pdf.gz">凶猛的传送门</a></p>]]></content>
      
      
      <categories>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> gdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小花的新家</title>
      <link href="/2013-03-21/xiaohua&#39;s-new-home/"/>
      <url>/2013-03-21/xiaohua&#39;s-new-home/</url>
      
        <content type="html"><![CDATA[<p>下午请了半天假，到社保中心换卡。</p><p>到了社保中心一问，下午两点上班，现在才一点。于是我往旁边一瞅，有一个小亭子，阳光还不错，正好手里有一份《周末画报》，我决定把这一个小时用在这儿。</p><p>坐了一会，起风了，一摸报纸，一手灰。把报纸收起来，一看旁边，一只黑白相间的小狗正信步向我走来。</p><p>我喜欢狗，于是我决定逗逗这条小狗。</p><span id="more"></span><p>小东西应该是京巴跟蝴蝶的串，脸上的毛的花纹有点像史努比，混身脏兮兮的，一看就是流浪狗。但是眼睛炯炯有神，一点也不怕我。它过来蹭我的腿，我就摸摸它的脑袋，一会它就趴在我旁边准备打个盹了。狗狗做出这种动作，就表明它对你已经信任了，我很开心可以看到它这样做。</p><p>我手里没什么吃的，旁边似乎也没有什么店可以买点零食喂它，遂作罢。</p><p>过了一会，来了一个30岁左右的男人，唤了一声“小花！”，正在睡梦中的小花一下子就睁开了眼睛，欢快地向男人奔了过去。这一人一狗显然是互相认识的。看他俩亲密的样子，我不仅出口问道“这是流浪狗吧？”男人抬头看了我一眼，语气沉重地回答道：“是啊，前一阵它妈丢了，它就自己一个人了。”说完又摸了摸小花。我只能叹一声气表示抱歉，男人接着说，“正犹豫要不要把它弄回家呢。”我就有点惊讶了。流浪狗一般是不会招人待见的，即便是不去欺负它，给它点吃的就算不错了。而他竟然在想要把它弄回家。</p><p>我正准备问其他的问题，身后又有人叫道“小花！”，我回头一看，是4个女人，估计40岁左右的样子，其中有一个稍微小点，30岁出头吧（好吧，我其实不太会看女人的年龄=。=）。唤小花的是一个穿着打扮比较讲究的，是那种一看就是接受过良好的教育的人。“小花！过来，看妈妈今天给你带了什么？”小花又乐颠颠地跑过去蹭她的腿。</p><p>我心头一热。这时候男人出声了，“呀，小花，今儿你有口福了，是大骨头哎。”说罢五个人一起哈哈大笑。原来这五个人也互相认识啊。</p><p>只听比较讲究的女人说，“中午去酒店吃饭，留下些骨头，我就都打包回来了。”另外几个女人也插嘴，说道“怪不得小花跟你最亲，你老给它好吃的，我们给的都是些火腿肠啥的，和你一比差远啦。”五个人说笑了一阵，就开始转向同一个话题——今天把它带回谁家。原来他们早已商量好了这次的事情。</p><p>男人先表态了：“我来吧。我挺喜欢小花的。”<br>比较年轻的女人插嘴了：“不行，你家已经有两条母狗了，把小花弄过去，不怕出事啊。”哦，原来小花是男生。<br>讲究的女人说道：“我来吧，小花听话，比亨利听话多了，我们家亨利也是公的，不怕。”看来她家里也有一条调皮捣蛋的狗，名叫亨利。<br>一个有点富态的女人说：“你们几家都有狗了，没必要再弄，之前就说小花我要了。”<br>年轻的女人反驳：“看到小花我就后悔了，不想让给你了，让它去我家吧。”看来她还是反悔了。</p><p>这时小花正在默默地低头啃骨头，全然不知把它围起来的这几个人正在决定它的命运。</p><p>几个人互相争了一会，一直没说话的那个女人出声了：“我觉得我们还是公平一点，让它自己选择吧。我们都唤它，看它去找谁，就表明谁跟它最有缘。”</p><p>这个提议得到了大家的一致认同，虽然有点儿戏，不过看起来似乎是最好的解决方案。</p><p>几个人拉开距离，然后以各自的方式唤小花。男人是吹口哨；讲究的女人是拿装骨头的塑料袋子诱惑它–遭到了大家的反对后，她不得不扔掉了袋子；年轻的女人蹲下来拍手，像唤孩子那样，富态的女人站着拍手，同时叫小花的名字；比较沉默的女人只是很单调地叫小花。</p><p>小花迷茫地抬起头，看看这个，看看那个——甚至还回头望了我一眼——全然不知这几个老小孩为什么要这么做。几个人都眼巴巴地看着小花，小花也不知道自己要做什么。</p><p>过了大约1分钟的时间，小花似乎终于做了决定。它回头看了一眼自己的骨头，就奔向了比较讲究的女人。</p><p>情理之中。狗总是对那个给自己好吃的东西的人有独特的感情。</p><p>其他四个人叹了口气，站起身来，纷纷抱怨她用美食诱惑小花。讲究的女人喜笑颜开，还打击其他人：“这叫个人魅力！”</p><p>总之，小花的去向定了下来，五个人就轻松了不少。接下来要商量的是回家前的处理工作。</p><p>“要先给它洗一下，把毛全给它剃了，让它重新长，这些毛没营养，不抗冻。”“剃毛之后要做做皮肤护理。”“要给它打针，免得得传染病。”“要不要洗洗胃，谁知道咱不在的时候它吃了什么东西。”“我看不如喂虫子药，洗胃太遭罪了。”</p><p>大家你一言我一语地讨论着，我在旁边看得心里热乎乎的。小花似乎也知道了些什么，不停地在五个人中间蹭来蹭去。</p><p>后来年轻的女人说话了：“那就这么定了，我先打电话给X哥，问问他那能不能弄。”</p><p>“喂？X哥啊，是我啊。是这样的，我这有条小狗，是条流浪狗，我打算把它带回家，您看您那能不能帮我处理一下。啊？不能啊，别啊，我们就给它洗一洗然后剃个毛就行。别啊，我们自己洗还不行么，您那不是有个小卫生间么，我们给它洗完了您就帮忙推一下毛就行。我们多给您点钱。啊？不行啊？”<br>这时讲究的女人要电话，直接就说：“X啊，我是你Y姐。对，你就帮我们个忙，其他的宠物店都太远了，我们过不去啊，就认识你一个，大家都街里街坊的—-不麻烦不麻烦，就剃个毛，不麻烦的。”<br>男人不耐烦了，在旁边说道：“咱就直接抱过去就完了，先抱过去，抱过去再说。”</p><p>讲究的女人又努力了一会，似乎没有和X哥达成共识，郁闷地挂断了电话。</p><p>我在旁边也很着急，这个X哥怎么这么大面子啊，这么些人求他他都不出手。</p><p>“估计是怕有病菌，毕竟他那个地方狗来狗往的。”沉默的女人突然来了句冷笑话。</p><p>其他几人很明显没心情听冷笑话，都皱着眉头，不知道在想什么。</p><p>后来还是男人打破沉默：“走，去我家洗，多大点事。”讲究的女人一听不干了：“那也得去我家洗。”<br>几个人争论了一会，还是决定去男人家给小花洗澡。</p><p>这个时候小花似乎发现了什么有趣的东西，向相反的方向走去。讲究的女人追了过来，叫道：“小花，别乱跑，回家了。”</p><p>这时她已经到我身边了，问我：“你也是这个小区的？”我笑答：“不是，我是去那儿办事的。”我指了指旁边的社保中心，“你们这的人真好，很团结，很有爱心。”我由衷地赞叹。讲究的女人叹了一口气，说道：“流浪狗多啊，我们看着也心疼，尽自己的微薄之力吧。这些小东西也挺不容易的，又听话，讨喜。”</p><p>说完，其他几个人叫她了。她全然不顾小花身上的脏兮兮，抱起小花，向我道别。</p><p>看着他们的背影，心里突然明白了为什么小花在一开始的时候不怕我了，因为它知道，有这么一帮人，是它的家人。</p><p><img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=3373849083,1383287608&fm=26&gp=0.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 口水 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 口水 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 下使用 crontab 定时执行任务</title>
      <link href="/2013-02-28/crontab-in-ubuntu/"/>
      <url>/2013-02-28/crontab-in-ubuntu/</url>
      
        <content type="html"><![CDATA[<p>在以前的工作里，crontab也用了一段时间，做为一个计划任务软件，crontab已经做得足够棒了，它可以完成绝大部分定时工作。</p><span id="more"></span><h3 id="基于用户的cron"><a href="#基于用户的cron" class="headerlink" title="基于用户的cron"></a>基于用户的cron</h3><p>而且用法极其简单：</p><pre><code class="bash">serious@serious:~/Desktop$ crontab [-u username] [-l|-r|-e]参数：-u：设定某个用户的cron服务，一般root用户在执行这个命令的时候需要此参数-l：列出某个用户cron服务的详细内容-r：删除没个用户的cron服务-e：编辑某个用户的cron服务如果想查看某个用户的计划任务列表：crontab -u username -l删除某个用户的计划任务列表：crontab -u username -r针对某个用户编辑计划任务：crontab -u username -e</code></pre><p>第一次进入crontab编辑时，会询问要选择哪种编辑器，哪种顺手就选哪种呗。</p><pre><code class="bash">serious@serious:~/Desktop$ crontab -eno crontab for serious - using an empty oneSelect an editor.  To change later, run &#39;select-editor&#39;.  1. /bin/ed  2. /bin/nano        &lt;---- easiest  3. /usr/bin/emacs23  4. /usr/bin/vim.basic  5. /usr/bin/vim.tinyChoose 1-5 [2]: 4</code></pre><p>默认为nano编辑器，我选择4，正常版的vim编辑器。</p><p>接下来在打开的vim编辑器中，可以看到如下内容：</p><pre><code class="bash"># Edit this file to introduce tasks to be run by cron.# # Each task to run has to be defined through a single line# indicating with different fields when the task will be run# and what command to run for the task# # To define the time you can provide concrete values for# minute (m), hour (h), day of month (dom), month (mon),# and day of week (dow) or use &#39;*&#39; in these fields (for &#39;any&#39;).# # Notice that tasks will be started based on the cron&#39;s system# daemon&#39;s notion of time and timezones.# # Output of the crontab jobs (including errors) is sent through# email to the user the crontab file belongs to (unless redirected).# # For example, you can run a backup of all your user accounts# at 5 a.m every week with:# 0 5 * * 1 tar -zcf /var/backups/home.tgz /home/# # For more information see the manual pages of crontab(5) and cron(8)# # m h  dom mon dow   command</code></pre><p>可以阅读一下它给你的说明。</p><p>然后在文件的最后添加一行</p><pre><code class="bash">30  16  *  *   *   date &gt;&gt; ~/time.log#分 时  日  月  周  &lt;-------命令------&gt;</code></pre><p>然后保存退出，这样在/var/spool/cron/crontabs/里可以看到你的定时计划文件了。记得使用root查看。</p><p>说一下每一个参数的信息：</p><p>数字范围：<br><img alt="" src="http://images.cy198706.com/Programming/QQ20130228164906.png" /></p><p>可用字符：<br><img alt="" src="http://images.cy198706.com/Programming/QQ20130228165829.png" /></p><p>现在就来举各种各样的例子吧。</p><p>你的女朋友的生日是每年的2月3日，你想在2月2日的23：59分发一封充满爱意的邮件给她，就可以使用如下命令：</p><pre><code class="bash">59 23 2 2 * mail sweety &lt; /home/serious/ToMyLover.txt</code></pre><p>哦对了，记得每年把信的内容变一变。</p><p>每5分钟执行一次/home/serious/test.sh文件：</p><pre><code class="bash">*/5 * * * * /home/serious/test.sh</code></pre><p>每周五下午5：30发封邮件提醒你的朋友，马上要下班啦：</p><pre><code class="bash">30 17 * * * mail friend@somewhere.com &lt; /home/serious/TGIF.txt</code></pre><h3 id="基于系统的cron"><a href="#基于系统的cron" class="headerlink" title="基于系统的cron"></a>基于系统的cron</h3><p>如果是系统例行任务呢？那就不再需要使用crontab -e来完成任务了，可以直接编辑/etc/crontab文件。</p><p>有一点需要特别注意一下，crontab -e这个crontab其实是/usr/bin/crontab这个执行文件，而且/etc/crontab是一个纯文本文件，你可以使root身份编辑该文件。</p><p>看看这个文件的内容吧：</p><pre><code class="bash"># /etc/crontab: system-wide crontab# Unlike any other crontab you don&#39;t have to run the `crontab&#39;# command to install the new version when you edit this file# and files in /etc/cron.d. These files also have username fields,# that none of the other crontabs do.SHELL=/bin/shPATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin# m h dom mon dow user  command17 *    * * *   root    cd / &amp;&amp; run-parts --report /etc/cron.hourly25 6    * * *   root    test -x /usr/sbin/anacron || ( cd / &amp;&amp; run-parts --report /etc/cron.daily )47 6    * * 7   root    test -x /usr/sbin/anacron || ( cd / &amp;&amp; run-parts --report /etc/cron.weekly )52 6    1 * *   root    test -x /usr/sbin/anacron || ( cd / &amp;&amp; run-parts --report /etc/cron.monthly )#</code></pre><p>看起来跟刚才的crontab -e内容差不多啊，只是有一个地方不太相同，这里的命令需要提供用户名。</p><h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><h4 id="1-找不到crond服务"><a href="#1-找不到crond服务" class="headerlink" title="1.找不到crond服务"></a>1.找不到crond服务</h4><pre><code class="bash">root@serious:~# service crond restartcrond: unrecognized service</code></pre><p>怎么会找不到crond服务呢？难道安装的时候喝high了，忘记安装crond组件？不可能。。这是集成的。</p><p>Google了一番，发现在Ubuntu里，crond服务改头换面，变成cron了，所以正确的命令应该是：</p><pre><code class="bash">root@serious:~# service cron restart或者是root@serious:~# /etc/init.d/cron restart</code></pre><h4 id="2-crontab设置完后不执行。"><a href="#2-crontab设置完后不执行。" class="headerlink" title="2.crontab设置完后不执行。"></a>2.crontab设置完后不执行。</h4><p>首先检查路径，在crontab中执行文件时，最好使用绝对路径，否则绝大部分不执行的原因都是因为路径问题。</p><p>第二，由于crontab机制问题，crontab每分钟会帮我们重新读取一次/etc/crontab，但在有些*nix系统中，crontab是读到内存中的，这个时候，就要将cron服务重新启动一遍了。</p><p>第三，环境变量问题。</p><p>比如我用C++写了个程序，需要使用crontab执行，但是这个程序的运行是需要环境变量支持的，那么就必须要在crontab文件中加入环境变量，否则会有各式各样的错误提示。</p><h4 id="3-我一下子选错了编辑器肿么办。"><a href="#3-我一下子选错了编辑器肿么办。" class="headerlink" title="3.我一下子选错了编辑器肿么办。"></a>3.我一下子选错了编辑器肿么办。</h4><p>执行如下命令，重新选择即可：</p><pre><code class="bash">serious@serious:~# select-editor</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的2012</title>
      <link href="/2013-01-31/my-2012/"/>
      <url>/2013-01-31/my-2012/</url>
      
        <content type="html"><![CDATA[<p>2012年，有惊无险地过来了。</p><p>回顾这一年，酸甜苦辣都有，算是让我在这一年体会到了人生的多姿多彩。</p><p>之前在我的脑海里，印象最深的一年是1993年，其实我也不知道为什么印象最深刻，但是如果别人问起来，肯定就是1993年，可能跟纽约世贸中心发生爆炸有关系？（笑）</p><p>现在来说，印象最深刻的肯定就是2012年了。</p><p>2012年注定是不平凡的一年，25岁，算是正式度过了人生的1/4&#8211;或许是1/3更好些。这一年世界上发生的事情太多，跟我有关系的倒是不多。或许世界末日跟我有点关系吧，但是这一天是跟最爱的人一起度过的，蛮有意义。</p><span id="more"></span><h2 style="text-align: center;">  <span style="color:#ffa500;">酸</span></h2><p style="text-align: center;">  <strong>&#8212; 酸是种催化剂</strong></p><p>2010年我来到北京，到2012年7月整两年。 </p><p>北京给我的第一印象很不错，交错盘杂的立交桥，哪哪都是人的景点，干净的街道，满目的高楼大厦，穿得很有质量的行人。</p><p>深入了解北京后，才感觉不是那么回事。北京表面看起来很光鲜亮丽，内里的污浊是深到骨髓里的。碍于天朝制度，我不能在这里说一朝之都的坏话，否则被跨省了就不好了。毕竟我也是天朝的一分子。 </p><p>现在的京城给我的感觉很差。混浊的空气，每天要瘫痪几次的交通（地铁很方便），鱼龙混杂的人，高明的骗子，昂贵的生活。</p><p>了解了京城，却又不得不在这种大环境下随波逐流，真的是很无奈，谁让咱是为了生活呢。 </p><p>2011年底，在合肥度过了一段灰暗的时光，在2012年年初又转战陕西，1个月不长不短，但却将我的信心和耐心磨得一干二净。索性离开陕西，独自一人踏上回北京的路，心中的酸涩无人可诉。</p><p>接下来在找工作的过程中，又被打击得体无完肤。总想着自己已经可以独当一面了，到头来还是什么都不会，被面试的人说得面红耳赤。 </p><p>最后来到这家公司，自己所在的部门只有自己一个人，在别人看起来&ldquo;哇，你既是部门经理又是技术总监又是员工哎！&rdquo;，却无法了解其中的难受之处。</p><p>因为前期被打击，工资没敢要太高，以致现在手头还是紧张得要命。我又不会存钱，几乎每个月都向月光群体靠拢，总是感觉钱不够。说实话我对金钱的欲望并不强烈，但有时在街上走，风啊雨啊的吹过来，还是很羡慕那些坐在车里暖暖和和舒舒服服的人的。 </p><p>换了工作，也换了个新的住所。也许是我涉世未深，也许是我真的没什么脑子，对人没什么防备之心，居然就被骗着住了个很暗很暗的隔断间。当时正是春夏交际时，温度和湿度都适宜，但到了夏天就有想死的心了。这都不是重点，大不了多洗澡，多开会风扇，重点是同住的人是有多奇葩。</p><p>隔壁是四个白痴，其中一个从来不上班，因为我随时都能听到他的大嗓门，在喊&ldquo;艹！加血啊！艹，会不会打！&rdquo;；第二个拉完屎从来不冲，终于在一个晚上隔壁的隔壁的女人忍不住了，跟这白痴大吵了一通，这白痴还TM穿着红裤衩，站在走廊里，跟个暴露狂一样；第三个会弹吉他，曾经的记录是连续唱了两个星期的《你的背包》，这也就罢了，关键是他唱歌的调调实在让人不敢直视，真教人欲死不欲生；第四个每天都要抱怨生活的不公平，每天回到家都要长叹一口气，然后开始诉苦，说真没意思，拿这两千块钱的工资，还每天累得跟孙子一样。</p><p>隔壁的隔壁的女人其实也是个奇葩。她跟另一个女人住在一起，洗澡时一定是两个人一起，时间特别特别长，至少要两个小时，这让我们喝多了水憋着的人情何以堪。</p><p>还有偷肥皂的，出门从来不关门的，洗了袜子内裤随便往别人衣服上搭的，在满是蟑螂的厨房里做饭的，在洗衣机里洗鞋的，在冰箱里放避孕套的。。人生真的很神奇，可以遇见各种各样的人。 </p><h2 style="text-align: center;">  <span style="color:#0000ff;">甜</span></h2><p style="text-align: center;">  <strong>&#8212; 最幸福的就是甜</strong></p><p>2012年2月2日，这个日子很普通，我认识了她。当时我人在合肥，一腔苦闷无人能解，也是她帮我排解，跟我一起嬉笑怒骂，给我指明方向。 </p><p>茫茫人海中两人从相遇，相识，相知，相亲相爱，这就是缘分吧。当我发现两人的手机号竟然只差一位数时，心里有种异样的感觉，我觉得，就是她了。 </p><p>她说她脾气很暴躁，总是动不动就发火，这点我领教到了。不过，爱她，就可以包容她的缺点，况且我的脾气好，也算是互补吧。</p><p>可是她也温柔似水啊，我就完全抗拒不了这一点。 </p><p>4月7号我就向她表白了。还算是顺利吧，虽然她后来老向我抱怨我没正式地追过她。。 </p><p>马上又要2月2号了，一年过得真快。在这一年里，我们一起毫无形象地大笑，一起为伤心的事情抱头痛哭，为了一点小屁事吵架，为了一点不公平合伙怒骂，这都是最美好的回忆。</p><p>我们一起出去旅行，一起为未来做打算，一起做饭，一起学跳舞，一起减肥（呃某人看到不要揍我），许许多多的故事，都是我们的财富。 </p><p>我曾经在她上课的时候突然出现在她的身后，在儿童节的时候带着兔斯基去驾校接她，在七夕的时候给她送花，在圣诞夜的时候给她定情的戒指&#8211;好吧，我承认这些都不浪漫，我并不是个会制造浪漫的人，她也老说&ldquo;咱俩就像老夫老妻似的，有木有&rdquo;。 </p><p>今年生过两场大病，都把她吓坏了。第一场是无缘故地拉肚子，持续了快一个周，整个人都虚脱了，发烧，没力气动。她半夜两点跑出去买退烧药，我在床上感动得死去活来的。第二场是非常严重的感冒，我从来没有感冒到这种程度，从一开始的嗓子疼，咳嗽，到后来呕吐，发烧，拉肚子，流鼻涕。。后来逢人我就说，这次可算是彻底感冒了一次。她请假在家照顾我，我很愧疚，在她做饭的时候，挪到厨房去看她，她说&ldquo;来这干什么，赶紧回去，别冻着。&rdquo;我向她表达我的歉疚之情，她很平淡地说&ldquo;这不应该的么。&rdquo;人生得此女，无所求也。 </p><p>2012年12月9号，我们订婚了。10个月相处的时间，我觉得这就是我的人生伴侣了，可以将自己交付予她，她也可以把自己的未来交给我。我相信，未来在我们自己的手上！ </p><h2 style="text-align: center;">  <span style="color:#008000;">苦</span></h2><p style="text-align: center;">  <strong>&#8212; 人间正道是沧桑</strong></p><p>佛说：人有八苦，生苦，老苦，病苦，死苦，怨憎会苦，爱别离苦，求不得苦，五蕴炽盛苦。唯有身心放空，方能人离难，难离身，一切灾殃化为尘。 </p><p>我这个人，没什么太大耐心，要说吃苦，真吃不了。可是有些苦，却是能捱过来的。 </p><p>从去年四月份进入这家公司，就开始了一种和以前截然不同的生活。每天上班要挤公交，挤完公交挤地铁，每天上班下班都要浪费掉两个小时，让人感叹北京人怎么这么多的同时，也暗暗叫苦。我有轻度强迫症，讨厌在车上被不认识的人碰，所以挤车的时候是个很痛苦的过程。常常很好的心情，就因为挤了个公交或者地铁，马上就乌云密布了。</p><p>但看看周围的人，哪个又不是这样，还有很多通州的人，大老早就坐车，到国贸上班。所以，这点苦，又算得了什么，我也没资格抱怨什么，年轻人，吃点苦怕什么，等到年纪大了，才能懂得，这些操蛋的经验才叫人生。</p><h2 style="text-align: center;">  <span style="color:#b22222;">辣</span></h2><p style="text-align: center;">  <strong>&#8212; 瞧我这爆脾气</strong></p><p>小的时候还蛮能吃辣的，长大了越发不行了。就好像我小时候被骂没什么关系，脸皮厚，长大了脸皮薄，被骂了就挂不住了。 </p><p>这一年被很多不同的人骂过。有的是善意的，有的是恶意的。恶意的我从来都不放在身上，因为我是不会去咬马路上对着我狂吠的狗的。善意的骂每次都会难过，但过后都会想明白，我被骂也是应该的。 </p><p>大抵是在1月份，当时在合肥，跟老外一起共事。有一次出了点问题，我没有跟他商量就擅自做了决定，当时我想，这个决定并不会对我们造成什么影响。没想到老外知道之后雷霆震怒，大声地斥责我，说为什么不告诉他，为什么不通知其他的领导让他们来拿主意。我的爆脾气也瞬间燃了，跟他对呛起来，场面一时失控。后来他抛下一句&ldquo;你自己想想吧&rdquo;就回办公室了。怒火过后，我静下心来，想当时的确不应该自己拿决定，毕竟不是一块钱两块钱的事，是每天上千万的交易，如果有了差错，事情只能落在我的头上，因为这个决定是我做的，我担当不起。事后跟老外道歉，他接受了，也没再说什么，所幸也没发生什么事情。 </p><p>后来有一次。那一段时间我无所事事，上面交给我的事情我都不做，因为他们都远在陕西。每天都是&ldquo;放羊混日子&rdquo;的状态，上班看小说，下班玩游戏，不亦乐乎。期间有个其他的领导会指使我做一些跑腿的事情，我碍于上下级的关系，就会帮他做些事情。后来我的直属领导专程打电话过来，劈头盖脸骂我一通，说&ldquo;我才是你的领导，别的领导指使我的员工，我的员工可以不干！下次再让我知道你替他跑腿，你就干脆去他那边得了！程序员不是用来跑腿买烟的！&rdquo;我心里很委屈，却也只能反思自己的不是。领导也是有逆鳞的，他的逆鳞大概就是这样吧。 </p><p>因为订婚，就牵扯到买房，结婚，生子。我心里压力骤增。80后都是悲摧的一代，他们生活的年代，拿着什么都买不起的工资，过着什么都买不起的日子。但是对我来说，压力是阻碍，也是动力，只想着靠死工资每天好吃懒作，什么时候是个头。爸妈肯定也希望我以后能有个好生活，不是么。</p><h2 style="text-align: center;">  续</h2><p style="text-align: center;">  <strong>&#8212; 人生还要继续</strong></p><p>从半个月前就开始规划这篇文章，后来发现还是没有按照预想的路子码字。 </p><p>酸甜苦辣写完，感觉又明白了很多东西。 </p><p>上高中的时候，我写过一句话：人生就是个舞台，各种各样的剧都在上演着。如果没有剧目，那就没人看了。</p><p>很对，是不？嘿嘿。 </p><p>路还要继续走，玛雅人说好的世界末日并没有如约而至，2013迈着轻松的脚步向我们走来。我们不能停下，更不能放弃，世界多么精彩。</p>]]></content>
      
      
      <categories>
          
          <category> 口水 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 口水 </tag>
            
            <tag> 年终总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bash 中的条件表达式</title>
      <link href="/2013-01-22/bash-condition-expressions/"/>
      <url>/2013-01-22/bash-condition-expressions/</url>
      
        <content type="html"><![CDATA[<p>每种语言都会有条件表达式，在Linux下的Bash中也不例外。</p><p>这篇文章来详细讲一下bash中的条件表达式的运用。</p><span id="more"></span><p>在Bash中，基本可以分为两类，一类是使用test命令，另一种是使用”[]”表达式。这两种方式的功能是等价的。</p><p>在Bash中，要注意，不要把写其他语言的习惯带到这儿来，因为Bash是通过解释来直接执行命令的，不需要编译过程，所以为了规避一些可能出现的问题，在”[]”中间，每个元素都必须用空格隔开。比如：</p><pre><code class="bash">[ -e /home/tom ][ $num -eq 2 ][ &quot;$string&quot; = &quot;You are a genius!&quot; ]    // 注意，等号两边须发有空格[ &quot;$p&quot; != &quot;sss&quot; ] || [ &quot;$p&quot; != &quot;ttt&quot; ]    // 同样地，&quot;!=&quot;两边也必须有空格</code></pre><p>如果写成这样：</p><pre><code class="bash">[ -e /home/tom][$num -eq 2][ &quot;$string&quot;=&quot;You are a genius!&quot;]  // [ ]运算符将&quot;$string&quot;=&quot;You are a genius!&quot;视为一个整体了[&quot;$p&quot;!=&quot;sss&quot;]||[&quot;$p&quot;!=&quot;ttt&quot;]</code></pre><p>是无法正确执行的。</p><p>下面看几个运行符。</p><h3 id="文件比较运算符"><a href="#文件比较运算符" class="headerlink" title="文件比较运算符"></a>文件比较运算符</h3><p>[ -e filename ]  如果filename存在,则为真     </p><pre><code class="bash">[ -e /var/log/syslog ]    ortest -e /var/log/syslog</code></pre><p>[ -d filename ]  如果filename为目录,则为真   </p><pre><code class="bash">[ -d /tmp/mydir ]    ortest -d /tmp/mydir</code></pre><p>[ -f filename ]   如果filename为常规文件,则为真    </p><pre><code class="bash">[ -f /usr/bin/httpd ]    ortest -f /usr/bin/httpd</code></pre><p>[ -L filename ]  如果filename为符号链接,则为真   </p><pre><code class="bash">[ -L /usr/bin/apache2 ]    ortest -L /usr/bin/apache2</code></pre><p>[ -r filename ]   如果filename可读,则为真        </p><pre><code class="bash">[ -r /var/log/syslog ]    ortest -r /var/log/syslog</code></pre><p>[ -w filename ]  如果filename可写,则为真       </p><pre><code class="bash">[ -w /var/haha.txt ]    ortest -w /var/haha.txt</code></pre><p>[ -x filename ]  如果filename可执行,则为真     </p><pre><code class="bash">[ -x /etc/init.d/mysqld ]    ortest -x /etc/init.d/mysqld</code></pre><p>[ filename1 -nt filename2 ] 如果filename1比filename2新,则为真  </p><pre><code class="bash">[ /tmp/install/etc/services -nt /etc/services ]   // newer than    ortest /tmp/install/etc/services -nt /etc/services</code></pre><p>[ filename1 -ot filename2 ] 如果filename1比filename2旧,则为真  </p><pre><code class="bash">[ /home/tom/test -ot /home/tom/test1 ]    // older than    ortest /home/tom/test -ot /home/tom/test1</code></pre><p>[ filename1 -ef filename2 ] 判断filename1与filename2是否为同一文件，可用在hard link的判定上。主要意义在于判定两个文件是否均指向同一个inode。</p><pre><code class="bash">[ /usr/bin/apache2 -ef /etc/bin/apache2 ]    // equal file    ortest /usr/bin/apache2 -ef /etc/bin/apache2</code></pre><h3 id="字符串比较运算符"><a href="#字符串比较运算符" class="headerlink" title="字符串比较运算符"></a>字符串比较运算符</h3><p>(请注意引号的使用，这是防止空格扰乱代码的好方法)</p><p>[ -z string ] 如果string长度为零,则为真  </p><pre><code class="bash">[ -z &quot;$myvar&quot; ]    ortest -z &quot;$myvar&quot;</code></pre><p>[ -n string ] 如果string长度非零,则为真  </p><pre><code class="bash">[ -n &quot;$myvar&quot; ]  // -n也可以省略    ortest -n &quot;$myvar&quot;</code></pre><p>[ string1  = string2 ] 如果string1与string2相同,则为真  </p><pre><code class="bash">[ &quot;$myvar&quot; = &quot;one two three&quot; ]    // &quot;==&quot; 也是可以的，在bash中，进行判断时，&quot;=&quot; 和 &quot;==&quot; 的功能是相同的， 这一点跟编程语言中不太相同                                  // 但为了区别开来，还是建议用 &quot;==&quot;    ortest &quot;$myvar&quot; = &quot;one two three&quot;</code></pre><p>[ string1 != string2 ] 如果string1与string2不同,则为真  </p><pre><code class="bash">[ &quot;$myvar&quot; != &quot;one two three&quot; ]    ortest &quot;$myvar&quot; != &quot;one two three&quot;</code></pre><h3 id="算术比较运算符"><a href="#算术比较运算符" class="headerlink" title="算术比较运算符"></a>算术比较运算符</h3><p>[ num1 -eq num2 ]  等于</p><pre><code class="bash">[ $mynum -eq 3 ]    // equal    ortest $mynum -eq 3</code></pre><p>[ num1 -ne num2 ]  不等于</p><pre><code class="bash">[ $mynum -ne 3 ]    // not equal    ortest $mynum -ne 3</code></pre><p>[ num1 -lt num2 ]  小于</p><pre><code class="bash">[ $mynum -lt 3 ]    // less than    ortest $mynum -lt 3</code></pre><p>[ num1 -le num2 ]  小于或等于</p><pre><code class="bash">[ $mynum -le 3 ]    // less or equal    ortest mynum -le 3</code></pre><p>[ num1 -gt num2 ]  大于</p><pre><code class="bash">[ $mynum -gt 3 ]    // greater than    ortest $mynum -gt 3</code></pre><p>[ num1 -ge num2 ]  大于或等于</p><pre><code class="bash">[ $mynum -ge 3 ]    // greater or equal    ortest $mynum -ge 3</code></pre><h3 id="多重条件判定"><a href="#多重条件判定" class="headerlink" title="多重条件判定"></a>多重条件判定</h3><p>-a 两个条件同时成立，则为真</p><pre><code class="bash">[ -r /home/tom/test -a -x /home/tom/test ]    // 即test文件同时具有rx权限时，才返回真    ortest -r /home/tom/test -a -x /home/tom/test </code></pre><p>-o 任意一个条件成立，则为真</p><pre><code class="bash">[ -r /home/tom/test -o -x /home/tom/test ]    // 即test文件具有r或x权限时，都返回真    ortest -r /home/tom/test -o -x /home/tom/test </code></pre><p>！ 条件不成立，则为真</p><pre><code class="bash">[ ! -x /home/tom/test ]    // 即test文件同时不具有x权限时，才返回真    ortest ! -x /home/tom/test </code></pre>]]></content>
      
      
      <categories>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Bash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>弱者只会抱怨，强者总会改变</title>
      <link href="/2013-01-08/dont-complain/"/>
      <url>/2013-01-08/dont-complain/</url>
      
        <content type="html"><![CDATA[<p>现在，每天中午，吃饭的时候，我跟三个同事是在一起的。而噩梦也就开始了。</p><span id="more"></span><p>我们四个人，我是山东的，两个湖北的，一个湖南的。湖北的两个暂且命名为 J 君和 H 君，湖南的命名为 L 君。</p><p>J君是比较正常的那种人，农村出身，有四个姐姐。对各种事情都有自己的见解，不随大流，喜欢各种各样的汽车，而且极其清楚每种配置的价格，喜好军事，喜好经济，口齿有点不清楚，脸上的青春痘也无视这家伙已经 23 了，噌噌地往外长。总之，是个很好相处的人。</p><p>L君是个特别喜欢秀下限的人。标准 90 后，自从他加入了我们，我们都感觉，我们小组的平均智商被拉到了一个肉眼不可见的水平。平时我们仨都喜欢调戏他，从他身上的围巾，到他深不可测的智商。我感觉，每一个四人组里，总需要这么一个人，也总会有这么一个人，这样在路上，不至于冷场。</p><p>H君是个让我特别有感触的人，看到他，我就知道，我以后不能做哪些事了。并不是说他多么多么不像样，而是，在外人面前，像这样表现，只能被别人无视，并且在心里骂一句『傻逼』。</p><p>他的技能就是『抱怨』，对任何一点小事都能抱怨个没完没了，厕所没纸了，昨天又加班了，发票报了没给钱，现在结婚真 TM 早，电梯真够慢的等等等等，每天都会听到他的抱怨。<br>他的另一个技能是『孤僻』，当大家都聊天的时候，他就独自装酷，甚至聊了一会，发现他居然不见了。回来问『去哪了』，也不吱声，看起来像个怨妇，在怨我们把他抛弃了。<br>第三个技能是『口刁』，无论中午吃什么，绝对能听到他说『什么东西，难吃死了』，然后吃得干干净净。或者在自己的菜比较单一时，夹别人一筷子，然后眉头紧皱，说『这种东西你也吃得下』，搞得别人全无胃口。</p><p>但因为我是后来人，算是『新人』，虽然年龄是最大的（一个 90 后，一个一脚踏在 90 门槛上，一个 89 年的），但也没资格说别人什么。其实我也不想对他说什么，没必要啊。</p><p>以前我也是个很能抱怨的人，大事小事都要抱怨一番，可能也烦到了我的一些朋友，他们可能也有跟我现在一样的想法。不过后来发现，抱怨其实什么也改变不了，安安心心吃你的饭，成功消化，成功排泄，这就算是功德圆满了，抱怨有什么用呢。</p><p>忘记在哪看到这句话了，『弱者抱怨命运的无情, 强者扼住命运的咽喉』。的确是这样，抱怨不是不可以，偶尔抱怨一下并不会表示你这个人是个废物，因为没有哪个人的心性是完美的。但是天天抱怨，当抱怨成为一种习惯，就会被命运抛弃。</p><p>有时，抱怨的感觉挺不错，因为我们总喜欢做『对』的一方。我们总是为自己辩解：『是这个人侵犯了我』、『是那个家伙的错』，殊不知我们正一步步滑入抱怨的泥潭，止步不前。其实我们可以选择：是陷入自以为是的泥潭，还是放下抱怨继续上路？别忘了自己活得滋润才是对他人最好的报复。</p><p>说真的，埋怨世界可以上瘾。但只要你愿意，你就能停止抱怨的游戏。有时我们没法改掉习惯，因为我们惧怕改变。但请相信只要你抛弃埋怨的习惯，一个崭新的你便诞生了。答案和方向就在你拨开云雾的那一刹那便可以清楚看到。</p><p>现在社会各种竞争激烈严酷、各种恐惧的蔓延纠结，让我们变得如刺猬般『剑气十足』：对周遭的一切抱怨不止，却极少静下心来反省自己。当然，这并不是说就应将一切责任都揽给自己，而是应该接受现实，从经历中成长，原谅自己，从失败中重新振作，并制定下一步的计划。不管怎样，时间不等人。</p><p>国外都有专家研究出，听多了抱怨，会损伤我们英明神武的大脑的。所以，让我们远离抱怨吧。</p><p>有一则古老的寓言，或许可以给我们一些启示。</p><blockquote><p>有一个年轻的农夫，划着小船，给另一个村子的居民运送自家的农产品。那天的天气酷热难耐，农夫汗流浃背，苦不堪言。他心急火燎地划着小船，希望赶紧完成运送任务，以便在天黑之前能返回家中。突然，农夫发现，前面另外一只小船，沿河而下，迎面向自己快速驶来。眼见着两只船就要撞上了，但那只船并没有丝毫避让的意思，似乎是有意要撞翻农夫的小船。</p><p>『让开，快点让开！你这个白痴！』农夫大声地向对面的船吼叫道。『再不让开你就要撞上我了！』但农夫的吼叫完全没用，尽管农夫手忙脚乱地企图让开水道，但为时已晚，那只船还是重重地撞上了他。农夫被激怒了，他厉声斥责道：『你会不会驾船，这么宽的河面，你竟然撞到了我的船上？！』当农夫怒目审视对方小船时，他吃惊地发现，小船上空无一人。听他大呼小叫，厉言斥骂的只是一只挣脱了绳索、顺河漂流的空船。</p></blockquote><p>好久没码字了，语竭词穷了。</p>]]></content>
      
      
      <categories>
          
          <category> 口水 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 口水 </tag>
            
            <tag> 人生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20亿像素的全景照片 &amp;#8211; 冲击吉尼斯世界纪录！</title>
      <link href="/2012-12-26//"/>
      <url>/2012-12-26//</url>
      
        <content type="html"><![CDATA[<p>据国外媒体报道，近日由名叫David Breashers所带领的GlacierWorks地质研究小组公布了<strong>一幅20亿像素的珠穆朗玛峰昆布冰川春季全景照片</strong>，洛子峰和努子峰两座高原雪山曼妙的身姿也在照片中得以展现。</p><p>同时，当人们放大观看照片时，可以清晰地看到冰川河床中星罗密布的帐篷以及整个冰川的所有细节，这着实让那些对神秘冰川充满向往，而由无法亲自前往的人们过足了眼瘾。</p><p>该团队在其官方Facebook页面中写道：&ldquo;我试图通过这种方式让人们能够近距离看到这些极精细的冰川景色。&rdquo;<br>他表示，&ldquo;我们的团队目前正在与微软以及英国皇家地理学会展开合作，未来该组织将进行更多有关昆布冰川读取自然气候地貌演变的科考活动。&rdquo;  </p><span id="more"></span><p>以下是此次所公布的全景照片的网页截图，想查看完整大图的读者可移步至<a class="f14_link" href="http://www.glacierworks.org/the-glaciers/pumori-spring-2012/" style="color: rgb(0, 0, 255);" target="_blank">这里</a>。操作方式很简单，可以用鼠标或下方按钮移动镜头，用滚轮或Shift、Ctrl键缩放。右下角的Full Screen可以全屏哦。<br><a href="http://images.cy198706.com/Mess-Ups/20121226112100.jpg" target="_blank"> <img alt="" src="http://images.cy198706.com/Mess-Ups/20121226112100.jpg" /></a></p><p><a href="http://i1352.photobucket.com/albums/q645/cy198706/mess-ups/20121226111623.jpg" target="_blank"> <img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/mess-ups/20121226111623.jpg" /></a></p><p><a href="http://i1352.photobucket.com/albums/q645/cy198706/mess-ups/20121226111938.jpg" target="_blank"> <img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/mess-ups/20121226111938.jpg" /></a><br>&nbsp;</p>]]></content>
      
      
      
        <tags>
            
            <tag> 图片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++获取本机MAC地址</title>
      <link href="/2012-12-21/c++-get-mac/"/>
      <url>/2012-12-21/c++-get-mac/</url>
      
        <content type="html"><![CDATA[<p>最近出现一个需求，要获取本机的MAC地址，就找了一些资料。</p><span id="more"></span><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>在Windows下，有两种方法可以获取MAC地址：</p><h4 id="1-通过SendARP函数来获取。"><a href="#1-通过SendARP函数来获取。" class="headerlink" title="1.通过SendARP函数来获取。"></a>1.通过SendARP函数来获取。</h4><p>SendARP的函数原型：</p><pre><code class="c">DWORD SendARP(  _In_     IPAddr DestIP,  _In_     IPAddr SrcIP,  _Out_    PULONG pMacAddr,  _Inout_  PULONG PhyAddrLen);</code></pre><p>根据函数原型可以看出，可以通过IP地址来获取，也可以无视IP地址，这样就获得第一个网卡的MAC地址。</p><p>第三个参数pMacAddr与第四个参数PhyAddrLen类型相同，是指向ULONG类型数组的指针，可以通过强转为unsigned char *，用来显示等。<br>示例如下：</p><pre><code class="c">int GetOtherMacAddr(char *szIP,char *szBuf,int *pnBufLen)&#123;    HRESULT hr;    IPAddr  ipAddr;    ULONG   pulMac[2];    ULONG   ulLen;    char strMacAddr[100]=&#123;0&#125;;    ipAddr = inet_addr (szIP);    memset (pulMac, 0xff, sizeof (pulMac));    ulLen = 6;    hr = SendARP (ipAddr, 0, pulMac, &amp;ulLen);    if(hr!=NO_ERROR)        return 1;    unsigned char * mac_addr=(unsigned char*)pulMac;    sprintf(strMacAddr,&quot;%02X:%02X:%02X:%02X:%02X:%02X&quot;,mac_addr[0],mac_addr[1],        mac_addr[2],mac_addr[3],mac_addr[4],mac_addr[5]);    if ( *pnBufLen &lt;= (int)strlen(strMacAddr) )        return 2;    strcpy(szBuf,strMacAddr);    *pnBufLen = strlen(szBuf);    return 0;&#125;int GetLocalMacAddr(char *szMac,int *pnMacLen,char *szIP /*=NULL */)&#123;    //如果指定了IP，则直接按IP获取MAC    //否则，需要先获取本机名称，再获取IP，再获取MAC    if ( szIP != NULL )        return GetOtherMacAddr(szIP,szMac,pnMacLen);    char szHostName[256] = &#123;0&#125;;    int nRet = gethostname(szHostName,256);    if ( nRet == SOCKET_ERROR )        return 1;    //获取本机名称    struct hostent* hHost = gethostbyname(szHostName);    if ( hHost == NULL ||  hHost-&gt;h_addr_list[0] == NULL )        return 2;    //获取IP地址    memset(szHostName,0,256);    strcpy(szHostName,inet_ntoa(*(struct in_addr *)hHost-&gt;h_addr_list[0]));    //获取MAC    return  GetOtherMacAddr(szHostName,szMac,pnMacLen);&#125;</code></pre><h4 id="2-通过PIP-ADAPTER-INFO结构体与GetAdaptersInfo函数来获取"><a href="#2-通过PIP-ADAPTER-INFO结构体与GetAdaptersInfo函数来获取" class="headerlink" title="2.通过PIP_ADAPTER_INFO结构体与GetAdaptersInfo函数来获取"></a>2.通过PIP_ADAPTER_INFO结构体与GetAdaptersInfo函数来获取</h4><p>PIP_ADAPTER_INFO结构体的结构如下：</p><pre><code class="c">typedef struct _IP_ADAPTER_INFO &#123;    struct _IP_ADAPTER_INFO* Next;    DWORD ComboIndex;    char AdapterName[MAX_ADAPTER_NAME_LENGTH + 4];    char Description[MAX_ADAPTER_DESCRIPTION_LENGTH + 4];    UINT AddressLength;    BYTE Address[MAX_ADAPTER_ADDRESS_LENGTH];    DWORD Index;    UINT Type;    UINT DhcpEnabled;    PIP_ADDR_STRING CurrentIpAddress;    IP_ADDR_STRING IpAddressList;    IP_ADDR_STRING GatewayList;    IP_ADDR_STRING DhcpServer;    BOOL HaveWins;    IP_ADDR_STRING PrimaryWinsServer;    IP_ADDR_STRING SecondaryWinsServer;    time_t LeaseObtained;    time_t LeaseExpires;&#125; IP_ADAPTER_INFO, *PIP_ADAPTER_INFO;</code></pre><p>可以看到，有网卡名称、描述信息、MAC地址、IP地址列表、DHCP服务器等信息。这次我们用到的就是MAC地址BYTE[MAX_ADAPTER_ADDRESS_LENGTH。而struct _IP_ADAPTER_INFO* Next则告诉我们所有的网卡信息将会构成一个链表，通过Next来得到下一个网卡的信息。</p><pre><code class="c">void GetMAC(BSTR* pVal)&#123;    CString sMAC;    PIP_ADAPTER_INFO pAdapterInfo;    PIP_ADAPTER_INFO pAdapter = NULL;    DWORD dwRetVal = 0;    ULONG ulOutBufLen;    pAdapterInfo=(PIP_ADAPTER_INFO)malloc(sizeof(IP_ADAPTER_INFO));    ulOutBufLen = sizeof(IP_ADAPTER_INFO);    if (GetAdaptersInfo(pAdapterInfo, &amp;ulOutBufLen) == ERROR_BUFFER_OVERFLOW)    &#123;        free(pAdapterInfo);        pAdapterInfo = (IP_ADAPTER_INFO *) malloc (ulOutBufLen);    &#125;    if ((dwRetVal = GetAdaptersInfo(pAdapterInfo, &amp;ulOutBufLen)) == NO_ERROR)    &#123;        pAdapter = pAdapterInfo;        if (pAdapter)&#123;            sMAC.Format(_T(&quot;本机MAC地址为：%02x-%02x-%02x-%02x-%02x-%02x&quot;),                pAdapter-&gt;Address[0],                pAdapter-&gt;Address[1],                pAdapter-&gt;Address[2],                pAdapter-&gt;Address[3],                pAdapter-&gt;Address[4],                pAdapter-&gt;Address[5]);            //pAdapter = pAdapter-&gt;Next;  //如果有多网卡，这儿就可以使用此条语句转到下一个网卡        &#125;    &#125;    *pVal = ::SysAllocString(sMAC.MakeUpper());&#125;</code></pre><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>在Linux下也类似。有一个名为ifreq的结构体，包含了网卡的所有信息。<br>ifreq的结构如下：</p><pre><code class="c">struct ifreq&#123;    char ifr_name[IFNAMSIZ];    union    &#123;        struct sockaddr ifru_addr;        struct sockaddr ifru_dstaddr;        struct sockaddr ifru_broadaddr;        struct sockaddr ifru_netmask;        struct sockaddr ifru_hwaddr;        short int ifru_flags;        int ifru_ivalue;        int ifru_mtu;        struct ifmap ifru_map;        char ifru_slave[IFNAMSIZ]; /* Just fits the size */        char ifru_newname[IFNAMSIZ];        __caddr_t ifru_data;    &#125; ifr_ifru;&#125;;# define ifr_name ifr_ifrn.ifrn_name /* interface name */# define ifr_hwaddr ifr_ifru.ifru_hwaddr /* MAC address */# define ifr_addr ifr_ifru.ifru_addr /* address */# define ifr_dstaddr ifr_ifru.ifru_dstaddr /* other end of p-p lnk */# define ifr_broadaddr ifr_ifru.ifru_broadaddr /* broadcast address */# define ifr_netmask ifr_ifru.ifru_netmask /* interface net mask */# define ifr_flags ifr_ifru.ifru_flags /* flags */# define ifr_metric ifr_ifru.ifru_ivalue /* metric */# define ifr_mtu ifr_ifru.ifru_mtu /* mtu */# define ifr_map ifr_ifru.ifru_map /* device map */# define ifr_slave ifr_ifru.ifru_slave /* slave device */# define ifr_data ifr_ifru.ifru_data /* for use by interface */# define ifr_ifindex ifr_ifru.ifru_ivalue /* interface index */# define ifr_bandwidth ifr_ifru.ifru_ivalue /* link bandwidth */# define ifr_qlen ifr_ifru.ifru_ivalue /* queue length */# define ifr_newname ifr_ifru.ifru_newname /* New name */# define _IOT_ifreq _IOT(_IOTS(char),IFNAMSIZ,_IOTS(char),16,0,0)# define _IOT_ifreq_short _IOT(_IOTS(char),IFNAMSIZ,_IOTS(short),1,0,0)# define _IOT_ifreq_int _IOT(_IOTS(char),IFNAMSIZ,_IOTS(int),1,0,0)</code></pre><p>稍微复杂点，但还是能找到我们所需要的信息的 - ifru_hwaddr。</p><p>通过下面的代码，就能完成工作了：</p><pre><code class="c">int GetLocalMacAddr(char *szMac,int *pnMacLen)&#123;    int   sock;    struct   ifreq   ifr;    unsigned   char   mac[6];    sock=socket(AF_INET,SOCK_DGRAM,0);    // 生成一个TCP的socket    if (sock==-1)    &#123;        perror(&quot;socket&quot;);        return 1;    &#125;    strncpy(ifr.ifr_name,&quot;eth0&quot;,sizeof(ifr.ifr_name));    ifr.ifr_name[IFNAMSIZ-1]   =   0;    memset(mac,0,sizeof(mac));    if (ioctl(sock,SIOCGIFHWADDR,&amp;ifr)&lt; 0)    &#123;        perror(&quot;ioctl&quot;);        return 2;    &#125;    memcpy(mac,&amp;ifr.ifr_hwaddr.sa_data,sizeof(mac));    char curmacstr[64];    memset(curmacstr,0,sizeof(curmacstr));    sprintf(curmacstr,&quot;%.2X:%.2X:%.2X:%.2X:%.2X:%.2X&quot;,mac[0],mac[1],mac[2],mac[3],mac[4],mac[5]);    strcpy(szMac,curmacstr);    return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> c/c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器插件：微博急简 &amp;#8211; 还你一个，干净的微博！</title>
      <link href="/2012-12-19//"/>
      <url>/2012-12-19//</url>
      
        <content type="html"><![CDATA[<p>这年头，无孔不入的广告已经把我们烦得要死要活的，再加上一些&ldquo;潜规则&rdquo;，本来有些地方是&ldquo;一方净土&rdquo;，也会在利益的驱使下变得污浊不堪。<br>当然，这只是些无关痛痒的话，现在谁还会因为平民的呼声就做出一些&ldquo;艰难的决定&rdquo;啊。</p><p>新浪微博从一开始的简洁明快，到后来的臃肿不堪，有利益在里面，也有事物的发展规律在里面。从利益方面，没有任何一个大型网站是不需要挣钱的，仅靠那一点点广告费，是不足以养活下面的百十号人的。  </p><span id="more"></span><p>那怎么办呢？会员？嗯！放点权限！会员可以知道谁取消了对他的关注！会员可以用专属的模版！会员应该戴一个皇冠！会员的话可以被更多人看到！</p><p>那怎么才能让会员的话被更多人看到呢？排序吧！</p><pre class="brush:cpp;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;">if(user.group == _VIPGROUP){&nbsp;&nbsp;&nbsp; pop_sort();}if(user.group == _NORMALGROUP){&nbsp;&nbsp;  push_sort();}</pre><p>废话少说，新浪微博的页面上有太多平时用不到的东西了，这也是为什么我喜欢wap版的微博的原因，简洁明快，我能很快地找到我需要的东西。<br><a href="http://i1352.photobucket.com/albums/q645/cy198706/mess-ups/20121219094357.jpg" target="_blank"><img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/mess-ups/20121219094357.jpg" /></a><br>看看这东西，多臃肿，太多平时用不到的东西了。。我就是看微博，发微博，没了。</p><p>这今天推荐一个微博急简工具，他们的口号是&ldquo;还你一个，干净的微博！&rdquo;针对FireFox，Chrome，Safari和360浏览器分别开发了插件，他们对待IE用户的态度是：I’m sorry, I’m so sorry, I’m sooooo sorry.<br>效果更是没话说，上图：<a href="http://i1352.photobucket.com/albums/q645/cy198706/mess-ups/20121219092616.jpg" target="_blank"><img alt="" src="http://i1352.photobucket.com/albums/q645/cy198706/mess-ups/20121219092616.jpg" /></a><br>因为在Win8下，Mactype不能很好地渲染Chrome，看着那蛋疼的字体实在让人蛋疼，所以偶目前使用的是火狐浏览器，还不错吧？<br>链接奉上：<a href="http://www.diff.im/weibo_wc/">微博急简</a></p><!--[syntaxhighlighter]--><!--代码高亮，请勿编辑--><link type="text/css" rel="stylesheet" href="http://cy198706.com/blog/wp-content/plugins/ck-and-syntaxhighlighter/syntaxhighlighter/styles/shCoreCk.css" /><link type="text/css" rel="stylesheet" href="http://cy198706.com/blog/wp-content/plugins/ck-and-syntaxhighlighter/syntaxhighlighter/styles/shThemeCk.css" /><!--[/syntaxhighlighter]-->]]></content>
      
      
      
        <tags>
            
            <tag> 旁门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>布卡漫画 &amp;#8211; 漫画神器</title>
      <link href="/2012-12-18//"/>
      <url>/2012-12-18//</url>
      
        <content type="html"><![CDATA[<p>偶从很小的时候就开始看漫画，那个时候的小漫画书还是四处借的，因为没钱买=。= 七龙珠，机器猫，乱马，蜡笔小新，柯南，灌篮高手。。。漫画陪我度过了童年。<br>现在虽然没有那种激情了，但是偶尔看个漫画，还是能找回当年的感觉的。</p><p>在酷安市场找到了这个漫画神器 &#8211; 布卡漫画（布卡？不卡？）。用了几天发现，真的是神器。不但资源丰富，而且一点也不卡（当然是在wifi下），应了名字的寓意。</p><p>软件的界面做得比较讨喜，风格很简洁，而且常用的东西基本上在两次操作以内都可以完成，没有太多繁冗的设置。图片的质量都比较高，我的Defy分辨率为854*480，无论横屏还是竖屏，看起来都相当清晰。<span id="more"></span></p><p><a href="http://images.cy198706.com/Android/Screenshot_2012-12-17-14-54-00.png" target="_blank"><img alt="" src="http://images.cy198706.com/Android/Screenshot_2012-12-17-14-54-00.png" style="height: 569px; width: 320px;" /></a>&nbsp;<a href="http://images.cy198706.com/Android/Screenshot_2012-12-17-14-54-23.png" target="_blank"><img alt="" src="http://images.cy198706.com/Android/Screenshot_2012-12-17-14-54-23.png" style="width: 320px; height: 569px;" /></a><br><a href="http://images.cy198706.com/Android/Screenshot_2012-12-17-14-54-38.png" target="_blank"><img alt="" src="http://images.cy198706.com/Android/Screenshot_2012-12-17-14-54-38.png" style="height: 569px; width: 320px;" /></a>&nbsp;<a href="http://images.cy198706.com/Android/Screenshot_2012-12-17-14-55-15.png" target="_blank"><img alt="" src="http://images.cy198706.com/Android/Screenshot_2012-12-17-14-55-15.png" style="height: 569px; width: 320px;" /></a><br>总的来说，这还是一款精品极品的软件，体积也不大，非常适合喜欢看漫画的人安装使用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卧床三天</title>
      <link href="/2012-12-03//"/>
      <url>/2012-12-03//</url>
      
        <content type="html"><![CDATA[<p>莫名发烧，卧床三天。看来冬季到底是来了。<br>病最严重的时候，大脑无时无刻不在折磨着我。恰好前些天在回顾美剧&ldquo;越狱&rdquo;，在睡觉的时候，里面的情节就有如潮水一般向我涌来，就算清醒过来也还不放过我。说话也开始变得糊涂，神智不清，不知道自己在说些什么，加之昏暗的房间，肚子也难受，头疼欲裂，整个人像快要死过去。<br>好在媳妇在身边。我妈打来电话，一听说我感冒了，第一时间就问&ldquo;你媳妇没事吧?&rdquo;我撇了撇嘴，回答&ldquo;没事。放心吧。&rdquo;父母表示有她在身边，一切放心。<br>这两日真真把她忙坏了。买菜，做饭，收拾屋子，倒水，灌药，倒腾凉毛巾，热水泡脚。。心里暖暖的，但是我实在没有力气站起来，帮她做点什么。昨天她在做饭，我挪到厨房去，说&ldquo;心里愧疚啊。&rdquo;她看了我一眼，&ldquo;这不应该的么。赶紧回去，别冻着。&rdquo;得女如此，夫复何求?<br>今日余热退尽，依旧行动不便，念此情此景，书之。<br><a href="http://img29.wal8.com/img29/310877_20121224145902/135633515792.jpg" target=""><img alt="" src="http://img29.wal8.com/img29/310877_20121224145902/135633515792.jpg" style="width: 610px;" /></a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 口水 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kelly Clarkson &amp;#8211; (What Doesn&amp;#8217;t Kill You Makes You) Stronger</title>
      <link href="/2012-11-27//"/>
      <url>/2012-11-27//</url>
      
        <content type="html"><![CDATA[<p><span style="font-size:14px;">美国偶像一姐Kelly Clarkson携力作《Stronger》强势回归，力压群雄，直击第一宝座！一向就是&ldquo;励志姐&rdquo;的Kelly Clarkson在蛰伏一阵子后猛力发力，以摇滚风范全新复出！&ldquo;What doesn’t kill you makes you stronger！&rdquo;越到困难就要越挫越勇！曲调轻快动感，Kelly用华丽和端庄两种装扮风格展示出自己的魅力。同时Kelly在这首歌中的音色表现被欧美乐评人称赞为整张专辑的亮点。</span></p><p><span style="font-size:14px;">Kelly Clarkson，1982年4月24日出生在德克萨斯州的Burleson。美国流行音乐女歌手。2002年，Kelly参加了美国真人秀节目《美国偶 像》第一季的比赛，凭着其扎实的唱功和稳定的演出，由全美电视观众投票选为比赛的冠军，成为新世代的美国偶像。<br /> 奉上MTV，虽然拍摄得中规中矩，但是却告诉我们，平凡的人，也有力量。</span></p><p style="text-align: center;">  <embed align="middle" allowfullscreen="true" allowscriptaccess="always" height="460" quality="high" src="http://player.youku.com/player.php/sid/XMzMyMzgzNjI4/v.swf" type="application/x-shockwave-flash" width="620">  </embed></p>]]></content>
      
      
      
        <tags>
            
            <tag> 音乐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>灰常有意思的卡农</title>
      <link href="/2012-11-22//"/>
      <url>/2012-11-22//</url>
      
        <content type="html"><![CDATA[<p>要说卡农，我也听了不少版本了，抒情的，低沉的，摇滚的，电子的，爵士的。这个版本的还是头一次听。</p><p>废话少说，奉上视频。</p><p style="text-align: center;"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 音乐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>偶最喜欢的阅读软件 &amp;#8211; 静读天下 Moon Reader</title>
      <link href="/2012-11-21//"/>
      <url>/2012-11-21//</url>
      
        <content type="html"><![CDATA[<p>要追溯俺的电子书读书历史，要从高二开始。那个时候我看班里有人开始用&ldquo;文曲星&rdquo;，我那个羡慕啊，那个嫉妒啊，那个恨啊，后来就缠着我爸给我买了一个。记得那个牌子叫&ldquo;诺亚舟&rdquo;，自此我也成为拥有电子产品的人，得众多少男少女们的羡慕。<br>&ldquo;诺亚舟&rdquo;有很多功能，学习英语是首位的，我也经常用来查个单词啊啥的。然后就是游戏功能了，推箱子、贪吃蛇、扫雷，三个游戏我玩了整整两年。<br>不过用的最多的功能还是看电子书。当时看的书，不外乎言情小说啊，科幻小说，再就是两三个人就能演完的那种小说。当时还没有玄幻小说，《诛仙》啥的还没出现呢。<br>后来到大学，有了手机。第一部智能机是MOTOROLA的E398。</p><span id="more"></span><p>&nbsp;<img alt="" height="280" src="http://2d.zol-img.com.cn/product/2/777/ce9iCrUA0Ft.jpg" width="374" /><br>那个时候看的书就比较杂了，科幻的，杂小说，玄幻类的。当时用的软件叫MOTO-TXT。<br>&nbsp;<img alt="" class="alignnone size-full wp-image-279" data-mce-="" src="http://images.cy198706.com/Android/20100302163631-2099173229.jpg" style="height: 320px; width: 240px;" title="20100302163631-2099173229" /><br>这东西简直就是神器，可定制性相当强。虽然现在看来，这个软件已经落后不知道多少了，但是这段时光是永远也忘不了滴。<br>后来又买了MOTOROLA E2。<br><img alt="" class="alignnone size-full wp-image-280" data-mce-="" src="http://images.cy198706.com/Android/20080112100044426.jpg" style="height: 375px; width: 500px;" title="20080112100044426" /><br>这算是MOTOROLA的又一款经典机型。当时刷机刷得那叫一个疯啊~用了三年的软件叫Anyview。<br><img alt="" class="alignnone size-full wp-image-281" data-mce-="" src="http://images.cy198706.com/Android/200962516473099249.jpg" style="width: 240px; height: 320px;" title="200962516473099249" /><br>Anyview已经将键盘阅读软件提升到精品的高度，对于当时的偶来说，基本上一天里至少有5个小时是开着这个软件的。Anyview的作者现在好像还在开发，不过已经许久没有用过了，向他致敬。<br>毕业后，有了点钱，买了个诺基亚的E71，也是一款经典街机。<br><img alt="" class="alignnone size-full wp-image-282" data-mce-="" src="http://images.cy198706.com/Android/241720.jpg" style="width: 269px; height: 292px;" title="241720" /><br>找了好多读书软件，都找不到大学四年，晚上黑乎乎的，看《鬼吹灯》看到凌晨四点才睡的感觉了。在E71被贼人偷去之前，一直在用的是百阅，也算是比较好的东西了。百阅目前在Android平台上也有自己的市场，只是个人不喜欢这种只在乎发展其在线模块（也就是赚钱模块）而忽视离线本地阅读体验的软件，遂放弃。<br>现在在用的是MOTOROLA Defy（你看，我真是MOTO的忠实粉丝啊。。）。读电子书的习惯一直都保持着。睡前，如厕，地铁上，公交上，甚至电梯里。。我喜欢折腾手机，你看我买的几款机器，都是可以刷机的，可定制性非常强，我不喜欢被自己的手机束缚住这种感脚。iPhone也用过一段时间，苹果的东西蛮不错的，用户体验做得非常棒，但不习惯，遂放弃。在Android下，可折腾空间就大了许多了。阅读软件也用了不少不少的。Anyview、百阅、iReader、静读天下、开卷有益，还有些用了一两次就直接干掉的软件，iReader也用了好长一段时间，但最后还是锁定了静读天下。<br>静读天下是款可定制性非常强的离线阅读软件，其赢利的方式是购买专业版以解锁高级功能。网上流传的基本上都是XX版的，在作者的声明里也明确表示了&ldquo;如果你使用的是破解版，请不要联系偶&rdquo;。</p><blockquote><p>功能万金油：<br>1、实现真正的平滑滚动。<br>2、多个在线书库，数十万本小说/报纸/杂志<br>3、支持传统中文的竖排/直读模式<br>4、深度优化txt长篇小说阅读体验，高效智能识别章节段落，自动生成目录<br>5、支持四十多种编码，三十多种外挂字体（繁体字TXT文档请在可视设置里手工选择相应文字编码）<br>6、预置十种配色方案，可定制白天晚上模式<br>7、可视化设置，所有颜色背景等即时可见<br>8、支持十多种翻页模式<br>9、支持五种自动滚屏方案，并可实时调节<br>10、智能排版，首行缩进，裁剪多余空行<br>11、视力保护提醒选项<br>12、真实纸张翻页效果<br>13、豪华书架管理，我的珍藏/下载/作者/分类并可自制封面<br>14、强大的本地书籍文档查找（支持通配符检索及导入），全方位的书本内容搜索（支持正则表达式）<br>15、词典/翻译/高亮/标注，长按阅读内容可选择通过微博，短信和邮件等方式进行分享<br>16、多语种阅读支持：共有26个语言的版本，支持Justified和Hyphenation排版，支持韩语和日语排版，支持300多部各语种离线词典<br>17、支持格式：txt、html、epub、fb2、umd、chm、zip、OPDS<br>专业版增强：<br>1、删除广告条<br>2、语音朗读<br>3、多点触摸支持<br>4、密码保护<br>5、耳机或蓝牙控制<br>6、创建桌面书籍快捷方式<br>7、标签/高亮/标注的分享及导入导出功能<br>8、邮件技术支持服务</p></blockquote><p>上几张自用截图</p><p><a href="http://0.serious.duapp.com/wp-content/uploads/Screenshot_2012-11-21-16-20-16.png"><img alt="" class="alignnone size-full wp-image-226" src="http://images.cy198706.com/Android/Screenshot_2012-11-21-16-20-16.png" style="height: 854px; width: 480px;" title="Screenshot_2012-11-21-16-20-16" /></a></p><p>这便是开始界面了，近期看过的书籍都摆在上方了，可以通过滑动来选择其他的。</p><p><a href="http://0.serious.duapp.com/wp-content/uploads/Screenshot_2012-11-21-16-21-13.png"><img alt="" class="alignnone size-full wp-image-224" src="http://images.cy198706.com/Android/Screenshot_2012-11-21-16-21-13.png" style="width: 480px; height: 854px;" title="Screenshot_2012-11-21-16-21-13" /></a></p><p>阅读界面。因为是epub书籍，所以排版方面做得相当不错。</p><p><a href="http://0.serious.duapp.com/wp-content/uploads/Screenshot_2012-11-21-16-21-06.png"><img alt="" class="alignnone size-full wp-image-227" src="http://images.cy198706.com/Android/Screenshot_2012-11-21-16-21-06.png" style="width: 480px; height: 854px;" title="Screenshot_2012-11-21-16-21-06" /></a></p><p>各种配色方案。用了很久的羊皮纸，现在喜欢蓝底白字。</p><p><a href="http://0.serious.duapp.com/wp-content/uploads/Screenshot_2012-11-21-16-21-20.png"><img alt="" class="alignnone size-full wp-image-225" src="http://images.cy198706.com/Android/Screenshot_2012-11-21-16-21-20.png" style="width: 480px; height: 854px;" title="Screenshot_2012-11-21-16-21-20" /></a></p><p>可定制性非常强，有很多很多的设置选项，像我一样喜欢折腾的强迫症患者，可以好好研究一下子了。</p><p>附上下载地址：<a href="http://www.coolapk.com/apk/3276/">凶猛的传送门</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>某视记者直播十八大时忘词连线中断</title>
      <link href="/2012-11-20//"/>
      <url>/2012-11-20//</url>
      
        <content type="html"><![CDATA[<p>忘词很常见，但这么重要的时刻忘词，就是记者的问题了。这是CCAV的节目，天朝最大的媒体，在审核记者的水平上，看起来还真是不尽人意。</p><p>不过还好我们有“由于技术原因，连线暂时中断”这种借口，但是主持人用的不是地方。第一次发现记者开始忘词的时候，就应该速度救场，而不是提醒。现场的工作在员，在发现这种尴尬的情况时，也应该速度掐掉网络，造成真正的“技术原因”，但是这些本该训练有素的“攻城狮”却没有及时这么做，真真叫人费解。</p><p>总的来说，发生这种事情，总该引人深思一下，究竟是谁之过?</p>]]></content>
      
      
      
        <tags>
            
            <tag> 态度, 视频 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>幸福很简单</title>
      <link href="/2012-11-16//"/>
      <url>/2012-11-16//</url>
      
        <content type="html"><![CDATA[<p>昨天晚上，吃完饭，试了试新买的保暖内衣，很暖和，很舒服，就想着给我爸妈和媳妇的爸妈一人弄一套，于是跟媳妇说&ldquo;给咱爸妈一人弄一套就行。&rdquo;没想到媳妇听完愣了一下，然后一脸惊喜地扑过来抱住了我。我也愣了，然后瞬间就明白过来了。 她需要的东西很简单。一个贴心的动作，一句不经意的话，一件微不足道的小事，都能让人感动。 幸福其实很简单，就看你能不能捕捉到。<a href="http://images.cy198706.com/Gabby/hold your hands.jpg" target="_blank"><img alt="" src="http://images.cy198706.com/Gabby/hold%20your%20hands.jpg" style="width: 610px;" /></a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 口水 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>华丽的资源管理器-Solid Explorer</title>
      <link href="/2012-11-15//"/>
      <url>/2012-11-15//</url>
      
        <content type="html"><![CDATA[<p>之前在都一直在用RE管理器，感觉不错，功能强大，操作也快捷。后来在酷安市场发现了这个资源管理器，就完全把RE抛弃了。 Solid Explorer（SE）也是一个可以获得Root权限的资源管理器，也算是个新东西，现在用户量也在慢慢涨起来。分页模式让操作变得更加快捷，华丽的UI让人一进入就爱不释手。我承认，我就是被这东西的UI吸引的。。<span id="more"></span>&nbsp;来两张图吧。</p><div style="text-align: center;">  <a href="http://images.cy198706.com/Android/Screenshot_2012-11-15-14-11-57.png" target="_blank"><img alt="" src="http://images.cy198706.com/Android/Screenshot_2012-11-15-14-11-57.png" style="width: 480px; height: 854px;" /></a></div><p>Solid Explorer 的界面简洁高雅，除了强大的本地文件管理功能之外，它还能读取和操作远程电脑的文件共享和FTP/SFTP服务器等，甚至还能管理如 Dropbox、SkyDrive、Google Drive、Box 等云端网络硬盘，功能那是相当的全面。</p><div style="text-align: center;">  <a href="http://images.cy198706.com/Android/Screenshot_2012-11-15-14-12-21.png" target="_blank"><img alt="" src="http://images.cy198706.com/Android/Screenshot_2012-11-15-14-12-21.png" style="width: 480px; height: 854px;" /></a></div><p>最让我喜爱的还是它拥有的两个独立浏览面板（这也是它的最大的特色所在），你在一个文件夹中复制了某个文件后，滑动一下，就能转到另外一个文件夹，然后就剪贴过去就好了。</p><div style="text-align: center;">  <a href="http://images.cy198706.com/Android/Screenshot_2012-11-15-14-14-56.png" target="_blank"><img alt="" src="http://images.cy198706.com/Android/Screenshot_2012-11-15-14-14-56.png" style="width: 480px; height: 854px;" /></a></div><p>然后让人眼前一亮的是更改文件属性的页面，非常棒，很直观，还有md5校验的功能。</p><div style="text-align: center;">  <a href="http://images.cy198706.com/Android/Screenshot_2012-11-15-14-16-20.png" target="_blank"><img alt="" src="http://images.cy198706.com/Android/Screenshot_2012-11-15-14-16-20.png" style="width: 480px; height: 854px;" /></a></div><p>其实这小东西也算小众软件了，知晓的人并不多，用过的才知道^^ 最后附上个下载地址吧。<a href="http://www.coolapk.com/apk/5192/" target="_blank" title="低调的传送门">低调的传送门</a> &nbsp;</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elvis Aron Presley &amp;#8211; My Way</title>
      <link href="/2012-11-15//"/>
      <url>/2012-11-15//</url>
      
        <content type="html"><![CDATA[<p>悲伤的歌曲。</p><blockquote><p>《My Way》是一首欧美著名英文流行曲，旋律源自法国名曲Comme d’habitude（一如往日），法文原版由克罗德&middot;法兰索瓦（Claude Fran&ccedil;ois）、雅克&middot;赫霍（Jacques Revaux）及吉尔&middot;提伯（Gilles Thibaut）在1967年共同创作，随后由保罗&middot;安卡（Paul Anka）改编成英文版，1969年首次收录在法兰&middot;仙纳杜拉同名大碟，自此风靡全球。这首歌不但成为仙纳杜拉的代表作，在流行文化上亦常被用作为告别曲，表示一场表演的结束或一个人的离开。这亦是英国最受欢迎的丧礼挽曲。相比英文版哀伤的曲调，法文版的配乐则有忧伤、轻快、或摇滚版本。 &#8211;来自度娘</p></blockquote><p>其实这首歌本来不喜欢，但朋友无意间推荐了一下，又找了些背景资料，就喜欢上了。 这首歌蛮奇怪的。这首歌曲创作时，克罗德&middot;法兰索瓦刚刚与一位叫法兰丝&middot;盖尔（France Gall）的女子分手，心情抑郁，当他在友人前哼出这首歌的旋律后，他们一同编写歌词，表达克罗德失恋的心情，创作这首歌后的11年，他在浴缸中意外被电死，这也成为他的告别作。 这首歌最初改作英文版时，曾有不同歌词推出，其中当时初出道的大卫&middot;宝儿把歌词写成Even a Fool Learns to Love（傻子也学会爱），但保罗&middot;安卡最后买了法文版的旋律，1969年改成My Way，并交由美国著名歌手法兰&middot;仙纳杜拉演出这首歌，大卫&middot;宝儿的版本从未曾演出。 在西方流行乐坛中，经常把这首歌与离别刻意扯上关系，如&ldquo;猫王&rdquo;皮礼士利在1970年中期曾表演这首作品，不久后逝世，令乐迷引起遐思。此后，电影《盗亦有盗》（GoodFellas）以此作为闭幕歌曲；而德国前总理施罗德在离任时亦特别要求以此曲告别。 根据英国《卫报》的资料，这首歌已成了英国最常播放的丧礼歌曲；美国车手阿伦&middot;库尔威基（Alan Kulwicki）1993年离世后，他的友人也选了My Way为挽曲。歌曲中的I did it my way（我走我的路），亦成为家传户晓的座右铭。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 音乐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浮生若梦</title>
      <link href="/2012-11-13//"/>
      <url>/2012-11-13//</url>
      
        <content type="html"><![CDATA[<p><a href="http://images.cy198706.com/Android/boat-in-water.jpg" target="_blank"><img alt="" src="http://images.cy198706.com/Gabby/boat-in-water.jpg" /></a><br>图片很棒，分享之。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 口水, 图图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生活还是很美好</title>
      <link href="/2012-11-12//"/>
      <url>/2012-11-12//</url>
      
        <content type="html"><![CDATA[<p>昨晚跟媳妇聊了一晚上，感觉距离更近了，这种感觉让人发自内心地舒服。 爱你，老婆。<br><a href="http://img29.wal8.com/img29/310877_20121224145902/135634222435.jpg" target="_blank"><img alt="" src="http://images.cy198706.com/Gabby/she.jpg" style="width: 224px; height: 300px;" /></a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 口水 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>特别想回家</title>
      <link href="/2012-11-07//"/>
      <url>/2012-11-07//</url>
      
        <content type="html"><![CDATA[<p>现在回家要1个小时，很累。 想早点回去见媳妇。&nbsp;<br><a href="http://images.cy198706.com/Gabby/97c2ba7c8c52eddc6f2a2c2b5a781fb6.jpg" target="_blank"><img alt="" src="http://images.cy198706.com/Gabby/97c2ba7c8c52eddc6f2a2c2b5a781fb6.jpg" style="width: 610px;" /></a><br>=。=这是网上找的图片</p>]]></content>
      
      
      
        <tags>
            
            <tag> 口水 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
