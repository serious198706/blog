<!DOCTYPE html><html class="appearance-user-can-set" lang="zh"><head><meta charset="UTF-8"><title>Notex</title><meta name="description" content="Keep low profile, he said."><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="注意：本笔记为设计模式核心学习笔记，为笔者快速复习和回顾设计模式时使用，更详细的教程请查看更专业的设计模式教程。



一、设计模式六大原则设计模式有六大原则，如下所示：

单一职责原则
开放封闭原则
里氏替换原则
依赖倒置
迪米特原则
接口隔离原则

单一职责原则一个类应该仅有一个引起它变化的原因，即不要让一个类承担过多的职责，以此降低耦合性。
开放封闭原则类、函数、模块应该是可以扩展的，但是不可以修改，即对扩展开放，修改封闭。
里氏替换原则所有引用基类的地方都能透明地替换为子类对象，即可以在定义时尽量使用基类对象，等到运行时再确定其子类类型，用子类对象来替换父类对象。
依赖倒置原则高层、底层模块、模块间和细节都应该依赖于抽象，即通过接口或抽象类产生依赖关系。
迪米特原则一个软件实体应该尽可能少地与其它实.."><script src="//unpkg.com/valine/dist/Valine.min.js"></script><meta name="generator" content="Hexo 5.4.2"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><!-- a(href= url_for("/"))= (theme.user && theme.user.name || config.author) + "'s blog"--><a href="/">Notex</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">开发者必须掌握的设计模式</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">主页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">主页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99"><span class="toc-text">一、设计模式六大原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99"><span class="toc-text">单一职责原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E6%94%BE%E5%B0%81%E9%97%AD%E5%8E%9F%E5%88%99"><span class="toc-text">开放封闭原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99"><span class="toc-text">里氏替换原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99"><span class="toc-text">依赖倒置原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AA%E7%B1%B3%E7%89%B9%E5%8E%9F%E5%88%99"><span class="toc-text">迪米特原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99"><span class="toc-text">接口隔离原则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB"><span class="toc-text">二、设计模式分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Android%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">三、Android开发常用设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">1、创建型设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-text">单例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E9%A5%BF%E6%B1%89%E6%A8%A1%E5%BC%8F"><span class="toc-text">1、饿汉模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F%EF%BC%88%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%89"><span class="toc-text">2、懒汉模式（线程安全）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E6%A8%A1%E5%BC%8F%EF%BC%88DCL%EF%BC%89"><span class="toc-text">3、双重检查模式（DCL）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-text">4、静态内部类单例模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81%E6%9E%9A%E4%B8%BE%E5%8D%95%E4%BE%8B"><span class="toc-text">5、枚举单例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%88%E8%A1%A5%E5%85%85%EF%BC%89"><span class="toc-text">简单工厂模式（补充）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B"><span class="toc-text">简单示例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="toc-text">工厂方法模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B-1"><span class="toc-text">简单示例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-text">建造者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B-2"><span class="toc-text">简单示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E7%BB%93%E6%9E%84%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">2、结构型设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-text">1、代理模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-text">静态代理示例代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-text">动态代理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-text">动态代理示例代码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F"><span class="toc-text">装饰模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-text">示例代码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%EF%BC%88%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="toc-text">外观模式（门面模式）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B-3"><span class="toc-text">简单示例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F"><span class="toc-text">享元模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B-4"><span class="toc-text">简单示例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-text">适配器模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B-5"><span class="toc-text">简单示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">3、行为型设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="toc-text">1、策略模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B-6"><span class="toc-text">简单示例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="toc-text">2、模板方法模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B-7"><span class="toc-text">简单示例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="toc-text">3、观察者模式（发布 - 订阅模式）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B-8"><span class="toc-text">简单示例</span></a></li></ol></li></ol></li></ol></li></ol></div><div class="column is-9"><header class="my-4"></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">开发者必须掌握的设计模式</h1><time class="has-text-grey" datetime="2020-09-08T16:00:00.000Z">2020-09-09</time><article class="mt-2 post-content"><p>注意：本笔记为设计模式核心学习笔记，为笔者快速复习和回顾设计模式时使用，更详细的教程请查看更专业的设计模式教程。</p>
<span id="more"></span>


<h2 id="一、设计模式六大原则"><a href="#一、设计模式六大原则" class="headerlink" title="一、设计模式六大原则"></a>一、设计模式六大原则</h2><p>设计模式有六大原则，如下所示：</p>
<ul>
<li>单一职责原则</li>
<li>开放封闭原则</li>
<li>里氏替换原则</li>
<li>依赖倒置</li>
<li>迪米特原则</li>
<li>接口隔离原则</li>
</ul>
<h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>一个类应该仅有一个引起它变化的原因，即不要让一个类承担过多的职责，以此降低耦合性。</p>
<h3 id="开放封闭原则"><a href="#开放封闭原则" class="headerlink" title="开放封闭原则"></a>开放封闭原则</h3><p>类、函数、模块应该是可以扩展的，但是不可以修改，即对扩展开放，修改封闭。</p>
<h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><p>所有引用基类的地方都能透明地替换为子类对象，即可以在定义时尽量使用基类对象，等到运行时再确定其子类类型，用子类对象来替换父类对象。</p>
<h3 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h3><p>高层、底层模块、模块间和细节都应该依赖于抽象，即通过接口或抽象类产生依赖关系。</p>
<h3 id="迪米特原则"><a href="#迪米特原则" class="headerlink" title="迪米特原则"></a>迪米特原则</h3><p>一个软件实体应该尽可能少地与其它实体发生相互作用，即最少知识原则。</p>
<p>如果一个对象需要调用其它对象的某个方法，可以通过第三者来调用，这个第三者的作用就如Android中的事件总线EventBus一样。</p>
<h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><p>一个类对另一个类的依赖应该建立在最小的接口上。</p>
<h2 id="二、设计模式分类"><a href="#二、设计模式分类" class="headerlink" title="二、设计模式分类"></a>二、设计模式分类</h2><p>GoF提出的设计模式有23种，按照目的准则分类，有三大类：</p>
<ul>
<li>创建性设计模式5种：单例、工厂方法、抽象工厂、建造者、原型。</li>
<li>结构型设计模式7种：适配器、装饰、代理、外观、桥接、组合、享元。</li>
<li>行为型设计模式11种：策略、模板方法、观察者、迭代器、责任链、命令、备忘录、状态、访问者、中介者、解释器。</li>
</ul>
<h2 id="三、Android开发常用设计模式"><a href="#三、Android开发常用设计模式" class="headerlink" title="三、Android开发常用设计模式"></a>三、Android开发常用设计模式</h2><h3 id="1、创建型设计模式"><a href="#1、创建型设计模式" class="headerlink" title="1、创建型设计模式"></a>1、创建型设计模式</h3><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>保证一个类仅有一个实例，提供一个访问它的全局访问点。</p>
<p>单例模式共有5种写法：</p>
<h5 id="1、饿汉模式"><a href="#1、饿汉模式" class="headerlink" title="1、饿汉模式"></a>1、饿汉模式</h5><pre><code class="java">public class Singleton &#123;
    private static Singleton instance = new Singleton;
    private Singleton () &#123;
        
    &#125;
    public static Singleton getInstance() &#123;
        return instance;
    &#125;
&#125;
</code></pre>
<ul>
<li>在类加载的时候就完成实例化，如果从始至终未使用这个实例，则会造成内存的浪费。</li>
</ul>
<h5 id="2、懒汉模式（线程安全）"><a href="#2、懒汉模式（线程安全）" class="headerlink" title="2、懒汉模式（线程安全）"></a>2、懒汉模式（线程安全）</h5><pre><code class="java">public class Singletion &#123;
    private static Singleton instance;
    private Singleton () &#123;
    &#125;
    public static synchronized Singleton getInstance() &#123;
        if (instance == null) &#123;
            instance = new Singleton();
        &#125;
        return instance;
    &#125;
&#125;
</code></pre>
<ul>
<li>为了处理并发，每次调用getInstance方法时都需要进行同步，会有不必要的同步开销。</li>
</ul>
<h5 id="3、双重检查模式（DCL）"><a href="#3、双重检查模式（DCL）" class="headerlink" title="3、双重检查模式（DCL）"></a>3、双重检查模式（DCL）</h5><pre><code class="java">public class Singleton &#123;
    private static volatile Singleton instance;
    private Singleton &#123;
    &#125;
    public static Singleton getInstance() &#123;
        if (instance == null) &#123;
            synchronized (Singleton.class) &#123;
                if (instance == null) &#123;
                    instance = new Singleton();
                &#125;
            &#125;
        &#125;
        return instance;
    &#125;
&#125;
</code></pre>
<ul>
<li>第一次判空，省去了不必要的同步。第二次是在Singleton等于空时才创建实例。</li>
<li>使用volatile保证了实例的可见性。</li>
<li>DCL在一定程度上解决了资源的消耗和多余的同步、线程安全等问题，但是在某些情况下会失效。</li>
</ul>
<p>假设线程A执行到instance = new Singleton()语句，看起来只有一行代码，但实际上它并不是原子操作，这句代码最终会被编译成多条汇编指令，它大致做了3件事：</p>
<p>1）给instance的实例分配内存。</p>
<p>2）调用Singleton()构造函数，初始化成员字段。</p>
<p>3）将instance对象指向分配的内存空间（此时instance就不是null了）。</p>
<p>但是，由于Java编译器允许处理器乱序执行，以及JDK1.5之前JMM中的Cache、寄存器到主内存回写顺序的规定，上面的2和3的顺序是无法保证的，也就是说，执行顺序可能是1-2-3也可能是1-3-2。如果是后者，并且在3执行完毕、2未执行之前，被切换到线程B上，这时候instance因为已经在线程A内执行过了3，instance已经是非空了，所以，线程B直接取走instance，再使用时就会出错，这就是DCL失效问题，而且这种难以跟踪难以重现的错误可能会隐藏很久。</p>
<p>在JDK1.5之后，SUN官方已经注意到这种问题，调整了JVM，具体化了volatile关键字，因此，如果JDK1.5或之后的版本，只需要将instance的定义改成private volatile static Singleton instance = null就可以保证instance对象每次都是从主内存中读取，就可以使用DCL的写法来完成单例模式。当然，volatile或多或少也会影响到性能，但考虑到程序的正确性，这点牺牲也是值得的。</p>
<p>DCL优点：资源利用率高，第一次执行getInstance时单例对象才会被实例化，效率高。</p>
<p>缺点：第一次加载稍慢，也由于JMM的原因导致偶尔会失败。在高并发环境下也有一定的缺陷，虽然发生概率很小。DCL模式是使用最多的单例实现方式，它能够在需要时才实例化对象，并且能在绝大多数场景下保证对象的唯一性，除非你的代码在并发场景比较复杂或低于JDK1.6版本下使用，否则，这种方式一般能够满足要求。</p>
<h5 id="4、静态内部类单例模式"><a href="#4、静态内部类单例模式" class="headerlink" title="4、静态内部类单例模式"></a>4、静态内部类单例模式</h5><pre><code class="java">public class Singleton() &#123;
    private Singleton() &#123;
    &#125;
    public static Singleton getInstance() &#123;
        return SingletonHolder.sInstance;
    &#125;
    private static class SingletonHolder &#123;
        private static final Singleton sInstance = new Singleton();
    &#125;
&#125;
</code></pre>
<ul>
<li>第一次调用getInstance方法时虚拟机才加载SingletonHolder并初始化sInstance，这样保证了线程安全和实例的唯一性。</li>
</ul>
<h5 id="5、枚举单例"><a href="#5、枚举单例" class="headerlink" title="5、枚举单例"></a>5、枚举单例</h5><pre><code class="java">public enum Singleton &#123;
    INSTANCE;
    public void doSomeThing() &#123;
    &#125;
&#125;
</code></pre>
<ul>
<li>默认枚举实例的创建是线程安全的，并且在任何情况下都是单例。</li>
<li>简单、可读性不高。</li>
</ul>
<p>注意：上面的几种单例模式创建的单例对象被反序列化时会重新创建实例，可以重写readReslove方法返回当前的单例对象。</p>
<h4 id="简单工厂模式（补充）"><a href="#简单工厂模式（补充）" class="headerlink" title="简单工厂模式（补充）"></a>简单工厂模式（补充）</h4><p>也称为静态工厂方法模式，由一个工厂对象决定创建出哪一种产品类的实例。</p>
<p>简单工厂模式中有如下角色：</p>
<ul>
<li>工厂类：核心，负责创建所有实例的内部逻辑，由外界直接调用。</li>
<li>抽象产品类：要创建所有对象的抽象父类，负责描述所有实例所共有的公共接口。</li>
<li>具体产品类：要创建的产品。</li>
</ul>
<h5 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h5><p>1、抽象产品类</p>
<pre><code class="java">public abstract class Computer &#123;
    public abstarct void start();
&#125;
</code></pre>
<p>2、具体产品类</p>
<pre><code class="java">public class LenovaComputer extends Computer &#123;
    @Override
    public void start() &#123;
        ...
    &#125;
&#125;

public class HpComputer extends Computer &#123;
    @Override
    public void start() &#123;
        ...
    &#125;
&#125;

public class AsusComputer extends Computer &#123;
    @Override
    public void start() &#123;
        ...
    &#125;
&#125;
</code></pre>
<p>3、工厂类</p>
<pre><code class="java">public class ComputerFactory &#123;
    public static Computer createComputer(String type) &#123;
        Computer mComputer = null;
        switch (type) &#123;
            case &quot;lenovo&quot;:
                mComputer = new LenovoComputer();
                break;
            case &quot;hp&quot;:
                mComputer = new HpComputer();
                break;
            case &quot;asus&quot;:
                mComputer = new AsusComputer();
                break;
        &#125;
        return mComputer;
    &#125;
&#125;
</code></pre>
<ul>
<li>它需要知道所有工厂类型，因此只适合工厂类负责创建的对象比较少的情况。</li>
<li>避免直接实例化类，降低耦合性。</li>
<li>增加新产品需要修改工厂，违背开放封闭原则。</li>
</ul>
<h4 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h4><p>定义一个用于创建对象的接口，使类的实例化延迟到子类。</p>
<p>工厂方法有以下角色：</p>
<ul>
<li>抽象产品类。</li>
<li>具体产品类。</li>
<li>抽象工厂类：返回一个泛型的产品对象。</li>
<li>具体工厂类：返回具体的产品对象。</li>
</ul>
<h5 id="简单示例-1"><a href="#简单示例-1" class="headerlink" title="简单示例"></a>简单示例</h5><p>抽象产品类和具体产品类同简单工厂一样。</p>
<p>3、抽象工厂类</p>
<pre><code class="java">public abstract class ComputerFactory &#123;
    public abstract &lt;T extends Computer&gt; T createComputer(Class&lt;T&gt; clz);
&#125;
</code></pre>
<p>4、具体工厂类</p>
<pre><code class="java">public class GDComputerFactory extends ComputerFactory &#123;
    @Override
    public &lt;T extends Computer&gt; T createComputer(Class&lt;T&gt; clz) &#123;
        Computer computer = null;
        String classname = clz.getName();
        try &#123;
            computer = (Computer) Class.forName(classname).newInstance();
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
        return (T) computer;
    &#125;
&#125;
</code></pre>
<ul>
<li>相比简单工厂，如果我们需要新增产品类，无需修改工厂类，直接创建产品即可。</li>
</ul>
<h4 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h4><p>将一个复杂对象的构建和它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
<p>建造者有以下角色：</p>
<ul>
<li>导演类：负责安排已有模块的安装顺序，最后通知建造者开始建造。</li>
<li>建造者：抽象Builder类，用于规范产品的组建。</li>
<li>具体建造者：实现抽象Builder类的所有方法，并返回建造好的对象。</li>
<li>产品类。</li>
</ul>
<h5 id="简单示例-2"><a href="#简单示例-2" class="headerlink" title="简单示例"></a>简单示例</h5><p>1、产品类</p>
<pre><code class="java">public class Computer &#123;
    private String mCpu;
    private Stiring mMainboard;
    private String mRam;
    public void setmCpu(String mCpu) &#123;
        this.mCpu = mCpu;
    &#125;
    public void setmMainboard(String mMainboard) &#123;
        this.mMainboard = mMainboard;
    &#125;
    public void setmRam(String mRam) &#123;
        this.mRam = mRam;
    &#125;
&#125;
</code></pre>
<p>2、抽象建造者</p>
<pre><code class="java">public abstract class Builder &#123;
    public abstract void buildCpu(String cpu);
    public abstract void buildMainboard(String mainboard);
    public abstract void buildRam(String ram);
    public abstract Computer create();
&#125;
</code></pre>
<p>3、具体建造者</p>
<pre><code class="java">public class MoonComputerBuilder extends Builder &#123;
    private Computer mComputer = new Computer();
    
    @Override
    public void buildCpu(String cpu) &#123;
        mComputer.setmCpu(cpu);
    &#125;
    
    @Override
    public void buildMainboard(String mainboard) &#123;
        mComputer.setmMainboard(mainboard);
    &#125;
    
    @Override
    public void buildRam(String ram) &#123;
        mComputer.setmRam(ram);
    &#125;
    
    @Override
    public Computer create() &#123;
        return mComputer;
    &#125;
&#125;
</code></pre>
<p>4、导演类</p>
<pre><code class="java">public class Director &#123;
    Builder mBuilder = null;
    public Director (Builder builder) &#123;
        this.mBuilder = builder;
    &#125;
    
    public Computer createComputer(String cpu, String mainboard, String ram) &#123;
        this.mBuilder.buildCpu(cpu);
        this.mBuilder.buildMainboard(mainboard);
        this.mBuilder.buildRam(ram);
        return mBuilder.create();
    &#125;
&#125;
</code></pre>
<ul>
<li>屏蔽产品内部组成细节。</li>
<li>具体建造者类之间相互独立，容易扩展。</li>
<li>会产生多余的建造者对象和导演类。</li>
</ul>
<h3 id="2、结构型设计模式"><a href="#2、结构型设计模式" class="headerlink" title="2、结构型设计模式"></a>2、结构型设计模式</h3><h4 id="1、代理模式"><a href="#1、代理模式" class="headerlink" title="1、代理模式"></a>1、代理模式</h4><p>为其它对象提供一种代理以控制这个对象的访问。</p>
<p>代理模式中有以下角色：</p>
<ul>
<li>抽象主题类：声明真实主题和代理的共同接口方法。</li>
<li>真实主题类。</li>
<li>代理类：持有对真实主题类的引用。</li>
<li>客户端类。</li>
</ul>
<h5 id="静态代理示例代码"><a href="#静态代理示例代码" class="headerlink" title="静态代理示例代码"></a>静态代理示例代码</h5><p>1、抽象主题类</p>
<pre><code class="java">public interface IShop &#123;
    void buy();
&#125;
</code></pre>
<p>2、真实主题类</p>
<pre><code class="java">public class JsonChao implements IShop &#123;
    @Override 
    public void buy() &#123;
        ...
    &#125;
&#125;
</code></pre>
<p>3、代理类</p>
<pre><code class="java">public class Purchasing implements IShop &#123;
    private IShop mShop;
    public Purchasing(IShop shop) &#123;
        this.mShop = shop;
    &#125;
    
    @Override 
    public void buy() &#123;
        mShop.buy();
    &#125;
&#125;
</code></pre>
<p>4、客户端类</p>
<pre><code class="java">public class Clent &#123;
    
    public static void main(String[] args) &#123;
        IShop jsonChao = new JsonChao();
        IShop purchasing = new Purchasing(jsonChao);
        purchasing.buy();
    &#125;
&#125;
</code></pre>
<h5 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h5><p>在代码运行时通过反射来动态地生成代理类的对象，并确定到底来代理谁。</p>
<h5 id="动态代理示例代码"><a href="#动态代理示例代码" class="headerlink" title="动态代理示例代码"></a>动态代理示例代码</h5><p>改写静态代理的代理类和客户端类，如下所示：</p>
<p>1、动态代理类</p>
<pre><code class="java">public class DynamicPurchasing implements InvocationHandler &#123;
    private Object obj;
    public DynamicPurchasing(Object obj) &#123;
        this.obj = obj;
    &#125;
    
    @Overrdie
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;
        return method.invoke(obj, args);
    &#125;
&#125;
</code></pre>
<p>2、客户端类</p>
<pre><code class="java">public class Clent &#123;
    
    public static void main(String[] args) &#123;
        IShop jsonChao = new JsonChao();
        DynamicPurchasing mDynamicPurchasing = new DynamicPurchasing(jsonChao);
        ClassLoader cl = jsonChao.getClass.getClassLoader();
        IShop purchasing = Proxy.newProxyInstance(cl, new Class[]&#123;IShop.class&#125;, mDynamicPurchasing);
        purchasing.buy();
    &#125;
&#125;
</code></pre>
<ul>
<li>真实主题类发生变化时，由于它实现了公用的接口，因此代理类不需要修改。</li>
</ul>
<h4 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h4><p>动态地给一个对象添加一些额外的职责。</p>
<p>装饰模式有以下角色：</p>
<ul>
<li>抽象组件：接口/抽象类，被装饰的最原始的对象。</li>
<li>具体组件：被装饰的具体对象。</li>
<li>抽象装饰者：扩展抽象组件的功能。</li>
<li>具体装饰者：装饰者具体实现类。</li>
</ul>
<h5 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h5><p>1、抽象组件</p>
<pre><code class="java">public abstract class Swordsman &#123;
    public abstract void attackMagic();
&#125;
</code></pre>
<p>2、具体组件</p>
<pre><code class="java">public class YangGuo extends Swordsman &#123;
    @Override
    public void attackMagic() &#123;
        ...
    &#125;
&#125;
</code></pre>
<p>3、抽象装饰者</p>
<p>抽象装饰者必须持有抽象组件的引用，以便扩展功能。</p>
<pre><code class="java">public abstract class Master extends Swordsman &#123;
    private Swordsman swordsman;
    public Master(Swordsman swordsman) &#123;
        this.swordman = swordman;
    &#125;
    
    @Override
    public void attackMagic() &#123;
        swordsman.attackMagic();
    &#125;
&#125;
</code></pre>
<p>4、具体装饰者</p>
<pre><code class="java">public class HongQiGong extends Master &#123;
    public HongQiGong(Swordsman swordsman) &#123;
        this.swordsman = swordsman;
    &#125;
    
    public void teachAttackMagic() &#123;
        ...
    &#125;
    
    @Override
    public void attackMagic() &#123;
        super.attackMagic();
        teackAttackMagic();
    &#125;
&#125;
</code></pre>
<p>5、使用</p>
<pre><code class="java">YangGuo mYangGuo = new YangGuo();
HongQiGong mHongQiGong = new HongQiGong(mYangGuo);
mHongQiGong.attackMagic();
</code></pre>
<ul>
<li>使用组合，动态地扩展对象的功能，在运行时能够使用不同的装饰器实现不同的行为。</li>
<li>比继承更易出错，旨在必要时使用。</li>
</ul>
<h4 id="外观模式（门面模式）"><a href="#外观模式（门面模式）" class="headerlink" title="外观模式（门面模式）"></a>外观模式（门面模式）</h4><p>一个子系统的内部和外部通信必须通过一个统一的对象进行。即提供一个高层的接口，方便子系统更易于使用。</p>
<p>外观模式有以下角色：</p>
<ul>
<li>外观类：将客户端的请求代理给适当的子系统对象。</li>
<li>子系统类：可以有一个或多个子系统，用于处理外观类指派的任务。注意子系统不含外观类的引用。</li>
</ul>
<h5 id="简单示例-3"><a href="#简单示例-3" class="headerlink" title="简单示例"></a>简单示例</h5><p>1、子系统类（这个有三个子系统）</p>
<pre><code class="java">public class ZhaoShi &#123;
    public void TaiJiQuan() &#123;
        ...
    &#125;
    
    public void QiShanQuan() &#123;
        ...
    &#125;
    
    public void ShengHuo() &#123;
        ...
    &#125;
&#125;

public class NeiGong &#123;
    public void JiuYang() &#123;
        ...
    &#125;
    
    public void QianKun() &#123;
        ...
    &#125;
&#125;

public class JingMai &#123;
    public void JingMai() &#123;
        ...
    &#125;
&#125;
</code></pre>
<p>2、外观类</p>
<pre><code class="java">public class ZhangWuJi &#123;
    private ZhaoShi zhaoShi;
    private JingMai jingMai;
    pirvate Neigong neiGong;
    
    public ZhangWuJi() &#123;
        zhaoShi = new ZhaoShi();
        jingMai = new JingMai();
        neiGong = new NeiGong();
    &#125;
    
    public void qianKun() &#123;
        jingMai.JingMai();
        neiGong.QianKun();
    &#125;
    
    public void qiShang() &#123;
        jingMai.JingMai();
        neiGong.JiuYang();
        zhaoShi.QiShangQuan();
    &#125;
&#125;
</code></pre>
<p>3、使用</p>
<pre><code class="java">ZhangWuJi zhangWuJi = new ZhangWuJi();
zhangWuJi.QianKun();
zhangWuJi.QiShang();
</code></pre>
<ul>
<li>将对子系统的依赖转换为对外观类的依赖。</li>
<li>对外部隐藏子系统的具体实现。</li>
<li>这种外观特性增强了安全性。</li>
</ul>
<h4 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h4><p>使用共享对象有效支持大量细粒度（性质相似）的对象。</p>
<p>额外的两个概念：</p>
<ul>
<li>1、内部状态：共享信息，不可改变。</li>
<li>2、外部状态：依赖标记，可以改变。</li>
</ul>
<p>享元模式有以下角色：</p>
<ul>
<li>抽象享元角色：定义对象内部和外部状态的接口。</li>
<li>具体享元角色：实现抽象享元角色的任务。</li>
<li>享元工厂：管理对象池及创建享元对象。</li>
</ul>
<h5 id="简单示例-4"><a href="#简单示例-4" class="headerlink" title="简单示例"></a>简单示例</h5><p>1、抽象享元角色</p>
<pre><code class="java">public interface IGoods &#123;
    public void showGoodsPrice(String name);
&#125;
</code></pre>
<p>2、具体享元角色</p>
<pre><code class="java">public class Goods implements IGoods &#123;
    private String name;
    private String price;
    
    Goods (String name) &#123;
        this.name = name;
    &#125;
    
    @Override
    public void showGoodsPrice(String name) &#123;
        ...
    &#125;
&#125;
</code></pre>
<p>3、享元工厂</p>
<pre><code class="java">public class GoodsFactory &#123;
    private static Map&lt;String, Goods&gt; pool = new HashMap&lt;String, Goods&gt;();
    public static Goods getGoods(String name) &#123;
        if (pool.containsKey(name)) &#123;
            return pool.get(name);
        &#125; else &#123;
            Goods goods = new Goods(name);
            pool.put(name, goods);
            return goods;
        &#125;
    &#125;
&#125;
</code></pre>
<p>4、使用</p>
<pre><code class="java">Goods goods1 = GoodsFactory.getGoods(&quot;Android进阶之光&quot;);
goods1.showGoodsPrice(&quot;普通版&quot;);
Goods goods2 = GoodsFactory.getGoods(&quot;Android进阶之光&quot;);
goods1.showGoodsPrice(&quot;普通版&quot;);
Goods goods3 = GoodsFactory.getGoods(&quot;Android进阶之光&quot;);
goods1.showGoodsPrice(&quot;签名版&quot;);
</code></pre>
<p>goods1为新创建的对象，后面的都是从对象池中取出的缓存对象。</p>
<h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><p>将一个接口转换为另一个需要的接口。</p>
<p>适配器有以下角色：</p>
<ul>
<li>要转换的接口。</li>
<li>要转换的接口的实现类。</li>
<li>转换后的接口。</li>
<li>转换后的接口的实现类。</li>
<li>适配器类。</li>
</ul>
<h5 id="简单示例-5"><a href="#简单示例-5" class="headerlink" title="简单示例"></a>简单示例</h5><p>1、要转换的接口（火鸡）</p>
<pre><code class="java">public interface Turkey &#123;
    public void gobble();
    public void fly();
&#125;
</code></pre>
<p>2、要转换的接口的实现类</p>
<pre><code class="java">public class WildTurkey implements Turkey &#123;
    @Override
    public void gobble() &#123;
        ...
    &#125;
    
    @Override
    public void fly() &#123;
        ...
    &#125;
&#125;
</code></pre>
<p>3、转换后的接口（鸭子）</p>
<pre><code class="java">public interface Duck &#123;
    public void quack();
    public void fly();
&#125;
</code></pre>
<p>4、转换后的接口的实现类。</p>
<pre><code class="java">public class MallardDuck implements Duck &#123;
    @Override
    public void quack() &#123;
        ...
    &#125;
    
    @Overrdie
    public void fly() &#123;
        ...
    &#125;
&#125;
</code></pre>
<p>5、适配器类</p>
<pre><code class="java">public class TurkeyAdapter implements Duck &#123;
    Turkey turkey;
    
    public TurkeyAdapter(Turkey turkey) &#123;
        this.turkey = turkey;
    &#125;
    
    @Override
    public void quack() &#123;
        turkey.gobble();
    &#125;
    
    @Override
    public void fly() &#123;
        // 火鸡没有鸭子飞的远，因此多飞几次，达到适配鸭子fly的作用
        for(int i;i &lt; 5;i++) &#123;
            turkey.fly();
        &#125;
    &#125;
&#125;
</code></pre>
<p>6、使用</p>
<pre><code class="java">WildTurkey wildTurkey = new WildTurkey();
TurkeyAdapter turkeyAdapter = new TurkeyAdapter(wildTurkey);
turkeyAdapter.quack();
turkeyAdapter.fly();
</code></pre>
<ul>
<li>注重适度使用即可。</li>
</ul>
<h3 id="3、行为型设计模式"><a href="#3、行为型设计模式" class="headerlink" title="3、行为型设计模式"></a>3、行为型设计模式</h3><h4 id="1、策略模式"><a href="#1、策略模式" class="headerlink" title="1、策略模式"></a>1、策略模式</h4><p>定义一系列的算法，将每一个算法都封装起来，并且可相互替换。这使得算法可以独立于调用者而单独变化。</p>
<p>策略模式有以下角色：</p>
<ul>
<li>上下文角色：用来操作策略使用的上下文环境。屏蔽了高层模块对策略和算法的直接访问。</li>
<li>抽象策略角色。</li>
<li>具体策略角色。</li>
</ul>
<h5 id="简单示例-6"><a href="#简单示例-6" class="headerlink" title="简单示例"></a>简单示例</h5><p>1、抽象策略角色</p>
<pre><code class="java">public interface FightingStrategy &#123;
    public void fighting();
&#125;
</code></pre>
<p>2、具体策略角色</p>
<pre><code class="java">public class WeakRivalStrategy implements FightingStrategy &#123;
    
    @Override
    public void fighting() &#123;
        ...
    &#125;
&#125;

public class CommonRivalStrategy implements FightingStrategy &#123;
    
    @Override
    public void fighting() &#123;
        ...
    &#125;
&#125;

public class StrongRivalStrategy implements FightingStrategy &#123;
    
    @Override
    public void fighting() &#123;
        ...
    &#125;
&#125;
</code></pre>
<p>3、上下文角色</p>
<pre><code class="java">public class Context &#123;
    private FightingStrategy mFightingStrategy;
    
    public void Context(FightingStrategy fightingStrategy) &#123;
        this.mFightingStrategy = fightingStrategy;
    &#125;
    
    public void fighting() &#123;
        mFightingStrategy.fighting();
    &#125;
&#125;
</code></pre>
<p>4、使用</p>
<pre><code class="java">Context context;
context = new Context(new WeakRivalStrategy());
context.fighting();
context = new Context(new CommonRivalStategy());
context.fighting();
context = new Context(new StrongRivalStategy());
context.fighting();
</code></pre>
<ul>
<li>隐藏具体策略中算法的实现细节。</li>
<li>避免使用多重条件语句。</li>
<li>易于扩展</li>
<li>每一个策略都是一个类，复用性小。</li>
<li>上层模块必须知道有哪些策略类，与迪米特原则相违背。</li>
</ul>
<h4 id="2、模板方法模式"><a href="#2、模板方法模式" class="headerlink" title="2、模板方法模式"></a>2、模板方法模式</h4><p>定义了一套算法框架，将某些步骤交给子类去实现。使得子类不需改变框架结构即可重写算法中的某些步骤。</p>
<p>模板方法模式有以下角色：</p>
<ul>
<li>抽象类：定义了一套算法框架。</li>
<li>具体实现类。</li>
</ul>
<h5 id="简单示例-7"><a href="#简单示例-7" class="headerlink" title="简单示例"></a>简单示例</h5><p>1、抽象类</p>
<pre><code class="java">public abstract class AbstractSwordsman &#123;

    public final void fighting() &#123;
        neigong();
        
        // 这个是具体方法
        jingmai();
        
        if (hasWeapons()) &#123;
            weapons();
        &#125;
        
        moves();
        
        hook();
    &#125;
    
    protected void hook() &#123; &#125;;
    protected void abstract neigong();
    protected void abstract weapons();
    protected void abstract moves();
    public void jingmai() &#123;
        ...
    &#125;
    
    protected boolean hasWeapons() &#123;
        return ture;
    &#125;
&#125;
</code></pre>
<p>2、具体实现类</p>
<pre><code class="java">public class ZhangWuJi extends AbstractSwordsman &#123;
    
    @Override
    public void neigong() &#123;
        ...
    &#125;
    
    @Override 
    public void weapons() &#123;
        // 没有武器，不做处理
    &#125;
    
    @Override 
    public void moves() &#123;
        ...
    &#125;
    
    @Override
    public boolean hasWeapons() &#123;
        return false;
    &#125;
&#125;

public class ZhangSanFeng extends AbstractSwordsman &#123;
    
    @Override
    public void neigong() &#123;
        ...
    &#125;
    
    @Override 
    public void weapons() &#123;
        ...
    &#125;
    
    @Override 
    public void moves() &#123;
        ...
    &#125;
    
    @Override
    public void hook() &#123;
        // 额外处理
        ...
    &#125;
&#125;
</code></pre>
<p>3、使用</p>
<pre><code class="java">ZhangWuJi zhangWuJi = new ZhangWuJi();
zhangWuJi.fighting();
ZhangSanFeng zhangSanFeng = new ZhangSanFeng();
zhangSanFeng.fighting();
</code></pre>
<ul>
<li>可以使用hook方法实现子类对父类的反向控制。</li>
<li>可以把核心或固定的逻辑搬移到基类，其它细节交给子类实现。</li>
<li>每个不同的实现都需要定义一个子类，复用性小。</li>
</ul>
<h4 id="3、观察者模式（发布-订阅模式）"><a href="#3、观察者模式（发布-订阅模式）" class="headerlink" title="3、观察者模式（发布 - 订阅模式）"></a>3、观察者模式（发布 - 订阅模式）</h4><p>定义对象间的一种1对多的依赖关系，每当这个对象的状态改变时，其它的对象都会接收到通知并被自动更新。</p>
<p>观察者模式有以下角色：</p>
<ul>
<li>抽象被观察者：将所有已注册的观察者对象保存在一个集合中。</li>
<li>具体被观察者：当内部状态发生变化时，将会通知所有已注册的观察者。</li>
<li>抽象观察者：定义了一个更新接口，当被观察者状态改变时更新自己。</li>
<li>具体被观察者：实现抽象观察者的更新接口。</li>
</ul>
<h5 id="简单示例-8"><a href="#简单示例-8" class="headerlink" title="简单示例"></a>简单示例</h5><p>1、抽象观察者</p>
<pre><code class="java">public interface observer &#123;
    
    public void update(String message);
&#125;
</code></pre>
<p>2、具体观察者</p>
<pre><code class="java">public class WeXinUser implements observer &#123;
    private String name;
    
    public WeXinUser(String name) &#123;
        this.name = name;
    &#125;
    
    @Override
    public void update(String message) &#123;
        ...
    &#125;
&#125;
</code></pre>
<p>3、抽象被观察者</p>
<pre><code class="java">public interface observable &#123;
    
    public void addWeXinUser(WeXinUser weXinUser);
    
    public void removeWeXinUser(WeXinUser weXinUser);
    
    public void notify(String message);
&#125;
</code></pre>
<p>4、具体被观察者</p>
<pre><code class="java">public class Subscription implements observable &#123;
    private List&lt;WeXinUser&gt; mUserList = new ArrayList();

    @Override
    public void addWeXinUser(WeXinUser weXinUser) &#123;
        mUserList.add(weXinUser);
    &#125;

    @Override
    public void removeWeXinUser(WeXinUser weXinUser) &#123;
        mUserList.remove(weXinUser);
    &#125;

    @Override
    public void notify(String message) &#123;
        for(WeXinUser weXinUser : mUserList) &#123;
            weXinUser.update(message);
        &#125;
    &#125;
&#125;
</code></pre>
<p>5、使用</p>
<pre><code class="java">Subscription subscription = new Subscription();

WeXinUser hongYang = new WeXinUser(&quot;HongYang&quot;);
WeXinUser rengYuGang = new WeXinUser(&quot;RengYuGang&quot;);
WeXinUser liuWangShu = new WeXinUser(&quot;LiuWangShu&quot;);

subscription.addWeiXinUser(hongYang);
subscription.addWeiXinUser(rengYuGang);
subscription.addWeiXinUser(liuWangShu);
subscription.notify(&quot;New article coming&quot;);
</code></pre>
<ul>
<li>实现了观察者和被观察者之间的抽象耦合，容易扩展。</li>
<li>有利于建立一套触发机制。</li>
<li>一个被观察者卡顿，会影响整体的执行效率。采用异步机制可解决此类问题。</li>
</ul>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/Java/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81/" title="Java 中线程的状态及转换"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">Previous: Java 中线程的状态及转换</span></a><a class="button is-default" href="/Android/MVC-MVP-MVVM/" title="MVC-MVP-MVVM 进化之路"><span class="has-text-weight-semibold">Next: MVC-MVP-MVVM 进化之路</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container" id="vcomments" data-comment_valine_id="b7rbKQnQFa9DYl1anYfacJRz-gzGzoHsz" data-comment_valine_key="nUuKvGHOJBRylruJLW2Fmekg"></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com//"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/serious198706"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com//"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com//"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> cy198706 2023</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="京ICP备2022033375号" target="_blank" rel="noopener" href="https://beian.miit.gov.cn/">京ICP备2022033375号 </a></p></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>