<!DOCTYPE html><html class="appearance-user-can-set" lang="zh"><head><meta charset="UTF-8"><title>Notex</title><meta name="description" content="Keep low profile, he said."><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="在 Android 中传递一些数据时，我们需要将数据序列化。序列化经常会用到 Serializable 和 Parcelable 这两个类，那么你有没有想过他们的区别是什么呢？这篇文章来分析一下各自的特点及优缺点，并对比一下两种结构的区别。


在讲它们之前，先提一个问题：为什么要序列化？
为什么要序列化Android开发的时候，我们时长遇到传递对象的需求，但是我们无法将对象的引用传给 Activity 或者 Fragment，我们需要将这些对象放到一个Intent 或者 Bundle 里面，然后再传递，这时候就用到了序列化。所谓序列化就是把 Java 对象转换为字节序列的过程，该字节序列可以被存储到一个储存媒介里或者在网络上进行传输；反序列化就是把字节序列恢复为 Java 对象的过程。但是我们要知道序列化.."><script src="//unpkg.com/valine/dist/Valine.min.js"></script><meta name="generator" content="Hexo 5.4.2"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><!-- a(href= url_for("/"))= (theme.user && theme.user.name || config.author) + "'s blog"--><a href="/">Notex</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Android 中的序列化</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">主页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">主页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">为什么要序列化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">序列化的两种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Serializable"><span class="toc-text">Serializable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#transient-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">transient 关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Parcelable"><span class="toc-text">Parcelable</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%96%B9%E5%BC%8F%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-text">两种序列化方式的对比</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/Android"><i class="tag post-item-tag">Android</i></a><a href="/tags/%E5%BA%8F%E5%88%97%E5%8C%96"><i class="tag post-item-tag">序列化</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">Android 中的序列化</h1><time class="has-text-grey" datetime="2020-04-19T16:00:00.000Z">2020-04-20</time><article class="mt-2 post-content"><p>在 Android 中传递一些数据时，我们需要将数据序列化。序列化经常会用到 Serializable 和 Parcelable 这两个类，那么你有没有想过他们的区别是什么呢？这篇文章来分析一下各自的特点及优缺点，并对比一下两种结构的区别。</p>
<span id="more"></span>

<p>在讲它们之前，先提一个问题：为什么要序列化？</p>
<h2 id="为什么要序列化"><a href="#为什么要序列化" class="headerlink" title="为什么要序列化"></a>为什么要序列化</h2><p>Android开发的时候，我们时长遇到传递对象的需求，但是我们无法将对象的引用传给 Activity 或者 Fragment，我们需要将这些对象放到一个Intent 或者 Bundle 里面，然后再传递，这时候就用到了序列化。所谓序列化就是<strong>把 Java 对象转换为字节序列的过程</strong>，该字节序列可以被存储到一个储存媒介里或者在网络上进行传输；反序列化就是把<strong>字节序列恢复为 Java 对象的过程</strong>。但是我们要知道序列化与反序列化仅处理 Java 变量而不处理方法，仅对数据进行处理。</p>
<h2 id="序列化的两种方式"><a href="#序列化的两种方式" class="headerlink" title="序列化的两种方式"></a>序列化的两种方式</h2><p>Android中序列化有两种方式：Serializable 以及 Parcelable。其中 Serializable 是 Java 自带的，而 Parcelable 是 Android 专有的。</p>
<h3 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h3><p>Serializable 是 Java 提供的序列化技术。使用起来非常简单，只需要让某个 Class 实现 Serializable 就可以。在Serializable的文档中提出，Serializable 在序列化运行时会关联一个版本号，用<code>serialVersionUID</code>来标识，主要用来验证发送者和接收者处理的是不是同一个版本的类。如果版本不一致，则会抛出<code>InvalidClassException</code>异常。要使用这个标识，需要在类里声明如下：</p>
<pre><code class="java">private/public/protected static final long serialVersionUID = 42L;
</code></pre>
<p>虽然不提供这个值也行，Java 会自己生成一个该值，但是最好还是能提供一个。因为受编译器版本不同、内核版本不同等等的影响，有可能同一个类计算出来的<code>serialVersionUID</code>值不同，就会导致序列化/反序列化失败。</p>
<p>当父类实现了序列化，其子类也会自动实现序列化，不需要再显式实现 Serializable 接口了。</p>
<blockquote>
<p>Seralizable 无法序列化静态变量，使用 transient 修饰的对象也无法序列化。所以，当类中有静态变量时，序列化并不会保存该变量。</p>
<h3 id="transient-关键字"><a href="#transient-关键字" class="headerlink" title="transient 关键字"></a>transient 关键字</h3><p>transient 关键字的作用是<strong>控制变量的序列化</strong>，在变量声明前加上该关键字，可以<strong>阻止该变量被序列化到文件中</strong>，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。</p>
</blockquote>
<p>实现 Serializable 时，还可以添加<code>writeObject()</code>和<code>readObject()</code>方法，虚拟机在序列化和反序列化时，会试图调用这两个方法，通过这两个方法，我们可以<strong>控制序列化的过程</strong>，比如可以在序列化的过程中动态改变序列化的数值。举例如下：</p>
<pre><code class="java">class SerializableTest implements Serializable &#123;
    private static final long serialVersionUID = 1L;

    private String password = &quot;pass&quot;;

    public String getPassword() &#123;
        return password;
    &#125;

    public void setPassword(String password) &#123;
        this.password = password;
    &#125;

    private String encrypt() &#123;
        ...
    &#125;

    private String decrypt() &#123;
        ...
    &#125;

    private void writeObject(ObjectOutputStream out) &#123;
        try &#123;
            PutField putFields = out.putFields();
            System.out.println(&quot;原密码:&quot; + this.password);
            this.password = encrypt(); // 加密
            putFields.put(&quot;password&quot;, this.password);
            System.out.println(&quot;加密后的密码&quot; + this.password);
            out.writeFields();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    private void readObject(ObjectInputStream in) &#123;
        try &#123;
            GetField readFields = in.readFields();
            Object object = readFields.get(&quot;password&quot;, &quot;&quot;);
            this.password = decrypt(object.toString())
            System.out.println(&quot;解密后的密码:&quot; + this.password);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125; catch (ClassNotFoundException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="Parcelable"><a href="#Parcelable" class="headerlink" title="Parcelable"></a>Parcelable</h3><p>Parcelable 是 Android 提供的序列化方案。它的出现是为了解决Serializable在序列化的过程中消耗资源严重的问题，但是因为本身使用需要手动处理序列化和反序列化过程，会与具体的代码绑定，使用较为繁琐，一般只获取内存数据的时候使用。</p>
<p>而 Parcelable 依赖于Parcel，Parcel 的意思是包装，实现原理是在内存中<strong>建立一块共享数据块</strong>，序列化和反序列化均是操作这一块的数据，如此来实现。如图所示：</p>
<p><img src="/img/55.png"></p>
<p>听起来跟 Linux 的共享内存有没有很像？对，Parcelable 可以用于 Android 的进程间通信。举个简单的例子，应用的 Activity 要与 Service 通信的话，就可以使用 Parcelable。</p>
<p>使用 Parcelable 要稍微麻烦一些。它需要实现以下几点：</p>
<ul>
<li>类本身要实现 Parcelable 接口</li>
<li>有一个非空的静态成员变量叫<code>CREATOR</code>，并且它要实现<code>Parcelable.Creator</code>接口<ul>
<li>覆写<code>createFromParcel(Parcel in)</code>方法</li>
<li>覆写<code>newArray(int size)</code>方法</li>
</ul>
</li>
<li>覆写<code>describeContents()</code>方法</li>
<li>覆写<code>writeToParcel(Parcel dest, int flags)</code>方法</li>
</ul>
<p>看起来真的好麻烦。我们还是用代码来解释一下吧：</p>
<pre><code class="java">public class MyParcelable implements Parcelable &#123;
    // 要被序列化的数据
    private int mData;

    // 描述在这个 Parcelable 实例的中含有的特殊对象的类型。
    // 例如，如果在对象的 output 中包含一个文件描述符，那它的返回值必须要包含 CONTENTS_FILE_DESCRIPTOR 的 bit 值
    // 返回一个 bitmask 值
    public int describeContents() &#123;
        return 0;
    &#125;

    // 用二向箔把对象搞成 Parcelable
    public void writeToParcel(Parcel out, int flags) &#123;
        out.writeInt(mData);
    &#125;

    // 一个必须要实现的接口，用来从一个 Parcel 创建你自定义的 Parcelable 实例
    public static final Parcelable.Creator&lt;MyParcelable&gt; CREATOR
            = new Parcelable.Creator&lt;MyParcelable&gt;() &#123;

        // 使用之前存储的 Parcel 来创建实例
        public MyParcelable createFromParcel(Parcel in) &#123;
            return new MyParcelable(in);
        &#125;

        // 创建一个 Parcelable 的数组，所有元素都是 null
        public MyParcelable[] newArray(int size) &#123;
            return new MyParcelable[size];
        &#125;
    &#125;;

    // 从读取的数据中进行恢复
    private MyParcelable(Parcel in) &#123;
        mData = in.readInt();
    &#125;
&#125;
</code></pre>
<h2 id="两种序列化方式的对比"><a href="#两种序列化方式的对比" class="headerlink" title="两种序列化方式的对比"></a>两种序列化方式的对比</h2><ol>
<li>Serializable 代码量少，Parcelable 代码量多。</li>
<li>在内存间传递数据的时候，Parcelable 比 Serializable 性能高、内存开销方面较小，所以推荐使用 Parcelable；而在需要保存数据到本地或者进行网络传输时，使用 Serializable。</li>
<li>Serializable 在序列化时使用的是<strong>反射</strong>的技术，会产生大量的临时变量，从而引起频繁的 GC。而 Parcelable 方式的实现原理是将一个完整的对象进行<strong>字节化</strong>，而<strong>字节化</strong>之后的每一部分都是 Intent 所支持的数据类型，这样也就实现传递对象的功能了。</li>
</ol>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/Android/Activity%20%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/" title="Activity四大启动模式解析"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">Previous: Activity四大启动模式解析</span></a><a class="button is-default" href="/Android/ActivityManagerService/" title="关于 ActivityManagerService"><span class="has-text-weight-semibold">Next: 关于 ActivityManagerService</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container" id="vcomments" data-comment_valine_id="b7rbKQnQFa9DYl1anYfacJRz-gzGzoHsz" data-comment_valine_key="nUuKvGHOJBRylruJLW2Fmekg"></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com//"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/serious198706"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com//"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com//"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> cy198706 2023</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="京ICP备2022033375号" target="_blank" rel="noopener" href="https://beian.miit.gov.cn/">京ICP备2022033375号 </a></p></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>