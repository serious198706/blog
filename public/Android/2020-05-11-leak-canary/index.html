<!DOCTYPE html><html class="appearance-user-can-set" lang="zh"><head><meta charset="UTF-8"><title>Notex</title><meta name="description" content="Keep low profile, he said."><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="
“A small leak will sink a great ship.” - Benjamin Franklin

这篇文章来讲讲著名的第三方内存泄漏检测工具 - LeakCanary。

注：本文源代码基于 leakcanary-android:2.3



LeakCanary 的使用非常简单，我们一笔带过：
dependencies &amp;#123;
  // debugImplementation because LeakCanary should only run in debug builds.
  debugImplementation &amp;#39;com.squareup.leakcanary:leakcanary-android:2.3&amp;#39;
&amp;#125;

配置完 gradle 依赖.."><script src="//unpkg.com/valine/dist/Valine.min.js"></script><meta name="generator" content="Hexo 5.4.2"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><!-- a(href= url_for("/"))= (theme.user && theme.user.name || config.author) + "'s blog"--><a href="/">Notex</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">关于 Leak Canary</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">主页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">主页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E8%A6%81%E8%A2%AB%E4%BF%9D%E7%95%99%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-text">检查要被保留的对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dump-Heap"><span class="toc-text">Dump Heap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90-HPROF-%E6%96%87%E4%BB%B6"><span class="toc-text">分析 HPROF 文件</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/Android"><i class="tag post-item-tag">Android</i></a><a href="/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><i class="tag post-item-tag">源码解析</i></a><a href="/tags/leakcanary"><i class="tag post-item-tag">leakcanary</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">关于 Leak Canary</h1><time class="has-text-grey" datetime="2023-01-31T06:58:14.691Z">2023-01-31</time><article class="mt-2 post-content"><blockquote>
<p>“A small leak will sink a great ship.” - Benjamin Franklin</p>
</blockquote>
<p>这篇文章来讲讲著名的第三方内存泄漏检测工具 - LeakCanary。</p>
<blockquote>
<p>注：本文源代码基于 leakcanary-android:2.3</p>
</blockquote>
<span id="more"></span>

<p>LeakCanary 的使用非常简单，我们一笔带过：</p>
<pre><code>dependencies &#123;
  // debugImplementation because LeakCanary should only run in debug builds.
  debugImplementation &#39;com.squareup.leakcanary:leakcanary-android:2.3&#39;
&#125;
</code></pre>
<p>配置完 gradle 依赖后，任何代码都不用写，就能直接生效。</p>
<p>神奇吗？神奇就对了。</p>
<p>官方文档上提到，LeakCanary 能够自动检测下面几种对象：</p>
<ul>
<li>销毁之后的 Activity 实例</li>
<li>销毁之后的 Fragment 实例</li>
<li>销毁之后的 Fragment View 实例</li>
<li>清除之后的 ViewModel 实例</li>
</ul>
<p>在这几种行为发生后，LeanCanary 会做四个步骤来帮助我们分析是否有内存泄漏：</p>
<ol>
<li>检查是否有被保留下的对象</li>
<li>Dump Heap</li>
<li>分析 HPROF 文件</li>
<li>对泄漏的部分进行分类</li>
</ol>
<p>我们来按步骤分析分析它的源码，看它究竟是如何做到的。</p>
<h2 id="检查要被保留的对象"><a href="#检查要被保留的对象" class="headerlink" title="检查要被保留的对象"></a>检查要被保留的对象</h2><p>LeanCanary 会监测 Android 组件（并不是全部）的生命周期，在它们销毁的时候，会检测它们是否出现了内存泄漏。</p>
<p>这些对象会被传递到一个 ObjectWatcher 类，它使用 WeakReference 来持有这些实例。当然，你也可以使用这个类来自己观察某个对象是否出现了泄漏。</p>
<p>它的代码如下所示：</p>
<pre><code class="kotlin">/**
 * [ObjectWatcher] can be passed objects to [watch]. It will create [KeyedWeakReference] instances
 * that reference watches objects, and check if those references have been cleared as expected on
 * the [checkRetainedExecutor] executor. If not, these objects are considered retained and
 * [ObjectWatcher] will then notify the [onObjectRetainedListener] on that executor thread.
 *
 * [checkRetainedExecutor] is expected to run its tasks on a background thread, with a significant
 * to give the GC the opportunity to identify weakly reachable objects.
 *
 * [ObjectWatcher] is thread safe.
 */
// Thread safe by locking on all methods, which is reasonably efficient given how often
// these methods are accessed.
class ObjectWatcher constructor(
  private val clock: Clock,
  private val checkRetainedExecutor: Executor,
  /**
   * Calls to [watch] will be ignored when [isEnabled] returns false
   */
  private val isEnabled: () -&gt; Boolean = &#123; true &#125;
) &#123;

  private val onObjectRetainedListeners = mutableSetOf&lt;OnObjectRetainedListener&gt;()

  /**
   * References passed to [watch].
   */
  private val watchedObjects = mutableMapOf&lt;String, KeyedWeakReference&gt;()

  private val queue = ReferenceQueue&lt;Any&gt;()

  ...

  /**
   * Returns the objects that are currently considered retained. Useful for logging purposes.
   * Be careful with those objects and release them ASAP as you may creating longer lived leaks
   * then the one that are already there.
   */
  val retainedObjects: List&lt;Any&gt;
    @Synchronized get() &#123;
      removeWeaklyReachableObjects()
      val instances = mutableListOf&lt;Any&gt;()
      for (weakReference in watchedObjects.values) &#123;
        if (weakReference.retainedUptimeMillis != -1L) &#123;
          val instance = weakReference.get()
          if (instance != null) &#123;
            instances.add(instance)
          &#125;
        &#125;
      &#125;
      return instances
    &#125;

  ...

  /**
   * Watches the provided [watchedObject].
   *
   * @param description Describes why the object is watched.
   */
  @Synchronized fun watch(
    watchedObject: Any,
    description: String
  ) &#123;
    if (!isEnabled()) &#123;
      return
    &#125;
    removeWeaklyReachableObjects()
    val key = UUID.randomUUID()
        .toString()
    val watchUptimeMillis = clock.uptimeMillis()
    val reference =
      KeyedWeakReference(watchedObject, key, description, watchUptimeMillis, queue)
    SharkLog.d &#123;
      &quot;Watching &quot; +
          (if (watchedObject is Class&lt;*&gt;) watchedObject.toString() else &quot;instance of $&#123;watchedObject.javaClass.name&#125;&quot;) +
          (if (description.isNotEmpty()) &quot; ($description)&quot; else &quot;&quot;) +
          &quot; with key $key&quot;
    &#125;

    watchedObjects[key] = reference
    checkRetainedExecutor.execute &#123;
      moveToRetained(key)
    &#125;
  &#125;

  ...
&#125;
</code></pre>
<p>可以看到，ObjectWatcher 内部有这么几个重要的东西：</p>
<ul>
<li><code>onObjectRetainedListeners</code>，使用者可以手动添加 OnObjectRetainedListener，当有对象被保留时，可以接收到回调；</li>
<li><code>watchedObjects</code>，持有对要观察的对象的 WeakReference。可以看到 LeakCanary 使用了 KeyedWeakReference，它是 WeakReference 的子类，添加了一个字段用于保存对象被观测的时长；</li>
<li><code>queue</code>，<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/ref/ReferenceQueue.html">ReferenceQueue</a>，这是 Java 中的特性，当内存中对象的可达性发生变化时，GC 会将变化的对象添加到这个队列中；</li>
<li><code>retainedObjects</code>，可能会发生内存泄漏的对象就保存在这个 List 中，供后续分析使用。</li>
</ul>
<p>默认情况下，LeakCanary 会将应用中的 Activity、Fragment 等组件注册到 ObjectWatcher 中，那么问题来了，是在何时注册的？</p>
<p>通过扒拉代码，我发现了位于 leakcanary/internal/ 中的这个类：AppWatcherInstaller。我们看一下它的代码：</p>
<pre><code class="kotlin">/**
 * Content providers are loaded before the application class is created. [AppWatcherInstaller] is
 * used to install [leakcanary.AppWatcher] on application start.
 */
internal sealed class AppWatcherInstaller : ContentProvider() &#123;
  ...
  override fun onCreate(): Boolean &#123;
    val application = context!!.applicationContext as Application
    InternalAppWatcher.install(application)
    return true
  &#125;
  ...
&#125;
</code></pre>
<p>厉害了，利用了 Content Provider 会早于 Application 类加载的这个特性，在 <code>onCreate()</code> 方法中调用了 <code>InternalAppWatcher.install()</code> 方法进行初始化的工作：</p>
<pre><code class="kotlin">internal object InternalAppWatcher &#123;

  private val onAppWatcherInstalled: (Application) -&gt; Unit

  ...

  init &#123;
    val internalLeakCanary = try &#123;
      val leakCanaryListener = Class.forName(&quot;leakcanary.internal.InternalLeakCanary&quot;)
      leakCanaryListener.getDeclaredField(&quot;INSTANCE&quot;).get(null)
    &#125; catch (ignored: Throwable) &#123;
      NoLeakCanary
    &#125;
    @kotlin.Suppress(&quot;UNCHECKED_CAST&quot;)
    onAppWatcherInstalled = internalLeakCanary as (Application) -&gt; Unit
  &#125;

  ...

  val objectWatcher = ObjectWatcher(
      clock = clock,
      checkRetainedExecutor = checkRetainedExecutor,
      isEnabled = &#123; AppWatcher.config.enabled &#125;
  )

  fun install(application: Application) &#123;
    SharkLog.logger = DefaultCanaryLog()
    checkMainThread()
    if (this::application.isInitialized) &#123;
      return
    &#125;
    InternalAppWatcher.application = application

    val configProvider = &#123; AppWatcher.config &#125;
    ActivityDestroyWatcher.install(application, objectWatcher, configProvider)
    FragmentDestroyWatcher.install(application, objectWatcher, configProvider)
    onAppWatcherInstalled(application)
  &#125;

  ...

  private fun checkMainThread() &#123;
    if (Looper.getMainLooper().thread !== Thread.currentThread()) &#123;
      throw UnsupportedOperationException(
          &quot;Should be called from the main thread, not $&#123;Thread.currentThread()&#125;&quot;
      )
    &#125;
  &#125;

  ...
&#125;
</code></pre>
<p><code>InternalAppWatcher.install()</code> 方法中，首先检查了当前代码是否运行在主线程上，如果不是，则抛出异常；然后分别调用了 ActivityDestroyWatcher 和 FragmentDestroyWatcher 的 <code>install()</code> 方法，当这些事情都做完后，用了一个秀儿的方法，给 <code>internalLeakCanary</code> 这个成员变量赋值。</p>
<p><img src="https://s3.ax1x.com/2020/12/11/rAhsB9.md.jpg"></p>
<p>来看 ActivityDestroyWatcher：</p>
<pre><code class="kotlin">internal class ActivityDestroyWatcher private constructor(
  private val objectWatcher: ObjectWatcher,
  private val configProvider: () -&gt; Config
) &#123;

  private val lifecycleCallbacks =
    object : Application.ActivityLifecycleCallbacks by noOpDelegate() &#123;
      override fun onActivityDestroyed(activity: Activity) &#123;
        if (configProvider().watchActivities) &#123;
          objectWatcher.watch(
              activity, &quot;$&#123;activity::class.java.name&#125; received Activity#onDestroy() callback&quot;
          )
        &#125;
      &#125;
    &#125;

  companion object &#123;
    fun install(
      application: Application,
      objectWatcher: ObjectWatcher,
      configProvider: () -&gt; Config
    ) &#123;
      val activityDestroyWatcher = ActivityDestroyWatcher(objectWatcher, configProvider)
      application.registerActivityLifecycleCallbacks(activityDestroyWatcher.lifecycleCallbacks)
    &#125;
  &#125;
&#125;
</code></pre>
<p>它的功能非常简单，直接创建 ActivityDestroyWatcher 的实例，并利用 Application 中的 ActivityLifecycleCallbacks 接口，接收 Activity 的 <code>onActivityDestroyed()</code> 回调，然后将 Activity 交给 ObjectWatcher。</p>
<blockquote>
<p>kotlin 中的 by 一般用于实现委托机制，在这里的功能相当于可以省略掉其他的回调的代码。<br>noOpDelegate 的代码如下：</p>
<pre><code class="kotlin">inline fun &lt;reified T : Any&gt; noOpDelegate(): T &#123;
    val javaClass = T::class.java
    val noOpHandler = InvocationHandler &#123; _, _, _ -&gt;
      // no op
    &#125;
    return Proxy.newProxyInstance(
        javaClass.classLoader, arrayOf(javaClass), noOpHandler
    ) as T
  &#125;
</code></pre>
</blockquote>
<p>FragmentDestroyWatcher 稍微复杂一些：</p>
<pre><code class="kotlin">internal object FragmentDestroyWatcher &#123;

  private const val ANDROIDX_FRAGMENT_CLASS_NAME = &quot;androidx.fragment.app.Fragment&quot;
  private const val ANDROIDX_FRAGMENT_DESTROY_WATCHER_CLASS_NAME = &quot;leakcanary.internal.AndroidXFragmentDestroyWatcher&quot;

  // Using a string builder to prevent Jetifier from changing this string to Android X Fragment
  @Suppress(&quot;VariableNaming&quot;, &quot;PropertyName&quot;)
  private val ANDROID_SUPPORT_FRAGMENT_CLASS_NAME = StringBuilder(&quot;android.&quot;).append(&quot;support.v4.app.Fragment&quot;).toString()
  private const val ANDROID_SUPPORT_FRAGMENT_DESTROY_WATCHER_CLASS_NAME = &quot;leakcanary.internal.AndroidSupportFragmentDestroyWatcher&quot;

  fun install(
    application: Application,
    objectWatcher: ObjectWatcher,
    configProvider: () -&gt; AppWatcher.Config
  ) &#123;
    val fragmentDestroyWatchers = mutableListOf&lt;(Activity) -&gt; Unit&gt;()

    if (SDK_INT &gt;= O) &#123;
      fragmentDestroyWatchers.add(
          AndroidOFragmentDestroyWatcher(objectWatcher, configProvider)
      )
    &#125;

    getWatcherIfAvailable(
        ANDROIDX_FRAGMENT_CLASS_NAME,
        ANDROIDX_FRAGMENT_DESTROY_WATCHER_CLASS_NAME,
        objectWatcher,
        configProvider
    )?.let &#123;
      fragmentDestroyWatchers.add(it)
    &#125;

    getWatcherIfAvailable(
        ANDROID_SUPPORT_FRAGMENT_CLASS_NAME,
        ANDROID_SUPPORT_FRAGMENT_DESTROY_WATCHER_CLASS_NAME,
        objectWatcher,
        configProvider
    )?.let &#123;
      fragmentDestroyWatchers.add(it)
    &#125;

    if (fragmentDestroyWatchers.size == 0) &#123;
      return
    &#125;

    application.registerActivityLifecycleCallbacks(object : Application.ActivityLifecycleCallbacks by noOpDelegate() &#123;
      override fun onActivityCreated(activity: Activity, savedInstanceState: Bundle?) &#123;
        for (watcher in fragmentDestroyWatchers) &#123;
          watcher(activity)
        &#125;
      &#125;
    &#125;)
  &#125;

  private fun getWatcherIfAvailable(
    fragmentClassName: String,
    watcherClassName: String,
    objectWatcher: ObjectWatcher,
    configProvider: () -&gt; AppWatcher.Config
  ): ((Activity) -&gt; Unit)? &#123;

    return if (classAvailable(fragmentClassName) &amp;&amp;
        classAvailable(watcherClassName)
    ) &#123;
      val watcherConstructor = Class.forName(watcherClassName)
          .getDeclaredConstructor(ObjectWatcher::class.java, Function0::class.java)
      @Suppress(&quot;UNCHECKED_CAST&quot;)
      watcherConstructor.newInstance(objectWatcher, configProvider) as (Activity) -&gt; Unit

    &#125; else &#123;
      null
    &#125;
  &#125;

  private fun classAvailable(className: String): Boolean &#123;
    return try &#123;
      Class.forName(className)
      true
    &#125; catch (e: Throwable) &#123;
      // e is typically expected to be a ClassNotFoundException
      // Unfortunately, prior to version 25.0.2 of the support library the
      // FragmentManager.FragmentLifecycleCallbacks class was a non static inner class.
      // Our AndroidSupportFragmentDestroyWatcher class is compiled against the static version of
      // the FragmentManager.FragmentLifecycleCallbacks class, leading to the
      // AndroidSupportFragmentDestroyWatcher class being rejected and a NoClassDefFoundError being
      // thrown here. So we&#39;re just covering our butts here and catching everything, and assuming
      // any throwable means &quot;can&#39;t use this&quot;. See https://github.com/square/leakcanary/issues/1662
      false
    &#125;
  &#125;
&#125;
</code></pre>
<p>对 Fragment 的监控是主要采用了两个类：<code>leakcanary.internal.AndroidXFragmentDestroyWatcher</code> 和 <code>leakcanary.internal.AndroidSupportFragmentDestroyWatcher</code>。这两个类的实现方式相同，都是 lambda 表达式，我们只看其中一个：</p>
<pre><code class="kotlin">internal class AndroidXFragmentDestroyWatcher(
  private val objectWatcher: ObjectWatcher,
  private val configProvider: () -&gt; Config
) : (Activity) -&gt; Unit &#123;

  private val fragmentLifecycleCallbacks = object : FragmentManager.FragmentLifecycleCallbacks() &#123;

    override fun onFragmentCreated(
      fm: FragmentManager,
      fragment: Fragment,
      savedInstanceState: Bundle?
    ) &#123;
      ViewModelClearedWatcher.install(fragment, objectWatcher, configProvider)
    &#125;

    override fun onFragmentViewDestroyed(
      fm: FragmentManager,
      fragment: Fragment
    ) &#123;
      val view = fragment.view
      if (view != null &amp;&amp; configProvider().watchFragmentViews) &#123;
        objectWatcher.watch(
            view, &quot;$&#123;fragment::class.java.name&#125; received Fragment#onDestroyView() callback &quot; +
            &quot;(references to its views should be cleared to prevent leaks)&quot;
        )
      &#125;
    &#125;

    override fun onFragmentDestroyed(
      fm: FragmentManager,
      fragment: Fragment
    ) &#123;
      if (configProvider().watchFragments) &#123;
        objectWatcher.watch(
            fragment, &quot;$&#123;fragment::class.java.name&#125; received Fragment#onDestroy() callback&quot;
        )
      &#125;
    &#125;
  &#125;

  override fun invoke(activity: Activity) &#123;
    if (activity is FragmentActivity) &#123;
      val supportFragmentManager = activity.supportFragmentManager
      supportFragmentManager.registerFragmentLifecycleCallbacks(fragmentLifecycleCallbacks, true)
      ViewModelClearedWatcher.install(activity, objectWatcher, configProvider)
    &#125;
  &#125;
&#125;
</code></pre>
<p>利用了 FragmentManager 中的 FragmentLifecycleCallbacks 接口实现了对 Fragment 生命周期的监听，同时还对 ViewModel 的销毁事件做了监听。</p>
<p>当 Activity 走完自己的 <code>onDestroy()</code> 方法后，Watcher 中的 watch() 方法会被执行（上方代码），然后，利用了 Executor （注意，该 Executor 是在主线程上跑的）开始执行<code>moveToRetained(key)</code>代码：</p>
<pre><code class="kotlin">@Synchronized private fun moveToRetained(key: String) &#123;
  removeWeaklyReachableObjects()
  val retainedRef = watchedObjects[key]
  if (retainedRef != null) &#123;
    retainedRef.retainedUptimeMillis = clock.uptimeMillis()
    onObjectRetainedListeners.forEach &#123; it.onObjectRetained() &#125;
  &#125;
&#125;
</code></pre>
<p>首先移除了所有在 GC 后依旧有可达性的对象，如果全部都移除了，<code>retainedRef</code> 就是 <code>null</code>，则不会触发回调，证明没有内存泄漏；如果移除不了，说明有内存泄漏，开始进行下一步：Dump Heap。</p>
<h2 id="Dump-Heap"><a href="#Dump-Heap" class="headerlink" title="Dump Heap"></a>Dump Heap</h2><p>书接上文，Watcher 开始回调所有的 <code>onObjectRetainedListeners</code>。这些 Listeners 是在何时被添加的呢？</p>
<p>我们回到初始化的部分，也即<code>InternalAppWatcher.install()</code>，其中有这样的代码：</p>
<pre><code class="kotlin">init &#123;
    val internalLeakCanary = try &#123;
      val leakCanaryListener = Class.forName(&quot;leakcanary.internal.InternalLeakCanary&quot;)
      leakCanaryListener.getDeclaredField(&quot;INSTANCE&quot;).get(null)
    &#125; catch (ignored: Throwable) &#123;
      NoLeakCanary
    &#125;
    @kotlin.Suppress(&quot;UNCHECKED_CAST&quot;)
    onAppWatcherInstalled = internalLeakCanary as (Application) -&gt; Unit
  &#125;
</code></pre>
<p>当 <code>onAppWatcherInstalled</code> 这个 Lambda 表达式被执行时，<code>leakcanary.internal.InternalLeakCanary</code> 这个类会被初始化，我们看一下这个类：</p>
<pre><code class="kotlin">internal object InternalLeakCanary : (Application) -&gt; Unit, OnObjectRetainedListener &#123;
  private lateinit var heapDumpTrigger: HeapDumpTrigger
  lateinit var application: Application

  override fun invoke(application: Application) &#123;
    this.application = application

    checkRunningInDebuggableBuild()

    AppWatcher.objectWatcher.addOnObjectRetainedListener(this)

    val heapDumper = AndroidHeapDumper(application, leakDirectoryProvider)

    val gcTrigger = GcTrigger.Default

    val configProvider = &#123; LeakCanary.config &#125;

    val handlerThread = HandlerThread(LEAK_CANARY_THREAD_NAME)
    handlerThread.start()
    val backgroundHandler = Handler(handlerThread.looper)

    heapDumpTrigger = HeapDumpTrigger(
        application, backgroundHandler, AppWatcher.objectWatcher, gcTrigger, heapDumper,
        configProvider
    )
    application.registerVisibilityListener &#123; applicationVisible -&gt;
      this.applicationVisible = applicationVisible
      heapDumpTrigger.onApplicationVisibilityChanged(applicationVisible)
    &#125;
    registerResumedActivityListener(application)
    addDynamicShortcut(application)

    disableDumpHeapInTests()
  &#125;

  ...

  override fun onObjectRetained() &#123;
    if (this::heapDumpTrigger.isInitialized) &#123;
      heapDumpTrigger.onObjectRetained()
    &#125;
  &#125;

  fun onDumpHeapReceived(forceDump: Boolean) &#123;
    if (this::heapDumpTrigger.isInitialized) &#123;
      heapDumpTrigger.onDumpHeapReceived(forceDump)
    &#125;
  &#125;

  ...

&#125;
</code></pre>
<p>好家伙，我 TM 直接好家伙，这居然又是个 Lambda 表达式，话不多说，直接看 <code>invoke()</code> 回调部分中，有 <code>AppWatcher.objectWatcher.addOnObjectRetainedListener(this)</code> 这样一句，将自己做为被回调方添加到了 watcher 中，那么上面的 <code>onObjectRetainedListener</code> 就找到了实现者。</p>
<p>可以看到，调用了 <code>heapDumpTrigger.onObjectRetained()</code> 方法，我们去看看这里做了什么。</p>
<pre><code class="kotlin">fun onObjectRetained() &#123;
    scheduleRetainedObjectCheck(
        reason = &quot;found new object retained&quot;,
        rescheduling = false
    )
&#125;
</code></pre>
<p>可以看到只是很简单地调用了 <code>scheduleRetainedObjectCheck()</code> 方法：</p>
<pre><code class="kotlin">private fun scheduleRetainedObjectCheck(
  reason: String,
  rescheduling: Boolean,
  delayMillis: Long = 0L
) &#123;
  val checkCurrentlyScheduledAt = checkScheduledAt
  if (checkCurrentlyScheduledAt &gt; 0) &#123;
    val scheduledIn = checkCurrentlyScheduledAt - SystemClock.uptimeMillis()
    SharkLog.d &#123; &quot;Ignoring request to check for retained objects ($reason), already scheduled in $&#123;scheduledIn&#125;ms&quot; &#125;
    return
  &#125; else &#123;
    val verb = if (rescheduling) &quot;Rescheduling&quot; else &quot;Scheduling&quot;
    val delay = if (delayMillis &gt; 0) &quot; in $&#123;delayMillis&#125;ms&quot; else &quot;&quot;
    SharkLog.d &#123; &quot;$verb check for retained objects$&#123;delay&#125; because $reason&quot; &#125;
  &#125;
  checkScheduledAt = SystemClock.uptimeMillis() + delayMillis
  backgroundHandler.postDelayed(&#123;
    checkScheduledAt = 0
    checkRetainedObjects(reason)
  &#125;, delayMillis)
&#125;
</code></pre>
<p>记录了时间戳之后，开始在子线程中执行 <code>checkRetainedObjects(reason)</code> 方法：</p>
<pre><code class="kotlin">private fun checkRetainedObjects(reason: String) &#123;
  ...

  val now = SystemClock.uptimeMillis()
  val elapsedSinceLastDumpMillis = now - lastHeapDumpUptimeMillis
  if (elapsedSinceLastDumpMillis &lt; WAIT_BETWEEN_HEAP_DUMPS_MILLIS) &#123;
    onRetainInstanceListener.onEvent(DumpHappenedRecently)
    showRetainedCountNotification(
        objectCount = retainedReferenceCount,
        contentText = application.getString(R.string.leak_canary_notification_retained_dump_wait)
    )
    scheduleRetainedObjectCheck(
        reason = &quot;previous heap dump was $&#123;elapsedSinceLastDumpMillis&#125;ms ago (&lt; $&#123;WAIT_BETWEEN_HEAP_DUMPS_MILLIS&#125;ms)&quot;,
        rescheduling = true,
        delayMillis = WAIT_BETWEEN_HEAP_DUMPS_MILLIS - elapsedSinceLastDumpMillis
    )
    return
  &#125;

  SharkLog.d &#123; &quot;Check for retained objects found $retainedReferenceCount objects, dumping the heap&quot; &#125;
  dismissRetainedCountNotification()
  dumpHeap(retainedReferenceCount, retry = true)

  ...
&#125;
</code></pre>
<p>首次运行时，<code>lastHeapDumpUptimeMillis</code> 为 <code>0</code>，所以代码会执行到 <code>dumpHeap(retainedReferenceCount, retry = true)</code>，而后续执行时，如果两次执行的间隔过小（60秒），则直接展示通知，不再 dump heap。</p>
<pre><code class="kotlin">private fun dumpHeap(retainedReferenceCount: Int, retry: Boolean) &#123;
  saveResourceIdNamesToMemory()
  val heapDumpUptimeMillis = SystemClock.uptimeMillis()
  KeyedWeakReference.heapDumpUptimeMillis = heapDumpUptimeMillis
  val heapDumpFile = heapDumper.dumpHeap()
  if (heapDumpFile == null) &#123;
    if (retry) &#123;
      SharkLog.d &#123; &quot;Failed to dump heap, will retry in $WAIT_AFTER_DUMP_FAILED_MILLIS ms&quot; &#125;
      scheduleRetainedObjectCheck(
          reason = &quot;failed to dump heap&quot;,
          rescheduling = true,
          delayMillis = WAIT_AFTER_DUMP_FAILED_MILLIS
      )
    &#125; else &#123;
      SharkLog.d &#123; &quot;Failed to dump heap, will not automatically retry&quot; &#125;
    &#125;
    showRetainedCountNotification(
        objectCount = retainedReferenceCount,
        contentText = application.getString(
            R.string.leak_canary_notification_retained_dump_failed
        )
    )
    return
  &#125;
  lastDisplayedRetainedObjectCount = 0
  lastHeapDumpUptimeMillis = SystemClock.uptimeMillis()
  objectWatcher.clearObjectsWatchedBefore(heapDumpUptimeMillis)
  HeapAnalyzerService.runAnalysis(application, heapDumpFile)
&#125;
</code></pre>
<p>可以看到，这里关键的一步是 <code>heapDumper.dumpHeap()</code> 方法，这里 dump 出来的内存数据会直接供后面的 HeapAnalyzerService 使用。此处的 <code>heapDumper</code> 是一个 AndroidHeapDumper 的实例，我们看一下它的代码：</p>
<pre><code class="kotlin">internal class AndroidHeapDumper(
  context: Context,
  private val leakDirectoryProvider: LeakDirectoryProvider
) : HeapDumper &#123;

  private val context: Context = context.applicationContext
  private val mainHandler: Handler = Handler(Looper.getMainLooper())

  override fun dumpHeap(): File? &#123;
    val heapDumpFile = leakDirectoryProvider.newHeapDumpFile() ?: return null

    val waitingForToast = FutureResult&lt;Toast?&gt;()
    showToast(waitingForToast)

    if (!waitingForToast.wait(5, SECONDS)) &#123;
      SharkLog.d &#123; &quot;Did not dump heap, too much time waiting for Toast.&quot; &#125;
      return null
    &#125;

    val notificationManager =
      context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
    if (Notifications.canShowNotification) &#123;
      val dumpingHeap = context.getString(R.string.leak_canary_notification_dumping)
      val builder = Notification.Builder(context)
          .setContentTitle(dumpingHeap)
      val notification = Notifications.buildNotification(context, builder, LEAKCANARY_LOW)
      notificationManager.notify(R.id.leak_canary_notification_dumping_heap, notification)
    &#125;

    val toast = waitingForToast.get()

    return try &#123;
      Debug.dumpHPROFData(heapDumpFile.absolutePath)
      if (heapDumpFile.length() == 0L) &#123;
        SharkLog.d &#123; &quot;Dumped heap file is 0 byte length&quot; &#125;
        null
      &#125; else &#123;
        heapDumpFile
      &#125;
    &#125; catch (e: Exception) &#123;
      SharkLog.d(e) &#123; &quot;Could not dump heap&quot; &#125;
      // Abort heap dump
      null
    &#125; finally &#123;
      cancelToast(toast)
      notificationManager.cancel(R.id.leak_canary_notification_dumping_heap)
    &#125;
  &#125;

  private fun showToast(waitingForToast: FutureResult&lt;Toast?&gt;) &#123;
    mainHandler.post(Runnable &#123;
      val resumedActivity = InternalLeakCanary.resumedActivity
      if (resumedActivity == null) &#123;
        waitingForToast.set(null)
        return@Runnable
      &#125;
      val toast = Toast(resumedActivity)
      val iconSize = resumedActivity.resources.getDimensionPixelSize(
          R.dimen.leak_canary_toast_icon_size
      )
      toast.setGravity(Gravity.CENTER_VERTICAL, 0, -iconSize)
      toast.duration = Toast.LENGTH_LONG
      // Inflating with application context: https://github.com/square/leakcanary/issues/1385
      val inflater = LayoutInflater.from(context)
      toast.view = inflater.inflate(R.layout.leak_canary_heap_dump_toast, null)
      toast.show()

      val toastIcon = toast.view.findViewById&lt;View&gt;(R.id.leak_canary_toast_icon)
      toastIcon.translationY = -iconSize.toFloat()
      toastIcon
          .animate()
          .translationY(0f)
          .setListener(object : AnimatorListenerAdapter() &#123;
            override fun onAnimationEnd(animation: Animator) &#123;
              waitingForToast.set(toast)
            &#125;
          &#125;)
    &#125;)
  &#125;

  private fun cancelToast(toast: Toast?) &#123;
    if (toast == null) &#123;
      return
    &#125;
    mainHandler.post &#123; toast.cancel() &#125;
  &#125;
&#125;
</code></pre>
<p>dump 的过程比较简单，可以分为四步：</p>
<ol>
<li>创建一个 HPROF 文件，用于存储内存信息；</li>
<li>展示一个通知方便开发者点击察看；</li>
<li>展示一个 toast 告诉开发者有内存泄漏并请等待；</li>
<li>调用 <code>Debug.dumpHPROFData()</code> 方法写入文件。</li>
</ol>
<p><code>Debug.dumpHPROFData()</code> 方法是 Android 提供的一个方法，会将 HPROF 信息存储到指定的路径中，同时可能会引起一次 GC。</p>
<p>生成 HPROF 文件之后，就来到了重头戏，第三步——分析 HPROF 文件。</p>
<h2 id="分析-HPROF-文件"><a href="#分析-HPROF-文件" class="headerlink" title="分析 HPROF 文件"></a>分析 HPROF 文件</h2><p>上面提到了，分析 HPROF 文件使用的是 HeapAnalyzerService 这个服务，我们来看一下它的实现方法。</p>
<p>HeapAnalyzerService 本质上是一个 IntentService，它继承自 leakcanary.internal.ForegoundService，而 ForegroundService 又继承自 IntentService。</p>
<pre><code class="kotlin">internal class HeapAnalyzerService : ForegroundService(
    HeapAnalyzerService::class.java.simpleName,
    R.string.leak_canary_notification_analysing,
    R.id.leak_canary_notification_analyzing_heap
), OnAnalysisProgressListener &#123;

    override fun onHandleIntentInForeground(intent: Intent?) &#123;
    if (intent == null || !intent.hasExtra(HEAPDUMP_FILE_EXTRA)) &#123;
      SharkLog.d &#123; &quot;HeapAnalyzerService received a null or empty intent, ignoring.&quot; &#125;
      return
    &#125;

    // Since we&#39;re running in the main process we should be careful not to impact it.
    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND)
    val heapDumpFile = intent.getSerializableExtra(HEAPDUMP_FILE_EXTRA) as File

    val config = LeakCanary.config
    val heapAnalysis = if (heapDumpFile.exists()) &#123;
      analyzeHeap(heapDumpFile, config)
    &#125; else &#123;
      missingFileFailure(heapDumpFile)
    &#125;
    onAnalysisProgress(REPORTING_HEAP_ANALYSIS)
    config.onHeapAnalyzedListener.onHeapAnalyzed(heapAnalysis)
  &#125;

  ...

  companion object &#123;
    private const val HEAPDUMP_FILE_EXTRA = &quot;HEAPDUMP_FILE_EXTRA&quot;
    private const val PROGUARD_MAPPING_FILE_NAME = &quot;leakCanaryObfuscationMapping.txt&quot;

    fun runAnalysis(
      context: Context,
      heapDumpFile: File
    ) &#123;
      val intent = Intent(context, HeapAnalyzerService::class.java)
      intent.putExtra(HEAPDUMP_FILE_EXTRA, heapDumpFile)
      startForegroundService(context, intent)
    &#125;

    private fun startForegroundService(
      context: Context,
      intent: Intent
    ) &#123;
      if (SDK_INT &gt;= 26) &#123;
        context.startForegroundService(intent)
      &#125; else &#123;
        // Pre-O behavior.
        context.startService(intent)
      &#125;
    &#125;
  &#125;
&#125;
</code></pre>
<p>在调用了 <code>HeapAnalyzerService.runAnalysis()</code> 方法之后，就启动了这个前台服务，最终会调用回 <code>onHandleIntentInForeground()</code> 方法，紧接着，在调低进程优先级后，调用了 <code>analyzeHeap()</code> 方法；</p>
<pre><code class="kotlin">private fun analyzeHeap(
  heapDumpFile: File,
  config: Config
): HeapAnalysis &#123;
  val heapAnalyzer = HeapAnalyzer(this)

  val proguardMappingReader = try &#123;
    ProguardMappingReader(assets.open(PROGUARD_MAPPING_FILE_NAME))
  &#125; catch (e: IOException) &#123;
    null
  &#125;
  return heapAnalyzer.analyze(
      heapDumpFile = heapDumpFile,
      leakingObjectFinder = config.leakingObjectFinder,
      referenceMatchers = config.referenceMatchers,
      computeRetainedHeapSize = config.computeRetainedHeapSize,
      objectInspectors = config.objectInspectors,
      metadataExtractor = config.metadataExtractor,
      proguardMapping = proguardMappingReader?.readProguardMapping()
  )
&#125;
</code></pre>
<p>此处新建了 HeapAnalyzer 的实例并进行 HPROF 文件的处理。</p>
<p>Leakcanary 在分析 HPROF 文件方面进行了一次变革，之前使用的是第三方库 <a target="_blank" rel="noopener" href="https://github.com/square/haha">HAHA</a>，后来又着手开发了自己的库叫 <a target="_blank" rel="noopener" href="https://square.github.io/leakcanary/shark/">Shark</a>。接下来就开始使用到自己的 Shark 库了，HeapAnalyzer 就是这个库中的类。</p>
<pre><code class="kotlin">class HeapAnalyzer constructor(
  private val listener: OnAnalysisProgressListener
) &#123;
  ...
  /**
   * Searches the heap dump for leaking instances and then computes the shortest strong reference
   * path from those instances to the GC roots.
   */
  fun analyze(
    heapDumpFile: File,
    leakingObjectFinder: LeakingObjectFinder,
    referenceMatchers: List&lt;ReferenceMatcher&gt; = emptyList(),
    computeRetainedHeapSize: Boolean = false,
    objectInspectors: List&lt;ObjectInspector&gt; = emptyList(),
    metadataExtractor: MetadataExtractor = MetadataExtractor.NO_OP,
    proguardMapping: ProguardMapping? = null
  ): HeapAnalysis &#123;

    ...

    return try &#123;
      listener.onAnalysisProgress(PARSING_HEAP_DUMP)
      Hprof.open(heapDumpFile)
          .use &#123; hprof -&gt;
            val graph = HprofHeapGraph.indexHprof(hprof, proguardMapping)
            val helpers = FindLeakInput(graph, referenceMatchers, computeRetainedHeapSize, objectInspectors)
            helpers.analyzeGraph(
                metadataExtractor, leakingObjectFinder, heapDumpFile, analysisStartNanoTime
            )
          &#125;
    &#125; catch (exception: Throwable) &#123;
      HeapAnalysisFailure(
          heapDumpFile, System.currentTimeMillis(), since(analysisStartNanoTime),
          HeapAnalysisException(exception)
      )
    &#125;
  &#125;
&#125;
</code></pre>
<p>在这篇文章中就不具体展开 Shark 对于 HPROF 文件的解析了，有空单开一篇文章讲一讲。</p>
<p>总之，在分析完 HRPOF 文件后，返回分析结果，并交给 <code>config.onHeapAnalyzedListener.onHeapAnalyzed(heapAnalysis)</code>。</p>
<p>这个 Config 有必要提一下，它是个贯穿始终的角色，里面存储了 N 多的全局变量，是一个 data 类，开发者可以使用 <code>copy()</code> 方法修改 Leakcanary 的默认配置，或者自定义解析器、各种 Listener 等等。此处的 <code>onHeapAnalyzedListener</code> 是在 config 中已经被预定义好的：</p>
<pre><code class="kotlin">/**
  * Called on a background thread when the heap analysis is complete.
  * If you want leaks to be added to the activity that lists leaks, make sure to delegate
  * calls to a [DefaultOnHeapAnalyzedListener].
  *
  * Defaults to [DefaultOnHeapAnalyzedListener]
  */
val onHeapAnalyzedListener: OnHeapAnalyzedListener = DefaultOnHeapAnalyzedListener.create(),
</code></pre>
<p>我们看一下它的 <code>onHeapAnalyzed()</code> 方法：</p>
<pre><code class="kotlin">class DefaultOnHeapAnalyzedListener(private val application: Application) : OnHeapAnalyzedListener &#123;
  private val mainHandler = Handler(Looper.getMainLooper())

  override fun onHeapAnalyzed(heapAnalysis: HeapAnalysis) &#123;
    SharkLog.d &#123; &quot;$heapAnalysis&quot; &#125;

    val id = LeaksDbHelper(application).writableDatabase.use &#123; db -&gt;
      HeapAnalysisTable.insert(db, heapAnalysis)
    &#125;

    val (contentTitle, screenToShow) = when (heapAnalysis) &#123;
      is HeapAnalysisFailure -&gt; application.getString(
          R.string.leak_canary_analysis_failed
      ) to HeapAnalysisFailureScreen(id)
      is HeapAnalysisSuccess -&gt; &#123;
        val retainedObjectCount = heapAnalysis.allLeaks.sumBy &#123; it.leakTraces.size &#125;
        val leakTypeCount = heapAnalysis.applicationLeaks.size + heapAnalysis.libraryLeaks.size
        application.getString(
            R.string.leak_canary_analysis_success_notification, retainedObjectCount, leakTypeCount
        ) to HeapDumpScreen(id)
      &#125;
    &#125;

    if (InternalLeakCanary.formFactor == TV) &#123;
      showToast(heapAnalysis)
      printIntentInfo()
    &#125; else &#123;
      showNotification(screenToShow, contentTitle)
    &#125;
  &#125;
&#125;
</code></pre>
<p>不考虑我们是 TV 的情况，会展示一个通知：</p>
<pre><code class="kotlin">private fun showNotification(
  screenToShow: Screen,
  contentTitle: String
) &#123;
  val pendingIntent = LeakActivity.createPendingIntent(
      application, arrayListOf(HeapDumpsScreen(), screenToShow)
  )

  val contentText = application.getString(R.string.leak_canary_notification_message)

  Notifications.showNotification(
      application, contentTitle, contentText, pendingIntent,
      R.id.leak_canary_notification_analysis_result,
      LEAKCANARY_MAX
  )
&#125;
</code></pre>
<p>点击这个通知，就会进入 LeakActivity。LeakActivity 就会完整展示内存泄漏的 Reference 路径，方便开发者查找问题。</p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/Flutter/2020-05-27-flutter-intro/" title="Flutter 为什么这么丝滑？"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">Previous: Flutter 为什么这么丝滑？</span></a><a class="button is-default" href="/Android/Android%20%E5%8A%A8%E7%94%BB/" title="关于 Android 动画的一切"><span class="has-text-weight-semibold">Next: 关于 Android 动画的一切</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container" id="vcomments" data-comment_valine_id="b7rbKQnQFa9DYl1anYfacJRz-gzGzoHsz" data-comment_valine_key="nUuKvGHOJBRylruJLW2Fmekg"></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com//"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/serious198706"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com//"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com//"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> cy198706 2023</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="京ICP备2022033375号" target="_blank" rel="noopener" href="https://beian.miit.gov.cn/">京ICP备2022033375号 </a></p></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>