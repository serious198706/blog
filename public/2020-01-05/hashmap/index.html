<!DOCTYPE html><html class="appearance-user-can-set" lang="zh"><head><meta charset="UTF-8"><title>Notex</title><meta name="description" content="Keep low profile, he said."><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="在 Java 和 Android 的开发中，我相信没有人没用过 HashMap 了吧。这几乎是 Java 中最重要的类之一，作为 Key-Value 存储类型的典范，我们在学会使用的同时，也必须要明白 HashMap 内部的实现原理，同时也必须知道它的一些衍生类，以及它们的用法。


概述话不多说，先来看一下 HashMap 在官方文档里的定义：

HashMap 是 Map 接口基于哈希表的实现。这个实现提供了所有可用的对 map 的操作，而且还允许插入 null 值和 null 键。
HashMap 与 Hashtable 类差不多，但 HashMap 是异步的，并且允许 null 值/键。这个类无法保证 map 内元素的顺序；更特别的是，它也无法保证能一直按照某个顺序排列。

Map 接口有三个比较重.."><script src="//unpkg.com/valine/dist/Valine.min.js"></script><meta name="generator" content="Hexo 5.4.2"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><!-- a(href= url_for("/"))= (theme.user && theme.user.name || config.author) + "'s blog"--><a href="/">Notex</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">HashMap 解析</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">主页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">主页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">HashMap 的数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-text">扩容机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9D%87%E5%8C%80%E5%88%86%E5%B8%83"><span class="toc-text">均匀分布</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#equals-%E6%96%B9%E6%B3%95%E5%92%8C-hashCode-%E6%96%B9%E6%B3%95"><span class="toc-text">equals 方法和 hashCode 方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hashtable"><span class="toc-text">Hashtable</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConcurrentHashMap"><span class="toc-text">ConcurrentHashMap</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/Java"><i class="tag post-item-tag">Java</i></a><a href="/tags/HashMap"><i class="tag post-item-tag">HashMap</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">HashMap 解析</h1><time class="has-text-grey" datetime="2020-01-04T16:00:00.000Z">2020-01-05</time><article class="mt-2 post-content"><p>在 Java 和 Android 的开发中，我相信没有人没用过 HashMap 了吧。这几乎是 Java 中最重要的类之一，作为 Key-Value 存储类型的典范，我们在学会使用的同时，也必须要明白 HashMap 内部的实现原理，同时也必须知道它的一些衍生类，以及它们的用法。</p>
<span id="more"></span>

<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>话不多说，先来看一下 HashMap 在官方文档里的定义：</p>
<blockquote>
<p>HashMap 是 Map 接口基于哈希表的实现。这个实现提供了所有可用的对 map 的操作，而且还允许插入 null 值和 null 键。</p>
<p>HashMap 与 Hashtable 类差不多，但 HashMap 是异步的，并且允许 null 值/键。这个类无法保证 map 内元素的顺序；更特别的是，它也无法保证能一直按照某个顺序排列。</p>
</blockquote>
<p>Map 接口有三个比较重要的具体实现类：<strong>HashMap</strong>、<strong>WeakHashMap</strong> 和 <strong>TreeMap</strong>。HashMap 还有一个重要的子类 <strong>LinkedHashMap</strong>，它们几个都是非线程安全的类。</p>
<p>我们可以通过一张图简单了解一下它们之间的关系：</p>
<div align="center">

<p><img src="/img/56.png"></p>
</div>

<p>可以看到，刚才官方文档中提到的 Hashtable，也是 Map 的一个实现类，它的官方描述中有这么一段：</p>
<blockquote>
<p>不像 collection 的实现那样，Hashtable 是同步的。如果不要求线程安全，那你可以使用 HashMap 来替代 Hashtable；如果你对线程安全要求非常高，那推荐你使用 java.util.concurrent.ConcurrentHashMap 来替代 Hashtable。</p>
</blockquote>
<p>后面我们会讨论 <a href="#hashtable">Hashtable</a> 和 <a href="#concurrenthashmap">ConcurrentHashMap</a>。</p>
<h2 id="HashMap-的数据结构"><a href="#HashMap-的数据结构" class="headerlink" title="HashMap 的数据结构"></a>HashMap 的数据结构</h2><p>HashMap 的数据结构是我们非常常用的数据结构，就是由<strong>数组和链表组合构成</strong>的数据结构。如下图所示：</p>
<div align="center">

<p><img src="/img/57.png"></p>
</div>

<p>数组的每个位置都存储了一个key-value这样的实例，在 Java 7 中叫Entry，在 Java 8 中叫Node。这个数组每个元素原本都是 null，在 put 插入数据的时候会根据 key 值的 hash 去计算一个 index 值。</p>
<p>比如我调用<code>put(&quot;debugLife&quot;, 42)</code>，这个时候会通过哈希函数计算出插入的位置，比如说 index 为2吧，那结果就如下图所示：</p>
<div align="center">

<p><img src="/img/58.png"></p>
</div>

<p>那么，只用一个数组就好了呀，为啥还要用到链表？</p>
<p>原因很简单，数组长度有限，在有限的长度里使用哈希，会有很大概率出现不同的 key 的计算出的 index 结果相同。比如我调用<code>put(&quot;lifeDebug, 24)</code>计算出的 index 也为2，就会出现下面的情况：</p>
<div align="center">

<p><img src="/img/59.png"></p>
</div>

<p>上面 index 为2的两对key-value形成了一个链表。这点我们可以通过查看 Node 的代码来佐证：</p>
<pre><code class="java">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;
    final int hash;
    final K key;
    V value;
    Node&lt;K,V&gt; next;
    ...
&#125;
</code></pre>
<p>那么问题来了，如果两次计算的 index 相同，那新的 Node 在插入的时候，是怎么插入的？</p>
<p>在 Java 8 之前是<strong>头插法</strong>，也即新来的 Node 会取代原来的 Node，原有值就被推到链表中去，像上面的图一样。</p>
<p>但是从 Java 8 之后，就采用<strong>尾部插入</strong>了。为什么呢？这个要先从 HashMap 的<strong>扩容机制</strong>说起。</p>
<h3 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h3><p>刚才上面提到了，数组的长度是有限的，当数据多次插入，达到一定的数量之后，就会进行<strong>扩容（resize）</strong>。扩容的因素有两个：</p>
<ul>
<li>Capacity：HashMap 当前的容量</li>
<li>LoadFactor：负载因子，默认值是<code>0.75f</code></li>
</ul>
<pre><code class="java">/**
 * The load factor used when none specified in constructor.
 */
static final float DEFAULT_LOAD_FACTOR = 0.75f;
</code></pre>
<p>负载因子可以理解为，如果当前容量是100，存75个还没事，但存第76个的时候，就要进行扩容。我们来看看代码：</p>
<pre><code class="java">public V put(K key, V value) &#123;
    return putVal(hash(key), key, value, false, true);
&#125;

final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                boolean evict) &#123;
    ...
    if (++size &gt; threshold)
        resize();
&#125;

// 扩容的阈值（容量 * 负载因子)
int threshold;

// 默认的容量，必须是2的幂
static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16

// 如果构造函数未指定的话，负载因子就是0.75f
static final float DEFAULT_LOAD_FACTOR = 0.75f;
</code></pre>
<p>而扩容也并不是简单地扩大点容量就完事了，我们来简单看一下<code>resize()</code>的代码：</p>
<pre><code class="java">// 初始化或者扩容为原来的2倍。
// 如果内容为 null，分配默认容量大小的区域。
// 如果不是，因为我们使用了『2次幂扩展』，所有的元素要么待在原来的 index，要么就在新 table 里偏移『2次幂』个位置。
final Node&lt;K,V&gt;[] resize() &#123;
    Node&lt;K,V&gt;[] oldTab = table;
    int oldCap = (oldTab == null) ? 0 : oldTab.length;
    int oldThr = threshold;
    int newCap, newThr = 0;
    if (oldCap &gt; 0) &#123;
        // 数据量已经到最大值 1 &lt;&lt; 30了，就将阈值设置为 Integer.MAX_VALUE 吧，也不用扩容了，还扩啥扩
        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;
            threshold = Integer.MAX_VALUE;
            return oldTab;
        &#125;
        // 新的容量是旧容量 * 2，新的阈值也是旧的阈值 * 2
        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;
                oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
            newThr = oldThr &lt;&lt; 1;
    &#125;
    // 数据量为0，但是旧阈值大于0，新的容量就是旧的阈值
    else if (oldThr &gt; 0)
        newCap = oldThr;
    // 数据量为0，旧阈值等于0，新的容量就是默认容量，新的阈值就是默认容量 * 默认负载因子
    else &#123;
        newCap = DEFAULT_INITIAL_CAPACITY;
        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
    &#125;
    // 经过上面的处理，新的阈值还是0的话，就进行对比：
    // 如果：新的容量小于最大容量 且 用户设置的阈值小于最大容量的话，新的阈值就是用户设置的阈值
    // 否则：新的阈值就是 Integer.MAX_VALUE
    if (newThr == 0) &#123;
        float ft = (float)newCap * loadFactor;
        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?
                (int)ft : Integer.MAX_VALUE);
    &#125;
    // 设置新的阈值
    threshold = newThr;
    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)
    // 先申请一个长度为之前2倍的新数组
    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];
    // 清空原有数组
    table = newTab;
    if (oldTab != null) &#123;
        // 开始循环处理旧数组
        for (int j = 0; j &lt; oldCap; ++j) &#123;
            Node&lt;K,V&gt; e;
            // 如果旧数组[j]元素不为 null
            if ((e = oldTab[j]) != null) &#123;
                // 把旧数组[j]置为 null
                oldTab[j] = null;
                // 如果旧数组[j]的next无Node，也即该index上只有它自己
                if (e.next == null)
                    // e.hash &amp; (newCap - 1) 是在计算该元素的 index
                    newTab[e.hash &amp; (newCap - 1)] = e;
                // 如果旧数组[j]是红黑树节点，就调用它的split方法，将其子节点复制到新数组中
                else if (e instanceof TreeNode)
                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);
                // 保留之前数据的顺序
                else &#123;
                    Node&lt;K,V&gt; loHead = null, loTail = null;
                    Node&lt;K,V&gt; hiHead = null, hiTail = null;
                    Node&lt;K,V&gt; next;
                    do &#123;
                        // 获取该节点的 next
                        next = e.next;
                        if ((e.hash &amp; oldCap) == 0) &#123;
                            if (loTail == null)
                                loHead = e;
                            else
                                loTail.next = e;
                            loTail = e;
                        &#125;
                        else &#123;
                            if (hiTail == null)
                                hiHead = e;
                            else
                                hiTail.next = e;
                            hiTail = e;
                        &#125;
                    &#125; while ((e = next) != null);
                    if (loTail != null) &#123;
                        loTail.next = null;
                        newTab[j] = loHead;
                    &#125;
                    if (hiTail != null) &#123;
                        hiTail.next = null;
                        newTab[j + oldCap] = hiHead;
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
    return newTab;
&#125;
</code></pre>
<p>可以看得出来，扩容基本上分为两步：</p>
<ol>
<li>将数组的容量扩展为原来的2倍</li>
<li>重新计算所有 Node 的 hash 值，也即 rehash，并插入到新数组中</li>
</ol>
<p>那么，为什么要 rehash？直接扩容不就完事了？</p>
<p>这样做是不行的，因为数组的容量扩大后，<strong>计算 index 的规则也发生了变化</strong>。</p>
<p>index 的计算规则是<code>index = key.hash &amp; (capacity - 1)</code>，之前 capacity 16，变成了 32 的话，值明显就不一样了哇。</p>
<p>好，回到刚才提到的头插尾插。</p>
<p>我们来举个例子，如果现在我们采用头插法，HashMap 的容量是2，负载因子是0.75，那么在插入第二个元素的时候，就要准备扩容了。</p>
<p>现在我们往这个容量是2的数组里用<strong>不同线程</strong>插入 C、B、A 三个 Entry（头插法是 Java8 之前的哦，要叫 Entry 的哦），那么，在数据插入之后，扩容之前，数据结构可能是下面这样：</p>
<div align="center">

<p><img src="/img/60.png"></p>
</div>

<p>我们可以看到链表的指向是 A-&gt;B-&gt;C，因为使用的是头插法，同一 index 时，<strong>新元素总是会被放在链表头的位置</strong>。</p>
<p>resize()之后，旧数组中同一个 index 上的链表，其 Entry 可能会被分配到其他的 index 上，也即出现下面的情况：</p>
<div align="center">

<p><img src="/img/61.png"></p>
</div>

<p>那么待3个线程都调整完毕后，就有可能出现下面的情况：</p>
<div align="center">

<p><img src="/img/62.png"></p>
</div>

<p>出现了！无限循环！ 因为 HashMap 是线程不安全的啊！</p>
<div align="center">

<p><img src="/img/loop.jpg"></p>
</div>

<p>而尾插法就不会出现这样的问题。使用头插时会改变链表上的顺序，但是如果使用尾插，在扩容时会保持链表元素原本的顺序，就不会出现链表成环的问题了。也就是说原本是A-&gt;B，在扩容后那个链表还是A-&gt;B：</p>
<div align="center">

<p><img src="/img/63.png"></p>
</div>

<p>总结起来就是：</p>
<ol>
<li>Java 7 在多线程操作 HashMap 时可能引起死循环，原因是扩容转移后前后链表顺序倒置，在转移过程中修改了原来链表中节点的引用关系。</li>
<li>Java 8 在同样的前提下并不会引起死循环，原因是扩容转移后前后链表顺序不变，保持之前节点的引用关系。</li>
</ol>
<p>但这并不意味着在 Java 8 中可以把 HashMap 用于多线程。从源码的<code>put/get</code>方法中，没有任何同步机制，也就是说，无法保证你某个线程<code>put</code>进去的值，再<code>get</code>的时候还是原值，所以，还是无法保证线程安全。如果要线程安全，请使用 <a href="#hashtable">Hashtable</a> 或者 <a href="#concurrenthashmap">ConcurrentHashMap</a>。 </p>
<h2 id="均匀分布"><a href="#均匀分布" class="headerlink" title="均匀分布"></a>均匀分布</h2><p>从上面的代码里，我们看到了，HashMap 默认初始化长度是<code>1 &lt;&lt; 4</code>，也就是16。那么为什么是16呢？我们来看一下。</p>
<p>HashMap 使用了位运算来得到『16』这个数字，我们都知道，位运算比算数运算的效率要高很多，之所以选择16这个数字，是为了服务将 key 映射到index 的这个算法（前面提到过）：</p>
<pre><code class="java">index = key.hash &amp; (capacity - 1)
</code></pre>
<p>比如我们有个 key 为<code>wtf</code>，它的 hashCode 值是<code>118057</code>，转换为二进制是<code>11100110100101001</code>，使用capacity的默认值16，capacity - 1 是15，转换为二进制是<code>1111</code>，那么套入 index 计算公式的话，就是：</p>
<pre><code class="java">index = 0b11100110100101001 &amp; 0b1111
index = 9
</code></pre>
<p>至于为什么要使用16，而不是14、19、25，是因为使用2次幂数字的时候，减去1，转换为二进制全为1，这种情况下，<code>&amp;</code>出来的结果等同于 hashCode 后几位的值。这种位运算的速度可比取余的方法性能高多了。同时，只要 hashcode 本身分布均匀，index 的分布就是均匀的。</p>
<p>那么，为什么8和32也是2次幂，偏偏选择了16？其实8和32也都可以，可能只是作者认为这个数字比较符合常用吧。</p>
<p>另外，还有个小知识点：Hashmap中的链表大小超过8个时会<strong>自动转化为红黑树</strong>，当删除小于6时<strong>重新变为链表</strong>。这是因为根据**<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-hans/%E6%B3%8A%E6%9D%BE%E5%88%86%E4%BD%88">泊松分布</a><strong>，在负载因子默认为0.75的时候，单个 hash 槽内元素个数为8的</strong>概率小于百万分之一**，所以将7作为一个分水岭，等于7的时候不转换，大于等于8的时候才进行转换，小于等于6的时候就化为链表。</p>
<h2 id="equals-方法和-hashCode-方法"><a href="#equals-方法和-hashCode-方法" class="headerlink" title="equals 方法和 hashCode 方法"></a>equals 方法和 hashCode 方法</h2><p>我们有时为了对比两个对象是否相等，会重写<code>equals()</code>方法，那么，我们是不是也需要重写<code>hashCode()</code>方法呢？</p>
<p>答案是，如果你的对象要放在 HashMap 中的话，需要。</p>
<p>在 Java 中，所有的对象都继承自 Object 类，Obejct 类中有两个方法<code>equals()</code>和<code>hashCode()</code>，用于比较两个对象是否相等。当我们**未重写<code>equals()</code>**时，比较的是两个对象的内存地址，如果是<code>new</code>了两个对象的话，那肯定不同。</p>
<p>刚才我们提到过，HashMap 是通过 hashCode 来计算 index 的，当我们去<code>get</code>的时候，很可能会拿到一个在链表上的值，那么如何确定是链表上的哪个值呢？是了，通过<code>equals()</code>，我们来看看它的代码部分：</p>
<pre><code class="java">public V get(Object key) &#123;
    Node&lt;K,V&gt; e;
    return (e = getNode(hash(key), key)) == null ? null : e.value;
&#125;

final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;
    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
        (first = tab[(n - 1) &amp; hash]) != null) &#123;
        if (first.hash == hash &amp;&amp; // always check first node
            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))
            return first;
        if ((e = first.next) != null) &#123;
            if (first instanceof TreeNode)
                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);
            do &#123;
                // 就是这里啦，对比 hash 和 equals
                if (e.hash == hash &amp;&amp;
                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                    return e;
            &#125; while ((e = e.next) != null);
        &#125;
    &#125;
    return null;
&#125;
</code></pre>
<p>所以，如果我们对<code>equals()</code>方法进行了重写，那最好也对<code>hashCode()</code>方法进行重写，以保证相同的对象返回相同的 hash 值，不同的对象返回不同的 hash 值。</p>
<h2 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h2><p>这个 Map 的派生类是为了在<code>put/get</code>达到一定的线程安全，才出现的。它的解决方案比较粗暴，直接在<code>put/get</code>方法上加 synchronized 关键字，锁住方法。由此可见，并发度会比较低：</p>
<pre><code class="java">public synchronized V get(Object key) &#123;
    Entry&lt;?,?&gt; tab[] = table;
    int hash = key.hashCode();
    int index = (hash &amp; 0x7FFFFFFF) % tab.length;
    for (Entry&lt;?,?&gt; e = tab[index] ; e != null ; e = e.next) &#123;
        if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;
            return (V)e.value;
        &#125;
    &#125;
    return null;
&#125;
</code></pre>
<p>所以，这个类必定会渐渐地退出舞台，在茫茫历史长河中被慢慢淹没。</p>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>这个必须要单独来一篇<a href="/concurrent-hashmap/">ConcurrentHashMap的文章</a>了。因为 ConcurrentHashMap 内部的原理比 HashMap 要复杂得多，如果赋在这下面，这篇就太长了。</p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2020-01-07/cache-algorithms/" title="关于几种常见的缓存算法"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">Previous: 关于几种常见的缓存算法</span></a><a class="button is-default" href="/2020-01-03/job-interview-network/" title="网络面试题"><span class="has-text-weight-semibold">Next: 网络面试题</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container" id="vcomments" data-comment_valine_id="b7rbKQnQFa9DYl1anYfacJRz-gzGzoHsz" data-comment_valine_key="nUuKvGHOJBRylruJLW2Fmekg"></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com/serious008/"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/serious198706"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com/serious008/"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><a title="zhihu" target="_blank" rel="noopener nofollow" href="//zhihu.com/people/cy198706"><i class="iconfont icon-zhihu"></i></a><!-- 领英--><a title="linkedin" target="_blank" rel="noopener nofollow" href="//www.linkedin.com/in/serious_chen/"><i class="iconfont icon-linkedin"></i></a><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com/serious008/"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> Notex 2023</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="京ICP备2022033375号" target="_blank" rel="noopener" href="https://beian.miit.gov.cn/">京ICP备2022033375号 </a></p></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>