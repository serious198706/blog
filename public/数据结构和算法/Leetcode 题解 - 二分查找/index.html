<!DOCTYPE html><html class="appearance-user-can-set" lang="zh"><head><meta charset="UTF-8"><title>Notex</title><meta name="description" content="Keep low profile, he said."><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="
1. 求开方
2. 大于给定元素的最小元素
3. 有序数组的 Single Element
4. 第一个错误的版本
5. 旋转数组的最小数字
6. 查找区间

正常实现  
Input : [1,2,3,4,5]
key : 3
return the index : 2

public int binarySearch(int[] nums, int key) &amp;#123;
    int l = 0, h = nums.length - 1;
    while (l &amp;lt;= h) &amp;#123;
        int m = l + (h - l) / 2;
        if (nums[m] == key) &amp;#123;
            return m;
        &amp;#125.."><script src="//unpkg.com/valine/dist/Valine.min.js"></script><meta name="generator" content="Hexo 5.4.2"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><!-- a(href= url_for("/"))= (theme.user && theme.user.name || config.author) + "'s blog"--><a href="/">Notex</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center"></p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">主页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">主页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E6%B1%82%E5%BC%80%E6%96%B9"><span class="toc-text">1. 求开方</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%A4%A7%E4%BA%8E%E7%BB%99%E5%AE%9A%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E5%B0%8F%E5%85%83%E7%B4%A0"><span class="toc-text">2. 大于给定元素的最小元素</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84-Single-Element"><span class="toc-text">3. 有序数组的 Single Element</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC"><span class="toc-text">4. 第一个错误的版本</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97"><span class="toc-text">5. 旋转数组的最小数字</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E6%9F%A5%E6%89%BE%E5%8C%BA%E9%97%B4"><span class="toc-text">6. 查找区间</span></a></li></ol></div><div class="column is-9"><header class="my-4"></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle"></h1><time class="has-text-grey" datetime="2023-01-31T06:58:14.701Z">2023-01-31</time><article class="mt-2 post-content"><ul>
<li><a href="#1-%E6%B1%82%E5%BC%80%E6%96%B9">1. 求开方</a></li>
<li><a href="#2-%E5%A4%A7%E4%BA%8E%E7%BB%99%E5%AE%9A%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E5%B0%8F%E5%85%83%E7%B4%A0">2. 大于给定元素的最小元素</a></li>
<li><a href="#3-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84-single-element">3. 有序数组的 Single Element</a></li>
<li><a href="#4-%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC">4. 第一个错误的版本</a></li>
<li><a href="#5-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97">5. 旋转数组的最小数字</a></li>
<li><a href="#6-%E6%9F%A5%E6%89%BE%E5%8C%BA%E9%97%B4">6. 查找区间</a></li>
</ul>
<p><strong>正常实现</strong>  </p>
<pre><code class="text">Input : [1,2,3,4,5]
key : 3
return the index : 2
</code></pre>
<pre><code class="java">public int binarySearch(int[] nums, int key) &#123;
    int l = 0, h = nums.length - 1;
    while (l &lt;= h) &#123;
        int m = l + (h - l) / 2;
        if (nums[m] == key) &#123;
            return m;
        &#125; else if (nums[m] &gt; key) &#123;
            h = m - 1;
        &#125; else &#123;
            l = m + 1;
        &#125;
    &#125;
    return -1;
&#125;
</code></pre>
<p><strong>时间复杂度</strong>  </p>
<p>二分查找也称为折半查找，每次都能将查找区间减半，这种折半特性的算法时间复杂度为 O(logN)。</p>
<p><strong>m 计算</strong>  </p>
<p>有两种计算中值 m 的方式：</p>
<ul>
<li>m = (l + h) / 2</li>
<li>m = l + (h - l) / 2</li>
</ul>
<p>l + h 可能出现加法溢出，也就是说加法的结果大于整型能够表示的范围。但是 l 和 h 都为正数，因此 h - l 不会出现加法溢出问题。所以，最好使用第二种计算法方法。</p>
<p><strong>未成功查找的返回值</strong>  </p>
<p>循环退出时如果仍然没有查找到 key，那么表示查找失败。可以有两种返回值：</p>
<ul>
<li>-1：以一个错误码表示没有查找到 key</li>
<li>l：将 key 插入到 nums 中的正确位置</li>
</ul>
<p><strong>变种</strong>  </p>
<p>二分查找可以有很多变种，实现变种要注意边界值的判断。例如在一个有重复元素的数组中查找 key 的最左位置的实现如下：</p>
<pre><code class="java">public int binarySearch(int[] nums, int key) &#123;
    int l = 0, h = nums.length - 1;
    while (l &lt; h) &#123;
        int m = l + (h - l) / 2;
        if (nums[m] &gt;= key) &#123;
            h = m;
        &#125; else &#123;
            l = m + 1;
        &#125;
    &#125;
    return l;
&#125;
</code></pre>
<p>该实现和正常实现有以下不同：</p>
<ul>
<li>h 的赋值表达式为 h = m</li>
<li>循环条件为 l &lt; h</li>
<li>最后返回 l 而不是 -1</li>
</ul>
<p>在 nums[m] &gt;= key 的情况下，可以推导出最左 key 位于 [l, m] 区间中，这是一个闭区间。h 的赋值表达式为 h = m，因为 m 位置也可能是解。</p>
<p>在 h 的赋值表达式为 h = m 的情况下，如果循环条件为 l &lt;= h，那么会出现循环无法退出的情况，因此循环条件只能是 l &lt; h。以下演示了循环条件为 l &lt;= h 时循环无法退出的情况：</p>
<pre><code class="text">nums = &#123;0, 1, 2&#125;, key = 1
l   m   h
0   1   2  nums[m] &gt;= key
0   0   1  nums[m] &lt; key
1   1   1  nums[m] &gt;= key
1   1   1  nums[m] &gt;= key
...
</code></pre>
<p>当循环体退出时，不表示没有查找到 key，因此最后返回的结果不应该为 -1。为了验证有没有查找到，需要在调用端判断一下返回位置上的值和 key 是否相等。</p>
<h1 id="1-求开方"><a href="#1-求开方" class="headerlink" title="1. 求开方"></a>1. 求开方</h1><p>69. Sqrt(x) (Easy)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/sqrtx/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sqrtx/description/">力扣</a></p>
<pre><code class="html">Input: 4
Output: 2

Input: 8
Output: 2
Explanation: The square root of 8 is 2.82842..., and since we want to return an integer, the decimal part will be truncated.
</code></pre>
<p>一个数 x 的开方 sqrt 一定在 0 ~ x 之间，并且满足 sqrt == x / sqrt。可以利用二分查找在 0 ~ x 之间查找 sqrt。</p>
<p>对于 x = 8，它的开方是 2.82842…，最后应该返回 2 而不是 3。在循环条件为 l &lt;= h 并且循环退出时，h 总是比 l 小 1，也就是说 h = 2，l = 3，因此最后的返回值应该为 h 而不是 l。</p>
<pre><code class="java">public int mySqrt(int x) &#123;
    if (x &lt;= 1) &#123;
        return x;
    &#125;
    int l = 1, h = x;
    while (l &lt;= h) &#123;
        int mid = l + (h - l) / 2;
        int sqrt = x / mid;
        if (sqrt == mid) &#123;
            return mid;
        &#125; else if (mid &gt; sqrt) &#123;
            h = mid - 1;
        &#125; else &#123;
            l = mid + 1;
        &#125;
    &#125;
    return h;
&#125;
</code></pre>
<h1 id="2-大于给定元素的最小元素"><a href="#2-大于给定元素的最小元素" class="headerlink" title="2. 大于给定元素的最小元素"></a>2. 大于给定元素的最小元素</h1><p>744. Find Smallest Letter Greater Than Target (Easy)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-smallest-letter-greater-than-target/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/description/">力扣</a></p>
<pre><code class="html">Input:
letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]
target = &quot;d&quot;
Output: &quot;f&quot;

Input:
letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]
target = &quot;k&quot;
Output: &quot;c&quot;
</code></pre>
<p>题目描述：给定一个有序的字符数组 letters 和一个字符 target，要求找出 letters 中大于 target 的最小字符，如果找不到就返回第 1 个字符。</p>
<pre><code class="java">public char nextGreatestLetter(char[] letters, char target) &#123;
    int n = letters.length;
    int l = 0, h = n - 1;
    while (l &lt;= h) &#123;
        int m = l + (h - l) / 2;
        if (letters[m] &lt;= target) &#123;
            l = m + 1;
        &#125; else &#123;
            h = m - 1;
        &#125;
    &#125;
    return l &lt; n ? letters[l] : letters[0];
&#125;
</code></pre>
<h1 id="3-有序数组的-Single-Element"><a href="#3-有序数组的-Single-Element" class="headerlink" title="3. 有序数组的 Single Element"></a>3. 有序数组的 Single Element</h1><p>540. Single Element in a Sorted Array (Medium)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/single-element-in-a-sorted-array/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/single-element-in-a-sorted-array/description/">力扣</a></p>
<pre><code class="html">Input: [1, 1, 2, 3, 3, 4, 4, 8, 8]
Output: 2
</code></pre>
<p>题目描述：一个有序数组只有一个数不出现两次，找出这个数。</p>
<p>要求以 O(logN) 时间复杂度进行求解，因此不能遍历数组并进行异或操作来求解，这么做的时间复杂度为 O(N)。</p>
<p>令 index 为 Single Element 在数组中的位置。在 index 之后，数组中原来存在的成对状态被改变。如果 m 为偶数，并且 m + 1 &lt; index，那么 nums[m] == nums[m + 1]；m + 1 &gt;= index，那么 nums[m] != nums[m + 1]。</p>
<p>从上面的规律可以知道，如果 nums[m] == nums[m + 1]，那么 index 所在的数组位置为 [m + 2, h]，此时令 l = m + 2；如果 nums[m] != nums[m + 1]，那么 index 所在的数组位置为 [l, m]，此时令 h = m。</p>
<p>因为 h 的赋值表达式为 h = m，那么循环条件也就只能使用 l &lt; h 这种形式。</p>
<pre><code class="java">public int singleNonDuplicate(int[] nums) &#123;
    int l = 0, h = nums.length - 1;
    while (l &lt; h) &#123;
        int m = l + (h - l) / 2;
        if (m % 2 == 1) &#123;
            m--;   // 保证 l/h/m 都在偶数位，使得查找区间大小一直都是奇数
        &#125;
        if (nums[m] == nums[m + 1]) &#123;
            l = m + 2;
        &#125; else &#123;
            h = m;
        &#125;
    &#125;
    return nums[l];
&#125;
</code></pre>
<h1 id="4-第一个错误的版本"><a href="#4-第一个错误的版本" class="headerlink" title="4. 第一个错误的版本"></a>4. 第一个错误的版本</h1><p>278. First Bad Version (Easy)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/first-bad-version/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/first-bad-version/description/">力扣</a></p>
<p>题目描述：给定一个元素 n 代表有 [1, 2, …, n] 版本，在第 x 位置开始出现错误版本，导致后面的版本都错误。可以调用 isBadVersion(int x) 知道某个版本是否错误，要求找到第一个错误的版本。</p>
<p>如果第 m 个版本出错，则表示第一个错误的版本在 [l, m] 之间，令 h = m；否则第一个错误的版本在 [m + 1, h] 之间，令 l = m + 1。</p>
<p>因为 h 的赋值表达式为 h = m，因此循环条件为 l &lt; h。</p>
<pre><code class="java">public int firstBadVersion(int n) &#123;
    int l = 1, h = n;
    while (l &lt; h) &#123;
        int mid = l + (h - l) / 2;
        if (isBadVersion(mid)) &#123;
            h = mid;
        &#125; else &#123;
            l = mid + 1;
        &#125;
    &#125;
    return l;
&#125;
</code></pre>
<h1 id="5-旋转数组的最小数字"><a href="#5-旋转数组的最小数字" class="headerlink" title="5. 旋转数组的最小数字"></a>5. 旋转数组的最小数字</h1><p>153. Find Minimum in Rotated Sorted Array (Medium)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/description/">力扣</a></p>
<pre><code class="html">Input: [3,4,5,1,2],
Output: 1
</code></pre>
<pre><code class="java">public int findMin(int[] nums) &#123;
    int l = 0, h = nums.length - 1;
    while (l &lt; h) &#123;
        int m = l + (h - l) / 2;
        if (nums[m] &lt;= nums[h]) &#123;
            h = m;
        &#125; else &#123;
            l = m + 1;
        &#125;
    &#125;
    return nums[l];
&#125;
</code></pre>
<h1 id="6-查找区间"><a href="#6-查找区间" class="headerlink" title="6. 查找区间"></a>6. 查找区间</h1><p>34. Find First and Last Position of Element in Sorted Array</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">力扣</a></p>
<pre><code class="html">Input: nums = [5,7,7,8,8,10], target = 8
Output: [3,4]

Input: nums = [5,7,7,8,8,10], target = 6
Output: [-1,-1]
</code></pre>
<p>题目描述：给定一个有序数组 nums 和一个目标 target，要求找到 target 在 nums 中的第一个位置和最后一个位置。</p>
<p>可以用二分查找找出第一个位置和最后一个位置，但是寻找的方法有所不同，需要实现两个二分查找。我们将寻找  target 最后一个位置，转换成寻找 target+1 第一个位置，再往前移动一个位置。这样我们只需要实现一个二分查找代码即可。</p>
<pre><code class="java">public int[] searchRange(int[] nums, int target) &#123;
    int first = findFirst(nums, target);
    int last = findFirst(nums, target + 1) - 1;
    if (first == nums.length || nums[first] != target) &#123;
        return new int[]&#123;-1, -1&#125;;
    &#125; else &#123;
        return new int[]&#123;first, Math.max(first, last)&#125;;
    &#125;
&#125;

private int findFirst(int[] nums, int target) &#123;
    int l = 0, h = nums.length; // 注意 h 的初始值
    while (l &lt; h) &#123;
        int m = l + (h - l) / 2;
        if (nums[m] &gt;= target) &#123;
            h = m;
        &#125; else &#123;
            l = m + 1;
        &#125;
    &#125;
    return l;
&#125;
</code></pre>
<p>在寻找第一个位置的二分查找代码中，需要注意 h 的取值为 nums.length，而不是 nums.length - 1。先看以下示例：</p>
<pre><code>nums = [2,2], target = 2
</code></pre>
<p>如果 h 的取值为 nums.length - 1，那么 last = findFirst(nums, target + 1) - 1 = 1 - 1 = 0。这是因为 findLeft 只会返回 [0, nums.length - 1] 范围的值，对于 findFirst([2,2], 3) ，我们希望返回 3 插入 nums 中的位置，也就是数组最后一个位置再往后一个位置，即 nums.length。所以我们需要将 h 取值为 nums.length，从而使得 findFirst返回的区间更大，能够覆盖 target 大于 nums 最后一个元素的情况。</p>
<div align="center"><img width="320px" src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/githubio/公众号二维码-2.png"></img></div>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><em></em></section><article class="mt-6 comment-container" id="vcomments" data-comment_valine_id="b7rbKQnQFa9DYl1anYfacJRz-gzGzoHsz" data-comment_valine_key="nUuKvGHOJBRylruJLW2Fmekg"></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com//"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/serious198706"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com//"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com//"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> cy198706 2023</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="京ICP备2022033375号" target="_blank" rel="noopener" href="https://beian.miit.gov.cn/">京ICP备2022033375号 </a></p></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>