<!DOCTYPE html><html class="appearance-user-can-set" lang="zh"><head><meta charset="UTF-8"><title>Notex</title><meta name="description" content="Keep low profile, he said."><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="
1. 找出两个链表的交点
2. 链表反转
3. 归并两个有序的链表
4. 从有序链表中删除重复节点
5. 删除链表的倒数第 n 个节点
6. 交换链表中的相邻结点
7. 链表求和
8. 回文链表
9. 分隔链表
10. 链表元素按奇偶聚集

链表是空节点，或者有一个值和一个指向下一个链表的指针，因此很多链表问题可以用递归来处理。
1. 找出两个链表的交点160. Intersection of Two Linked Lists (Easy)
Leetcode / 力扣
例如以下示例中 A 和 B 两个链表相交于 c1：
A:          a1 → a2
                    ↘
                      c1 → c2 → c3
                 .."><script src="//unpkg.com/valine/dist/Valine.min.js"></script><meta name="generator" content="Hexo 5.4.2"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><!-- a(href= url_for("/"))= (theme.user && theme.user.name || config.author) + "'s blog"--><a href="/">Notex</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center"></p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">主页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">主页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E6%89%BE%E5%87%BA%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BA%A4%E7%82%B9"><span class="toc-text">1. 找出两个链表的交点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC"><span class="toc-text">2. 链表反转</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%BD%92%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8"><span class="toc-text">3. 归并两个有序的链表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E4%BB%8E%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9"><span class="toc-text">4. 从有序链表中删除重复节点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-n-%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-text">5. 删除链表的倒数第 n 个节点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E7%9B%B8%E9%82%BB%E7%BB%93%E7%82%B9"><span class="toc-text">6. 交换链表中的相邻结点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E9%93%BE%E8%A1%A8%E6%B1%82%E5%92%8C"><span class="toc-text">7. 链表求和</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8"><span class="toc-text">8. 回文链表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8"><span class="toc-text">9. 分隔链表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0%E6%8C%89%E5%A5%87%E5%81%B6%E8%81%9A%E9%9B%86"><span class="toc-text">10. 链表元素按奇偶聚集</span></a></li></ol></div><div class="column is-9"><header class="my-4"></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle"></h1><time class="has-text-grey" datetime="2023-01-31T06:58:14.699Z">2023-01-31</time><article class="mt-2 post-content"><ul>
<li><a href="#1-%E6%89%BE%E5%87%BA%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BA%A4%E7%82%B9">1. 找出两个链表的交点</a></li>
<li><a href="#2-%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC">2. 链表反转</a></li>
<li><a href="#3-%E5%BD%92%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8">3. 归并两个有序的链表</a></li>
<li><a href="#4-%E4%BB%8E%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9">4. 从有序链表中删除重复节点</a></li>
<li><a href="#5-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-n-%E4%B8%AA%E8%8A%82%E7%82%B9">5. 删除链表的倒数第 n 个节点</a></li>
<li><a href="#6-%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E7%9B%B8%E9%82%BB%E7%BB%93%E7%82%B9">6. 交换链表中的相邻结点</a></li>
<li><a href="#7-%E9%93%BE%E8%A1%A8%E6%B1%82%E5%92%8C">7. 链表求和</a></li>
<li><a href="#8-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8">8. 回文链表</a></li>
<li><a href="#9-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8">9. 分隔链表</a></li>
<li><a href="#10-%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0%E6%8C%89%E5%A5%87%E5%81%B6%E8%81%9A%E9%9B%86">10. 链表元素按奇偶聚集</a></li>
</ul>
<p>链表是空节点，或者有一个值和一个指向下一个链表的指针，因此很多链表问题可以用递归来处理。</p>
<h1 id="1-找出两个链表的交点"><a href="#1-找出两个链表的交点" class="headerlink" title="1. 找出两个链表的交点"></a>1. 找出两个链表的交点</h1><p>160. Intersection of Two Linked Lists (Easy)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/intersection-of-two-linked-lists/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/description/">力扣</a></p>
<p>例如以下示例中 A 和 B 两个链表相交于 c1：</p>
<pre><code class="html">A:          a1 → a2
                    ↘
                      c1 → c2 → c3
                    ↗
B:    b1 → b2 → b3
</code></pre>
<p>但是不会出现以下相交的情况，因为每个节点只有一个 next 指针，也就只能有一个后继节点，而以下示例中节点 c 有两个后继节点。</p>
<pre><code class="html">A:          a1 → a2       d1 → d2
                    ↘  ↗
                      c
                    ↗  ↘
B:    b1 → b2 → b3        e1 → e2
</code></pre>
<p>要求时间复杂度为 O(N)，空间复杂度为 O(1)。如果不存在交点则返回 null。</p>
<p>设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b = b + c + a。</p>
<p>当访问 A 链表的指针访问到链表尾部时，令它从链表 B 的头部开始访问链表 B；同样地，当访问 B 链表的指针访问到链表尾部时，令它从链表 A 的头部开始访问链表 A。这样就能控制访问 A 和 B 两个链表的指针能同时访问到交点。</p>
<p>如果不存在交点，那么 a + b = b + a，以下实现代码中 l1 和 l2 会同时为 null，从而退出循环。</p>
<pre><code class="java">public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;
    ListNode l1 = headA, l2 = headB;
    while (l1 != l2) &#123;
        l1 = (l1 == null) ? headB : l1.next;
        l2 = (l2 == null) ? headA : l2.next;
    &#125;
    return l1;
&#125;
</code></pre>
<p>如果只是判断是否存在交点，那么就是另一个问题，即 <a href="">编程之美 3.6</a> 的问题。有两种解法：</p>
<ul>
<li>把第一个链表的结尾连接到第二个链表的开头，看第二个链表是否存在环；</li>
<li>或者直接比较两个链表的最后一个节点是否相同。</li>
</ul>
<h1 id="2-链表反转"><a href="#2-链表反转" class="headerlink" title="2. 链表反转"></a>2. 链表反转</h1><p>206. Reverse Linked List (Easy)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-linked-list/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-linked-list/description/">力扣</a></p>
<p>递归</p>
<pre><code class="java">public ListNode reverseList(ListNode head) &#123;
    if (head == null || head.next == null) &#123;
        return head;
    &#125;
    ListNode next = head.next;
    ListNode newHead = reverseList(next);
    next.next = head;
    head.next = null;
    return newHead;
&#125;
</code></pre>
<p>头插法</p>
<pre><code class="java">public ListNode reverseList(ListNode head) &#123;
    ListNode newHead = new ListNode(-1);
    while (head != null) &#123;
        ListNode next = head.next;
        head.next = newHead.next;
        newHead.next = head;
        head = next;
    &#125;
    return newHead.next;
&#125;
</code></pre>
<h1 id="3-归并两个有序的链表"><a href="#3-归并两个有序的链表" class="headerlink" title="3. 归并两个有序的链表"></a>3. 归并两个有序的链表</h1><p>21. Merge Two Sorted Lists (Easy)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/merge-two-sorted-lists/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-two-sorted-lists/description/">力扣</a></p>
<pre><code class="java">public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;
    if (l1 == null) return l2;
    if (l2 == null) return l1;
    if (l1.val &lt; l2.val) &#123;
        l1.next = mergeTwoLists(l1.next, l2);
        return l1;
    &#125; else &#123;
        l2.next = mergeTwoLists(l1, l2.next);
        return l2;
    &#125;
&#125;
</code></pre>
<h1 id="4-从有序链表中删除重复节点"><a href="#4-从有序链表中删除重复节点" class="headerlink" title="4. 从有序链表中删除重复节点"></a>4. 从有序链表中删除重复节点</h1><p>83. Remove Duplicates from Sorted List (Easy)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/description/">力扣</a></p>
<pre><code class="html">Given 1-&gt;1-&gt;2, return 1-&gt;2.
Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3.
</code></pre>
<pre><code class="java">public ListNode deleteDuplicates(ListNode head) &#123;
    if (head == null || head.next == null) return head;
    head.next = deleteDuplicates(head.next);
    return head.val == head.next.val ? head.next : head;
&#125;
</code></pre>
<h1 id="5-删除链表的倒数第-n-个节点"><a href="#5-删除链表的倒数第-n-个节点" class="headerlink" title="5. 删除链表的倒数第 n 个节点"></a>5. 删除链表的倒数第 n 个节点</h1><p>19. Remove Nth Node From End of List (Medium)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/description/">力扣</a></p>
<pre><code class="html">Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.
After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.
</code></pre>
<pre><code class="java">public ListNode removeNthFromEnd(ListNode head, int n) &#123;
    ListNode fast = head;
    while (n-- &gt; 0) &#123;
        fast = fast.next;
    &#125;
    if (fast == null) return head.next;
    ListNode slow = head;
    while (fast.next != null) &#123;
        fast = fast.next;
        slow = slow.next;
    &#125;
    slow.next = slow.next.next;
    return head;
&#125;
</code></pre>
<h1 id="6-交换链表中的相邻结点"><a href="#6-交换链表中的相邻结点" class="headerlink" title="6. 交换链表中的相邻结点"></a>6. 交换链表中的相邻结点</h1><p>24. Swap Nodes in Pairs (Medium)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/swap-nodes-in-pairs/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/description/">力扣</a></p>
<pre><code class="html">Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.
</code></pre>
<p>题目要求：不能修改结点的 val 值，O(1) 空间复杂度。</p>
<pre><code class="java">public ListNode swapPairs(ListNode head) &#123;
    ListNode node = new ListNode(-1);
    node.next = head;
    ListNode pre = node;
    while (pre.next != null &amp;&amp; pre.next.next != null) &#123;
        ListNode l1 = pre.next, l2 = pre.next.next;
        ListNode next = l2.next;
        l1.next = next;
        l2.next = l1;
        pre.next = l2;

        pre = l1;
    &#125;
    return node.next;
&#125;
</code></pre>
<h1 id="7-链表求和"><a href="#7-链表求和" class="headerlink" title="7. 链表求和"></a>7. 链表求和</h1><p>445. Add Two Numbers II (Medium)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/add-two-numbers-ii/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/add-two-numbers-ii/description/">力扣</a></p>
<pre><code class="html">Input: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)
Output: 7 -&gt; 8 -&gt; 0 -&gt; 7
</code></pre>
<p>题目要求：不能修改原始链表。</p>
<pre><code class="java">public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;
    Stack&lt;Integer&gt; l1Stack = buildStack(l1);
    Stack&lt;Integer&gt; l2Stack = buildStack(l2);
    ListNode head = new ListNode(-1);
    int carry = 0;
    while (!l1Stack.isEmpty() || !l2Stack.isEmpty() || carry != 0) &#123;
        int x = l1Stack.isEmpty() ? 0 : l1Stack.pop();
        int y = l2Stack.isEmpty() ? 0 : l2Stack.pop();
        int sum = x + y + carry;
        ListNode node = new ListNode(sum % 10);
        node.next = head.next;
        head.next = node;
        carry = sum / 10;
    &#125;
    return head.next;
&#125;

private Stack&lt;Integer&gt; buildStack(ListNode l) &#123;
    Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
    while (l != null) &#123;
        stack.push(l.val);
        l = l.next;
    &#125;
    return stack;
&#125;
</code></pre>
<h1 id="8-回文链表"><a href="#8-回文链表" class="headerlink" title="8. 回文链表"></a>8. 回文链表</h1><p>234. Palindrome Linked List (Easy)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/palindrome-linked-list/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/palindrome-linked-list/description/">力扣</a></p>
<p>题目要求：以 O(1) 的空间复杂度来求解。</p>
<p>切成两半，把后半段反转，然后比较两半是否相等。</p>
<pre><code class="java">public boolean isPalindrome(ListNode head) &#123;
    if (head == null || head.next == null) return true;
    ListNode slow = head, fast = head.next;
    while (fast != null &amp;&amp; fast.next != null) &#123;
        slow = slow.next;
        fast = fast.next.next;
    &#125;
    if (fast != null) slow = slow.next;  // 偶数节点，让 slow 指向下一个节点
    cut(head, slow);                     // 切成两个链表
    return isEqual(head, reverse(slow));
&#125;

private void cut(ListNode head, ListNode cutNode) &#123;
    while (head.next != cutNode) &#123;
        head = head.next;
    &#125;
    head.next = null;
&#125;

private ListNode reverse(ListNode head) &#123;
    ListNode newHead = null;
    while (head != null) &#123;
        ListNode nextNode = head.next;
        head.next = newHead;
        newHead = head;
        head = nextNode;
    &#125;
    return newHead;
&#125;

private boolean isEqual(ListNode l1, ListNode l2) &#123;
    while (l1 != null &amp;&amp; l2 != null) &#123;
        if (l1.val != l2.val) return false;
        l1 = l1.next;
        l2 = l2.next;
    &#125;
    return true;
&#125;
</code></pre>
<h1 id="9-分隔链表"><a href="#9-分隔链表" class="headerlink" title="9. 分隔链表"></a>9. 分隔链表</h1><p>725. Split Linked List in Parts(Medium)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/split-linked-list-in-parts/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/split-linked-list-in-parts/description/">力扣</a></p>
<pre><code class="html">Input:
root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3
Output: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]
Explanation:
The input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts.
</code></pre>
<p>题目描述：把链表分隔成 k 部分，每部分的长度都应该尽可能相同，排在前面的长度应该大于等于后面的。</p>
<pre><code class="java">public ListNode[] splitListToParts(ListNode root, int k) &#123;
    int N = 0;
    ListNode cur = root;
    while (cur != null) &#123;
        N++;
        cur = cur.next;
    &#125;
    int mod = N % k;
    int size = N / k;
    ListNode[] ret = new ListNode[k];
    cur = root;
    for (int i = 0; cur != null &amp;&amp; i &lt; k; i++) &#123;
        ret[i] = cur;
        int curSize = size + (mod-- &gt; 0 ? 1 : 0);
        for (int j = 0; j &lt; curSize - 1; j++) &#123;
            cur = cur.next;
        &#125;
        ListNode next = cur.next;
        cur.next = null;
        cur = next;
    &#125;
    return ret;
&#125;
</code></pre>
<h1 id="10-链表元素按奇偶聚集"><a href="#10-链表元素按奇偶聚集" class="headerlink" title="10. 链表元素按奇偶聚集"></a>10. 链表元素按奇偶聚集</h1><p>328. Odd Even Linked List (Medium)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/odd-even-linked-list/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/odd-even-linked-list/description/">力扣</a></p>
<pre><code class="html">Example:
Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL,
return 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL.
</code></pre>
<pre><code class="java">public ListNode oddEvenList(ListNode head) &#123;
    if (head == null) &#123;
        return head;
    &#125;
    ListNode odd = head, even = head.next, evenHead = even;
    while (even != null &amp;&amp; even.next != null) &#123;
        odd.next = odd.next.next;
        odd = odd.next;
        even.next = even.next.next;
        even = even.next;
    &#125;
    odd.next = evenHead;
    return head;
&#125;
</code></pre>
<div align="center"><img width="320px" src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/githubio/公众号二维码-2.png"></img></div>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><em></em></section><article class="mt-6 comment-container" id="vcomments" data-comment_valine_id="b7rbKQnQFa9DYl1anYfacJRz-gzGzoHsz" data-comment_valine_key="nUuKvGHOJBRylruJLW2Fmekg"></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com//"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/serious198706"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com//"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com//"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> cy198706 2023</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="京ICP备2022033375号" target="_blank" rel="noopener" href="https://beian.miit.gov.cn/">京ICP备2022033375号 </a></p></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>