<!DOCTYPE html><html class="appearance-user-can-set" lang="zh"><head><meta charset="UTF-8"><title>Notex</title><meta name="description" content="Keep low profile, he said."><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="
素数分解
整除
最大公约数最小公倍数
1. 生成素数序列
2. 最大公约数
3. 使用位操作和减法求解最大公约数


进制转换
1. 7 进制
2. 16 进制
3. 26 进制


阶乘
1. 统计阶乘尾部有多少个 0


字符串加法减法
1. 二进制加法
2. 字符串加法


相遇问题
1. 改变数组元素使所有的数组元素都相等


多数投票问题
1. 数组中出现次数多于 n / 2 的元素


其它
1. 平方数
2. 3 的 n 次方
3. 乘积数组
4. 找出数组中的乘积最大的三个数



素数分解每一个数都可以分解成素数的乘积，例如 84 = 22 * 31 * 50 * 71 * 110 * 130 * 170 * …
整除令 x = 2m0 * 3m1 * 5m2 * 7m3 * 11m4 .."><script src="//unpkg.com/valine/dist/Valine.min.js"></script><meta name="generator" content="Hexo 5.4.2"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><!-- a(href= url_for("/"))= (theme.user && theme.user.name || config.author) + "'s blog"--><a href="/">Notex</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center"></p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">主页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">主页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B4%A0%E6%95%B0%E5%88%86%E8%A7%A3"><span class="toc-text">素数分解</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B4%E9%99%A4"><span class="toc-text">整除</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0"><span class="toc-text">最大公约数最小公倍数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%94%9F%E6%88%90%E7%B4%A0%E6%95%B0%E5%BA%8F%E5%88%97"><span class="toc-text">1. 生成素数序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0"><span class="toc-text">2. 最大公约数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8%E4%BD%8D%E6%93%8D%E4%BD%9C%E5%92%8C%E5%87%8F%E6%B3%95%E6%B1%82%E8%A7%A3%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0"><span class="toc-text">3. 使用位操作和减法求解最大公约数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-text">进制转换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-%E8%BF%9B%E5%88%B6"><span class="toc-text">1. 7 进制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-16-%E8%BF%9B%E5%88%B6"><span class="toc-text">2. 16 进制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-26-%E8%BF%9B%E5%88%B6"><span class="toc-text">3. 26 进制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%98%B6%E4%B9%98"><span class="toc-text">阶乘</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%BB%9F%E8%AE%A1%E9%98%B6%E4%B9%98%E5%B0%BE%E9%83%A8%E6%9C%89%E5%A4%9A%E5%B0%91%E4%B8%AA-0"><span class="toc-text">1. 统计阶乘尾部有多少个 0</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8A%A0%E6%B3%95%E5%87%8F%E6%B3%95"><span class="toc-text">字符串加法减法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E6%B3%95"><span class="toc-text">1. 二进制加法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8A%A0%E6%B3%95"><span class="toc-text">2. 字符串加法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9B%B8%E9%81%87%E9%97%AE%E9%A2%98"><span class="toc-text">相遇问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%94%B9%E5%8F%98%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E4%BD%BF%E6%89%80%E6%9C%89%E7%9A%84%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E9%83%BD%E7%9B%B8%E7%AD%89"><span class="toc-text">1. 改变数组元素使所有的数组元素都相等</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E6%95%B0%E6%8A%95%E7%A5%A8%E9%97%AE%E9%A2%98"><span class="toc-text">多数投票问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E5%A4%9A%E4%BA%8E-n-2-%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-text">1. 数组中出现次数多于 n &#x2F; 2 的元素</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B6%E5%AE%83"><span class="toc-text">其它</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%B9%B3%E6%96%B9%E6%95%B0"><span class="toc-text">1. 平方数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E7%9A%84-n-%E6%AC%A1%E6%96%B9"><span class="toc-text">2. 3 的 n 次方</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84"><span class="toc-text">3. 乘积数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E7%9A%84%E4%B8%89%E4%B8%AA%E6%95%B0"><span class="toc-text">4. 找出数组中的乘积最大的三个数</span></a></li></ol></li></ol></div><div class="column is-9"><header class="my-4"></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle"></h1><time class="has-text-grey" datetime="2023-01-31T06:58:14.696Z">2023-01-31</time><article class="mt-2 post-content"><ul>
<li><a href="#%E7%B4%A0%E6%95%B0%E5%88%86%E8%A7%A3">素数分解</a></li>
<li><a href="#%E6%95%B4%E9%99%A4">整除</a></li>
<li><a href="#%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0">最大公约数最小公倍数</a><ul>
<li><a href="#1-%E7%94%9F%E6%88%90%E7%B4%A0%E6%95%B0%E5%BA%8F%E5%88%97">1. 生成素数序列</a></li>
<li><a href="#2-%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0">2. 最大公约数</a></li>
<li><a href="#3-%E4%BD%BF%E7%94%A8%E4%BD%8D%E6%93%8D%E4%BD%9C%E5%92%8C%E5%87%8F%E6%B3%95%E6%B1%82%E8%A7%A3%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0">3. 使用位操作和减法求解最大公约数</a></li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2">进制转换</a><ul>
<li><a href="#1-7-%E8%BF%9B%E5%88%B6">1. 7 进制</a></li>
<li><a href="#2-16-%E8%BF%9B%E5%88%B6">2. 16 进制</a></li>
<li><a href="#3-26-%E8%BF%9B%E5%88%B6">3. 26 进制</a></li>
</ul>
</li>
<li><a href="#%E9%98%B6%E4%B9%98">阶乘</a><ul>
<li><a href="#1-%E7%BB%9F%E8%AE%A1%E9%98%B6%E4%B9%98%E5%B0%BE%E9%83%A8%E6%9C%89%E5%A4%9A%E5%B0%91%E4%B8%AA-0">1. 统计阶乘尾部有多少个 0</a></li>
</ul>
</li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8A%A0%E6%B3%95%E5%87%8F%E6%B3%95">字符串加法减法</a><ul>
<li><a href="#1-%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E6%B3%95">1. 二进制加法</a></li>
<li><a href="#2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8A%A0%E6%B3%95">2. 字符串加法</a></li>
</ul>
</li>
<li><a href="#%E7%9B%B8%E9%81%87%E9%97%AE%E9%A2%98">相遇问题</a><ul>
<li><a href="#1-%E6%94%B9%E5%8F%98%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E4%BD%BF%E6%89%80%E6%9C%89%E7%9A%84%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E9%83%BD%E7%9B%B8%E7%AD%89">1. 改变数组元素使所有的数组元素都相等</a></li>
</ul>
</li>
<li><a href="#%E5%A4%9A%E6%95%B0%E6%8A%95%E7%A5%A8%E9%97%AE%E9%A2%98">多数投票问题</a><ul>
<li><a href="#1-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E5%A4%9A%E4%BA%8E-n--2-%E7%9A%84%E5%85%83%E7%B4%A0">1. 数组中出现次数多于 n / 2 的元素</a></li>
</ul>
</li>
<li><a href="#%E5%85%B6%E5%AE%83">其它</a><ul>
<li><a href="#1-%E5%B9%B3%E6%96%B9%E6%95%B0">1. 平方数</a></li>
<li><a href="#2-3-%E7%9A%84-n-%E6%AC%A1%E6%96%B9">2. 3 的 n 次方</a></li>
<li><a href="#3-%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84">3. 乘积数组</a></li>
<li><a href="#4-%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E7%9A%84%E4%B8%89%E4%B8%AA%E6%95%B0">4. 找出数组中的乘积最大的三个数</a></li>
</ul>
</li>
</ul>
<h1 id="素数分解"><a href="#素数分解" class="headerlink" title="素数分解"></a>素数分解</h1><p>每一个数都可以分解成素数的乘积，例如 84 = 2<sup>2</sup> * 3<sup>1</sup> * 5<sup>0</sup> * 7<sup>1</sup> * 11<sup>0</sup> * 13<sup>0</sup> * 17<sup>0</sup> * …</p>
<h1 id="整除"><a href="#整除" class="headerlink" title="整除"></a>整除</h1><p>令 x = 2<sup>m0</sup> * 3<sup>m1</sup> * 5<sup>m2</sup> * 7<sup>m3</sup> * 11<sup>m4</sup> * …</p>
<p>令 y = 2<sup>n0</sup> * 3<sup>n1</sup> * 5<sup>n2</sup> * 7<sup>n3</sup> * 11<sup>n4</sup> * …</p>
<p>如果 x 整除 y（y mod x == 0），则对于所有 i，mi &lt;= ni。</p>
<h1 id="最大公约数最小公倍数"><a href="#最大公约数最小公倍数" class="headerlink" title="最大公约数最小公倍数"></a>最大公约数最小公倍数</h1><p>x 和 y 的最大公约数为：gcd(x,y) =  2<sup>min(m0,n0)</sup> * 3<sup>min(m1,n1)</sup> * 5<sup>min(m2,n2)</sup> * …</p>
<p>x 和 y 的最小公倍数为：lcm(x,y) =  2<sup>max(m0,n0)</sup> * 3<sup>max(m1,n1)</sup> * 5<sup>max(m2,n2)</sup> * …</p>
<h2 id="1-生成素数序列"><a href="#1-生成素数序列" class="headerlink" title="1. 生成素数序列"></a>1. 生成素数序列</h2><p>204. Count Primes (Easy)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/count-primes/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-primes/description/">力扣</a></p>
<p>埃拉托斯特尼筛法在每次找到一个素数时，将能被素数整除的数排除掉。</p>
<pre><code class="java">public int countPrimes(int n) &#123;
    boolean[] notPrimes = new boolean[n + 1];
    int count = 0;
    for (int i = 2; i &lt; n; i++) &#123;
        if (notPrimes[i]) &#123;
            continue;
        &#125;
        count++;
        // 从 i * i 开始，因为如果 k &lt; i，那么 k * i 在之前就已经被去除过了
        for (long j = (long) (i) * i; j &lt; n; j += i) &#123;
            notPrimes[(int) j] = true;
        &#125;
    &#125;
    return count;
&#125;
</code></pre>
<h2 id="2-最大公约数"><a href="#2-最大公约数" class="headerlink" title="2. 最大公约数"></a>2. 最大公约数</h2><pre><code class="java">int gcd(int a, int b) &#123;
    return b == 0 ? a : gcd(b, a % b);
&#125;
</code></pre>
<p>最小公倍数为两数的乘积除以最大公约数。</p>
<pre><code class="java">int lcm(int a, int b) &#123;
    return a * b / gcd(a, b);
&#125;
</code></pre>
<h2 id="3-使用位操作和减法求解最大公约数"><a href="#3-使用位操作和减法求解最大公约数" class="headerlink" title="3. 使用位操作和减法求解最大公约数"></a>3. 使用位操作和减法求解最大公约数</h2><p><a href="#">编程之美：2.7</a></p>
<p>对于 a 和 b 的最大公约数 f(a, b)，有：</p>
<ul>
<li>如果 a 和 b 均为偶数，f(a, b) = 2*f(a/2, b/2);</li>
<li>如果 a 是偶数 b 是奇数，f(a, b) = f(a/2, b);</li>
<li>如果 b 是偶数 a 是奇数，f(a, b) = f(a, b/2);</li>
<li>如果 a 和 b 均为奇数，f(a, b) = f(b, a-b);</li>
</ul>
<p>乘 2 和除 2 都可以转换为移位操作。</p>
<pre><code class="java">public int gcd(int a, int b) &#123;
    if (a &lt; b) &#123;
        return gcd(b, a);
    &#125;
    if (b == 0) &#123;
        return a;
    &#125;
    boolean isAEven = isEven(a), isBEven = isEven(b);
    if (isAEven &amp;&amp; isBEven) &#123;
        return 2 * gcd(a &gt;&gt; 1, b &gt;&gt; 1);
    &#125; else if (isAEven &amp;&amp; !isBEven) &#123;
        return gcd(a &gt;&gt; 1, b);
    &#125; else if (!isAEven &amp;&amp; isBEven) &#123;
        return gcd(a, b &gt;&gt; 1);
    &#125; else &#123;
        return gcd(b, a - b);
    &#125;
&#125;
</code></pre>
<h1 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h1><h2 id="1-7-进制"><a href="#1-7-进制" class="headerlink" title="1. 7 进制"></a>1. 7 进制</h2><p>504. Base 7 (Easy)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/base-7/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/base-7/description/">力扣</a></p>
<pre><code class="java">public String convertToBase7(int num) &#123;
    if (num == 0) &#123;
        return &quot;0&quot;;
    &#125;
    StringBuilder sb = new StringBuilder();
    boolean isNegative = num &lt; 0;
    if (isNegative) &#123;
        num = -num;
    &#125;
    while (num &gt; 0) &#123;
        sb.append(num % 7);
        num /= 7;
    &#125;
    String ret = sb.reverse().toString();
    return isNegative ? &quot;-&quot; + ret : ret;
&#125;
</code></pre>
<p>Java 中 static String toString(int num, int radix) 可以将一个整数转换为 radix 进制表示的字符串。</p>
<pre><code class="java">public String convertToBase7(int num) &#123;
    return Integer.toString(num, 7);
&#125;
</code></pre>
<h2 id="2-16-进制"><a href="#2-16-进制" class="headerlink" title="2. 16 进制"></a>2. 16 进制</h2><p>405. Convert a Number to Hexadecimal (Easy)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/convert-a-number-to-hexadecimal/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal/description/">力扣</a></p>
<pre><code class="html">Input:
26

Output:
&quot;1a&quot;

Input:
-1

Output:
&quot;ffffffff&quot;
</code></pre>
<p>负数要用它的补码形式。</p>
<pre><code class="java">public String toHex(int num) &#123;
    char[] map = &#123;&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;&#125;;
    if (num == 0) return &quot;0&quot;;
    StringBuilder sb = new StringBuilder();
    while (num != 0) &#123;
        sb.append(map[num &amp; 0b1111]);
        num &gt;&gt;&gt;= 4; // 因为考虑的是补码形式，因此符号位就不能有特殊的意义，需要使用无符号右移，左边填 0
    &#125;
    return sb.reverse().toString();
&#125;
</code></pre>
<h2 id="3-26-进制"><a href="#3-26-进制" class="headerlink" title="3. 26 进制"></a>3. 26 进制</h2><p>168. Excel Sheet Column Title (Easy)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/excel-sheet-column-title/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/excel-sheet-column-title/description/">力扣</a></p>
<pre><code class="html">1 -&gt; A
2 -&gt; B
3 -&gt; C
...
26 -&gt; Z
27 -&gt; AA
28 -&gt; AB
</code></pre>
<p>因为是从 1 开始计算的，而不是从 0 开始，因此需要对 n 执行 -1 操作。</p>
<pre><code class="java">public String convertToTitle(int n) &#123;
    if (n == 0) &#123;
        return &quot;&quot;;
    &#125;
    n--;
    return convertToTitle(n / 26) + (char) (n % 26 + &#39;A&#39;);
&#125;
</code></pre>
<h1 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h1><h2 id="1-统计阶乘尾部有多少个-0"><a href="#1-统计阶乘尾部有多少个-0" class="headerlink" title="1. 统计阶乘尾部有多少个 0"></a>1. 统计阶乘尾部有多少个 0</h2><p>172. Factorial Trailing Zeroes (Easy)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/factorial-trailing-zeroes/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/factorial-trailing-zeroes/description/">力扣</a></p>
<p>尾部的 0 由 2 * 5 得来，2 的数量明显多于 5 的数量，因此只要统计有多少个 5 即可。</p>
<p>对于一个数 N，它所包含 5 的个数为：N/5 + N/5<sup>2</sup> + N/5<sup>3</sup> + …，其中 N/5 表示不大于 N 的数中 5 的倍数贡献一个 5，N/5<sup>2</sup> 表示不大于 N 的数中 5<sup>2</sup> 的倍数再贡献一个 5 …。</p>
<pre><code class="java">public int trailingZeroes(int n) &#123;
    return n == 0 ? 0 : n / 5 + trailingZeroes(n / 5);
&#125;
</code></pre>
<p>如果统计的是 N! 的二进制表示中最低位 1 的位置，只要统计有多少个 2 即可，该题目出自 <a href="#">编程之美：2.2</a> 。和求解有多少个 5 一样，2 的个数为 N/2 + N/2<sup>2</sup> + N/2<sup>3</sup> + …</p>
<h1 id="字符串加法减法"><a href="#字符串加法减法" class="headerlink" title="字符串加法减法"></a>字符串加法减法</h1><h2 id="1-二进制加法"><a href="#1-二进制加法" class="headerlink" title="1. 二进制加法"></a>1. 二进制加法</h2><p>67. Add Binary (Easy)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/add-binary/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/add-binary/description/">力扣</a></p>
<pre><code class="html">a = &quot;11&quot;
b = &quot;1&quot;
Return &quot;100&quot;.
</code></pre>
<pre><code class="java">public String addBinary(String a, String b) &#123;
    int i = a.length() - 1, j = b.length() - 1, carry = 0;
    StringBuilder str = new StringBuilder();
    while (carry == 1 || i &gt;= 0 || j &gt;= 0) &#123;
        if (i &gt;= 0 &amp;&amp; a.charAt(i--) == &#39;1&#39;) &#123;
            carry++;
        &#125;
        if (j &gt;= 0 &amp;&amp; b.charAt(j--) == &#39;1&#39;) &#123;
            carry++;
        &#125;
        str.append(carry % 2);
        carry /= 2;
    &#125;
    return str.reverse().toString();
&#125;
</code></pre>
<h2 id="2-字符串加法"><a href="#2-字符串加法" class="headerlink" title="2. 字符串加法"></a>2. 字符串加法</h2><p>415. Add Strings (Easy)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/add-strings/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/add-strings/description/">力扣</a></p>
<p>字符串的值为非负整数。</p>
<pre><code class="java">public String addStrings(String num1, String num2) &#123;
    StringBuilder str = new StringBuilder();
    int carry = 0, i = num1.length() - 1, j = num2.length() - 1;
    while (carry == 1 || i &gt;= 0 || j &gt;= 0) &#123;
        int x = i &lt; 0 ? 0 : num1.charAt(i--) - &#39;0&#39;;
        int y = j &lt; 0 ? 0 : num2.charAt(j--) - &#39;0&#39;;
        str.append((x + y + carry) % 10);
        carry = (x + y + carry) / 10;
    &#125;
    return str.reverse().toString();
&#125;
</code></pre>
<h1 id="相遇问题"><a href="#相遇问题" class="headerlink" title="相遇问题"></a>相遇问题</h1><h2 id="1-改变数组元素使所有的数组元素都相等"><a href="#1-改变数组元素使所有的数组元素都相等" class="headerlink" title="1. 改变数组元素使所有的数组元素都相等"></a>1. 改变数组元素使所有的数组元素都相等</h2><p>462. Minimum Moves to Equal Array Elements II (Medium)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements-ii/description/">力扣</a></p>
<pre><code class="html">Input:
[1,2,3]

Output:
2

Explanation:
Only two moves are needed (remember each move increments or decrements one element):

[1,2,3]  =&gt;  [2,2,3]  =&gt;  [2,2,2]
</code></pre>
<p>每次可以对一个数组元素加一或者减一，求最小的改变次数。</p>
<p>这是个典型的相遇问题，移动距离最小的方式是所有元素都移动到中位数。理由如下：</p>
<p>设 m 为中位数。a 和 b 是 m 两边的两个元素，且 b &gt; a。要使 a 和 b 相等，它们总共移动的次数为 b - a，这个值等于 (b - m) + (m - a)，也就是把这两个数移动到中位数的移动次数。</p>
<p>设数组长度为 N，则可以找到 N/2 对 a 和 b 的组合，使它们都移动到 m 的位置。</p>
<p><strong>解法 1</strong>  </p>
<p>先排序，时间复杂度：O(NlogN)</p>
<pre><code class="java">public int minMoves2(int[] nums) &#123;
    Arrays.sort(nums);
    int move = 0;
    int l = 0, h = nums.length - 1;
    while (l &lt;= h) &#123;
        move += nums[h] - nums[l];
        l++;
        h--;
    &#125;
    return move;
&#125;
</code></pre>
<p><strong>解法 2</strong>  </p>
<p>使用快速选择找到中位数，时间复杂度 O(N)</p>
<pre><code class="java">public int minMoves2(int[] nums) &#123;
    int move = 0;
    int median = findKthSmallest(nums, nums.length / 2);
    for (int num : nums) &#123;
        move += Math.abs(num - median);
    &#125;
    return move;
&#125;

private int findKthSmallest(int[] nums, int k) &#123;
    int l = 0, h = nums.length - 1;
    while (l &lt; h) &#123;
        int j = partition(nums, l, h);
        if (j == k) &#123;
            break;
        &#125;
        if (j &lt; k) &#123;
            l = j + 1;
        &#125; else &#123;
            h = j - 1;
        &#125;
    &#125;
    return nums[k];
&#125;

private int partition(int[] nums, int l, int h) &#123;
    int i = l, j = h + 1;
    while (true) &#123;
        while (nums[++i] &lt; nums[l] &amp;&amp; i &lt; h) ;
        while (nums[--j] &gt; nums[l] &amp;&amp; j &gt; l) ;
        if (i &gt;= j) &#123;
            break;
        &#125;
        swap(nums, i, j);
    &#125;
    swap(nums, l, j);
    return j;
&#125;

private void swap(int[] nums, int i, int j) &#123;
    int tmp = nums[i];
    nums[i] = nums[j];
    nums[j] = tmp;
&#125;
</code></pre>
<h1 id="多数投票问题"><a href="#多数投票问题" class="headerlink" title="多数投票问题"></a>多数投票问题</h1><h2 id="1-数组中出现次数多于-n-2-的元素"><a href="#1-数组中出现次数多于-n-2-的元素" class="headerlink" title="1. 数组中出现次数多于 n / 2 的元素"></a>1. 数组中出现次数多于 n / 2 的元素</h2><p>169. Majority Element (Easy)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/majority-element/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/majority-element/description/">力扣</a></p>
<p>先对数组排序，最中间那个数出现次数一定多于 n / 2。</p>
<pre><code class="java">public int majorityElement(int[] nums) &#123;
    Arrays.sort(nums);
    return nums[nums.length / 2];
&#125;
</code></pre>
<p>可以利用 Boyer-Moore Majority Vote Algorithm 来解决这个问题，使得时间复杂度为 O(N)。可以这么理解该算法：使用 cnt 来统计一个元素出现的次数，当遍历到的元素和统计元素不相等时，令 cnt–。如果前面查找了 i 个元素，且 cnt == 0，说明前 i 个元素没有 majority，或者有 majority，但是出现的次数少于 i / 2，因为如果多于 i / 2 的话 cnt 就一定不会为 0。此时剩下的 n - i 个元素中，majority 的数目依然多于 (n - i) / 2，因此继续查找就能找出 majority。</p>
<pre><code class="java">public int majorityElement(int[] nums) &#123;
    int cnt = 0, majority = nums[0];
    for (int num : nums) &#123;
        majority = (cnt == 0) ? num : majority;
        cnt = (majority == num) ? cnt + 1 : cnt - 1;
    &#125;
    return majority;
&#125;
</code></pre>
<h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><h2 id="1-平方数"><a href="#1-平方数" class="headerlink" title="1. 平方数"></a>1. 平方数</h2><p>367. Valid Perfect Square (Easy)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/valid-perfect-square/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-perfect-square/description/">力扣</a></p>
<pre><code class="html">Input: 16
Returns: True
</code></pre>
<p>平方序列：1,4,9,16,..</p>
<p>间隔：3,5,7,…</p>
<p>间隔为等差数列，使用这个特性可以得到从 1 开始的平方序列。</p>
<pre><code class="java">public boolean isPerfectSquare(int num) &#123;
    int subNum = 1;
    while (num &gt; 0) &#123;
        num -= subNum;
        subNum += 2;
    &#125;
    return num == 0;
&#125;
</code></pre>
<h2 id="2-3-的-n-次方"><a href="#2-3-的-n-次方" class="headerlink" title="2. 3 的 n 次方"></a>2. 3 的 n 次方</h2><p>326. Power of Three (Easy)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/power-of-three/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/power-of-three/description/">力扣</a></p>
<pre><code class="java">public boolean isPowerOfThree(int n) &#123;
    return n &gt; 0 &amp;&amp; (1162261467 % n == 0);
&#125;
</code></pre>
<h2 id="3-乘积数组"><a href="#3-乘积数组" class="headerlink" title="3. 乘积数组"></a>3. 乘积数组</h2><p>238. Product of Array Except Self (Medium)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/product-of-array-except-self/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/product-of-array-except-self/description/">力扣</a></p>
<pre><code class="html">For example, given [1,2,3,4], return [24,12,8,6].
</code></pre>
<p>给定一个数组，创建一个新数组，新数组的每个元素为原始数组中除了该位置上的元素之外所有元素的乘积。</p>
<p>要求时间复杂度为 O(N)，并且不能使用除法。</p>
<pre><code class="java">public int[] productExceptSelf(int[] nums) &#123;
    int n = nums.length;
    int[] products = new int[n];
    Arrays.fill(products, 1);
    int left = 1;
    for (int i = 1; i &lt; n; i++) &#123;
        left *= nums[i - 1];
        products[i] *= left;
    &#125;
    int right = 1;
    for (int i = n - 2; i &gt;= 0; i--) &#123;
        right *= nums[i + 1];
        products[i] *= right;
    &#125;
    return products;
&#125;
</code></pre>
<h2 id="4-找出数组中的乘积最大的三个数"><a href="#4-找出数组中的乘积最大的三个数" class="headerlink" title="4. 找出数组中的乘积最大的三个数"></a>4. 找出数组中的乘积最大的三个数</h2><p>628. Maximum Product of Three Numbers (Easy)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-product-of-three-numbers/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-product-of-three-numbers/description/">力扣</a></p>
<pre><code class="html">Input: [1,2,3,4]
Output: 24
</code></pre>
<pre><code class="java">public int maximumProduct(int[] nums) &#123;
    int max1 = Integer.MIN_VALUE, max2 = Integer.MIN_VALUE, max3 = Integer.MIN_VALUE, min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE;
    for (int n : nums) &#123;
        if (n &gt; max1) &#123;
            max3 = max2;
            max2 = max1;
            max1 = n;
        &#125; else if (n &gt; max2) &#123;
            max3 = max2;
            max2 = n;
        &#125; else if (n &gt; max3) &#123;
            max3 = n;
        &#125;

        if (n &lt; min1) &#123;
            min2 = min1;
            min1 = n;
        &#125; else if (n &lt; min2) &#123;
            min2 = n;
        &#125;
    &#125;
    return Math.max(max1*max2*max3, max1*min1*min2);
&#125;
</code></pre>
<div align="center"><img width="320px" src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/githubio/公众号二维码-2.png"></img></div>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><em></em></section><article class="mt-6 comment-container" id="vcomments" data-comment_valine_id="b7rbKQnQFa9DYl1anYfacJRz-gzGzoHsz" data-comment_valine_key="nUuKvGHOJBRylruJLW2Fmekg"></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com//"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/serious198706"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com//"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com//"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> cy198706 2023</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="京ICP备2022033375号" target="_blank" rel="noopener" href="https://beian.miit.gov.cn/">京ICP备2022033375号 </a></p></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>