<!DOCTYPE html><html class="appearance-user-can-set" lang="zh"><head><meta charset="UTF-8"><title>Notex</title><meta name="description" content="Keep low profile, he said."><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="
1. 把数组中的 0 移到末尾
2. 改变矩阵维度
3. 找出数组中最长的连续 1
4. 有序矩阵查找
5. 有序矩阵的 Kth Element
6. 一个数组元素在 [1, n] 之间，其中一个数被替换为另一个数，找出重复的数和丢失的数
7. 找出数组中重复的数，数组值在 [1, n] 之间
8. 数组相邻差值的个数
9. 数组的度
10. 对角元素相等的矩阵
11. 嵌套数组
12. 分隔数组

1. 把数组中的 0 移到末尾283. Move Zeroes (Easy)
Leetcode / 力扣
For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, .."><script src="//unpkg.com/valine/dist/Valine.min.js"></script><meta name="generator" content="Hexo 5.4.2"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><!-- a(href= url_for("/"))= (theme.user && theme.user.name || config.author) + "'s blog"--><a href="/">Notex</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center"></p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">主页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">主页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E6%8A%8A%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84-0-%E7%A7%BB%E5%88%B0%E6%9C%AB%E5%B0%BE"><span class="toc-text">1. 把数组中的 0 移到末尾</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E6%94%B9%E5%8F%98%E7%9F%A9%E9%98%B5%E7%BB%B4%E5%BA%A6"><span class="toc-text">2. 改变矩阵维度</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9C%80%E9%95%BF%E7%9A%84%E8%BF%9E%E7%BB%AD-1"><span class="toc-text">3. 找出数组中最长的连续 1</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E6%9F%A5%E6%89%BE"><span class="toc-text">4. 有序矩阵查找</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E7%9A%84-Kth-Element"><span class="toc-text">5. 有序矩阵的 Kth Element</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%9C%A8-1-n-%E4%B9%8B%E9%97%B4%EF%BC%8C%E5%85%B6%E4%B8%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E8%A2%AB%E6%9B%BF%E6%8D%A2%E4%B8%BA%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%95%B0%EF%BC%8C%E6%89%BE%E5%87%BA%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%92%8C%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%95%B0"><span class="toc-text">6. 一个数组元素在 [1, n] 之间，其中一个数被替换为另一个数，找出重复的数和丢失的数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%EF%BC%8C%E6%95%B0%E7%BB%84%E5%80%BC%E5%9C%A8-1-n-%E4%B9%8B%E9%97%B4"><span class="toc-text">7. 找出数组中重复的数，数组值在 [1, n] 之间</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E6%95%B0%E7%BB%84%E7%9B%B8%E9%82%BB%E5%B7%AE%E5%80%BC%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-text">8. 数组相邻差值的个数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E6%95%B0%E7%BB%84%E7%9A%84%E5%BA%A6"><span class="toc-text">9. 数组的度</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-%E5%AF%B9%E8%A7%92%E5%85%83%E7%B4%A0%E7%9B%B8%E7%AD%89%E7%9A%84%E7%9F%A9%E9%98%B5"><span class="toc-text">10. 对角元素相等的矩阵</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-%E5%B5%8C%E5%A5%97%E6%95%B0%E7%BB%84"><span class="toc-text">11. 嵌套数组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-%E5%88%86%E9%9A%94%E6%95%B0%E7%BB%84"><span class="toc-text">12. 分隔数组</span></a></li></ol></div><div class="column is-9"><header class="my-4"></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle"></h1><time class="has-text-grey" datetime="2023-01-31T06:58:14.698Z">2023-01-31</time><article class="mt-2 post-content"><ul>
<li><a href="#1-%E6%8A%8A%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84-0-%E7%A7%BB%E5%88%B0%E6%9C%AB%E5%B0%BE">1. 把数组中的 0 移到末尾</a></li>
<li><a href="#2-%E6%94%B9%E5%8F%98%E7%9F%A9%E9%98%B5%E7%BB%B4%E5%BA%A6">2. 改变矩阵维度</a></li>
<li><a href="#3-%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9C%80%E9%95%BF%E7%9A%84%E8%BF%9E%E7%BB%AD-1">3. 找出数组中最长的连续 1</a></li>
<li><a href="#4-%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E6%9F%A5%E6%89%BE">4. 有序矩阵查找</a></li>
<li><a href="#5-%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E7%9A%84-kth-element">5. 有序矩阵的 Kth Element</a></li>
<li><a href="#6-%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%9C%A8-%5B1,-n%5D-%E4%B9%8B%E9%97%B4%EF%BC%8C%E5%85%B6%E4%B8%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E8%A2%AB%E6%9B%BF%E6%8D%A2%E4%B8%BA%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%95%B0%EF%BC%8C%E6%89%BE%E5%87%BA%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%92%8C%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%95%B0">6. 一个数组元素在 [1, n] 之间，其中一个数被替换为另一个数，找出重复的数和丢失的数</a></li>
<li><a href="#7-%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%EF%BC%8C%E6%95%B0%E7%BB%84%E5%80%BC%E5%9C%A8-%5B1,-n%5D-%E4%B9%8B%E9%97%B4">7. 找出数组中重复的数，数组值在 [1, n] 之间</a></li>
<li><a href="#8-%E6%95%B0%E7%BB%84%E7%9B%B8%E9%82%BB%E5%B7%AE%E5%80%BC%E7%9A%84%E4%B8%AA%E6%95%B0">8. 数组相邻差值的个数</a></li>
<li><a href="#9-%E6%95%B0%E7%BB%84%E7%9A%84%E5%BA%A6">9. 数组的度</a></li>
<li><a href="#10-%E5%AF%B9%E8%A7%92%E5%85%83%E7%B4%A0%E7%9B%B8%E7%AD%89%E7%9A%84%E7%9F%A9%E9%98%B5">10. 对角元素相等的矩阵</a></li>
<li><a href="#11-%E5%B5%8C%E5%A5%97%E6%95%B0%E7%BB%84">11. 嵌套数组</a></li>
<li><a href="#12-%E5%88%86%E9%9A%94%E6%95%B0%E7%BB%84">12. 分隔数组</a></li>
</ul>
<h1 id="1-把数组中的-0-移到末尾"><a href="#1-把数组中的-0-移到末尾" class="headerlink" title="1. 把数组中的 0 移到末尾"></a>1. 把数组中的 0 移到末尾</h1><p>283. Move Zeroes (Easy)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/move-zeroes/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/move-zeroes/description/">力扣</a></p>
<pre><code class="html">For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].
</code></pre>
<pre><code class="java">public void moveZeroes(int[] nums) &#123;
    int idx = 0;
    for (int num : nums) &#123;
        if (num != 0) &#123;
            nums[idx++] = num;
        &#125;
    &#125;
    while (idx &lt; nums.length) &#123;
        nums[idx++] = 0;
    &#125;
&#125;
</code></pre>
<h1 id="2-改变矩阵维度"><a href="#2-改变矩阵维度" class="headerlink" title="2. 改变矩阵维度"></a>2. 改变矩阵维度</h1><p>566. Reshape the Matrix (Easy)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/reshape-the-matrix/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reshape-the-matrix/description/">力扣</a></p>
<pre><code class="html">Input:
nums =
[[1,2],
 [3,4]]
r = 1, c = 4

Output:
[[1,2,3,4]]

Explanation:
The row-traversing of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list.
</code></pre>
<pre><code class="java">public int[][] matrixReshape(int[][] nums, int r, int c) &#123;
    int m = nums.length, n = nums[0].length;
    if (m * n != r * c) &#123;
        return nums;
    &#125;
    int[][] reshapedNums = new int[r][c];
    int index = 0;
    for (int i = 0; i &lt; r; i++) &#123;
        for (int j = 0; j &lt; c; j++) &#123;
            reshapedNums[i][j] = nums[index / n][index % n];
            index++;
        &#125;
    &#125;
    return reshapedNums;
&#125;
</code></pre>
<h1 id="3-找出数组中最长的连续-1"><a href="#3-找出数组中最长的连续-1" class="headerlink" title="3. 找出数组中最长的连续 1"></a>3. 找出数组中最长的连续 1</h1><p>485. Max Consecutive Ones (Easy)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/max-consecutive-ones/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/max-consecutive-ones/description/">力扣</a></p>
<pre><code class="java">public int findMaxConsecutiveOnes(int[] nums) &#123;
    int max = 0, cur = 0;
    for (int x : nums) &#123;
        cur = x == 0 ? 0 : cur + 1;
        max = Math.max(max, cur);
    &#125;
    return max;
&#125;
</code></pre>
<h1 id="4-有序矩阵查找"><a href="#4-有序矩阵查找" class="headerlink" title="4. 有序矩阵查找"></a>4. 有序矩阵查找</h1><p>240. Search a 2D Matrix II (Medium)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/search-a-2d-matrix-ii/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/description/">力扣</a></p>
<pre><code class="html">[
   [ 1,  5,  9],
   [10, 11, 13],
   [12, 13, 15]
]
</code></pre>
<pre><code class="java">public boolean searchMatrix(int[][] matrix, int target) &#123;
    if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return false;
    int m = matrix.length, n = matrix[0].length;
    int row = 0, col = n - 1;
    while (row &lt; m &amp;&amp; col &gt;= 0) &#123;
        if (target == matrix[row][col]) return true;
        else if (target &lt; matrix[row][col]) col--;
        else row++;
    &#125;
    return false;
&#125;
</code></pre>
<h1 id="5-有序矩阵的-Kth-Element"><a href="#5-有序矩阵的-Kth-Element" class="headerlink" title="5. 有序矩阵的 Kth Element"></a>5. 有序矩阵的 Kth Element</h1><p>378. Kth Smallest Element in a Sorted Matrix ((Medium))</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/description/">力扣</a></p>
<pre><code class="html">matrix = [
  [ 1,  5,  9],
  [10, 11, 13],
  [12, 13, 15]
],
k = 8,

return 13.
</code></pre>
<p>解题参考：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/discuss/85173">Share my thoughts and Clean Java Code</a></p>
<p>二分查找解法：</p>
<pre><code class="java">public int kthSmallest(int[][] matrix, int k) &#123;
    int m = matrix.length, n = matrix[0].length;
    int lo = matrix[0][0], hi = matrix[m - 1][n - 1];
    while (lo &lt;= hi) &#123;
        int mid = lo + (hi - lo) / 2;
        int cnt = 0;
        for (int i = 0; i &lt; m; i++) &#123;
            for (int j = 0; j &lt; n &amp;&amp; matrix[i][j] &lt;= mid; j++) &#123;
                cnt++;
            &#125;
        &#125;
        if (cnt &lt; k) lo = mid + 1;
        else hi = mid - 1;
    &#125;
    return lo;
&#125;
</code></pre>
<p>堆解法：</p>
<pre><code class="java">public int kthSmallest(int[][] matrix, int k) &#123;
    int m = matrix.length, n = matrix[0].length;
    PriorityQueue&lt;Tuple&gt; pq = new PriorityQueue&lt;Tuple&gt;();
    for(int j = 0; j &lt; n; j++) pq.offer(new Tuple(0, j, matrix[0][j]));
    for(int i = 0; i &lt; k - 1; i++) &#123; // 小根堆，去掉 k - 1 个堆顶元素，此时堆顶元素就是第 k 的数
        Tuple t = pq.poll();
        if(t.x == m - 1) continue;
        pq.offer(new Tuple(t.x + 1, t.y, matrix[t.x + 1][t.y]));
    &#125;
    return pq.poll().val;
&#125;

class Tuple implements Comparable&lt;Tuple&gt; &#123;
    int x, y, val;
    public Tuple(int x, int y, int val) &#123;
        this.x = x; this.y = y; this.val = val;
    &#125;

    @Override
    public int compareTo(Tuple that) &#123;
        return this.val - that.val;
    &#125;
&#125;
</code></pre>
<h1 id="6-一个数组元素在-1-n-之间，其中一个数被替换为另一个数，找出重复的数和丢失的数"><a href="#6-一个数组元素在-1-n-之间，其中一个数被替换为另一个数，找出重复的数和丢失的数" class="headerlink" title="6. 一个数组元素在 [1, n] 之间，其中一个数被替换为另一个数，找出重复的数和丢失的数"></a>6. 一个数组元素在 [1, n] 之间，其中一个数被替换为另一个数，找出重复的数和丢失的数</h1><p>645. Set Mismatch (Easy)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/set-mismatch/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/set-mismatch/description/">力扣</a></p>
<pre><code class="html">Input: nums = [1,2,2,4]
Output: [2,3]
</code></pre>
<pre><code class="html">Input: nums = [1,2,2,4]
Output: [2,3]
</code></pre>
<p>最直接的方法是先对数组进行排序，这种方法时间复杂度为 O(NlogN)。本题可以以 O(N) 的时间复杂度、O(1) 空间复杂度来求解。</p>
<p>主要思想是通过交换数组元素，使得数组上的元素在正确的位置上。</p>
<pre><code class="java">public int[] findErrorNums(int[] nums) &#123;
    for (int i = 0; i &lt; nums.length; i++) &#123;
        while (nums[i] != i + 1 &amp;&amp; nums[nums[i] - 1] != nums[i]) &#123;
            swap(nums, i, nums[i] - 1);
        &#125;
    &#125;
    for (int i = 0; i &lt; nums.length; i++) &#123;
        if (nums[i] != i + 1) &#123;
            return new int[]&#123;nums[i], i + 1&#125;;
        &#125;
    &#125;
    return null;
&#125;

private void swap(int[] nums, int i, int j) &#123;
    int tmp = nums[i];
    nums[i] = nums[j];
    nums[j] = tmp;
&#125;
</code></pre>
<h1 id="7-找出数组中重复的数，数组值在-1-n-之间"><a href="#7-找出数组中重复的数，数组值在-1-n-之间" class="headerlink" title="7. 找出数组中重复的数，数组值在 [1, n] 之间"></a>7. 找出数组中重复的数，数组值在 [1, n] 之间</h1><p>287. Find the Duplicate Number (Medium)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-the-duplicate-number/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-the-duplicate-number/description/">力扣</a></p>
<p>要求不能修改数组，也不能使用额外的空间。</p>
<p>二分查找解法：</p>
<pre><code class="java">public int findDuplicate(int[] nums) &#123;
     int l = 1, h = nums.length - 1;
     while (l &lt;= h) &#123;
         int mid = l + (h - l) / 2;
         int cnt = 0;
         for (int i = 0; i &lt; nums.length; i++) &#123;
             if (nums[i] &lt;= mid) cnt++;
         &#125;
         if (cnt &gt; mid) h = mid - 1;
         else l = mid + 1;
     &#125;
     return l;
&#125;
</code></pre>
<p>双指针解法，类似于有环链表中找出环的入口：</p>
<pre><code class="java">public int findDuplicate(int[] nums) &#123;
    int slow = nums[0], fast = nums[nums[0]];
    while (slow != fast) &#123;
        slow = nums[slow];
        fast = nums[nums[fast]];
    &#125;
    fast = 0;
    while (slow != fast) &#123;
        slow = nums[slow];
        fast = nums[fast];
    &#125;
    return slow;
&#125;
</code></pre>
<h1 id="8-数组相邻差值的个数"><a href="#8-数组相邻差值的个数" class="headerlink" title="8. 数组相邻差值的个数"></a>8. 数组相邻差值的个数</h1><p>667. Beautiful Arrangement II (Medium)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/beautiful-arrangement-ii/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/beautiful-arrangement-ii/description/">力扣</a></p>
<pre><code class="html">Input: n = 3, k = 2
Output: [1, 3, 2]
Explanation: The [1, 3, 2] has three different positive integers ranging from 1 to 3, and the [2, 1] has exactly 2 distinct integers: 1 and 2.
</code></pre>
<p>题目描述：数组元素为 1~n 的整数，要求构建数组，使得相邻元素的差值不相同的个数为 k。</p>
<p>让前 k+1 个元素构建出 k 个不相同的差值，序列为：1 k+1 2 k 3 k-1 … k/2 k/2+1.</p>
<pre><code class="java">public int[] constructArray(int n, int k) &#123;
    int[] ret = new int[n];
    ret[0] = 1;
    for (int i = 1, interval = k; i &lt;= k; i++, interval--) &#123;
        ret[i] = i % 2 == 1 ? ret[i - 1] + interval : ret[i - 1] - interval;
    &#125;
    for (int i = k + 1; i &lt; n; i++) &#123;
        ret[i] = i + 1;
    &#125;
    return ret;
&#125;
</code></pre>
<h1 id="9-数组的度"><a href="#9-数组的度" class="headerlink" title="9. 数组的度"></a>9. 数组的度</h1><p>697. Degree of an Array (Easy)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/degree-of-an-array/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/degree-of-an-array/description/">力扣</a></p>
<pre><code class="html">Input: [1,2,2,3,1,4,2]
Output: 6
</code></pre>
<p>题目描述：数组的度定义为元素出现的最高频率，例如上面的数组度为 3。要求找到一个最小的子数组，这个子数组的度和原数组一样。</p>
<pre><code class="java">public int findShortestSubArray(int[] nums) &#123;
    Map&lt;Integer, Integer&gt; numsCnt = new HashMap&lt;&gt;();
    Map&lt;Integer, Integer&gt; numsLastIndex = new HashMap&lt;&gt;();
    Map&lt;Integer, Integer&gt; numsFirstIndex = new HashMap&lt;&gt;();
    for (int i = 0; i &lt; nums.length; i++) &#123;
        int num = nums[i];
        numsCnt.put(num, numsCnt.getOrDefault(num, 0) + 1);
        numsLastIndex.put(num, i);
        if (!numsFirstIndex.containsKey(num)) &#123;
            numsFirstIndex.put(num, i);
        &#125;
    &#125;
    int maxCnt = 0;
    for (int num : nums) &#123;
        maxCnt = Math.max(maxCnt, numsCnt.get(num));
    &#125;
    int ret = nums.length;
    for (int i = 0; i &lt; nums.length; i++) &#123;
        int num = nums[i];
        int cnt = numsCnt.get(num);
        if (cnt != maxCnt) continue;
        ret = Math.min(ret, numsLastIndex.get(num) - numsFirstIndex.get(num) + 1);
    &#125;
    return ret;
&#125;
</code></pre>
<h1 id="10-对角元素相等的矩阵"><a href="#10-对角元素相等的矩阵" class="headerlink" title="10. 对角元素相等的矩阵"></a>10. 对角元素相等的矩阵</h1><p>766. Toeplitz Matrix (Easy)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/toeplitz-matrix/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/toeplitz-matrix/description/">力扣</a></p>
<pre><code class="html">1234
5123
9512

In the above grid, the diagonals are &quot;[9]&quot;, &quot;[5, 5]&quot;, &quot;[1, 1, 1]&quot;, &quot;[2, 2, 2]&quot;, &quot;[3, 3]&quot;, &quot;[4]&quot;, and in each diagonal all elements are the same, so the answer is True.
</code></pre>
<pre><code class="java">public boolean isToeplitzMatrix(int[][] matrix) &#123;
    for (int i = 0; i &lt; matrix[0].length; i++) &#123;
        if (!check(matrix, matrix[0][i], 0, i)) &#123;
            return false;
        &#125;
    &#125;
    for (int i = 0; i &lt; matrix.length; i++) &#123;
        if (!check(matrix, matrix[i][0], i, 0)) &#123;
            return false;
        &#125;
    &#125;
    return true;
&#125;

private boolean check(int[][] matrix, int expectValue, int row, int col) &#123;
    if (row &gt;= matrix.length || col &gt;= matrix[0].length) &#123;
        return true;
    &#125;
    if (matrix[row][col] != expectValue) &#123;
        return false;
    &#125;
    return check(matrix, expectValue, row + 1, col + 1);
&#125;
</code></pre>
<h1 id="11-嵌套数组"><a href="#11-嵌套数组" class="headerlink" title="11. 嵌套数组"></a>11. 嵌套数组</h1><p>565. Array Nesting (Medium)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/array-nesting/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/array-nesting/description/">力扣</a></p>
<pre><code class="html">Input: A = [5,4,0,3,1,6,2]
Output: 4
Explanation:
A[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.

One of the longest S[K]:
S[0] = &#123;A[0], A[5], A[6], A[2]&#125; = &#123;5, 6, 2, 0&#125;
</code></pre>
<p>题目描述：S[i] 表示一个集合，集合的第一个元素是 A[i]，第二个元素是 A[A[i]]，如此嵌套下去。求最大的 S[i]。</p>
<pre><code class="java">public int arrayNesting(int[] nums) &#123;
    int max = 0;
    for (int i = 0; i &lt; nums.length; i++) &#123;
        int cnt = 0;
        for (int j = i; nums[j] != -1; ) &#123;
            cnt++;
            int t = nums[j];
            nums[j] = -1; // 标记该位置已经被访问
            j = t;

        &#125;
        max = Math.max(max, cnt);
    &#125;
    return max;
&#125;
</code></pre>
<h1 id="12-分隔数组"><a href="#12-分隔数组" class="headerlink" title="12. 分隔数组"></a>12. 分隔数组</h1><p>769. Max Chunks To Make Sorted (Medium)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/max-chunks-to-make-sorted/description/">Leetcode</a> / <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/max-chunks-to-make-sorted/description/">力扣</a></p>
<pre><code class="html">Input: arr = [1,0,2,3,4]
Output: 4
Explanation:
We can split into two chunks, such as [1, 0], [2, 3, 4].
However, splitting into [1, 0], [2], [3], [4] is the highest number of chunks possible.
</code></pre>
<p>题目描述：分隔数组，使得对每部分排序后数组就为有序。</p>
<pre><code class="java">public int maxChunksToSorted(int[] arr) &#123;
    if (arr == null) return 0;
    int ret = 0;
    int right = arr[0];
    for (int i = 0; i &lt; arr.length; i++) &#123;
        right = Math.max(right, arr[i]);
        if (right == i) ret++;
    &#125;
    return ret;
&#125;
</code></pre>
<div align="center"><img width="320px" src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/githubio/公众号二维码-2.png"></img></div>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><em></em></section><article class="mt-6 comment-container" id="vcomments" data-comment_valine_id="b7rbKQnQFa9DYl1anYfacJRz-gzGzoHsz" data-comment_valine_key="nUuKvGHOJBRylruJLW2Fmekg"></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com//"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/serious198706"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com//"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com//"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> cy198706 2023</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="京ICP备2022033375号" target="_blank" rel="noopener" href="https://beian.miit.gov.cn/">京ICP备2022033375号 </a></p></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>