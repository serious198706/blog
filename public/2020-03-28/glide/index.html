<!DOCTYPE html><html class="appearance-user-can-set" lang="zh"><head><meta charset="UTF-8"><title>Notex</title><meta name="description" content="Keep low profile, he said."><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="Glide 是比较著名的图片加载库之一，类似的库还有 Picasso、COIL。这篇文章来讲讲 Glide 是如何加载图片到显示的，并且讲一讲它有哪些设计精妙的地方。
该文章使用的是 Glide 4.15.0。


一、代码结构拉取最新的代码后，使用 Android Studio 打开，可以看到 Glide 的项目结构如下：


annotation: Glide 有几个非常有用的注解，如 @GlideModule、@GlideOption 等，需要在本 module 里进行解析。
benchmark: 一些基准测试，可以忽略
glide: 主打包脚本
instrumentation: 一些测试，可以忽略
integration: 可以集成使用的三方库，比如 okhttp3、recyclerview 等，用.."><script src="//unpkg.com/valine/dist/Valine.min.js"></script><meta name="generator" content="Hexo 5.4.2"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><!-- a(href= url_for("/"))= (theme.user && theme.user.name || config.author) + "'s blog"--><a href="/">Notex</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">关于 Glide 的一切</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">主页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">主页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84"><span class="toc-text">一、代码结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Glide-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E7%9A%84%E5%8A%A0%E8%BD%BD"><span class="toc-text">二、Glide 如何实现图片的加载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#load"><span class="toc-text">load()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#into"><span class="toc-text">into()</span></a></div><div class="column is-9"><header class="my-4"><a href="/tags/Android"><i class="tag post-item-tag">Android</i></a><a href="/tags/Glide"><i class="tag post-item-tag">Glide</i></a><a href="/tags/%E4%B8%89%E6%96%B9%E5%BA%93"><i class="tag post-item-tag">三方库</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">关于 Glide 的一切</h1><time class="has-text-grey" datetime="2020-03-27T16:00:00.000Z">2020-03-28</time><article class="mt-2 post-content"><p>Glide 是比较著名的图片加载库之一，类似的库还有 <a target="_blank" rel="noopener" href="https://square.github.io/picasso/">Picasso</a>、<a target="_blank" rel="noopener" href="https://coil-kt.github.io/coil/">COIL</a>。这篇文章来讲讲 Glide 是如何加载图片到显示的，并且讲一讲它有哪些设计精妙的地方。</p>
<p>该文章使用的是 Glide <a target="_blank" rel="noopener" href="https://bumptech.github.io/glide/doc/download-setup.html">4.15.0</a>。</p>
<span id="more"></span>

<h3 id="一、代码结构"><a href="#一、代码结构" class="headerlink" title="一、代码结构"></a>一、代码结构</h3><p>拉取最新的代码后，使用 Android Studio 打开，可以看到 Glide 的项目结构如下：</p>
<p><img src="/img/glide-1.png"></p>
<ol>
<li><code>annotation</code>: Glide 有几个非常有用的注解，如 <code>@GlideModule</code>、<code>@GlideOption</code> 等，需要在本 module 里进行解析。</li>
<li><code>benchmark</code>: 一些基准测试，可以忽略</li>
<li><code>glide</code>: 主打包脚本</li>
<li><code>instrumentation</code>: 一些测试，可以忽略</li>
<li><code>integration</code>: 可以集成使用的三方库，比如 okhttp3、recyclerview 等，用于打包时进行集成。比如， Glide 支持插件化替换网络请求模块，此 module 便提供该支持</li>
<li><code>library</code>: 主 module，也是后面我们主要分析的模块</li>
<li><code>mocks</code>: 用于测试时模拟请求</li>
<li><code>samples</code>: 一些示例，可以看到基本用法和高级用法</li>
<li><code>testutil</code>: 顾名思义，测试工具类</li>
<li><code>third_party</code>: 使用的三方库，包含 <code>disklrucache</code> 和 <code>gif_decoder</code>。</li>
</ol>
<p>我们会在下面主要分析 <code>annotation</code> 和 <code>library</code> 模块。</p>
<h3 id="二、Glide-如何实现图片的加载"><a href="#二、Glide-如何实现图片的加载" class="headerlink" title="二、Glide 如何实现图片的加载"></a>二、Glide 如何实现图片的加载</h3><p>我们先看一下 Glide 在4.0+版本的基本用法。</p>
<pre><code class="java">
// 单一 imageview
ImageView imageView = (ImageView) findViewById(R.id.my_image_view);
Glide.with(this).load(&quot;http://image.url&quot;).into(imageView);

// list 中的 imageview
@Override 
public View getView(int position, View recycled, ViewGroup container) &#123;
  final ImageView myImageView;
  if (recycled == null) &#123;
    myImageView = (ImageView) inflater.inflate(R.layout.my_image_view, container, false);
  &#125; else &#123;
    myImageView = (ImageView) recycled;
  &#125;

  String url = myUrls.get(position);

  Glide
    .with(myFragment)
    .load(url)
    .centerCrop()
    .placeholder(R.drawable.loading_spinner)
    .into(myImageView);

  return myImageView;
&#125;
</code></pre>
<p>通过两种调用方式，我们可以看出，Glide 用了非常经典的 Builder 设计模式，将各种参数收集、处理，最后调用<code>into()</code>方法，将图片交给 ImageView。接下来我们来一步步阅读源码，看看 Glide 为了完成图片加载功能，都经过了哪些步骤。</p>
<p>首先看<code>Glide.with()</code>方法的源码，该方法有5个重载，大体相同，但也有不同的地方，我们在下面会解释：</p>
<pre><code class="java">public class Glide implements ComponentCallbacks2 &#123;
    ...

    @GuardedBy(&quot;Glide.class&quot;)
    private static volatile Glide glide;

    @GuardedBy(&quot;managers&quot;)
    private final List&lt;RequestManager&gt; managers = new ArrayList&lt;&gt;();

    /**
     * Begin a load with Glide by passing in a context.
     *
     * &lt;p&gt;Any requests started using a context will only have the application level options applied
     * and will not be started or stopped based on lifecycle events. In general, loads should be
     * started at the level the result will be used in. If the resource will be used in a view in a
     * child fragment, the load should be started with &#123;@link #with(android.app.Fragment)&#125;&#125; using that
     * child fragment. Similarly, if the resource will be used in a view in the parent fragment, the
     * load should be started with &#123;@link #with(android.app.Fragment)&#125; using the parent fragment. In
     * the same vein, if the resource will be used in a view in an activity, the load should be
     * started with &#123;@link #with(android.app.Activity)&#125;&#125;.
     *
     * &lt;p&gt;This method is appropriate for resources that will be used outside of the normal fragment or
     * activity lifecycle (For example in services, or for notification thumbnails).
     *
     * @param context Any context, will not be retained.
     * @return A RequestManager for the top level application that can be used to start a load.
     * @see #with(android.app.Activity)
     * @see #with(android.app.Fragment)
     * @see #with(androidx.fragment.app.Fragment)
     * @see #with(androidx.fragment.app.FragmentActivity)
     */
    @NonNull
    public static RequestManager with(@NonNull Context context) &#123;
        return getRetriever(context).get(context);
    &#125;

    @NonNull
    public static RequestManager with(@NonNull Activity activity) &#123;
        return getRetriever(activity).get(activity);
    &#125;

    @NonNull
    public static RequestManager with(@NonNull FragmentActivity activity) &#123;
        return getRetriever(activity).get(activity);
    &#125;

    @NonNull
    public static RequestManager with(@NonNull Fragment fragment) &#123;
        return getRetriever(fragment.getContext()).get(fragment);
    &#125;

    @SuppressWarnings(&quot;deprecation&quot;)
    @Deprecated
    @NonNull
    public static RequestManager with(@NonNull android.app.Fragment fragment) &#123;
        return getRetriever(fragment.getActivity()).get(fragment);
    &#125;

    @NonNull
    public static RequestManager with(@NonNull View view) &#123;
        return getRetriever(view.getContext()).get(view);
    &#125;
&#125;
</code></pre>
<p>可以看到，<code>with(android.app.Fragment)</code>方法已经被弃用了，取而代之的是<code>with(androidx.fragment.app.Fragment)</code>，我们接下来不再讨论被弃用的这个方法。</p>
<p>那么，这5个方法，有什么不同呢？</p>
<p>首先，从它们的传入参数可以看出，它们分别用在 Application 级别、Activity 级别、FragmentActivity 级别、Fragment 级别和 View 级别。</p>
<p>Application 级别意味着它可以用在 Service 里，甚至 Notification 的 Thumbnail 里。而其他的几个，只能用在主线程的 Activity 的 View 树中。</p>
<p>需要注意的是，**<code>with(View)</code>方法在 View 没有被<code>attach</code>之前无效**。并且该方法效率较低，不推荐使用。</p>
<p>接着看看这五个重载方法都调用的<code>getRetriever()</code>方法的代码：</p>
<pre><code class="java">@NonNull
private static RequestManagerRetriever getRetriever(@Nullable Context context) &#123;
    // context 可能为 null（比如用户就传了个 null），
    // 但实际上它只会出现在 Fragment 的生命周期出现错误时
    Preconditions.checkNotNull(
        context,
        &quot;You cannot start a load on a not yet attached View or a Fragment where getActivity() &quot;
            + &quot;returns null (which usually occurs when getActivity() is called before the Fragment &quot;
            + &quot;is attached or after the Fragment is destroyed).&quot;);
    return Glide.get(context).getRequestManagerRetriever();
&#125;

@NonNull
public RequestManagerRetriever getRequestManagerRetriever() &#123;
    return requestManagerRetriever;
&#125;
</code></pre>
<p>可见<code>getRetriever()</code>方法实际上是在获取一个 <strong>RequestManger 的生成器</strong>。我们先把生成器放一边，先看看 Glide 是如何实例化和初始化的：</p>
<pre><code class="java">// 获取 Glide 的单例
@NonNull
public static Glide get(@NonNull Context context) &#123;
    if (glide == null) &#123;
        // 解析注解配置生成的类 com.bumptech.glide.GeneratedAppGlideModuleImpl
        GeneratedAppGlideModule annotationGeneratedModule =
            getAnnotationGeneratedGlideModules(context.getApplicationContext());
        synchronized (Glide.class) &#123;
            if (glide == null) &#123;
                checkAndInitializeGlide(context, annotationGeneratedModule);
            &#125;
        &#125;
    &#125;

    return glide;
&#125;

// 只有拿到了 Glide.class 这个引用的锁才可以调用该方法
@GuardedBy(&quot;Glide.class&quot;)
private static void checkAndInitializeGlide(
    @NonNull Context context, @Nullable GeneratedAppGlideModule generatedAppGlideModule) &#123;
    if (isInitializing) &#123;
        throw new IllegalStateException(
            &quot;You cannot call Glide.get() in registerComponents(),&quot;
                + &quot; use the provided Glide instance instead&quot;);
    &#125;
    isInitializing = true;
    initializeGlide(context, generatedAppGlideModule);
    isInitializing = false;
&#125;

@GuardedBy(&quot;Glide.class&quot;)
private static void initializeGlide(
    @NonNull Context context, @Nullable GeneratedAppGlideModule generatedAppGlideModule) &#123;
    initializeGlide(context, new GlideBuilder(), generatedAppGlideModule);
&#125;

@GuardedBy(&quot;Glide.class&quot;)
@SuppressWarnings(&quot;deprecation&quot;)
private static void initializeGlide(
    @NonNull Context context,
    @NonNull GlideBuilder builder,
    @Nullable GeneratedAppGlideModule annotationGeneratedModule) &#123;
    // 解析 GlideModule 配置
    Context applicationContext = context.getApplicationContext();
    List&lt;com.bumptech.glide.module.GlideModule&gt; manifestModules = Collections.emptyList();
    if (annotationGeneratedModule == null || annotationGeneratedModule.isManifestParsingEnabled()) &#123;
        manifestModules = new ManifestParser(applicationContext).parse();
    &#125;

    if (annotationGeneratedModule != null
        &amp;&amp; !annotationGeneratedModule.getExcludedModuleClasses().isEmpty()) &#123;
        Set&lt;Class&lt;?&gt;&gt; excludedModuleClasses = annotationGeneratedModule.getExcludedModuleClasses();
        Iterator&lt;com.bumptech.glide.module.GlideModule&gt; iterator = manifestModules.iterator();
        while (iterator.hasNext()) &#123;
            com.bumptech.glide.module.GlideModule current = iterator.next();
            if (!excludedModuleClasses.contains(current.getClass())) &#123;
                continue;
            &#125;
            if (Log.isLoggable(TAG, Log.DEBUG)) &#123;
                Log.d(TAG, &quot;AppGlideModule excludes manifest GlideModule: &quot; + current);
            &#125;
            iterator.remove();
        &#125;
    &#125;

    ...

    RequestManagerRetriever.RequestManagerFactory factory =
        annotationGeneratedModule != null
            ? annotationGeneratedModule.getRequestManagerFactory()
            : null;
    builder.setRequestManagerFactory(factory);
    for (com.bumptech.glide.module.GlideModule module : manifestModules) &#123;
        module.applyOptions(applicationContext, builder);
    &#125;
    if (annotationGeneratedModule != null) &#123;
        annotationGeneratedModule.applyOptions(applicationContext, builder);
    &#125;

    // 创建 Glide 实例
    Glide glide = builder.build(applicationContext);
    for (com.bumptech.glide.module.GlideModule module : manifestModules) &#123;
        try &#123;
        module.registerComponents(applicationContext, glide, glide.registry);
        &#125; catch (AbstractMethodError e) &#123;
        throw new IllegalStateException(
            &quot;Attempting to register a Glide v3 module. If you see this, you or one of your&quot;
                + &quot; dependencies may be including Glide v3 even though you&#39;re using Glide v4.&quot;
                + &quot; You&#39;ll need to find and remove (or update) the offending dependency.&quot;
                + &quot; The v3 module name is: &quot;
                + module.getClass().getName(),
            e);
        &#125;
    &#125;
    if (annotationGeneratedModule != null) &#123;
        annotationGeneratedModule.registerComponents(applicationContext, glide, glide.registry);
    &#125;
    applicationContext.registerComponentCallbacks(glide);
    
    // glide 变量的声明方式是 private static volatile Glide glide; 使用了 volatile 关键字保证了可见性
    Glide.glide = glide;
&#125;
</code></pre>
<p>在初始化工作中，主要是解析了 GlideModule，也即配置。在 Glide 4.0 中，有一个与 3.0 不一样的地方就在这里了：<strong>Glide 的 Module 配置不再是在 Manifest 中注册，而是通过在配置类上注解（@GlideModule）的方式来声明一个配置类</strong>。</p>
<p>它的使用方法如下：</p>
<pre><code class="java">@GlideModule
public class GlideModuleExample extends AppGlideModule &#123;
&#125;
</code></pre>
<p>当我们编译时，因为如果要使用 Glide 4.0，我们必须在 app/build.gradle 中这样配置：</p>
<pre><code class="groovy">implementation &#39;com.github.bumptech.glide:glide:4.11.0&#39;
annotationProcessor &#39;com.github.bumptech.glide:compiler:4.11.0&#39;
</code></pre>
<p>也即 glide 有自己的注解处理系统，当我们编译完成后，会生成下面几个类：</p>
<p><img src="/img/68.png"></p>
<p>其中就有我们上面提到的<code>com.bumptech.glide.GeneratedAppGlideModuleImpl</code>类。</p>
<p>配置解析完成后，就通过<code>GlideBuilder.build()</code>方法来创建实例了。创建完成后，将该实例赋给一个静态的 volatile 的变量。来看看<code>build()</code>方法做了些什么：</p>
<pre><code class="java">@NonNull
Glide build(@NonNull Context context) &#123;
    // 新建一个源线程的线程池
    if (sourceExecutor == null) &#123;
        sourceExecutor = GlideExecutor.newSourceExecutor();
    &#125;
    // 新建一个缓存用的线程池
    if (diskCacheExecutor == null) &#123;
        diskCacheExecutor = GlideExecutor.newDiskCacheExecutor();
    &#125;
    // 新建一个动画用的线程池
    if (animationExecutor == null) &#123;
        animationExecutor = GlideExecutor.newAnimationExecutor();
    &#125;
    // 基于设备的一些信息设定缓存区域的大小
    if (memorySizeCalculator == null) &#123;
        memorySizeCalculator = new MemorySizeCalculator.Builder(context).build();
    &#125;
    // 监听网络状态，如果没有 android.permission.ACCESS_NETWORK_STATE 权限的话，就不监测
    if (connectivityMonitorFactory == null) &#123;
        connectivityMonitorFactory = new DefaultConnectivityMonitorFactory();
    &#125;
    // 根据之前获取的缓存区域的大小，决定要用哪种 bitmapPool
    if (bitmapPool == null) &#123;
        int size = memorySizeCalculator.getBitmapPoolSize();
        if (size &gt; 0) &#123;
            // 使用 LRU 算法的 Bitmap 池
            bitmapPool = new LruBitmapPool(size);
        &#125; else &#123;
            // 使用空 Bitmap 池
            bitmapPool = new BitmapPoolAdapter();
        &#125;
    &#125;

    if (arrayPool == null) &#123;
        arrayPool = new LruArrayPool(memorySizeCalculator.getArrayPoolSizeInBytes());
    &#125;

    if (memoryCache == null) &#123;
        memoryCache = new LruResourceCache(memorySizeCalculator.getMemoryCacheSize());
    &#125;

    if (diskCacheFactory == null) &#123;
        diskCacheFactory = new InternalCacheDiskCacheFactory(context);
    &#125;
    // Engine 用来管理上方初始化的各种线程池和缓存 
    if (engine == null) &#123;
        engine =
            new Engine(
                memoryCache,
                diskCacheFactory,
                diskCacheExecutor,
                sourceExecutor,
                GlideExecutor.newUnlimitedSourceExecutor(),
                animationExecutor,
                isActiveResourceRetentionAllowed);
    &#125;

    if (defaultRequestListeners == null) &#123;
        defaultRequestListeners = Collections.emptyList();
    &#125; else &#123;
        defaultRequestListeners = Collections.unmodifiableList(defaultRequestListeners);
    &#125;

    RequestManagerRetriever requestManagerRetriever =
        new RequestManagerRetriever(requestManagerFactory);

    return new Glide(
        context,
        engine,
        memoryCache,
        bitmapPool,
        arrayPool,
        requestManagerRetriever,
        connectivityMonitorFactory,
        logLevel,
        defaultRequestOptionsFactory,
        defaultTransitionOptions,
        defaultRequestListeners,
        isLoggingRequestOriginsEnabled,
        isImageDecoderEnabledForBitmaps);
&#125;
</code></pre>
<p>可见 Glide 在初始化中做了很多的工作。</p>
<ol>
<li>首先初始化了3个线程池，分别用来处理线程、LRU缓存、动画</li>
<li>根据设备的具体信息，初始化缓存区域</li>
<li>初始化了一个 Engine 的实例用来管理上面实例化的东西</li>
<li>生成一个 RequestManagerRetriver 的实例，后面会用来获取 RequestManager</li>
<li>生成 Glide 实例</li>
</ol>
<h2 id="load"><a href="#load" class="headerlink" title="load()"></a><code>load()</code></h2><p>在调用with方法获取到RequestManager对象的前提下，调用load方法，并传递我们的url参数，来看下它的源码：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/guanmanman/p/7008259.html">继续看这里</a></p>
<h2 id="into"><a href="#into" class="headerlink" title="into()"></a><code>into()</code></h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/guanmanman/p/7040942.html">继续看这里</a></p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2020-04-02/job-interview/" title="Android 面试题合集"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">Previous: Android 面试题合集</span></a><a class="button is-default" href="/2020-03-24/context-and-its-friends/" title="Context 和它的朋友们"><span class="has-text-weight-semibold">Next: Context 和它的朋友们</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container" id="vcomments" data-comment_valine_id="b7rbKQnQFa9DYl1anYfacJRz-gzGzoHsz" data-comment_valine_key="nUuKvGHOJBRylruJLW2Fmekg"></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com/serious008/"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/serious198706"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com/serious008/"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><a title="zhihu" target="_blank" rel="noopener nofollow" href="//zhihu.com/people/cy198706"><i class="iconfont icon-zhihu"></i></a><!-- 领英--><a title="linkedin" target="_blank" rel="noopener nofollow" href="//www.linkedin.com/in/serious_chen/"><i class="iconfont icon-linkedin"></i></a><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com/serious008/"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> Notex 2023</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="京ICP备2022033375号" target="_blank" rel="noopener" href="https://beian.miit.gov.cn/">京ICP备2022033375号 </a></p></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>