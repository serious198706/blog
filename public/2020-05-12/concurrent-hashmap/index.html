<!DOCTYPE html><html class="appearance-user-can-set" lang="zh"><head><meta charset="UTF-8"><title>Notex</title><meta name="description" content="Keep low profile, he said."><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="ConcurrentHashMap åº•å±‚æ˜¯åŸºäºæ•°ç»„ + é“¾è¡¨ç»„æˆçš„ï¼Œä¸è¿‡åœ¨ jdk1.7 å’Œ 1.8 ä¸­å…·ä½“å®ç°ç¨æœ‰ä¸åŒã€‚


JDK 1.7æ•°æ®ç»“æ„åœ¨ JDK1.7 ä¸­æ˜¯è¿™æ ·çš„ï¼š

å¦‚å›¾æ‰€ç¤ºï¼Œæ˜¯ç”± Segment æ•°ç»„ã€HashEntry ç»„æˆï¼Œå’Œ HashMap ä¸€æ ·ï¼Œä»ç„¶æ˜¯æ•°ç»„åŠ é“¾è¡¨ã€‚
Segment æ˜¯ ConcurrentHashMap çš„ä¸€ä¸ªå†…éƒ¨ç±»ï¼Œä¸»è¦çš„ç»„æˆå¦‚ä¸‹ï¼š
staticÂ finalÂ classÂ Segment&amp;lt;K,V&amp;gt;Â extendsÂ ReentrantLockÂ implementsÂ SerializableÂ &amp;#123;Â Â Â Â 

    privateÂ staticÂ finalÂ longÂ serialVersionUIDÂ =Â 2249069246763182397L;Â .."><script src="//unpkg.com/valine/dist/Valine.min.js"></script><meta name="generator" content="Hexo 5.4.2"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><!-- a(href= url_for("/"))= (theme.user && theme.user.name || config.author) + "'s blog"--><a href="/">Notex</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">ConcurrentHashMap</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">ä¸»é¡µ</a></h3><h3 class="is-inline-block"><a href="/about">å…³äº</a></h3><h3 class="is-inline-block"><a href="/archives">å½’æ¡£</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">ä¸»é¡µ</a></h3><h3 class="is-inline-block"><a href="/about">å…³äº</a></h3><h3 class="is-inline-block"><a href="/archives">å½’æ¡£</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK-1-7"><span class="toc-text">JDK 1.7</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">æ•°æ®ç»“æ„</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#put"><span class="toc-text">put()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#get"><span class="toc-text">get()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-text">æ‰©å®¹æœºåˆ¶</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#size"><span class="toc-text">size()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK-1-8"><span class="toc-text">JDK 1.8</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1"><span class="toc-text">æ•°æ®ç»“æ„</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#put-1"><span class="toc-text">put()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#get-1"><span class="toc-text">get()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6-1"><span class="toc-text">æ‰©å®¹æœºåˆ¶</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#size-1"><span class="toc-text">size()</span></a></li></ol></li></ol></div><div class="column is-9"><header class="my-4"></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">ConcurrentHashMap</h1><time class="has-text-grey" datetime="2020-05-11T16:00:00.000Z">2020-05-12</time><article class="mt-2 post-content"><p><img src="/img/covers/cover-java-2020-05-12.png" alt="cover"><br>ConcurrentHashMap åº•å±‚æ˜¯åŸºäº<strong>æ•°ç»„ + é“¾è¡¨</strong>ç»„æˆçš„ï¼Œä¸è¿‡åœ¨ jdk1.7 å’Œ 1.8 ä¸­å…·ä½“å®ç°ç¨æœ‰ä¸åŒã€‚</p>
<span id="more"></span>

<h2 id="JDK-1-7"><a href="#JDK-1-7" class="headerlink" title="JDK 1.7"></a>JDK 1.7</h2><h3 id="æ•°æ®ç»“æ„"><a href="#æ•°æ®ç»“æ„" class="headerlink" title="æ•°æ®ç»“æ„"></a>æ•°æ®ç»“æ„</h3><p>åœ¨ JDK1.7 ä¸­æ˜¯è¿™æ ·çš„ï¼š</p>
<p><img src="/img/concurrent-hashmap-1589261515.png"></p>
<p>å¦‚å›¾æ‰€ç¤ºï¼Œæ˜¯ç”± Segment æ•°ç»„ã€HashEntry ç»„æˆï¼Œå’Œ HashMap ä¸€æ ·ï¼Œä»ç„¶æ˜¯<strong>æ•°ç»„åŠ é“¾è¡¨</strong>ã€‚</p>
<p>Segment æ˜¯ ConcurrentHashMap çš„ä¸€ä¸ªå†…éƒ¨ç±»ï¼Œä¸»è¦çš„ç»„æˆå¦‚ä¸‹ï¼š</p>
<pre><code class="java">staticÂ finalÂ classÂ Segment&lt;K,V&gt;Â extendsÂ ReentrantLockÂ implementsÂ SerializableÂ &#123;Â Â Â Â 

    privateÂ staticÂ finalÂ longÂ serialVersionUIDÂ =Â 2249069246763182397L;Â Â Â Â 

    //Â å’ŒÂ HashMapÂ ä¸­çš„Â HashEntryÂ ä½œç”¨ä¸€æ ·ï¼ŒçœŸæ­£å­˜æ”¾æ•°æ®çš„åœ°æ–¹Â Â Â 
    transientÂ volatileÂ HashEntry&lt;K,V&gt;[]Â table;Â Â Â Â 

    transientÂ intÂ count;

    // ç”¨äº fail-fastï¼Œå¿«é€Ÿå¤±è´¥
    transientÂ intÂ modCount;

    //Â å¤§å°
    transientÂ intÂ threshold;

    //Â è´Ÿè½½å› å­
    finalÂ floatÂ loadFactor;
&#125;
</code></pre>
<p>HashEntry è·Ÿ HashMap ä¸­çš„ Entry åŸºæœ¬ç›¸åŒï¼Œä½†æ˜¯ä¸åŒç‚¹æ˜¯ï¼Œä»–**ä½¿ç”¨<code>volatile</code>å»ä¿®é¥°äº†ä»–çš„æ•°æ®<code>value</code>è¿˜æœ‰ä¸‹ä¸€ä¸ªèŠ‚ç‚¹<code>next</code>**ã€‚</p>
<blockquote>
<p><strong><code>volatile</code>çš„åŠŸèƒ½</strong></p>
<p>ä¿è¯äº†ä¸åŒçº¿ç¨‹å¯¹è¿™ä¸ªå˜é‡è¿›è¡Œæ“ä½œæ—¶çš„å¯è§æ€§ï¼Œå³ä¸€ä¸ªçº¿ç¨‹ä¿®æ”¹äº†æŸä¸ªå˜é‡çš„å€¼ï¼Œè¿™æ–°å€¼å¯¹å…¶ä»–çº¿ç¨‹æ¥è¯´æ˜¯ç«‹å³å¯è§çš„ã€‚ï¼ˆå®ç°å¯è§æ€§ï¼‰</p>
<p>ç¦æ­¢è¿›è¡ŒæŒ‡ä»¤é‡æ’åºã€‚ï¼ˆå®ç°æœ‰åºæ€§ï¼‰</p>
<p>æ³¨æ„ï¼š<code>volatile</code>åªèƒ½ä¿è¯å¯¹<strong>å•æ¬¡è¯»/å†™çš„åŸå­æ€§</strong>ã€‚i++ è¿™ç§æ“ä½œä¸èƒ½ä¿è¯åŸå­æ€§ã€‚</p>
</blockquote>
<p>åŸç†ä¸Šæ¥è¯´ï¼ŒConcurrentHashMap é‡‡ç”¨äº†åˆ†æ®µé”æŠ€æœ¯ï¼Œå…¶ä¸­<strong>Segment ç»§æ‰¿äº ReentrantLock</strong>ã€‚</p>
<p>å®ƒä¸ä¼šåƒ HashTable é‚£æ ·ä¸ç®¡æ˜¯<code>put()</code>è¿˜æ˜¯<code>get()</code>æ“ä½œéƒ½éœ€è¦åšåŒæ­¥å¤„ç†ï¼Œç†è®ºä¸Š ConcurrentHashMap æ”¯æŒ CurrencyLevel (å€¼ä¸º Segment æ•°ç»„æ•°é‡ï¼‰çš„çº¿ç¨‹å¹¶å‘ã€‚</p>
<p>æ¯å½“ä¸€ä¸ªçº¿ç¨‹å ç”¨é”è®¿é—®ä¸€ä¸ª Segment æ—¶ï¼Œä¸ä¼šå½±å“åˆ°å…¶ä»–çš„ Segmentã€‚</p>
<p>å°±æ˜¯è¯´å¦‚æœ Segment å½“å‰å¤§å°æ˜¯16ä»–çš„å¹¶å‘åº¦å°±æ˜¯16ï¼Œå¯ä»¥åŒæ—¶å…è®¸16ä¸ªçº¿ç¨‹æ“ä½œ16ä¸ª Segment è€Œä¸”è¿˜æ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚</p>
<h3 id="put"><a href="#put" class="headerlink" title="put()"></a><code>put()</code></h3><p>æˆ‘ä»¬çœ‹ä¸€ä¸‹ ConcurrentHashMap çš„<code>put()</code>æ–¹æ³•ï¼š</p>
<pre><code class="java">// jdk1.7 ConcurrentHashMap.java
publicÂ VÂ put(KÂ key,Â VÂ value)Â &#123;
    Segment&lt;K,V&gt;Â s;

    ifÂ (valueÂ ==Â null)
        throwÂ newÂ NullPointerException(); //è¿™å°±æ˜¯ä¸ºå•¥ä»–ä¸å¯ä»¥putÂ nullå€¼çš„åŸå› 
    intÂ hashÂ =Â hash(key);
    intÂ jÂ =Â (hashÂ &gt;&gt;&gt;Â segmentShift)Â &amp;Â segmentMask;
    // if ä¸­æ‹¿åˆ°çš„ s ä¸æ˜¯ volatile çš„ï¼Œå°†ä¼šåœ¨ ensureSegment ä¸­é‡æ–°è¿›è¡Œæ£€æŸ¥
    ifÂ ((sÂ =Â (Segment&lt;K,V&gt;)UNSAFE.getObject(segments,Â (jÂ &lt;&lt;Â SSHIFT)Â +Â SBASE))Â ==Â null)
        sÂ =Â ensureSegment(j);
    returnÂ s.put(key,Â hash,Â value,Â false);
&#125;
</code></pre>
<p>ä»–å…ˆå®šä½åˆ°å½“å‰ key å±äºå“ªä¸ª Segmentï¼Œç„¶åå†å¯¹è¯¥ Segment è¿›è¡Œ<code>put()</code>æ“ä½œã€‚</p>
<p>ç„¶åæˆ‘ä»¬çœ‹çœ‹ Segment çš„<code>put()</code>æºä»£ç ï¼Œä½ å°±çŸ¥é“ä»–æ˜¯æ€ä¹ˆåšåˆ°çº¿ç¨‹å®‰å…¨çš„äº†ï¼Œå…³é”®å¥å­æˆ‘æ³¨é‡Šäº†ã€‚</p>
<pre><code class="java">final V put(K key, int hash, V value, boolean onlyIfAbsent) &#123;
    // å°†å½“å‰ Segment ä¸­çš„ table é€šè¿‡ key çš„ hashcode å®šä½åˆ° HashEntry
    // å› ä¸º Segment ç»§æ‰¿è‡ª ReentrantLockï¼Œæ‰€ä»¥æ­¤å¤„ç›´æ¥è°ƒç”¨äº†çˆ¶ç±»çš„ tryLock() æ–¹æ³•ï¼ŒæŒæœ‰å½“å‰é”
    HashEntry&lt;K,V&gt; node = tryLock() ? null : scanAndLockForPut(key, hash, value);
    V oldValue;
    try &#123;
        HashEntry&lt;K,V&gt;[] tab = table;
        // è®¡ç®— index
        int index = (tab.length - 1) &amp; hash;
        HashEntry&lt;K,V&gt; first = entryAt(tab, index);
        for (HashEntry&lt;K,V&gt; e = first;;) &#123;
            // å¦‚æœæ‹¿åˆ°çš„å½“å‰ index çš„å€¼ä¸ä¸ºç©ºï¼Œè¡¨ç¤ºè¯¥ index ä¸Šæœ‰æ•°æ®ï¼Œéœ€è¦è¿›è¡Œè¦†ç›–
            if (e != null) &#123;
                K k;
                // éå†è¯¥ HashEntryï¼Œ
                // å¦‚æœä¸ä¸ºç©ºåˆ™åˆ¤æ–­ä¼ å…¥çš„ key å’Œå½“å‰éå†çš„ key æ˜¯å¦ç›¸ç­‰ï¼Œç›¸ç­‰åˆ™è¦†ç›–æ—§çš„ valueã€‚
                if ((k = e.key) == key ||
                    (e.hash == hash &amp;&amp; key.equals(k))) &#123;
                    oldValue = e.value;
                    if (!onlyIfAbsent) &#123;
                        e.value = value;
                        ++modCount;
                    &#125;
                    break;
                &#125;
                e = e.next;
            &#125;
            else &#123;
                // ä¸ä¸ºç©ºåˆ™éœ€è¦æ–°å»ºä¸€ä¸ª HashEntry å¹¶åŠ å…¥åˆ° Segment ä¸­ï¼ŒåŒæ—¶ä¼šå…ˆåˆ¤æ–­æ˜¯å¦éœ€è¦æ‰©å®¹
                if (node != null)
                    node.setNext(first);
                else
                    node = new HashEntry&lt;K,V&gt;(hash, key, value, first);
                int c = count + 1;
                // åˆ¤æ–­æ˜¯å¦éœ€è¦æ‰©å®¹
                if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)
                    rehash(node);
                else
                    setEntryAt(tab, index, node);
                ++modCount;
                count = c;
                oldValue = null;
                break;
            &#125;
        &#125;
    &#125; finally &#123;
        //é‡Šæ”¾é”
        unlock();
    &#125;
    return oldValue;
&#125;

private HashEntry&lt;K,V&gt; scanAndLockForPut(K key, int hash, V value) &#123;
    HashEntry&lt;K,V&gt; first = entryForHash(this, hash);
    HashEntry&lt;K,V&gt; e = first;
    HashEntry&lt;K,V&gt; node = null;
    int retries = -1;
    while (!tryLock()) &#123;  // è‡ªæ—‹è·å–é”
        HashEntry&lt;K,V&gt; f;
        if (retries &lt; 0) &#123;
            if (e == null) &#123;
                if (node == null) // å°è¯•åˆ›å»ºæ–°çš„ HashEntry
                    node = new HashEntry&lt;K,V&gt;(hash, key, value, null);
                retries = 0;
            &#125;
            else if (key.equals(e.key))
                retries = 0;
            else
                e = e.next;
        &#125;
        else if (++retries &gt; MAX_SCAN_RETRIES) &#123; 
            // ç›´æ¥ä½¿ç”¨é˜»å¡é”çš„æ–¹å¼ï¼Œæš´åŠ›è€Œæœ‰æ•ˆ
            lock();
            break;
        &#125;
        else if ((retries &amp; 1) == 0 &amp;&amp;
                    (f = entryForHash(this, hash)) != first) &#123;
            e = first = f; // re-traverse if entry changed
            retries = -1;
        &#125;
    &#125;
    return node;
&#125;
</code></pre>
<p>é¦–å…ˆç¬¬ä¸€æ­¥çš„æ—¶å€™ä¼šå°è¯•<strong>è·å–é”</strong>ï¼Œå¦‚æœè·å–å¤±è´¥è‚¯å®šå°±æœ‰å…¶ä»–çº¿ç¨‹å­˜åœ¨ç«äº‰ï¼Œåˆ™åˆ©ç”¨<code>scanAndLockForPut()</code><strong>è‡ªæ—‹è·å–é”</strong>ã€‚å¦‚æœé‡è¯•çš„æ¬¡æ•°è¾¾åˆ°äº†<code>MAX_SCAN_RETRIES</code>ï¼ˆCPUæ•°é‡å¤§äº1æ—¶ï¼Œå€¼ä¸º64ï¼Œå¦åˆ™ä¸º1ï¼‰åˆ™æ”¹ä¸ºé˜»å¡é”è·å–ï¼Œä¿è¯èƒ½è·å–æˆåŠŸã€‚</p>
<blockquote>
<p>è‡ªæ—‹å°±æ˜¯æ‰§è¡Œä¸€æ®µæ— æ„ä¹‰çš„å¾ªç¯ã€‚</p>
</blockquote>
<h3 id="get"><a href="#get" class="headerlink" title="get()"></a><code>get()</code></h3><p><code>get()</code>é€»è¾‘æ¯”è¾ƒç®€å•ï¼Œå®šä½ Segment â†’ å®šä½ HashEntry â†’ å®šä½é“¾è¡¨èŠ‚ç‚¹ï¼š</p>
<pre><code class="java">    public V get(Object key) &#123;
        Segment&lt;K,V&gt; s; // manually integrate access methods to reduce overhead
        HashEntry&lt;K,V&gt;[] tab;
        int h = hash(key.hashCode());
        long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;
        // å®šä½ Segment
        if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;&amp;
            (tab = s.table) != null) &#123;
            // å®šä½ HashEntry
            for (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile
                     (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE);
                 e != null; e = e.next) &#123;
                K k;
                // å®šä½é“¾è¡¨ä¸Šçš„èŠ‚ç‚¹
                if ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))
                    return e.value;
            &#125;
        &#125;
        return null;
    &#125;
</code></pre>
<p>ç”±äº HashEntry ä¸­çš„<code>value</code>å±æ€§æ˜¯ç”¨<code>volatile</code>å…³é”®è¯ä¿®é¥°çš„ï¼Œä¿è¯äº†å†…å­˜å¯è§æ€§ï¼Œæ‰€ä»¥æ¯æ¬¡è·å–æ—¶éƒ½æ˜¯æœ€æ–°å€¼ã€‚æ‰€ä»¥ ConcurrentHashMap çš„<code>get()</code>æ–¹æ³•æ˜¯éå¸¸é«˜æ•ˆçš„ï¼Œå› ä¸ºæ•´ä¸ªè¿‡ç¨‹éƒ½ä¸éœ€è¦åŠ é”ã€‚</p>
<p>ä½†æ˜¯ï¼Œè™½ç„¶ JDK1.7 ä¸­å¯ä»¥æ”¯æŒæ¯ä¸ª Segment å¹¶å‘è®¿é—®ï¼Œä½†æ˜¯è¿˜æ˜¯å­˜åœ¨ä¸€äº›é—®é¢˜ï¼š<strong>æˆ‘ä»¬å»æŸ¥è¯¢çš„æ—¶å€™ï¼Œè¿˜å¾—éå†é“¾è¡¨</strong>ï¼Œä¼šå¯¼è‡´æ•ˆç‡å¾ˆä½ï¼Œè¿™ä¸ªè·Ÿ JDK1.7 çš„ HashMap æ˜¯å­˜åœ¨çš„ä¸€æ ·é—®é¢˜ï¼Œæ‰€ä»¥ä»–åœ¨ JDK1.8 å®Œå…¨ä¼˜åŒ–äº†ã€‚</p>
<h3 id="æ‰©å®¹æœºåˆ¶"><a href="#æ‰©å®¹æœºåˆ¶" class="headerlink" title="æ‰©å®¹æœºåˆ¶"></a>æ‰©å®¹æœºåˆ¶</h3><p>ç„¶åè®²è®²åœ¨ JDK1.7 ä¸­çš„æ‰©å®¹æœºåˆ¶ã€‚</p>
<p>æˆ‘ä»¬å‘ä¸Šç¿»ä¸€ä¸‹ï¼Œåœ¨<code>put()</code>æ–¹æ³•ä¸­ï¼Œå½“åˆ¤æ–­éœ€è¦æ‰©å®¹æ—¶ï¼Œè°ƒç”¨çš„æ˜¯<code>rehash()</code>æ–¹æ³•ï¼Œæˆ‘ä»¬æ¥çœ‹çœ‹å®ƒæ˜¯å¦‚ä½•åšçš„ï¼š</p>
<pre><code class="java">private void rehash(HashEntry&lt;K,V&gt; node) &#123;
    HashEntry&lt;K,V&gt;[] oldTable = table;
    int oldCapacity = oldTable.length;
    int newCapacity = oldCapacity &lt;&lt; 1; // ä¸ HashMap ç›¸åŒï¼Œé‡‡ç”¨2æ¬¡å¹‚æ‰©å®¹
    threshold = (int)(newCapacity * loadFactor);
    HashEntry&lt;K,V&gt;[] newTable = (HashEntry&lt;K,V&gt;[]) new HashEntry[newCapacity];
    int sizeMask = newCapacity - 1;
    for (int i = 0; i &lt; oldCapacity ; i++) &#123;
        HashEntry&lt;K,V&gt; e = oldTable[i];
        if (e != null) &#123;
            HashEntry&lt;K,V&gt; next = e.next;
            int idx = e.hash &amp; sizeMask;
            if (next == null)   // é“¾è¡¨ä¸­åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹
                newTable[idx] = e;
            else &#123; // å°†åŸæ¥çš„é¡ºåºåŸå°ä¸åŠ¨åœ°ç§»åˆ°æ–°çš„ table ä¸­
                HashEntry&lt;K,V&gt; lastRun = e;
                int lastIdx = idx;
                for (HashEntry&lt;K,V&gt; last = next; last != null; last = last.next) &#123;
                    int k = last.hash &amp; sizeMask;
                    if (k != lastIdx) &#123;
                        lastIdx = k;
                        lastRun = last;
                    &#125;
                &#125;
                newTable[lastIdx] = lastRun;
               
                for (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;
                    V v = p.value;
                    int h = p.hash;
                    int k = h &amp; sizeMask;
                    HashEntry&lt;K,V&gt; n = newTable[k];
                    newTable[k] = new HashEntry&lt;K,V&gt;(h, p.key, v, n);
                &#125;
            &#125;
        &#125;
    &#125;
    int nodeIndex = node.hash &amp; sizeMask; // å°†æ–°çš„èŠ‚ç‚¹åŠ å…¥
    node.setNext(newTable[nodeIndex]);
    newTable[nodeIndex] = node;
    table = newTable;
&#125;
</code></pre>
<p>å¯ä»¥çœ‹å‡ºï¼Œä¸ HashMap æ‰©å®¹æœºåˆ¶ç±»ä¼¼ï¼Œé‡‡å–äº†<strong>2æ¬¡å¹‚çš„æ–¹å¼</strong>æ¥å†³å®šæ–°æ•°ç»„çš„å¤§å°ã€‚ä½†æ˜¯ï¼ŒSegment æ²¡æœ‰æ‰©å®¹æœºåˆ¶ï¼Œåœ¨åˆå§‹åŒ–æ—¶ï¼Œå°±æŒ‡å®šå¥½äº† Segment æ•°ç»„çš„å¤§å°ï¼Œä¹Ÿæ—¢è¯¥ ConcurrentHashMap çš„å¹¶å‘æ•°ã€‚</p>
<h3 id="size"><a href="#size" class="headerlink" title="size()"></a><code>size()</code></h3><p>æ—¢ç„¶è¦è€ƒè™‘çº¿ç¨‹å®‰å…¨ï¼Œåœ¨è·å– ConcurrentHashMap çš„å¤§å°æ—¶ï¼Œä¹Ÿè¦ç‰¹æ®Šå¤„ç†ä¸€ä¸‹ã€‚è¿™é‡Œé‡‡ç”¨çš„æ˜¯<strong>å¤šæ¬¡å¯¹æ¯”æœºåˆ¶</strong>ï¼Œæˆ‘ä»¬æ¥çœ‹çœ‹å®ƒçš„ä»£ç ï¼š</p>
<pre><code class="java">public int size() &#123;
    final Segment&lt;K,V&gt;[] segments = this.segments;
    int size;
    boolean overflow; // true if size overflows 32 bits
    long sum;         // sum of modCounts
    long last = 0L;   // previous sum
    int retries = -1; // first iteration isn&#39;t retry
    try &#123;
        for (;;) &#123;
            if (retries++ == RETRIES_BEFORE_LOCK) &#123;  // é‡è¯•æ¬¡æ•°è¾¾åˆ°2
                for (int j = 0; j &lt; segments.length; ++j)
                    ensureSegment(j).lock(); // å¼ºåˆ¶è®©æ‰€æœ‰ Segment è·å¾—é˜»å¡é”
            &#125;
            sum = 0L;
            size = 0;
            overflow = false;
            for (int j = 0; j &lt; segments.length; ++j) &#123;
                Segment&lt;K,V&gt; seg = segmentAt(segments, j);
                if (seg != null) &#123;
                    sum += seg.modCount;
                    int c = seg.count;
                    if (c &lt; 0 || (size += c) &lt; 0)
                        overflow = true;
                &#125;
            &#125;
            // å¦‚æœæ­¤æ¬¡è·å–çš„å¤§å°ä¸ä¸Šæ¬¡ä¸€è‡´ï¼Œåˆ™è®¤ä¸ºè¿™å°±æ˜¯å½“å‰å¤§å°
            if (sum == last)
                break;
            last = sum;
        &#125;
    &#125; finally &#123;
        if (retries &gt; RETRIES_BEFORE_LOCK) &#123;
            for (int j = 0; j &lt; segments.length; ++j)
                segmentAt(segments, j).unlock();  // æ¯”å¯¹å®Œæˆåè®©æ‰€æœ‰ Segment è§£é”
        &#125;
    &#125;
    return overflow ? Integer.MAX_VALUE : size;
&#125;
</code></pre>
<p>å¯ä»¥çœ‹åˆ°ï¼Œè‡³å°‘è¦è¿›è¡Œä¸¤æ¬¡éå†ï¼Œå¦‚æœ<strong>ç›¸é‚»çš„ä¸¤æ¬¡éå†è®¡ç®—å‡ºçš„ key-value çš„æ•°é‡æ˜¯ç›¸ç­‰</strong>çš„ï¼Œé‚£å°±è®¤ä¸ºè¿™ä¸ªæ•°é‡æ˜¯å½“å‰çš„æ­£ç¡®æ•°é‡ã€‚å¦‚æœä¸€ç›´å¯¹æ¯”ä¸ä¸Šï¼Œè¿™è¯´æ˜æ•°æ®åœ¨ä¸æ–­åœ°æ›´æ”¹ï¼Œæ­¤æ—¶è¦è®©<strong>æ‰€æœ‰ Segment è·å–é˜»å¡é”</strong>ï¼Œç„¶åå†è¿›è¡Œå¯¹æ¯”ï¼Œå¯¹æ¯”æˆåŠŸåï¼Œè§£é”ï¼Œè¿”å›æ•°é‡ã€‚</p>
<h2 id="JDK-1-8"><a href="#JDK-1-8" class="headerlink" title="JDK 1.8"></a>JDK 1.8</h2><h3 id="æ•°æ®ç»“æ„-1"><a href="#æ•°æ®ç»“æ„-1" class="headerlink" title="æ•°æ®ç»“æ„"></a>æ•°æ®ç»“æ„</h3><p>åœ¨ JDK1.8 ä¸­ï¼ŒConcurrentHashMap æŠ›å¼ƒäº†åŸæœ‰çš„ Segment åˆ†æ®µé”ï¼Œè€Œé‡‡ç”¨äº† CAS + synchronized æ¥ä¿è¯å¹¶å‘å®‰å…¨æ€§ã€‚</p>
<p>è™½ç„¶å®ƒçš„æºç ä¸­è¿˜æ˜¯ä¼šåŒ…å« Segment ç±»ï¼Œä½†æ˜¯ä¹Ÿåªç”¨åœ¨ Serializable çš„<strong>åºåˆ—åŒ–å’Œååºåˆ—åŒ–</strong>ä¸­ï¼Œè€Œä¸”å¤šäºäº† Serializable çš„<code>serialVersionUID</code>ç‰¹æ€§ï¼Œåªè¦ç‰ˆæœ¬å·ä¿æŒä¸€è‡´ï¼ŒSegment å¯ä»¥åœ¨ JDK1.7 å’Œ JDK1.8 ç”šè‡³ JDKX.X ä¹‹é—´è‡ªç”±è½¬æ¢ï¼ŒJVM ä¼šè®¤ä¸ºæ˜¯åŒä¸€ä¸ªç±»ã€‚</p>
<p>è·Ÿ HashMap çš„1.7 â†’ 1.8å¾ˆåƒï¼ŒConcurrentHashMap ä¹ŸæŠŠä¹‹å‰ JDK1.7 ä¸­çš„ HashEntry æ”¹æˆäº† Nodeï¼Œä½†æ˜¯ä½œç”¨ä¸å˜ï¼ŒæŠŠ<code>value</code>å’Œ<code>next</code>é‡‡ç”¨äº†<code>volatile</code>å»ä¿®é¥°ï¼Œä¿è¯äº†å¯è§æ€§ï¼Œå¹¶ä¸”ä¹Ÿå¼•å…¥äº†<strong>çº¢é»‘æ ‘</strong>ï¼Œåœ¨é“¾è¡¨å¤§äºä¸€å®šå€¼çš„æ—¶å€™ä¼šè½¬æ¢ï¼ˆé»˜è®¤æ˜¯8ï¼‰ã€‚</p>
<p>å®ƒçš„æ•°æ®ç»“æ„å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š</p>
<p><img src="/img/concurrent-hashmap-1589262515.png"></p>
<p>å¯¹äºæ¯ä¸€ä¸ªé“¾è¡¨ï¼ŒConcurrentHashMap å°†å…¶ç§°ä¹‹ <strong>ã€æ¡¶ã€ï¼ˆbinï¼‰</strong>ã€‚</p>
<h3 id="put-1"><a href="#put-1" class="headerlink" title="put()"></a><code>put()</code></h3><p>å…ˆçœ‹ä¸€ä¸‹å®ƒçš„ put æ–¹æ³•ï¼š</p>
<pre><code class="java">public V put(K key, V value) &#123;
    return putVal(key, value, false);
&#125;

final V putVal(K key, V value, boolean onlyIfAbsent) &#123;
    if (key == null || value == null) throw new NullPointerException();
    // è®¡ç®— hashCode
    int hash = spread(key.hashCode());
    int binCount = 0;
    for (Node&lt;K,V&gt;[] tab = table;;) &#123;  // æ­»å¾ªç¯ç¡®ä¿å¯ä»¥æ’å…¥æ•°æ®
        Node&lt;K,V&gt; f; 
        int n, i, fh;
        // å¦‚æœ Node æ•°ç»„ä¸º nullï¼Œåˆ™éœ€è¦åˆå§‹åŒ–ï¼Œåªæœ‰åœ¨ç¬¬ä¸€æ¬¡è¿›è¡Œ put æ—¶æ‰ä¼šè¿›è¡Œè¿™ä¸ªæ“ä½œ
        if (tab == null || (n = tab.length) == 0)
            tab = initTable();
        else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123; // åˆ©ç”¨ (n - 1) &amp; hash è®¡ç®— indexï¼Œå¾—å‡ºè¦æ’å…¥çš„ Node æ•°ç»„çš„ index
            // å¦‚æœèŠ‚ç‚¹ä¸ºç©ºï¼Œåˆ™åˆ©ç”¨ CAS æœºåˆ¶å†™å…¥æ•°æ®
            if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null))) // å‘ç©ºæ¡¶ä¸­æ’å…¥æ•°æ®
                break;  // å‘ç©ºçš„æ¡¶ä¸­æ·»åŠ æ•°æ®æ—¶ï¼Œä¸éœ€è¦åŠ é”
        &#125;
        // è¦æ‰©å®¹äº†
        else if ((fh = f.hash) == MOVED)
            tab = helpTransfer(tab, f);
        else &#123;
            // å°è¯•ä½¿ç”¨ synchronized å†™å…¥æ•°æ®
            V oldVal = null;
            synchronized (f) &#123;
                if (tabAt(tab, i) == f) &#123;
                    if (fh &gt;= 0) &#123;
                        binCount = 1;
                        for (Node&lt;K,V&gt; e = f;; ++binCount) &#123;
                            K ek;
                            if (e.hash == hash &amp;&amp;
                                ((ek = e.key) == key ||
                                    (ek != null &amp;&amp; key.equals(ek)))) &#123;
                                oldVal = e.val;
                                if (!onlyIfAbsent)
                                    e.val = value;
                                break;
                            &#125;
                            Node&lt;K,V&gt; pred = e;
                            if ((e = e.next) == null) &#123;
                                pred.next = new Node&lt;K,V&gt;(hash, key,
                                                            value, null);
                                break;
                            &#125;
                        &#125;
                    &#125;
                    // å·²ç»è¢«è½¬æ¢ä¸ºçº¢é»‘æ ‘èŠ‚ç‚¹äº†ï¼Œéœ€è¦ç”¨ putTreeVal æ¥è¿›è¡Œæ’å…¥
                    else if (f instanceof TreeBin) &#123;
                        Node&lt;K,V&gt; p;
                        binCount = 2;
                        if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,
                                                        value)) != null) &#123;
                            oldVal = p.val;
                            if (!onlyIfAbsent)
                                p.val = value;
                        &#125;
                    &#125;
                    else if (f instanceof ReservationNode)
                        throw new IllegalStateException(&quot;Recursive update&quot;);
                &#125;
            &#125;
            if (binCount != 0) &#123;
                // æ¡¶ä¸­èŠ‚ç‚¹çš„æ•°é‡å¤§äº TREEIFY_THRESHOLDï¼Œå€¼ä¸º8ï¼Œè½¬æ¢çº¢é»‘æ ‘
                if (binCount &gt;= TREEIFY_THRESHOLD)
                    treeifyBin(tab, i);
                if (oldVal != null)
                    return oldVal;
                break;
            &#125;
        &#125;
    &#125;
    addCount(1L, binCount);
    return null;
&#125;
</code></pre>
<p>ConcurrentHashMap åœ¨è¿›è¡Œ<code>put()</code>æ“ä½œçš„è¿˜æ˜¯æ¯”è¾ƒå¤æ‚çš„ï¼Œå¤§è‡´å¯ä»¥åˆ†ä¸ºä»¥ä¸‹æ­¥éª¤ï¼š</p>
<ol>
<li>å¦‚æœæ˜¯ç¬¬ä¸€æ¬¡æ’å…¥æ•°æ®ï¼Œåˆ™éœ€è¦è°ƒç”¨<code>initTable()</code>åˆå§‹åŒ– Node æ•°ç»„ï¼›</li>
<li>åˆ©ç”¨<code>(n - 1) &amp; hash</code>å¾—å‡ºè¦æ’å…¥çš„æ•°ç»„ indexï¼›</li>
<li>å¦‚æœæ•°ç»„çš„ index ä½ç½®ä¸º nullï¼Œåˆ™ç›´æ¥åˆ©ç”¨ CAS æœºåˆ¶æ’å…¥ï¼Œä¸éœ€è¦åŠ é”ï¼›</li>
<li>å¦‚æœæ•°ç»„çš„ index ä½ç½®ä¸ä¸º nullï¼Œåˆ™è¦ä½¿ç”¨ synchronized æ–¹å¼æ’å…¥åˆ°æ¡¶ï¼ˆé“¾è¡¨ï¼‰ä¸­ï¼›</li>
<li>å¦‚æœæ’å…¥å®Œæˆåï¼Œæ¡¶çš„èŠ‚ç‚¹æ•°é‡å¤§äºç­‰äº8äº†ï¼Œå°±è¦è½¬æ¢ä¸ºçº¢é»‘æ ‘ï¼ˆçº¢é»‘æ¡¶ğŸ›¢ï¼‰ï¼›</li>
<li>å¦‚æœèŠ‚ç‚¹çš„ hash å€¼ä¸º -1ï¼Œåˆ™éœ€è¦æ‰©å®¹ã€‚</li>
</ol>
<blockquote>
<p><strong>CASï¼ˆCompare And Swapï¼‰</strong></p>
<p>CAS æ˜¯ä¹è§‚é”çš„ä¸€ç§å®ç°æ–¹å¼ï¼Œæ˜¯ä¸€ç§è½»é‡çº§é”ï¼ŒJUC ä¸­å¾ˆå¤šå·¥å…·ç±»çš„å®ç°å°±æ˜¯åŸºäº CAS çš„ã€‚<br>CAS çš„ä¸­å¿ƒæ€æƒ³æ˜¯çº¿ç¨‹<strong>åœ¨è¯»å–æ•°æ®æ—¶ä¸è¿›è¡ŒåŠ é”</strong>ï¼Œåœ¨å‡†å¤‡å†™å›æ•°æ®æ—¶ï¼Œ<strong>æ¯”è¾ƒåŸå€¼æ˜¯å¦ä¿®æ”¹</strong>ï¼Œè‹¥æœªè¢«å…¶ä»–çº¿ç¨‹ä¿®æ”¹åˆ™å†™å›ï¼Œè‹¥å·²è¢«ä¿®æ”¹ï¼Œåˆ™&gt; é‡æ–°æ‰§è¡Œè¯»å–æµç¨‹ã€‚<br>è¿™æ˜¯ä¸€ç§<strong>ä¹è§‚ç­–ç•¥</strong>ï¼Œè®¤ä¸ºå¹¶å‘æ“ä½œå¹¶ä¸æ€»ä¼šå‘ç”Ÿã€‚</p>
<p>ä½†æ˜¯ç»å…¸çš„ ABA é—®é¢˜ï¼Œå®ƒå°±æ— æ³•åˆ¤æ–­äº†ã€‚å°±æ˜¯æ•°æ®ä» A å˜ä¸º B åˆå˜æˆ Aï¼Œçœ‹ä¼¼æ²¡ä¿®æ”¹è¿‡ï¼Œä½†å®é™…ä¸Šæ˜¯ä¿®æ”¹è¿‡çš„ã€‚<br>æƒ³è¦è§£å†³ ABA é—®é¢˜ï¼Œè¦ä¹ˆä½¿ç”¨ç‰ˆæœ¬å·ï¼Œè¦ä¹ˆä½¿ç”¨æ—¶é—´æˆ³æ ‡è¯†ï¼Œéƒ½å¯ä»¥ã€‚</p>
</blockquote>
<h3 id="get-1"><a href="#get-1" class="headerlink" title="get()"></a><code>get()</code></h3><p>å†æ¥çœ‹å®ƒçš„<code>get()</code>ï¼š</p>
<pre><code class="java">public V get(Object key) &#123;
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;
    int h = spread(key.hashCode());
    // æ ¹æ®è®¡ç®—å‡ºæ¥çš„ hashcode å¯»å€ï¼Œå¦‚æœå°±åœ¨é“¾è¡¨ä¸Šé‚£ä¹ˆç›´æ¥è¿”å›å€¼ã€‚
    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
        (e = tabAt(tab, (n - 1) &amp; h)) != null) &#123;
        // å¦‚æœæ˜¯çº¢é»‘æ ‘é‚£å°±æŒ‰ç…§æ ‘çš„æ–¹å¼è·å–å€¼ã€‚
        if ((eh = e.hash) == h) &#123;
            if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))
                return e.val;
        &#125;
        // éƒ½ä¸æ»¡è¶³é‚£å°±æŒ‰ç…§é“¾è¡¨çš„æ–¹å¼éå†è·å–å€¼ã€‚
        else if (eh &lt; 0)
            return (p = e.find(h, key)) != null ? p.val : null;
        while ((e = e.next) != null) &#123;
            if (e.hash == h &amp;&amp;
                ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))))
                return e.val;
        &#125;
    &#125;
    return null;
&#125;
</code></pre>
<p>æ¯”è¾ƒç®€å•ï¼Œä¹Ÿä¸éœ€è¦åŠ é”ï¼Œå› ä¸ºèŠ‚ç‚¹çš„å€¼éƒ½æ˜¯ volatile çš„ã€‚</p>
<h3 id="æ‰©å®¹æœºåˆ¶-1"><a href="#æ‰©å®¹æœºåˆ¶-1" class="headerlink" title="æ‰©å®¹æœºåˆ¶"></a>æ‰©å®¹æœºåˆ¶</h3><p>æˆ‘ä»¬ç›´æ¥æ¥çœ‹å®ƒçš„ä»£ç ï¼š</p>
<pre><code class="java">private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#123;
    int n = tab.length, stride;
    if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)
        stride = MIN_TRANSFER_STRIDE; // subdivide range
    if (nextTab == null) &#123;            // initiating
        try &#123;
            @SuppressWarnings(&quot;unchecked&quot;)
            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];
            nextTab = nt;
        &#125; catch (Throwable ex) &#123;      // try to cope with OOME
            sizeCtl = Integer.MAX_VALUE;
            return;
        &#125;
        nextTable = nextTab;
        transferIndex = n;
    &#125;
    int nextn = nextTab.length;
    ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab);
    boolean advance = true;
    boolean finishing = false; // to ensure sweep before committing nextTab
    for (int i = 0, bound = 0;;) &#123;
        Node&lt;K,V&gt; f; int fh;
        while (advance) &#123;
            int nextIndex, nextBound;
            if (--i &gt;= bound || finishing)
                advance = false;
            else if ((nextIndex = transferIndex) &lt;= 0) &#123;
                i = -1;
                advance = false;
            &#125;
            else if (U.compareAndSwapInt
                        (this, TRANSFERINDEX, nextIndex,
                        nextBound = (nextIndex &gt; stride ?
                                    nextIndex - stride : 0))) &#123;
                bound = nextBound;
                i = nextIndex - 1;
                advance = false;
            &#125;
        &#125;
        if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) &#123;
            int sc;
            if (finishing) &#123;
                nextTable = null;
                table = nextTab;
                sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1);
                return;
            &#125;
            if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) &#123;
                if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)
                    return;
                finishing = advance = true;
                i = n; // recheck before commit
            &#125;
        &#125;
        else if ((f = tabAt(tab, i)) == null)
            advance = casTabAt(tab, i, null, fwd);
        else if ((fh = f.hash) == MOVED)
            advance = true; // already processed
        else &#123;
            synchronized (f) &#123;
                if (tabAt(tab, i) == f) &#123;
                    Node&lt;K,V&gt; ln, hn;
                    if (fh &gt;= 0) &#123;
                        int runBit = fh &amp; n;
                        Node&lt;K,V&gt; lastRun = f;
                        for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) &#123;
                            int b = p.hash &amp; n;
                            if (b != runBit) &#123;
                                runBit = b;
                                lastRun = p;
                            &#125;
                        &#125;
                        if (runBit == 0) &#123;
                            ln = lastRun;
                            hn = null;
                        &#125;
                        else &#123;
                            hn = lastRun;
                            ln = null;
                        &#125;
                        for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;
                            int ph = p.hash; K pk = p.key; V pv = p.val;
                            if ((ph &amp; n) == 0)
                                ln = new Node&lt;K,V&gt;(ph, pk, pv, ln);
                            else
                                hn = new Node&lt;K,V&gt;(ph, pk, pv, hn);
                        &#125;
                        setTabAt(nextTab, i, ln);
                        setTabAt(nextTab, i + n, hn);
                        setTabAt(tab, i, fwd);
                        advance = true;
                    &#125;
                    else if (f instanceof TreeBin) &#123;
                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;
                        TreeNode&lt;K,V&gt; lo = null, loTail = null;
                        TreeNode&lt;K,V&gt; hi = null, hiTail = null;
                        int lc = 0, hc = 0;
                        for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) &#123;
                            int h = e.hash;
                            TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;
                                (h, e.key, e.val, null, null);
                            if ((h &amp; n) == 0) &#123;
                                if ((p.prev = loTail) == null)
                                    lo = p;
                                else
                                    loTail.next = p;
                                loTail = p;
                                ++lc;
                            &#125;
                            else &#123;
                                if ((p.prev = hiTail) == null)
                                    hi = p;
                                else
                                    hiTail.next = p;
                                hiTail = p;
                                ++hc;
                            &#125;
                        &#125;
                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :
                            (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t;
                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :
                            (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t;
                        setTabAt(nextTab, i, ln);
                        setTabAt(nextTab, i + n, hn);
                        setTabAt(tab, i, fwd);
                        advance = true;
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>ConcurrentHashMap çš„ JDK1.8 ä¸ JDK1.7 ç‰ˆæœ¬çš„å¹¶å‘å®ç°ç›¸æ¯”ï¼Œæœ€å¤§çš„åŒºåˆ«åœ¨äº JDK1.8 çš„<strong>é”çš„ç²’åº¦æ›´ç»†</strong>ã€‚</p>
<p>ç†æƒ³æƒ…å†µä¸‹ table æ•°ç»„å…ƒç´ çš„å¤§å°å°±æ˜¯å…¶æ”¯æŒå¹¶å‘çš„æœ€å¤§ä¸ªæ•°ï¼Œåœ¨ JDK1.7 é‡Œé¢æœ€å¤§å¹¶å‘ä¸ªæ•°å°±æ˜¯ Segment çš„ä¸ªæ•°ï¼Œé»˜è®¤å€¼æ˜¯16ï¼Œå¯ä»¥é€šè¿‡æ„é€ å‡½æ•°æ”¹å˜ä¸€ç»åˆ›å»ºä¸å¯æ›´æ”¹ï¼Œè¿™ä¸ªå€¼å°±æ˜¯å¹¶å‘çš„ç²’åº¦ï¼Œæ¯ä¸€ä¸ª Segment ä¸‹é¢ç®¡ç†ä¸€ä¸ª table æ•°ç»„ï¼ŒåŠ é”çš„æ—¶å€™å…¶å®é”ä½çš„æ˜¯æ•´ä¸ª Segmentï¼Œè¿™æ ·è®¾è®¡çš„å¥½å¤„åœ¨äºæ•°ç»„çš„æ‰©å®¹æ˜¯ä¸ä¼šå½±å“å…¶ä»–çš„ Segmentï¼Œç®€åŒ–äº†å¹¶å‘è®¾è®¡ï¼Œä¸è¶³ä¹‹å¤„åœ¨äºå¹¶å‘çš„ç²’åº¦ç¨ç²—ï¼Œæ‰€ä»¥åœ¨ JDK1.8 é‡Œé¢ï¼Œå»æ‰äº†åˆ†æ®µé”ï¼Œå°†é”çš„çº§åˆ«æ§åˆ¶åœ¨äº†æ›´ç»†ç²’åº¦çš„ table å…ƒç´ çº§åˆ«ï¼Œä¹Ÿå°±æ˜¯è¯´åªéœ€è¦<strong>é”ä½è¿™ä¸ªé“¾è¡¨çš„ head èŠ‚ç‚¹ï¼Œå¹¶ä¸ä¼šå½±å“å…¶ä»–çš„ table å…ƒç´ çš„è¯»å†™</strong>ï¼Œå¥½å¤„åœ¨äº<strong>å¹¶å‘çš„ç²’åº¦æ›´ç»†ï¼Œå½±å“æ›´å°</strong>ï¼Œä»è€Œå¹¶å‘æ•ˆç‡æ›´å¥½ï¼Œä½†ä¸è¶³ä¹‹å¤„åœ¨äºå¹¶å‘æ‰©å®¹çš„æ—¶å€™ï¼Œç”±äºæ“ä½œçš„ table éƒ½æ˜¯åŒä¸€ä¸ªï¼Œä¸åƒ JDK1.7 ä¸­åˆ†æ®µæ§åˆ¶ï¼Œæ‰€ä»¥è¿™é‡Œ<strong>éœ€è¦ç­‰æ‰©å®¹å®Œä¹‹åï¼Œæ‰€æœ‰çš„è¯»å†™æ“ä½œæ‰èƒ½è¿›è¡Œ</strong>ï¼Œæ‰€ä»¥æ‰©å®¹çš„æ•ˆç‡å°±æˆä¸ºäº†æ•´ä¸ªå¹¶å‘çš„ä¸€ä¸ªç“¶é¢ˆç‚¹ã€‚å¥½åœ¨ Doug lea å¤§ç¥å¯¹æ‰©å®¹åšäº†ä¼˜åŒ–ï¼Œæœ¬æ¥åœ¨ä¸€ä¸ªçº¿ç¨‹æ‰©å®¹çš„æ—¶å€™ï¼Œå¦‚æœå½±å“äº†å…¶ä»–çº¿ç¨‹çš„æ•°æ®ï¼Œé‚£ä¹ˆå…¶ä»–çš„çº¿ç¨‹çš„è¯»å†™æ“ä½œéƒ½<strong>åº”è¯¥é˜»å¡</strong>ï¼Œä½†æ˜¯ä»–ä»¬é—²ç€ä¹Ÿæ˜¯é—²ç€ï¼Œä¸å¦‚æ¥ä¸€èµ·å‚ä¸æ‰©å®¹ä»»åŠ¡ï¼Œè¿™æ ·äººå¤šåŠ›é‡å¤§ï¼ŒåŠå®Œäº‹ä½ ä»¬è¯¥å¹²å•¥å¹²å•¥ï¼Œåˆ«æµªè´¹æ—¶é—´ï¼Œäºæ˜¯åœ¨ JDK1.8 çš„æºç é‡Œé¢å°±å¼•å…¥äº†ä¸€ä¸ª ForwardingNode ç±»ï¼Œåœ¨ä¸€ä¸ªçº¿ç¨‹å‘èµ·æ‰©å®¹çš„æ—¶å€™ï¼Œå°±ä¼šæ”¹å˜ <code>sizeCtl</code> è¿™ä¸ªå€¼ï¼Œå…¶å«ä¹‰å¦‚ä¸‹ï¼š</p>
<blockquote>
<p><strong>sizeCtl</strong> ï¼šé»˜è®¤ä¸º0ï¼Œç”¨æ¥æ§åˆ¶tableçš„åˆå§‹åŒ–å’Œæ‰©å®¹æ“ä½œï¼Œå…·ä½“åº”ç”¨åœ¨åç»­ä¼šä½“ç°å‡ºæ¥ã€‚<br>å€¼ä¸º -1 æ—¶ä»£è¡¨ table æ­£åœ¨åˆå§‹åŒ–<br>å€¼ä¸º -(1 + n) æ—¶ï¼Œè¡¨ç¤ºæ­£åœ¨æœ‰ n ä¸ªçº¿ç¨‹æ­£åœ¨æ‰©å®¹<br>å¦‚æœ table æœªåˆå§‹åŒ–ï¼Œå€¼è¡¨ç¤º table éœ€è¦åˆå§‹åŒ–çš„å¤§å°<br>å¦‚æœ table åˆå§‹åŒ–å®Œæˆï¼Œè¡¨ç¤º table çš„å®¹é‡ï¼Œå€¼æ˜¯ <code>table çš„å¤§å° x è´Ÿè½½å› å­</code></p>
</blockquote>
<p>æ‰©å®¹æ—¶å€™ä¼šåˆ¤æ–­è¿™ä¸ªå€¼ï¼Œå¦‚æœè¶…è¿‡é˜ˆå€¼å°±è¦æ‰©å®¹ï¼Œé¦–å…ˆæ ¹æ®è¿ç®—å¾—åˆ°éœ€è¦éå†çš„æ¬¡æ•°iï¼Œç„¶ååˆ©ç”¨<code>tabAt()</code>æ–¹æ³•è·å¾—<code>i</code>ä½ç½®çš„å…ƒç´ <code>f</code>ï¼Œåˆå§‹åŒ–ä¸€ä¸ªForwardingNode å®ä¾‹<code>fwd</code>ï¼Œå¦‚æœ<code>f == null</code>ï¼Œåˆ™åœ¨tableä¸­çš„<code>i</code>ä½ç½®æ”¾å…¥<code>fwd</code>ï¼Œå¦åˆ™é‡‡ç”¨å¤´æ’æ³•çš„æ–¹å¼æŠŠå½“å‰æ—§ table æ•°ç»„çš„æŒ‡å®šä»»åŠ¡èŒƒå›´çš„æ•°æ®ç»™è¿ç§»åˆ°æ–°çš„æ•°ç»„ä¸­ï¼Œç„¶å ç»™æ—§ table åŸä½ç½®èµ‹å€¼<code>fwd</code>ã€‚ç›´åˆ°éå†è¿‡æ‰€æœ‰çš„èŠ‚ç‚¹ä»¥åå°±å®Œæˆäº†å¤åˆ¶å·¥ä½œï¼ŒæŠŠ table æŒ‡å‘ nextTableï¼Œå¹¶æ›´æ–°<code>sizeCtl</code>ä¸ºæ–°æ•°ç»„å¤§å°çš„0.75å€ ï¼Œæ‰©å®¹å®Œæˆã€‚åœ¨æ­¤æœŸé—´å¦‚æœå…¶ä»–çº¿ç¨‹çš„æœ‰è¯»å†™æ“ä½œéƒ½ä¼šåˆ¤æ–­<code>head</code>èŠ‚ç‚¹æ˜¯å¦ä¸º ForwardingNode èŠ‚ç‚¹ ï¼Œå¦‚æœæ˜¯å°±å¸®åŠ©æ‰©å®¹ã€‚</p>
<p>æˆ‘ä»¬æ¥çœ‹çœ‹ ForwadingNode çš„ä»£ç ï¼š</p>
<pre><code class="java">
static final int MOVED     = -1; // hash for forwarding nodes

/**
 * A node inserted at head of bins during transfer operations.
 */
static final class ForwardingNode&lt;K,V&gt; extends Node&lt;K,V&gt; &#123;
    final Node&lt;K,V&gt;[] nextTable;
    ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;
        super(MOVED, null, null, null);
        this.nextTable = tab;
    &#125;

    Node&lt;K,V&gt; find(int h, Object k) &#123;
        // ä½¿ç”¨å¾ªç¯ï¼Œé¿å…å¤šæ¬¡ç¢°åˆ° ForwardingNode å¯¼è‡´é€’å½’è¿‡æ·±
        outer: for (Node&lt;K,V&gt;[] tab = nextTable;;) &#123;
            Node&lt;K,V&gt; e; int n;
            if (k == null || tab == null || (n = tab.length) == 0 ||
                (e = tabAt(tab, (n - 1) &amp; h)) == null)
                return null;
            for (;;) &#123;
                int eh; K ek;
                if ((eh = e.hash) == h &amp;&amp;
                    ((ek = e.key) == k || (ek != null &amp;&amp; k.equals(ek))))  // ç¬¬ä¸€ä¸ªèŠ‚ç‚¹å°±æ˜¯è¦æ‰¾çš„èŠ‚ç‚¹ï¼Œç›´æ¥è¿”å›
                    return e;
                if (eh &lt; 0) &#123;
                    if (e instanceof ForwardingNode) &#123;
                        tab = ((ForwardingNode&lt;K,V&gt;)e).nextTable;
                        continue outer;
                    &#125;
                    else
                        return e.find(h, k);  // ç‰¹æ®ŠèŠ‚ç‚¹ï¼Œè°ƒç”¨å…¶findæ–¹æ³•è¿›è¡ŒæŸ¥æ‰¾
                &#125;
                if ((e = e.next) == null)  // æ™®é€šèŠ‚ç‚¹ç›´æ¥å¾ªç¯éå†é“¾è¡¨
                    return null;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>ForwardingNode æ˜¯ä¸€ç§ä¸´æ—¶èŠ‚ç‚¹ï¼Œåœ¨<strong>æ‰©å®¹è¿›è¡Œä¸­</strong>æ‰ä¼šå‡ºç°ï¼Œhash å€¼å›ºå®šä¸º -1ï¼Œå¹¶ä¸”å®ƒä¸å­˜å‚¨å®é™…çš„æ•°æ®æ•°æ®ã€‚å¦‚æœæ—§æ•°ç»„çš„ä¸€ä¸ª hash æ¡¶ä¸­å…¨éƒ¨çš„èŠ‚ç‚¹éƒ½è¿ç§»åˆ°æ–°æ•°ç»„ä¸­ï¼Œæ—§æ•°ç»„å°±åœ¨è¿™ä¸ª hash æ¡¶ä¸­æ”¾ç½®ä¸€ä¸ª ForwardingNodeã€‚è¯»æ“ä½œæˆ–è€…è¿­ä»£è¯»æ—¶ç¢°åˆ° ForwardingNode æ—¶ï¼Œå°†æ“ä½œè½¬å‘åˆ°æ‰©å®¹åçš„æ–°çš„ table æ•°ç»„ä¸Šå»æ‰§è¡Œï¼Œå†™æ“ä½œç¢°è§å®ƒæ—¶ï¼Œåˆ™å°è¯•å¸®åŠ©æ‰©å®¹ã€‚</p>
<h3 id="size-1"><a href="#size-1" class="headerlink" title="size()"></a><code>size()</code></h3><p>ä¸ jdk1.7 ä¸­çš„è®¡æ•°æ–¹å¼ä¸åŒï¼Œjdk1.8 ä¸­çš„ ConcurrentHashMap å¼•å…¥äº†ä¸€ä¸ª CounterCell ç±»ï¼Œç”¨äºè®°å½•æ¯ä¸€ä¸ªæ¡¶ä¸­çš„èŠ‚ç‚¹æ•°é‡ï¼Œåœ¨<code>put()</code>å€¼æ—¶ï¼Œæœ€åè°ƒç”¨çš„<code>addCount()</code>ä¸­ï¼Œå°±ä¼šå¯¹è¿™ä¸ªå€¼åšå‡ºä¿®æ”¹ï¼Œæ‰€ä»¥åœ¨<code>size()</code>æ—¶ï¼Œç›´æ¥ä½¿ç”¨å¾ªç¯æ–¹å¼ç´¯åŠ æ‰€æœ‰çš„ CounterCell çš„å€¼å³å¯å¾—å‡ºå½“å‰çš„ key-value çš„æ•°é‡ã€‚</p>
<pre><code class="java">public int size() &#123;
    long n = sumCount();
    return ((n &lt; 0L) ? 0 :
            (n &gt; (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE :
            (int)n);
&#125;

static final class CounterCell &#123;
    volatile long value;
    CounterCell(long x) &#123; value = x; &#125;
&#125;

final long sumCount() &#123;
    CounterCell[] as = counterCells; CounterCell a;
    long sum = baseCount;
    if (as != null) &#123;
        for (int i = 0; i &lt; as.length; ++i) &#123;
            if ((a = as[i]) != null)
                sum += a.value;
        &#125;
    &#125;
    return sum;
&#125;
</code></pre>
<blockquote>
<p>çº¢é»‘æ ‘ï¼ˆRed Black Treeï¼‰ æ˜¯ä¸€ç§è‡ªå¹³è¡¡äºŒå‰æŸ¥æ‰¾æ ‘ã€‚å®ƒæ˜¯ä¸€ç§ç‰¹åŒ–çš„å¹³è¡¡äºŒå‰æ ‘ï¼Œéƒ½æ˜¯åœ¨è¿›è¡Œæ’å…¥å’Œåˆ é™¤æ“ä½œæ—¶é€šè¿‡ç‰¹å®šæ“ä½œä¿æŒäºŒå‰æŸ¥æ‰¾&gt; æ ‘çš„å¹³è¡¡ï¼Œä»è€Œè·å¾—è¾ƒé«˜çš„æŸ¥æ‰¾æ€§èƒ½ã€‚å®ƒçš„æŸ¥æ‰¾æ—¶é—´å¤æ‚åº¦æ˜¯O(log n)ã€‚</p>
<p>çº¢é»‘æ ‘æ˜¯æ¯ä¸ªèŠ‚ç‚¹éƒ½å¸¦æœ‰é¢œè‰²å±æ€§çš„äºŒå‰æŸ¥æ‰¾æ ‘ï¼Œé¢œè‰²æˆ–çº¢è‰²æˆ–é»‘è‰²ã€‚åœ¨äºŒå‰æŸ¥æ‰¾æ ‘å¼ºåˆ¶ä¸€èˆ¬è¦æ±‚ä»¥å¤–ï¼Œå¯¹äºä»»ä½•æœ‰æ•ˆçš„çº¢é»‘æ ‘æˆ‘ä»¬å¢åŠ äº†å¦‚ä¸‹çš„&gt; é¢å¤–è¦æ±‚:</p>
<ol>
<li>èŠ‚ç‚¹æ˜¯çº¢è‰²æˆ–é»‘è‰²</li>
<li>æ ¹èŠ‚ç‚¹æ˜¯é»‘è‰² </li>
<li>æ‰€æœ‰å¶å­éƒ½æ˜¯é»‘è‰²ã€‚ï¼ˆå¶å­æ˜¯NUILèŠ‚ç‚¹ï¼‰</li>
<li>æ¯ä¸ªçº¢è‰²èŠ‚ç‚¹çš„ä¸¤ä¸ªå­èŠ‚ç‚¹éƒ½æ˜¯é»‘è‰²ã€‚ï¼ˆä»æ¯ä¸ªå¶å­åˆ°æ ¹çš„æ‰€æœ‰è·¯å¾„ä¸Šä¸èƒ½æœ‰ä¸¤ä¸ªè¿ç»­çš„çº¢è‰²èŠ‚ç‚¹ï¼‰</li>
<li>ä»ä»»ä¸€èŠ‚ç‚¹åˆ°å…¶æ¯ä¸ªå¶å­çš„æ‰€æœ‰è·¯å¾„éƒ½åŒ…å«ç›¸åŒæ•°ç›®çš„é»‘è‰²èŠ‚ç‚¹</li>
</ol>
</blockquote>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2020-05-13/kotlin-coroutine/" title="Kotlin åç¨‹"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">Previous: Kotlin åç¨‹</span></a><a class="button is-default" href="/2020-05-10/service/" title="å…³äº Service"><span class="has-text-weight-semibold">Next: å…³äº Service</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container" id="vcomments" data-comment_valine_id="b7rbKQnQFa9DYl1anYfacJRz-gzGzoHsz" data-comment_valine_key="nUuKvGHOJBRylruJLW2Fmekg"></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com/serious008/"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/serious198706"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com/serious008/"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- çŸ¥ä¹--><a title="zhihu" target="_blank" rel="noopener nofollow" href="//zhihu.com/people/cy198706"><i class="iconfont icon-zhihu"></i></a><!-- é¢†è‹±--><a title="linkedin" target="_blank" rel="noopener nofollow" href="//www.linkedin.com/in/serious_chen/"><i class="iconfont icon-linkedin"></i></a><!-- è„¸ä¹¦--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com/serious008/"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright Â©</span><span> Notex 2023</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="äº¬ICPå¤‡2022033375å·" target="_blank" rel="noopener" href="https://beian.miit.gov.cn/">äº¬ICPå¤‡2022033375å· </a></p></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>