<!DOCTYPE html><html class="appearance-user-can-set" lang="zh"><head><meta charset="UTF-8"><title>Notex</title><meta name="description" content="Keep low profile, he said."><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="这篇文章来梳理一下 Android 最令人头疼的基本元素——事件机制。


事件序列当用户点击屏幕里View或者ViewGroup的时候，将会产生一个事件对象，这个事件对象就是MotionEvent对象，这个对象记录了事件的类型，触摸的位置，以及触摸的时间等。MotionEvent里面定义了事件的类型，其实很容易理解，因为用户可以在屏幕触摸，滑动，离开屏幕动作，分别对应：

MotionEvent.ACTION_DOWN：用户触摸View &amp;amp; ViewGroup
MotionEvent.ACTION_MOVE：用户手指移动View &amp;amp; ViewGroup
MotionEvent.ACTION_UP：用户手指离开屏幕
MotionEvent.ACTION_CANCEL：事件退出了，不是用户导致.."><script src="//unpkg.com/valine/dist/Valine.min.js"></script><meta name="generator" content="Hexo 5.4.2"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><!-- a(href= url_for("/"))= (theme.user && theme.user.name || config.author) + "'s blog"--><a href="/">Notex</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">View 事件分发机制</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">主页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">主页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%BA%8F%E5%88%97"><span class="toc-text">事件序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="toc-text">事件传递的顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">代码分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E9%87%8D%E8%A6%81%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">三个重要的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#dispatchTouchEvent"><span class="toc-text">dispatchTouchEvent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#onTouchEvent"><span class="toc-text">onTouchEvent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#onInterceptTouchEvent"><span class="toc-text">onInterceptTouchEvent</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%87%A0%E4%B8%AA%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9"><span class="toc-text">其他几个需要注意的点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#requestDisallowInterceptTouchEvent%E6%96%B9%E6%B3%95"><span class="toc-text">requestDisallowInterceptTouchEvent方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#onTouchListener%E3%80%81onTouchEvent%E3%80%81onClickListener%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-text">onTouchListener、onTouchEvent、onClickListener的优先级</span></a></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/Android"><i class="tag post-item-tag">Android</i></a><a href="/tags/Android%20Framework"><i class="tag post-item-tag">Android Framework</i></a><a href="/tags/View"><i class="tag post-item-tag">View</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">View 事件分发机制</h1><time class="has-text-grey" datetime="2023-01-31T06:58:14.000Z">2023-01-31</time><article class="mt-2 post-content"><p>这篇文章来梳理一下 Android 最令人头疼的基本元素——事件机制。</p>
<span id="more"></span>

<h2 id="事件序列"><a href="#事件序列" class="headerlink" title="事件序列"></a>事件序列</h2><p>当用户点击屏幕里View或者ViewGroup的时候，将会产生一个事件对象，这个事件对象就是MotionEvent对象，这个对象记录了事件的类型，触摸的位置，以及触摸的时间等。MotionEvent里面定义了事件的类型，其实很容易理解，因为用户可以在屏幕触摸，滑动，离开屏幕动作，分别对应：</p>
<ul>
<li>MotionEvent.ACTION_DOWN：用户触摸View &amp; ViewGroup</li>
<li>MotionEvent.ACTION_MOVE：用户手指移动View &amp; ViewGroup</li>
<li>MotionEvent.ACTION_UP：用户手指离开屏幕</li>
<li>MotionEvent.ACTION_CANCEL：事件退出了，不是用户导致的</li>
</ul>
<p>因此用户在触摸屏幕到离开屏幕会产生一系列事件：</p>
<pre><code>ACTION_DOWN -&gt; ACTION_MOVE(0个或者多个) -&gt; ACTION_UP
</code></pre>
<p>如下图：<br><img src="https://s3.ax1x.com/2020/12/09/rCptjP.png" alt="事件序列"></p>
<h2 id="事件传递的顺序"><a href="#事件传递的顺序" class="headerlink" title="事件传递的顺序"></a>事件传递的顺序</h2><p>事件传递的顺序如下：</p>
<pre><code>InputManageSystem -&gt; WindowInputEventReceiver(ViewRootImpl) -&gt; DecorView -&gt; Activity -&gt; DecorView -&gt; 子View
</code></pre>
<p>如果所有的 View 都没有消耗事件，那最后事件会传回到 Activity，由 Activity 处理（也即 Activity 的<code>onTouchEvent()</code>方法被调用）。</p>
<pre><code>子View --&gt; DecorView --&gt; Activity
</code></pre>
<p>由 DecorView 向下，事件的传递还算清晰，没有太多的疑问。那最关键的是，触摸事件是怎么产生并交给 DecorView 的呢？</p>
<p>我们知道，触摸屏幕，首先肯定是硬件产生的一个电信号，但是我们能接触到的触摸事件直接就到了 MotionEvent，那么这个 MotionEvent 在哪里产生？</p>
<p>其实这个过程是在 Framework 层做的处理。</p>
<p>屏幕对应 Android 来说，担任了<strong>键盘</strong>的作用，就是我们计算机组成的输入设备。我们知道 Android 是基于 Linux 系统的，当我们的输入设备可用时（对当前的例子来说——触摸屏），我们对触摸屏进行操作，Linux 就会收到相应的<strong>硬件中断</strong>，然后将中断加工成原始的<strong>输入事件</strong>并写入相应的<strong>设备节点</strong>中。而 Android 的输入系统所做的事情概括起来说就是监控这些设备节点，当某个设备节点有数据可读时，将数据读出并进行一系列的翻译加工，然后在所有的窗口中找到合适的事件接收者，并派发给它。这里所说的 Android 输入系统，就是 InputManagerService（IMS），它和我们熟知的 ActivityManagerService（AMS）一样，作为系统服务，都是在 ServiceServer 中被创建。</p>
<p>根据 <a href="/activity/">Activity、Window 和 View 之间的关系</a>，我们知道，Activity 在创建时，会创建对应的 PhoneWindow，创建完成之后，会同时创建 ViewRootImpl 实例，在这个实例的 <code>setView()</code> 方法中，会将该 Window 与 IMS 进行关联，关联的方式是创建 InputChannel 实例并通过 Binder 通信的方式把 PhoneWindow 和 InputChannel 一起扔给 IMS，IMS 去进行注册。待有事件发生，就会有所回调，而回调的一个关键类是下面即将会提到的 WindowInputEventReceiver。</p>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>WindowInputEventReceiver 是 ViewRootImpl 中的一个子类。它的其中一个功能是搭建 DecorView 与 IMS 之间的桥梁。 在 <code>ViewRootImpl.setView()</code> 中，有如下代码：</p>
<pre><code class="java">public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView, int userId) &#123;
    ...
    // Schedule the first layout -before- adding to the window
    // manager, to make sure we do the relayout before receiving
    // any other events from the system.
    requestLayout();                // 1
    InputChannel inputChannel = null;
    if ((mWindowAttributes.inputFeatures
            &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) &#123;
        inputChannel = new InputChannel();          // 2
    &#125;
    ...
    try &#123;
        ...
        res = mWindowSession.addToDisplayAsUser(mWindow, mSeq, mWindowAttributes,
                            getHostVisibility(), mDisplay.getDisplayId(), userId, mTmpFrame,
                            mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,
                            mAttachInfo.mDisplayCutout, inputChannel,
                            mTempInsets, mTempControls);        // 3
        ...
    &#125;
    ...
    if (inputChannel != null) &#123;
        ...
        mInputEventReceiver = new WindowInputEventReceiver(inputChannel, Looper.myLooper());  // 4
    &#125;
&#125;
</code></pre>
<ol>
<li>准备开始进行 layout 阶段；</li>
<li>创建 InputChannel 实例，注意，此时并未初始化该实例；</li>
<li>将 PhoneWindow 实例和 InputChannel 实例都通过 Binder 扔给 Session（mWindowSession 是 IWindowSession 类型的，其对应的实现为 Session 类，位于 com/android/server/wm/Session.java），Session 通过一系列操作将 PhoneWindow 与 InputChannel 绑定。值得一提的是，在绑定之前，才会利用 <code>InputChannel.openChannelPair(name)</code> 方法创建两个 InputChannel，一个是 Server 端，用于发布事件；一个是 Client 端，用于消耗事件，然后将新创建的 Client 端直接 <code>transferTo()</code> 到步骤 2 中创建的实例，从而完成其初始化的操作。</li>
<li>注册 WindowInputEventReceiver，当 InputChannel 有消息过来的时候，立刻回调它的 <code>onInputEvent()</code> 方法。</li>
</ol>
<p>需要注意的是，在创建 WindowInputEventReceiver 实例的时候，也给它了一个主线程的 Looper，这意味着，事件的接收和后续分发，都是在主线程上进行的，这也是为什么触摸事件不能做太复杂的操作的原因——会卡住主线程。</p>
<p>由 WindowInputEventReceiver 的<code>onInputEvent()</code>方法层层向下走，我们最终可以找到 ViewRootImpl.java 中，有这么一个方法：</p>
<pre><code class="java">// ViewRootImpl.java

View mView;

private int processPointerEvent(QueuedInputEvent q) &#123;
    final MotionEvent event = (MotionEvent)q.mEvent;
    ... 
    boolean handled = mView.dispatchPointerEvent(event);
    ...
    return handled ? FINISH_HANDLED : FORWARD;
&#125;
</code></pre>
<p>此处的<code>mView</code>，是在<code>ViewRootImpl.setView()</code>中赋值的，这个方法做了很多的重要工作，我会在<a href="/viewrootimpl/">关于 ViewRootImpl</a>一文中进行详解。这个<code>setView()</code>方法，是在<code>WindowManagerGlobal.addView()</code>中被调用的。而<code>WindowManagerGlobal.addView()</code>又是在<code>WindowManagerImpl.addView()</code>中被调用的，这个方法，又是在<code>Activity.makeVisible()</code>方法中调用的，于是我们找到了上面代码中<code>mView</code>的出处：</p>
<pre><code class="java">// android.app.Activity.java

View mDecor = null;

void makeVisible() &#123;
    if (!mWindowAdded) &#123;
        ViewManager wm = getWindowManager();
        wm.addView(mDecor, getWindow().getAttributes());
        mWindowAdded = true;
    &#125;
    mDecor.setVisibility(View.VISIBLE);
&#125;
</code></pre>
<p>原来就是 DecorView 啊。到此，事件终于稳稳地交给了我们的 DecorView。</p>
<p>接下来在 DecorView.java 中找找<code>dispatchPointerEvent()</code>。WTF？没找到？表着急，那肯定在 ViewGroup.java 里。WTF？没找到？表着急，那肯定在 View.java 里。</p>
<pre><code class="java">// View.java
@UnsupportedAppUsage
public final boolean dispatchPointerEvent(MotionEvent event) &#123;
    if (event.isTouchEvent()) &#123;
        return dispatchTouchEvent(event);
    &#125; else &#123;
        return dispatchGenericMotionEvent(event);
    &#125;
&#125;
</code></pre>
<p>由此引出下面的部分。</p>
<h2 id="三个重要的方法"><a href="#三个重要的方法" class="headerlink" title="三个重要的方法"></a>三个重要的方法</h2><p>事件分发中有3个比较重要的入口方法，分别是：</p>
<ul>
<li><code>public boolean dispatchTouchEvent(MotionEvent event)</code></li>
<li><code>public boolean onTouchEvent(MotionEvent event)</code></li>
<li><code>public boolean onInterceptTouchEvent(MotionEvent ev)</code>。</li>
</ul>
<p>先来看看这几个方法的调用关系：<br><em><img src="/img/15.png" alt="事件分发机制图"></em></p>
<p>上图中绿色线条表示默认的事件处理流程，即我们没有做任何处理，事件会按照绿色线条所示的方向由Activity -&gt; …ViewGroup… -&gt; View -&gt; …ViewGroup… -&gt; Activity 这个U型图进行传递。即一直默认调用<code>super.xxx</code>方法。</p>
<p>黑色线条表示默认Activity -&gt;…ViewGroup… -&gt; View -&gt;…ViewGroup… -&gt; Activity 这个U型图的任一节点中（不包括<code>onInterceptTouchEvent</code>）返回了true，事件即结束，不再向下一节点传递。</p>
<p>红色线条表示一些特殊情况，尤其是ViewGroup，<code>ViewGroup.onInterceptTouchEvent()</code>表示询问当前ViewGroup是否需要拦截此事件即要不要处理，为什么要『多此一举』呢，因为<code>ViewGroup.dispatchTouchEvent()</code>这个函数的特殊，从上图可知，该函数返回true，是消费事件，返回false是交由上一级的ViewGroup或者Activity的<code>onTouchEvent()</code>。那么它怎么向下传递事件或者想把事件交给自己的<code>onTouchEvent</code>处理呢，所以ViewGroup多了个<code>onInterceptTouchEvent</code>（View是没有该函数的），<code>onInterceptTouchEvent</code>起到作用的是分流。<code>onInterceptTouchEvent</code>返回<code>false</code>或者返回<code>super.xxx</code>是向下级View或者ViewGroup传递，返回<code>true</code>呢是把事件交给自己的onTouchEvent处理。</p>
<p>接上节，刚才事件交给了 DecorView，但是无奈最后还是在 View 中找到 <code>dispatchPointerEvent()</code> 方法，我们看看这个事件是怎么个走向：</p>
<h3 id="dispatchTouchEvent"><a href="#dispatchTouchEvent" class="headerlink" title="dispatchTouchEvent"></a><code>dispatchTouchEvent</code></h3><p><code>dispatchTouchEvent</code>方法用来进行事件的分发。事件传递到当前 View/ViewGroup 时，这个方法就会被调用。<code>dispatchTouchEvent</code>方法里面包含了具体的事件分发逻辑，返回结果受当前 View 的<code>onTouchEvent</code>方法和下级 View 的<code>dispatchTouchEvent</code>方法的影响。</p>
<p>因为 DecorView 继承自 ViewGroup，所以我们先看ViewGroup是如何通过<code>dispatchTouchEvent</code>分发事件的：</p>
<pre><code class="java">// ViewGroup.java
 @Override
    public boolean dispatchTouchEvent(MotionEvent ev) &#123;
        if (mInputEventConsistencyVerifier != null) &#123;
            mInputEventConsistencyVerifier.onTouchEvent(ev, 1);
        &#125;

        // If the event targets the accessibility focused view and this is it, start
        // normal event dispatch. Maybe a descendant is what will handle the click.
        if (ev.isTargetAccessibilityFocus() &amp;&amp; isAccessibilityFocusedViewOrHost()) &#123;
            ev.setTargetAccessibilityFocus(false);
        &#125;

        boolean handled = false;
        if (onFilterTouchEventForSecurity(ev)) &#123;
            final int action = ev.getAction();
            final int actionMasked = action &amp; MotionEvent.ACTION_MASK;

            // Handle an initial down.
            if (actionMasked == MotionEvent.ACTION_DOWN) &#123;
                // Throw away all previous state when starting a new touch gesture.
                // The framework may have dropped the up or cancel event for the previous gesture
                // due to an app switch, ANR, or some other state change.
                cancelAndClearTouchTargets(ev);
                resetTouchState();
            &#125;

            // Check for interception.
            final boolean intercepted;
            if (actionMasked == MotionEvent.ACTION_DOWN
                    || mFirstTouchTarget != null) &#123;
                final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;
                if (!disallowIntercept) &#123;
                    intercepted = onInterceptTouchEvent(ev); // 判断是否要拦截事件
                    ev.setAction(action); // restore action in case it was changed
                &#125; else &#123;
                    intercepted = false;
                &#125;
            &#125; else &#123;
                // There are no touch targets and this action is not an initial down
                // so this view group continues to intercept touches.
                intercepted = true;
            &#125;

            // If intercepted, start normal event dispatch. Also if there is already
            // a view that is handling the gesture, do normal event dispatch.
            if (intercepted || mFirstTouchTarget != null) &#123;
                ev.setTargetAccessibilityFocus(false);
            &#125;

            // Check for cancelation.
            final boolean canceled = resetCancelNextUpFlag(this)
                    || actionMasked == MotionEvent.ACTION_CANCEL;

            // Update list of touch targets for pointer down, if needed.
            final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0;
            TouchTarget newTouchTarget = null;
            boolean alreadyDispatchedToNewTouchTarget = false;

            // 在这里寻找合适的子view并派发事件
            if (!canceled &amp;&amp; !intercepted) &#123;

                // If the event is targeting accessibility focus we give it to the
                // view that has accessibility focus and if it does not handle it
                // we clear the flag and dispatch the event to all children as usual.
                // We are looking up the accessibility focused host to avoid keeping
                // state since these events are very rare.
                View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()
                        ? findChildWithAccessibilityFocus() : null;

                if (actionMasked == MotionEvent.ACTION_DOWN
                        || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)
                        || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;
                    final int actionIndex = ev.getActionIndex(); // always 0 for down
                    final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex)
                            : TouchTarget.ALL_POINTER_IDS;

                    // Clean up earlier touch targets for this pointer id in case they
                    // have become out of sync.
                    removePointersFromTouchTargets(idBitsToAssign);

                    final int childrenCount = mChildrenCount;
                    if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123;
                        final float x = ev.getX(actionIndex);
                        final float y = ev.getY(actionIndex);
                        // Find a child that can receive the event.
                        // Scan children from front to back.
                        final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList();
                        final boolean customOrder = preorderedList == null
                                &amp;&amp; isChildrenDrawingOrderEnabled();
                        final View[] children = mChildren;
                        for (int i = childrenCount - 1; i &gt;= 0; i--) &#123;
                            final int childIndex = getAndVerifyPreorderedIndex(
                                    childrenCount, i, customOrder);
                            final View child = getAndVerifyPreorderedView(
                                    preorderedList, children, childIndex);

                            // If there is a view that has accessibility focus we want it
                            // to get the event first and if not handled we will perform a
                            // normal dispatch. We may do a double iteration but this is
                            // safer given the timeframe.
                            if (childWithAccessibilityFocus != null) &#123;
                                if (childWithAccessibilityFocus != child) &#123;
                                    continue;
                                &#125;
                                childWithAccessibilityFocus = null;
                                i = childrenCount - 1;
                            &#125;

                            if (!child.canReceivePointerEvents()
                                    || !isTransformedTouchPointInView(x, y, child, null)) &#123;
                                ev.setTargetAccessibilityFocus(false);
                                continue;
                            &#125;

                            newTouchTarget = getTouchTarget(child);
                            if (newTouchTarget != null) &#123;
                                // Child is already receiving touch within its bounds.
                                // Give it the new pointer in addition to the ones it is handling.
                                newTouchTarget.pointerIdBits |= idBitsToAssign;
                                break;
                            &#125;

                            resetCancelNextUpFlag(child);
                            if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123;
                                // Child wants to receive touch within its bounds.
                                mLastTouchDownTime = ev.getDownTime();
                                if (preorderedList != null) &#123;
                                    // childIndex points into presorted list, find original index
                                    for (int j = 0; j &lt; childrenCount; j++) &#123;
                                        if (children[childIndex] == mChildren[j]) &#123;
                                            mLastTouchDownIndex = j;
                                            break;
                                        &#125;
                                    &#125;
                                &#125; else &#123;
                                    mLastTouchDownIndex = childIndex;
                                &#125;
                                mLastTouchDownX = ev.getX();
                                mLastTouchDownY = ev.getY();
                                newTouchTarget = addTouchTarget(child, idBitsToAssign);
                                alreadyDispatchedToNewTouchTarget = true;
                                break;
                            &#125;

                            // The accessibility focus didn&#39;t handle the event, so clear
                            // the flag and do a normal dispatch to all children.
                            ev.setTargetAccessibilityFocus(false);
                        &#125;
                        if (preorderedList != null) preorderedList.clear();
                    &#125;

                    if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) &#123;
                        // Did not find a child to receive the event.
                        // Assign the pointer to the least recently added target.
                        newTouchTarget = mFirstTouchTarget;
                        while (newTouchTarget.next != null) &#123;
                            newTouchTarget = newTouchTarget.next;
                        &#125;
                        newTouchTarget.pointerIdBits |= idBitsToAssign;
                    &#125;
                &#125;
            &#125;

            // Dispatch to touch targets.
            if (mFirstTouchTarget == null) &#123;
                // No touch targets so treat this as an ordinary view.
                handled = dispatchTransformedTouchEvent(ev, canceled, null,
                        TouchTarget.ALL_POINTER_IDS);
            &#125; else &#123;
                // Dispatch to touch targets, excluding the new touch target if we already
                // dispatched to it.  Cancel touch targets if necessary.
                TouchTarget predecessor = null;
                TouchTarget target = mFirstTouchTarget;
                while (target != null) &#123;
                    final TouchTarget next = target.next;
                    if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;
                        handled = true;
                    &#125; else &#123;
                        final boolean cancelChild = resetCancelNextUpFlag(target.child)
                                || intercepted;
                        if (dispatchTransformedTouchEvent(ev, cancelChild,
                                target.child, target.pointerIdBits)) &#123;
                            handled = true;
                        &#125;
                        if (cancelChild) &#123;
                            if (predecessor == null) &#123;
                                mFirstTouchTarget = next;
                            &#125; else &#123;
                                predecessor.next = next;
                            &#125;
                            target.recycle();
                            target = next;
                            continue;
                        &#125;
                    &#125;
                    predecessor = target;
                    target = next;
                &#125;
            &#125;

            // Update list of touch targets for pointer up or cancel, if needed.
            if (canceled
                    || actionMasked == MotionEvent.ACTION_UP
                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;
                resetTouchState();
            &#125; else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123;
                final int actionIndex = ev.getActionIndex();
                final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex);
                removePointersFromTouchTargets(idBitsToRemove);
            &#125;
        &#125;

        if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) &#123;
            mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);
        &#125;
        return handled;
    &#125;
</code></pre>
<p>简单总结，就是：</p>
<ol>
<li>先判断是否要拦截（通过<code>onInterceptTouchEvent()</code>方法），如果不拦截，那就寻找合适的子view进行事件的派发，也既调用子view的<code>dispatchTouchEvent()</code>。如果有任何一个子view消费了此次事件，即<code>dispatchTouchEvent()</code>返回了<code>true</code>，那派发中止，并返回true，表示事件已经被消费。如果没有任何一个子view消费此次事件，即<code>dispatchTouchEvent()</code>返回了<code>false</code>，那ViewGroup就自己处理此次事件，调用父类View的<code>onTouchEvent()</code>。如果最后还未消耗，那就会一直向上返回，直到Activity的<code>onTouchEvent()</code>。</li>
<li>如果要拦截，那就会直接调用自己父类View的<code>onTouchEvent()</code>。</li>
</ol>
<p>上一部分的代码里我们也也看到，<code>dispatchPointerEvent</code>直接调用了<code>dispatchTouchEvent(event)</code>，而DecorView又重写了这个方法。</p>
<p>所以我们看看<code>DecorView.dispatchTouchEvent()</code>做了些啥：</p>
<pre><code class="java">// DecorView.java
@Override
public boolean dispatchTouchEvent(MotionEvent ev) &#123;
    final Window.Callback cb = mWindow.getCallback();
    return cb != null &amp;&amp; !mWindow.isDestroyed() &amp;&amp; mFeatureId &lt; 0
            ? cb.dispatchTouchEvent(ev) : super.dispatchTouchEvent(ev);
&#125;
</code></pre>
<p>Callback来自于Window.java：</p>
<pre><code class="java">// Window.java
public final Callback getCallback() &#123;
    return mCallback;
&#125;
</code></pre>
<pre><code class="java">// Callback.java:
public interface Callback &#123;
    ...
    public boolean dispatchTouchEvent(MotionEvent event);
    ...
&#125;
</code></pre>
<p>那既然有<code>getCallback()</code>就肯定有<code>setCallback()</code>，我们找一下。<br><img src="/img/14.png" alt="Callback调用者"></p>
<p>在<code>Activity.attach()</code>方法中找到了<code>window.setCallback(this)</code>：</p>
<pre><code class="java">// Activity.java
@UnsupportedAppUsage
final void attach(Context context, ActivityThread aThread,
        Instrumentation instr, IBinder token, int ident,
        Application application, Intent intent, ActivityInfo info,
        CharSequence title, Activity parent, String id,
        NonConfigurationInstances lastNonConfigurationInstances,
        Configuration config, String referrer, IVoiceInteractor voiceInteractor,
        Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken) &#123;
    ...
    mWindow.setCallback(this);  
    ...
&#125;
</code></pre>
<p>所以说，MotionEvent最终又是传递到了Activity，<code>cb.dispatchTouchEvent(ev)</code>也就是相当于<code>Activity.dispatchTouchEvent()</code>。</p>
<p>那么来看看Activity是怎么处理的：</p>
<pre><code class="java">    // Activty.java
    /**
     * 被调用来处理触摸屏幕的事件。
     * 你可以覆写此方法以在事件分发到window之前拦截所有的事件。
     * 不过要确保调用此处的实现保证触摸事件都被正常处理。 
     *
     * @param ev The touch screen event.
     *
     * @return boolean Return true if this event was consumed.
     */
    public boolean dispatchTouchEvent(MotionEvent ev) &#123;
        if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;
            onUserInteraction();
        &#125;
        if (getWindow().superDispatchTouchEvent(ev)) &#123;
            return true;
        &#125;
        return onTouchEvent(ev);
    &#125;
</code></pre>
<p>Activity又调用了<code>getWindow().superDispatchTouchEvent(ev)</code>也就是PhoneWindow。</p>
<pre><code class="java">// PhoneWindow.java
@Override
public boolean superDispatchTouchEvent(MotionEvent event) &#123;    
    // 兜兜转转一大圈，还是把事件交给我们的DecorView，    
    // DecorView继承自FrameLayout，FrameLayout呢又继承自ViewGroup，    
    // 所以作为一个ViewGroup，DecorView继续向其子View派发事件，其流程在文章的开头就已经给了    
    return mDecor.superDispatchTouchEvent(event);
&#125;
</code></pre>
<p>这里又调用了DecorView的superDispatchTouchEvent(event)：</p>
<pre><code class="java">// DecorView.java
public boolean superDispatchTouchEvent(MotionEvent event) &#123;
    return super.dispatchTouchEvent(event);
&#125;
</code></pre>
<p>这里就是直接继承自ViewGroup的<code>dispatchTouchEvent(MotionEvent ev)</code>方法，也就是说，事件从 DecorView 传递到Activity，最终又回到 DecorView，最后按照分发机制分发到ViewGroup再到所有的子View。</p>
<p>兜兜转转一大圈我们神经都被绕弯了:joy: 。在这里总结一下，当我们触摸（点击）屏幕时，Android输入系统InputManagerService通过对事件的加工处理再找到合适的 Window 接收者并通过 InputChannel 向 Window 派发加工后的事件，并触发 WindowInputEventReceiver 的<code>onInputEvent</code>的调用，由此产生后面一系列的调用，把事件派发给整个控件树的根 DecorView 。而 DecorView 又上演了一出偷梁换柱的把戏，先把事件交给 Activity 处理，在 Activity 中又把事件交还给了我们的 DecorView 。自此沿着控件树自上向下依次派发事件。如果最后没有任何 View 处理此次点击事件，则 Activity 再来做最后的处理。</p>
<p>那就继续看看View的事件分发：</p>
<pre><code class="java">// View.java
/**
* 将触摸屏幕的手势事件向下传递给目标 view，如果当前 view 是目标 view的话，就传递给当前 view。
*
* @param event The motion event to be dispatched.
* @return 如果事件被处理（消耗），就返回 true，否则返回 false。
*/
public boolean dispatchTouchEvent(MotionEvent event) &#123;
    // If the event should be handled by accessibility focus first.
    if (event.isTargetAccessibilityFocus()) &#123;
        // We don&#39;t have focus or no virtual descendant has it, do not handle the event.
        if (!isAccessibilityFocusedViewOrHost()) &#123;
            return false;
        &#125;
        // We have focus and got the event, then use normal event dispatch.
        event.setTargetAccessibilityFocus(false);
    &#125;

    boolean result = false;

    if (mInputEventConsistencyVerifier != null) &#123;
        mInputEventConsistencyVerifier.onTouchEvent(event, 0);
    &#125;

    final int actionMasked = event.getActionMasked();
    if (actionMasked == MotionEvent.ACTION_DOWN) &#123;
        // Defensive cleanup for new gesture
        stopNestedScroll();
    &#125;

    // 这里决定了该 view 是否要消耗此次事件。
    //
    // 1. 如果该 view 有`TouchListener`的话，交给它的派生类的 `onTouch` 实现去决定是否要消耗事件。
    // 2. 如果没有 `TouchListener`，那么就看 view 自己处理 touchEvent 事件之后，是否要消耗掉该事件。 
    if (onFilterTouchEventForSecurity(event)) &#123;
        if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123;
            result = true;
        &#125;
        //noinspection SimplifiableIfStatement
        ListenerInfo li = mListenerInfo;
        if (li != null &amp;&amp; li.mOnTouchListener != null
                &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED
                &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123;
            result = true;
        &#125;

        if (!result &amp;&amp; onTouchEvent(event)) &#123;
            result = true;
        &#125;
    &#125;

    if (!result &amp;&amp; mInputEventConsistencyVerifier != null) &#123;
        mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);
    &#125;

    // Clean up after nested scrolls if this is the end of a gesture;
    // also cancel it if we tried an ACTION_DOWN but we didn&#39;t want the rest
    // of the gesture.
    if (actionMasked == MotionEvent.ACTION_UP ||
            actionMasked == MotionEvent.ACTION_CANCEL ||
            (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) &#123;
        stopNestedScroll();
    &#125;

    return result;
&#125;
</code></pre>
<h3 id="onTouchEvent"><a href="#onTouchEvent" class="headerlink" title="onTouchEvent"></a><code>onTouchEvent</code></h3><p>该方法在<code>View.dispatchTouchEvent()</code>方法中调用，用来处理点击事件，返回结果表示是否消耗当前事件，如果不消耗，则在同一个事件序列中，当前View无法再次接收到事件。例如一个<code>Button</code>设置为 <code>android:enabled=&quot;false&quot;</code>，那从 ACTION_DOWN 开始，就不消耗该事件，那么后面的 ACTION_MOVE、ACTION_UP等事件也就不会再接收到了。这是由一个叫<code>mIgnoreNextUpEvent</code>的变量控制的。</p>
<p>还是来看看它的代码：</p>
<pre><code class="java">// View.java
/**
    * 实现这个方法来处理屏幕触摸手势事件。
    * 
    * 如果这个方法被用来检测点击动作，那你最好使用 performClick() 方法来触发此次点击事件。
    * 这样做能保证它是一个高度一致性的系统行为，包括：
    *
    * · 遵守点击音效的设置
    * · 分发 OnClickListener
    * · 当启用 accessibity 时，正确处理 AccessibilityNodeInfo 中的 ACTION_CLICK 事件
    *
    * @param event The motion event.
    * @return 如果事件被处理（消耗），就返回 true，否则返回 false。
    */
public boolean onTouchEvent(MotionEvent event) &#123;
    final float x = event.getX();
    final float y = event.getY();
    final int viewFlags = mViewFlags;
    final int action = event.getAction();

    final boolean clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE
            || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)
            || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;

    if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;
        if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123;
            setPressed(false);
        &#125;
        mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;
        // A disabled view that is clickable still consumes the touch
        // events, it just doesn&#39;t respond to them.
        return clickable;
    &#125;
    if (mTouchDelegate != null) &#123;
        if (mTouchDelegate.onTouchEvent(event)) &#123;
            return true;
        &#125;
    &#125;

    if (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) &#123;
        switch (action) &#123;
            case MotionEvent.ACTION_UP:
                mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;
                if ((viewFlags &amp; TOOLTIP) == TOOLTIP) &#123;
                    handleTooltipUp();
                &#125;
                if (!clickable) &#123;
                    removeTapCallback();
                    removeLongPressCallback();
                    mInContextButtonPress = false;
                    mHasPerformedLongPress = false;
                    mIgnoreNextUpEvent = false;
                    break;
                &#125;
                boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0;
                if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) &#123;
                    // take focus if we don&#39;t have it already and we should in
                    // touch mode.
                    boolean focusTaken = false;
                    if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123;
                        focusTaken = requestFocus();
                    &#125;

                    if (prepressed) &#123;
                        // The button is being released before we actually
                        // showed it as pressed.  Make it show the pressed
                        // state now (before scheduling the click) to ensure
                        // the user sees it.
                        setPressed(true, x, y);
                    &#125;

                    if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123;
                        // This is a tap, so remove the longpress check
                        removeLongPressCallback();

                        // Only perform take click actions if we were in the pressed state
                        if (!focusTaken) &#123;
                            // Use a Runnable and post this rather than calling
                            // performClick directly. This lets other visual state
                            // of the view update before click actions start.
                            if (mPerformClick == null) &#123;
                                mPerformClick = new PerformClick();
                            &#125;
                            if (!post(mPerformClick)) &#123;
                                performClickInternal();
                            &#125;
                        &#125;
                    &#125;

                    if (mUnsetPressedState == null) &#123;
                        mUnsetPressedState = new UnsetPressedState();
                    &#125;

                    if (prepressed) &#123;
                        postDelayed(mUnsetPressedState,
                                ViewConfiguration.getPressedStateDuration());
                    &#125; else if (!post(mUnsetPressedState)) &#123;
                        // If the post failed, unpress right now
                        mUnsetPressedState.run();
                    &#125;

                    removeTapCallback();
                &#125;
                mIgnoreNextUpEvent = false;
                break;

            case MotionEvent.ACTION_DOWN:
                if (event.getSource() == InputDevice.SOURCE_TOUCHSCREEN) &#123;
                    mPrivateFlags3 |= PFLAG3_FINGER_DOWN;
                &#125;
                mHasPerformedLongPress = false;

                if (!clickable) &#123;
                    checkForLongClick(
                            ViewConfiguration.getLongPressTimeout(),
                            x,
                            y,
                            TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__LONG_PRESS);
                    break;
                &#125;

                if (performButtonActionOnTouchDown(event)) &#123;
                    break;
                &#125;

                // Walk up the hierarchy to determine if we&#39;re inside a scrolling container.
                boolean isInScrollingContainer = isInScrollingContainer();

                // For views inside a scrolling container, delay the pressed feedback for
                // a short period in case this is a scroll.
                if (isInScrollingContainer) &#123;
                    mPrivateFlags |= PFLAG_PREPRESSED;
                    if (mPendingCheckForTap == null) &#123;
                        mPendingCheckForTap = new CheckForTap();
                    &#125;
                    mPendingCheckForTap.x = event.getX();
                    mPendingCheckForTap.y = event.getY();
                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                &#125; else &#123;
                    // Not inside a scrolling container, so show the feedback right away
                    setPressed(true, x, y);
                    checkForLongClick(
                            ViewConfiguration.getLongPressTimeout(),
                            x,
                            y,
                            TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__LONG_PRESS);
                &#125;
                break;

            case MotionEvent.ACTION_CANCEL:
                if (clickable) &#123;
                    setPressed(false);
                &#125;
                removeTapCallback();
                removeLongPressCallback();
                mInContextButtonPress = false;
                mHasPerformedLongPress = false;
                mIgnoreNextUpEvent = false;
                mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;
                break;

            case MotionEvent.ACTION_MOVE:
                if (clickable) &#123;
                    drawableHotspotChanged(x, y);
                &#125;

                final int motionClassification = event.getClassification();
                final boolean ambiguousGesture =
                        motionClassification == MotionEvent.CLASSIFICATION_AMBIGUOUS_GESTURE;
                int touchSlop = mTouchSlop;
                if (ambiguousGesture &amp;&amp; hasPendingLongPressCallback()) &#123;
                    final float ambiguousMultiplier =
                            ViewConfiguration.getAmbiguousGestureMultiplier();
                    if (!pointInView(x, y, touchSlop)) &#123;
                        // The default action here is to cancel long press. But instead, we
                        // just extend the timeout here, in case the classification
                        // stays ambiguous.
                        removeLongPressCallback();
                        long delay = (long) (ViewConfiguration.getLongPressTimeout()
                                * ambiguousMultiplier);
                        // Subtract the time already spent
                        delay -= event.getEventTime() - event.getDownTime();
                        checkForLongClick(
                                delay,
                                x,
                                y,
                                TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__LONG_PRESS);
                    &#125;
                    touchSlop *= ambiguousMultiplier;
                &#125;

                // Be lenient about moving outside of buttons
                if (!pointInView(x, y, touchSlop)) &#123;
                    // Outside button
                    // Remove any future long press/tap checks
                    removeTapCallback();
                    removeLongPressCallback();
                    if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123;
                        setPressed(false);
                    &#125;
                    mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;
                &#125;

                final boolean deepPress =
                        motionClassification == MotionEvent.CLASSIFICATION_DEEP_PRESS;
                if (deepPress &amp;&amp; hasPendingLongPressCallback()) &#123;
                    // process the long click action immediately
                    removeLongPressCallback();
                    checkForLongClick(
                            0 /* send immediately */,
                            x,
                            y,
                            TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__DEEP_PRESS);
                &#125;

                break;
        &#125;

        return true;
    &#125;

    return false;
&#125;
</code></pre>
<h3 id="onInterceptTouchEvent"><a href="#onInterceptTouchEvent" class="headerlink" title="onInterceptTouchEvent"></a><code>onInterceptTouchEvent</code></h3><p><code>onInterceptTouchEvent()</code>方法在<code>ViewGroup.dispatchTouchEvent()</code>方法内部被调用，用来判断是否拦截某个事件。如果当前ViewGroup拦截了某个事件，那么在同一个事件序列当中，此方法不会被再次调用，返回结果表示是否拦截当前事件。这个方法只有ViewGroup中有，View中没有。</p>
<pre><code class="java">/**
    * 实现该方法来拦截所有的触摸事件。这能让你监测所有发送到子view的事件，并且得到该事件的所有信息。
    *
    * 使用该方法的时候要小心，因为它与View.onTouchEvent()有着相当复杂的交互。
    * 事件会按照下面的顺序被接收：
    *
    * · 按下事件(ACTION_DOWN)
    * · 按下事件要么被该ViewGroup的某个子view处理，要么就进到你自己的onTouchEvent()方法去处理；
    *   这意味着你在覆写onTouchEvent()时要返回 true，才能接收到接下来其他的事件（而不是由父view来接收处理)。
    *   这个方法返回 true时，你不会接收到来自 onInterceptTouchEvent() 的任何事件，
    *   并且接下来的触摸事件就会正常发生。
    * · 只要这个方法返回了 false，接下来的事件（直到ACTION_UP并包括ACTION_UP事件）都会先经过
    *   onInterceptTouchEvent，再被发送到目标view的 onTouchEvent。
    * · 如果这儿返回了 true，后面就不会接收到相同的事件了（除了ACTION_CANCEL），后续的事件将被传递到你自己的 onTouchEvent()
    *   并且不会再经过这儿。子view将不会再接收到任何事件。
    *
    * @param ev The motion event being dispatched down the hierarchy.
    * @return Return true to steal motion events from the children and have
    * them dispatched to this ViewGroup through onTouchEvent().
    * The current target will receive an ACTION_CANCEL event, and no further
    * messages will be delivered here.
    */
public boolean onInterceptTouchEvent(MotionEvent ev) &#123;
    if (ev.isFromSource(InputDevice.SOURCE_MOUSE)
            &amp;&amp; ev.getAction() == MotionEvent.ACTION_DOWN
            &amp;&amp; ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY)
            &amp;&amp; isOnScrollbarThumb(ev.getX(), ev.getY())) &#123;
        return true;
    &#125;
    return false;
&#125;
</code></pre>
<p><code>onInterceptTouchEvent</code>起到作用的是分流。<code>onInterceptTouchEvent</code>返回<code>false</code>或者返回<code>super.xxx</code>是向下级View或者ViewGroup传递，返回<code>true</code>呢是把事件交给自己的<code>onTouchEvent</code>处理。</p>
<p>ViewGroup默认不拦截任何事件。</p>
<p>到此，关于事件分发的机制，就差不多了。</p>
<h2 id="其他几个需要注意的点"><a href="#其他几个需要注意的点" class="headerlink" title="其他几个需要注意的点"></a>其他几个需要注意的点</h2><h3 id="requestDisallowInterceptTouchEvent方法"><a href="#requestDisallowInterceptTouchEvent方法" class="headerlink" title="requestDisallowInterceptTouchEvent方法"></a>requestDisallowInterceptTouchEvent方法</h3><p><code>requestDisallowInterceptTouchEvent</code>方法用于影响父元素的事件拦截策略，<code>requestDisallowInterceptTouchEvent(true)</code>，表示不允许父元素拦截事件，这样事件就会传递给子View。一般这个方法子View用的多，可以用来处理滑动冲突问题。</p>
<h3 id="onTouchListener、onTouchEvent、onClickListener的优先级"><a href="#onTouchListener、onTouchEvent、onClickListener的优先级" class="headerlink" title="onTouchListener、onTouchEvent、onClickListener的优先级"></a>onTouchListener、onTouchEvent、onClickListener的优先级</h3><ol>
<li><p><code>onTouchListener</code>和<code>onTouchEvent</code>都在<code>dispatchTouchEvent</code>方法中被调用，<code>onClickListener</code>在<code>onTouchEvent</code>方法中被调用；</p>
</li>
<li><p><code>onTouchListener</code>的优先级高于<code>onTouchEvent</code>方法，如果<code>onTouchListener</code>的<code>onTouch</code>方法返回<code>true</code>，则<code>onTouchEvent</code>方法不会被调用，当然<code>onClickListener</code>就更不会被调用了；</p>
</li>
<li><p>在<code>onTouchEvent</code>方法中，如果当前View设置了<code>onClickListener</code>，那么<code>onClickListener</code>的<code>onClick</code>方法会被调用；</p>
</li>
<li><p>只要View的<code>clickable</code>和<code>long_clickable</code>有一个为<code>true</code>，View就会消耗当前事件，也就是说<code>onTouchEvent</code>方法最后会返回<code>true</code>。</p>
</li>
<li><p>View的<code>long_clickable</code>属性默认为<code>false</code>，而<code>clickable</code>属性和具体的View有关，可点击的View的<code>clickable</code>属性为<code>true</code>，不可点击的View的<code>clickable</code>属性为<code>false</code>。</p>
</li>
</ol>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2023-01-31/listview-optimization/" title="关于 ListView 的渲染、缓存及优化"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">Previous: 关于 ListView 的渲染、缓存及优化</span></a><a class="button is-default" href="/2023-01-31/viewrootimpl/" title="ViewRootImpl 解析"><span class="has-text-weight-semibold">Next: ViewRootImpl 解析</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container" id="vcomments" data-comment_valine_id="b7rbKQnQFa9DYl1anYfacJRz-gzGzoHsz" data-comment_valine_key="nUuKvGHOJBRylruJLW2Fmekg"></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com/serious008/"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/serious198706"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com/serious008/"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><a title="zhihu" target="_blank" rel="noopener nofollow" href="//zhihu.com/people/cy198706"><i class="iconfont icon-zhihu"></i></a><!-- 领英--><a title="linkedin" target="_blank" rel="noopener nofollow" href="//www.linkedin.com/in/serious_chen/"><i class="iconfont icon-linkedin"></i></a><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com/serious008/"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> Notex 2023</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="京ICP备2022033375号" target="_blank" rel="noopener" href="https://beian.miit.gov.cn/">京ICP备2022033375号 </a></p></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>